(function(f){typeof define==='function'&&define.amd?define(f):f();}(function(){'use strict';var companyNames = ["Kiehn Inc", "Marks and Sons", "Waelchi Schiller and Denesik", "Olson Zemlak and Maggio", "Jacobs - Von", "Auer Lowe and Gutmann", "Feeney Rempel and Cassin", "Sawayn - Marks", "Johns and Sons", "Rodriguez Champlin and Dare", "Lowe - Ritchie", "Gleichner Goldner and Becker", "Jerde - Osinski", "Baumbach Group", "Schroeder Zulauf and Rempel", "O'Reilly Mills and Denesik", "Kohler - Veum", "O'Hara Inc", "Oberbrunner and Sons", "Emmerich Group", "Murray Zieme and Franecki", "Moen - Luettgen", "Gorczany Harvey and Gulgowski", "Reilly - Ruecker", "McDermott - Hyatt", "Spinka - Marks", "Hayes and Sons", "Kilback Kiehn and Monahan", "Davis and Sons", "Hudson - Yundt", "Goodwin - Zemlak", "Beer Kuhlman and Walker", "Jones Carroll and Anderson", "Rutherford Inc", "Predovic White and Collins", "Sporer Baumbach and Crist", "Grimes and Sons", "Kunde and Sons", "Tillman - Bode", "Cronin - Koepp", "Smitham Zieme and Daniel", "Kunze Welch and Russel", "Johns Labadie and Harber", "Lesch - Waters", "Brakus - Smitham", "Bins and Sons", "Nitzsche Inc", "Wunsch Inc", "Schowalter Franecki and Kuphal", "Reynolds - Swaniawski"];var isEditable = function (element) {
  if (element.ownerDocument.designMode && element.ownerDocument.designMode.toLowerCase() === 'on') {
    return true;
  }

  switch (element.tagName.toLowerCase()) {
    case 'input':
      return isEditableInput(element);
    case 'textarea':
      return true;
  }

  if (isContentEditable(element)) {
    return true;
  }

  return false;
};

function isContentEditable(element) {
  if (element.contentEditable && element.contentEditable.toLowerCase() === 'true') {
    return true;
  }
  if (element.contentEditable && element.contentEditable.toLowerCase() === 'inherit' && element.parentNode) {
    return isContentEditable(element.parentNode);
  }
  return false;
}

function isEditableInput(input) {
  switch (input.type) {
    case 'text':
      return true;
    case 'email':
      return true;
    case 'password':
      return true;
    case 'search':
      return true;
    case 'tel':
      return true;
    case 'url':
      return true;
    default:
      return false;
  }
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var CTRL = 1 << 0;
var META = 1 << 1;
var ALT = 1 << 2;
var SHIFT = 1 << 3;

// Key Events
var KeyEvents = {
  DOWN: 1 << 0,
  PRESS: 1 << 1,
  UP: 1 << 2,
  INPUT: 1 << 3
};
KeyEvents.ALL = KeyEvents.DOWN | KeyEvents.PRESS | KeyEvents.UP | KeyEvents.INPUT;

/**
 * Represents a keystroke, or a single key code with a set of active modifiers.
 *
 * @class Keystroke
 */
var Keystroke =
/**
 * @param {number} modifiers A bitmask formed by CTRL, META, ALT, and SHIFT.
 * @param {number} keyCode
 */
function Keystroke(modifiers, keyCode) {
  classCallCheck(this, Keystroke);

  this.modifiers = modifiers;
  this.ctrlKey = !!(modifiers & CTRL);
  this.metaKey = !!(modifiers & META);
  this.altKey = !!(modifiers & ALT);
  this.shiftKey = !!(modifiers & SHIFT);
  this.keyCode = keyCode;
};

/**
 * Simulates a keyboard with a particular key-to-character and key-to-action
 * mapping. Use `US_ENGLISH` to get a pre-configured keyboard.
 */
Keystroke.CTRL = CTRL;
Keystroke.META = META;
Keystroke.ALT = ALT;
Keystroke.SHIFT = SHIFT;
var Keyboard = function () {
  /**
   * @param {Object.<number, Keystroke>} charCodeKeyCodeMap
   * @param {Object.<string, number>} actionKeyCodeMap
   */
  function Keyboard(charCodeKeyCodeMap, actionKeyCodeMap) {
    classCallCheck(this, Keyboard);

    this._charCodeKeyCodeMap = charCodeKeyCodeMap;
    this._actionKeyCodeMap = actionKeyCodeMap;
  }

  /**
   * Determines the character code generated by pressing the given keystroke.
   *
   * @param {Keystroke} keystroke
   * @return {?number}
   */


  createClass(Keyboard, [{
    key: 'charCodeForKeystroke',
    value: function charCodeForKeystroke(keystroke) {
      var map = this._charCodeKeyCodeMap;
      for (var charCode in map) {
        if (Object.prototype.hasOwnProperty.call(map, charCode)) {
          var keystrokeForCharCode = map[charCode];
          if (keystroke.keyCode === keystrokeForCharCode.keyCode && keystroke.modifiers === keystrokeForCharCode.modifiers) {
            return parseInt(charCode, 10);
          }
        }
      }
      return null;
    }

    /**
     * Creates an event ready for dispatching onto the given target.
     *
     * @param {string} type One of "keydown", "keypress", "keyup", "textInput" or "input".
     * @param {Keystroke} keystroke
     * @param {HTMLElement} target
     * @return {Event}
     */

  }, {
    key: 'createEventFromKeystroke',
    value: function createEventFromKeystroke(type, keystroke, target) {
      var document = target.ownerDocument;
      var window = document.defaultView;
      var Event = window.Event;

      var event = void 0;

      try {
        event = new Event(type);
      } catch (e) {
        event = document.createEvent('UIEvents');
      }

      event.initEvent(type, true, true);

      switch (type) {
        case 'textInput':
          event.data = String.fromCharCode(this.charCodeForKeystroke(keystroke));
          break;

        case 'keydown':case 'keypress':case 'keyup':
          event.shiftKey = keystroke.shiftKey;
          event.altKey = keystroke.altKey;
          event.metaKey = keystroke.metaKey;
          event.ctrlKey = keystroke.ctrlKey;
          event.keyCode = type === 'keypress' ? this.charCodeForKeystroke(keystroke) : keystroke.keyCode;
          event.charCode = type === 'keypress' ? event.keyCode : 0;
          event.which = event.keyCode;
          break;
      }

      return event;
    }

    /**
     * Fires the correct sequence of events on the given target as if the given
     * action was undertaken by a human.
     *
     * @param {string} action e.g. "alt+shift+left" or "backspace"
     * @param {HTMLElement} target
     */

  }, {
    key: 'dispatchEventsForAction',
    value: function dispatchEventsForAction(action, target) {
      var keystroke = this.keystrokeForAction(action);
      this.dispatchEventsForKeystroke(keystroke, target);
    }

    /**
     * Fires the correct sequence of events on the given target as if the given
     * input had been typed by a human.
     *
     * @param {string} input
     * @param {HTMLElement} target
     */

  }, {
    key: 'dispatchEventsForInput',
    value: function dispatchEventsForInput(input, target) {
      var currentModifierState = 0;
      for (var i = 0, length = input.length; i < length; i++) {
        var keystroke = this.keystrokeForCharCode(input.charCodeAt(i));
        this.dispatchModifierStateTransition(target, currentModifierState, keystroke.modifiers);
        this.dispatchEventsForKeystroke(keystroke, target, false);
        currentModifierState = keystroke.modifiers;
      }
      this.dispatchModifierStateTransition(target, currentModifierState, 0);
    }

    /**
     * Fires the correct sequence of events on the given target as if the given
     * keystroke was performed by a human. When simulating, for example, typing
     * the letter "A" (assuming a U.S. English keyboard) then the sequence will
     * look like this:
     *
     *   keydown   keyCode=16 (SHIFT) charCode=0      shiftKey=true
     *   keydown   keyCode=65 (A)     charCode=0      shiftKey=true
     *   keypress  keyCode=65 (A)     charCode=65 (A) shiftKey=true
     *   textInput data=A
     *   input
     *   keyup     keyCode=65 (A)     charCode=0      shiftKey=true
     *   keyup     keyCode=16 (SHIFT) charCode=0      shiftKey=false
     *
     * If the keystroke would not cause a character to be input, such as when
     * pressing alt+shift+left, the sequence looks like this:
     *
     *   keydown   keyCode=16 (SHIFT) charCode=0 altKey=false shiftKey=true
     *   keydown   keyCode=18 (ALT)   charCode=0 altKey=true  shiftKey=true
     *   keydown   keyCode=37 (LEFT)  charCode=0 altKey=true  shiftKey=true
     *   keyup     keyCode=37 (LEFT)  charCode=0 altKey=true  shiftKey=true
     *   keyup     keyCode=18 (ALT)   charCode=0 altKey=false shiftKey=true
     *   keyup     keyCode=16 (SHIFT) charCode=0 altKey=false shiftKey=false
     *
     * To disable handling of modifier keys, call with `transitionModifers` set
     * to false. Doing so will omit the keydown and keyup events associated with
     * shift, ctrl, alt, and meta keys surrounding the actual keystroke.
     *
     * @param {Keystroke} keystroke
     * @param {HTMLElement} target
     * @param {boolean=} transitionModifiers
     * @param {number} events
     */

  }, {
    key: 'dispatchEventsForKeystroke',
    value: function dispatchEventsForKeystroke(keystroke, target) {
      var transitionModifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var events = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : KeyEvents.ALL;

      if (transitionModifiers) {
        this.dispatchModifierStateTransition(target, 0, keystroke.modifiers, events);
      }

      var keydownEvent = void 0;
      if (events & KeyEvents.DOWN) {
        keydownEvent = this.createEventFromKeystroke('keydown', keystroke, target);
      }

      if (keydownEvent && target.dispatchEvent(keydownEvent) && this.targetCanReceiveTextInput(target)) {
        var keypressEvent = void 0;
        if (events & KeyEvents.PRESS) {
          keypressEvent = this.createEventFromKeystroke('keypress', keystroke, target);
        }
        if (keypressEvent && keypressEvent.charCode && target.dispatchEvent(keypressEvent)) {
          if (events & KeyEvents.INPUT) {
            var textinputEvent = this.createEventFromKeystroke('textInput', keystroke, target);
            target.dispatchEvent(textinputEvent);

            var inputEvent = this.createEventFromKeystroke('input', keystroke, target);
            target.dispatchEvent(inputEvent);
          }
        }
      }

      if (events & KeyEvents.UP) {
        var keyupEvent = this.createEventFromKeystroke('keyup', keystroke, target);
        target.dispatchEvent(keyupEvent);
      }

      if (transitionModifiers) {
        this.dispatchModifierStateTransition(target, keystroke.modifiers, 0);
      }
    }

    /**
     * Transitions from one modifier state to another by dispatching key events.
     *
     * @param {EventTarget} target
     * @param {number} fromModifierState
     * @param {number} toModifierState
     * @param {number} events
     * @private
     */

  }, {
    key: 'dispatchModifierStateTransition',
    value: function dispatchModifierStateTransition(target, fromModifierState, toModifierState) {
      var events = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : KeyEvents.ALL;

      var currentModifierState = fromModifierState;
      var didHaveMeta = (fromModifierState & META) === META;
      var willHaveMeta = (toModifierState & META) === META;
      var didHaveCtrl = (fromModifierState & CTRL) === CTRL;
      var willHaveCtrl = (toModifierState & CTRL) === CTRL;
      var didHaveShift = (fromModifierState & SHIFT) === SHIFT;
      var willHaveShift = (toModifierState & SHIFT) === SHIFT;
      var didHaveAlt = (fromModifierState & ALT) === ALT;
      var willHaveAlt = (toModifierState & ALT) === ALT;

      var includeKeyUp = events & KeyEvents.UP;
      var includeKeyDown = events & KeyEvents.DOWN;

      if (includeKeyUp && didHaveMeta === true && willHaveMeta === false) {
        // Release the meta key.
        currentModifierState &= ~META;
        target.dispatchEvent(this.createEventFromKeystroke('keyup', new Keystroke(currentModifierState, this._actionKeyCodeMap.META), target));
      }

      if (includeKeyUp && didHaveCtrl === true && willHaveCtrl === false) {
        // Release the ctrl key.
        currentModifierState &= ~CTRL;
        target.dispatchEvent(this.createEventFromKeystroke('keyup', new Keystroke(currentModifierState, this._actionKeyCodeMap.CTRL), target));
      }

      if (includeKeyUp && didHaveShift === true && willHaveShift === false) {
        // Release the shift key.
        currentModifierState &= ~SHIFT;
        target.dispatchEvent(this.createEventFromKeystroke('keyup', new Keystroke(currentModifierState, this._actionKeyCodeMap.SHIFT), target));
      }

      if (includeKeyUp && didHaveAlt === true && willHaveAlt === false) {
        // Release the alt key.
        currentModifierState &= ~ALT;
        target.dispatchEvent(this.createEventFromKeystroke('keyup', new Keystroke(currentModifierState, this._actionKeyCodeMap.ALT), target));
      }

      if (includeKeyDown && didHaveMeta === false && willHaveMeta === true) {
        // Press the meta key.
        currentModifierState |= META;
        target.dispatchEvent(this.createEventFromKeystroke('keydown', new Keystroke(currentModifierState, this._actionKeyCodeMap.META), target));
      }

      if (includeKeyDown && didHaveCtrl === false && willHaveCtrl === true) {
        // Press the ctrl key.
        currentModifierState |= CTRL;
        target.dispatchEvent(this.createEventFromKeystroke('keydown', new Keystroke(currentModifierState, this._actionKeyCodeMap.CTRL), target));
      }

      if (includeKeyDown && didHaveShift === false && willHaveShift === true) {
        // Press the shift key.
        currentModifierState |= SHIFT;
        target.dispatchEvent(this.createEventFromKeystroke('keydown', new Keystroke(currentModifierState, this._actionKeyCodeMap.SHIFT), target));
      }

      if (includeKeyDown && didHaveAlt === false && willHaveAlt === true) {
        // Press the alt key.
        currentModifierState |= ALT;
        target.dispatchEvent(this.createEventFromKeystroke('keydown', new Keystroke(currentModifierState, this._actionKeyCodeMap.ALT), target));
      }

      if (currentModifierState !== toModifierState) {
        throw new Error('internal error, expected modifier state: ' + toModifierState + (', got: ' + currentModifierState));
      }
    }

    /**
     * Returns the keystroke associated with the given action.
     *
     * @param {string} action
     * @return {?Keystroke}
     */

  }, {
    key: 'keystrokeForAction',
    value: function keystrokeForAction(action) {
      var keyCode = null;
      var modifiers = 0;

      var parts = action.split('+');
      var lastPart = parts.pop();

      parts.forEach(function (part) {
        switch (part.toUpperCase()) {
          case 'CTRL':
            modifiers |= CTRL;break;
          case 'META':
            modifiers |= META;break;
          case 'ALT':
            modifiers |= ALT;break;
          case 'SHIFT':
            modifiers |= SHIFT;break;
          default:
            throw new Error('in "' + action + '", invalid modifier: ' + part);
        }
      });

      if (lastPart.toUpperCase() in this._actionKeyCodeMap) {
        keyCode = this._actionKeyCodeMap[lastPart.toUpperCase()];
      } else if (lastPart.length === 1) {
        var lastPartKeystroke = this.keystrokeForCharCode(lastPart.charCodeAt(0));
        modifiers |= lastPartKeystroke.modifiers;
        keyCode = lastPartKeystroke.keyCode;
      } else {
        throw new Error('in "' + action + '", invalid action: ' + lastPart);
      }

      return new Keystroke(modifiers, keyCode);
    }

    /**
     * Gets the keystroke used to generate the given character code.
     *
     * @param {number} charCode
     * @return {?Keystroke}
     */

  }, {
    key: 'keystrokeForCharCode',
    value: function keystrokeForCharCode(charCode) {
      return this._charCodeKeyCodeMap[charCode] || null;
    }

    /**
     * @param {EventTarget} target
     * @private
     */

  }, {
    key: 'targetCanReceiveTextInput',
    value: function targetCanReceiveTextInput(target) {
      if (!target) {
        return false;
      }

      return isEditable(target);
    }
  }]);
  return Keyboard;
}();

var US_ENGLISH_CHARCODE_KEYCODE_MAP = {
  32: new Keystroke(0, 32), // <space>
  33: new Keystroke(SHIFT, 49), // !
  34: new Keystroke(SHIFT, 222), // "
  35: new Keystroke(SHIFT, 51), // #
  36: new Keystroke(SHIFT, 52), // $
  37: new Keystroke(SHIFT, 53), // %
  38: new Keystroke(SHIFT, 55), // &
  39: new Keystroke(0, 222), // '
  40: new Keystroke(SHIFT, 57), // (
  41: new Keystroke(SHIFT, 48), // )
  42: new Keystroke(SHIFT, 56), // *
  43: new Keystroke(SHIFT, 187), // +
  44: new Keystroke(0, 188), // ,
  45: new Keystroke(0, 189), // -
  46: new Keystroke(0, 190), // .
  47: new Keystroke(0, 191), // /
  48: new Keystroke(0, 48), // 0
  49: new Keystroke(0, 49), // 1
  50: new Keystroke(0, 50), // 2
  51: new Keystroke(0, 51), // 3
  52: new Keystroke(0, 52), // 4
  53: new Keystroke(0, 53), // 5
  54: new Keystroke(0, 54), // 6
  55: new Keystroke(0, 55), // 7
  56: new Keystroke(0, 56), // 8
  57: new Keystroke(0, 57), // 9
  58: new Keystroke(SHIFT, 186), // :
  59: new Keystroke(0, 186), // ;
  60: new Keystroke(SHIFT, 188), // <
  61: new Keystroke(0, 187), // =
  62: new Keystroke(SHIFT, 190), // >
  63: new Keystroke(SHIFT, 191), // ?
  64: new Keystroke(SHIFT, 50), // @
  65: new Keystroke(SHIFT, 65), // A
  66: new Keystroke(SHIFT, 66), // B
  67: new Keystroke(SHIFT, 67), // C
  68: new Keystroke(SHIFT, 68), // D
  69: new Keystroke(SHIFT, 69), // E
  70: new Keystroke(SHIFT, 70), // F
  71: new Keystroke(SHIFT, 71), // G
  72: new Keystroke(SHIFT, 72), // H
  73: new Keystroke(SHIFT, 73), // I
  74: new Keystroke(SHIFT, 74), // J
  75: new Keystroke(SHIFT, 75), // K
  76: new Keystroke(SHIFT, 76), // L
  77: new Keystroke(SHIFT, 77), // M
  78: new Keystroke(SHIFT, 78), // N
  79: new Keystroke(SHIFT, 79), // O
  80: new Keystroke(SHIFT, 80), // P
  81: new Keystroke(SHIFT, 81), // Q
  82: new Keystroke(SHIFT, 82), // R
  83: new Keystroke(SHIFT, 83), // S
  84: new Keystroke(SHIFT, 84), // T
  85: new Keystroke(SHIFT, 85), // U
  86: new Keystroke(SHIFT, 86), // V
  87: new Keystroke(SHIFT, 87), // W
  88: new Keystroke(SHIFT, 88), // X
  89: new Keystroke(SHIFT, 89), // Y
  90: new Keystroke(SHIFT, 90), // Z
  91: new Keystroke(0, 219), // [
  92: new Keystroke(0, 220), // \
  93: new Keystroke(0, 221), // ]
  96: new Keystroke(0, 192), // `
  97: new Keystroke(0, 65), // a
  98: new Keystroke(0, 66), // b
  99: new Keystroke(0, 67), // c
  100: new Keystroke(0, 68), // d
  101: new Keystroke(0, 69), // e
  102: new Keystroke(0, 70), // f
  103: new Keystroke(0, 71), // g
  104: new Keystroke(0, 72), // h
  105: new Keystroke(0, 73), // i
  106: new Keystroke(0, 74), // j
  107: new Keystroke(0, 75), // k
  108: new Keystroke(0, 76), // l
  109: new Keystroke(0, 77), // m
  110: new Keystroke(0, 78), // n
  111: new Keystroke(0, 79), // o
  112: new Keystroke(0, 80), // p
  113: new Keystroke(0, 81), // q
  114: new Keystroke(0, 82), // r
  115: new Keystroke(0, 83), // s
  116: new Keystroke(0, 84), // t
  117: new Keystroke(0, 85), // u
  118: new Keystroke(0, 86), // v
  119: new Keystroke(0, 87), // w
  120: new Keystroke(0, 88), // x
  121: new Keystroke(0, 89), // y
  122: new Keystroke(0, 90), // z
  123: new Keystroke(SHIFT, 219), // {
  124: new Keystroke(SHIFT, 220), // |
  125: new Keystroke(SHIFT, 221), // }
  126: new Keystroke(SHIFT, 192) // ~
};

var US_ENGLISH_ACTION_KEYCODE_MAP = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPSLOCK: 20,
  ESCAPE: 27,
  PAGEUP: 33,
  PAGEDOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  INSERT: 45,
  DELETE: 46,
  META: 91,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123
};

/**
 * Gets a keyboard instance configured as a U.S. English keyboard would be.
 *
 * @return {Keyboard}
 */
Keyboard.US_ENGLISH = new Keyboard(US_ENGLISH_CHARCODE_KEYCODE_MAP, US_ENGLISH_ACTION_KEYCODE_MAP);var keyboard;
keyboard = Keyboard.US_ENGLISH;
function simulateKeys (target, keys, value) {
  if (target.focus) {
    target.focus();
  }

  target.value += value != null ? value || '' : keys;
  return keyboard.dispatchEventsForInput(keys, target);
}var keyboard$1;
keyboard$1 = Keyboard.US_ENGLISH;
function simulateAction (target, keys) {
  return keyboard$1.dispatchEventsForAction(keys, target);
}function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var REGEX_LEN_VAL = /^\d+(?:[a-z]|\%)+$/i;
var REGEX_DIGITS = /\d+$/;
var REGEX_SPACE = /\s/;
var REGEX_KEBAB = /([A-Z])+/g;
var IMPORTANT = 'important';
var POSSIBLE_PREFIXES = ['webkit', 'moz', 'ms', 'o'];
var REQUIRES_UNIT_VALUE = ['background-position-x', 'background-position-y', 'block-size', 'border-width', 'columnRule-width', 'cx', 'cy', 'font-size', 'grid-column-gap', 'grid-row-gap', 'height', 'inline-size', 'line-height', 'minBlock-size', 'min-height', 'min-inline-size', 'min-width', 'max-height', 'max-width', 'outline-offset', 'outline-width', 'perspective', 'shape-margin', 'stroke-dashoffset', 'stroke-width', 'text-indent', 'width', 'word-spacing', 'top', 'bottom', 'left', 'right', 'x', 'y'];
var QUAD_SHORTHANDS = ['margin', 'padding', 'border', 'border-radius'];
var DIRECTIONS = ['top', 'bottom', 'left', 'right'];
QUAD_SHORTHANDS.forEach(function (property) {
  var direction, i, len;
  REQUIRES_UNIT_VALUE.push(property);

  for (i = 0, len = DIRECTIONS.length; i < len; i++) {
    direction = DIRECTIONS[i];
    REQUIRES_UNIT_VALUE.push(property + '-' + direction);
  }
});
var SAMPLE_STYLE, styleConfig;
SAMPLE_STYLE = document.createElement('div').style;

var includes = function includes(target, item) {
  return target && target.indexOf(item) !== -1;
};

var isIterable = function isIterable(target) {
  return target && _typeof(target) === 'object' && typeof target.length === 'number' && !target.nodeType;
};

var toKebabCase = function toKebabCase(string) {
  return string.replace(REGEX_KEBAB, function (e, letter) {
    return "-".concat(letter.toLowerCase());
  });
};

var isPropSupported = function isPropSupported(property) {
  return typeof SAMPLE_STYLE[property] !== 'undefined';
};

var isValueSupported = function isValueSupported(property, value) {
  if (window.CSS && window.CSS.supports) {
    return window.CSS.supports(property, value);
  } else {
    SAMPLE_STYLE[property] = value;
    return SAMPLE_STYLE[property] === '' + value;
  }
};

var getPrefix = function getPrefix(property, skipInitialCheck) {
  var j, len1, prefix;

  if (skipInitialCheck || !isPropSupported(property)) {
    for (j = 0, len1 = POSSIBLE_PREFIXES.length; j < len1; j++) {
      prefix = POSSIBLE_PREFIXES[j];

      if (isPropSupported("-".concat(prefix, "-").concat(property))) {
        /* istanbul ignore next */
        return "-".concat(prefix, "-");
      }
    }
  }

  return '';
};

var normalizeProperty = function normalizeProperty(property) {
  property = toKebabCase(property);

  if (isPropSupported(property)) {
    return property;
  } else {
    return "".concat(getPrefix(property, true)).concat(property);
  }
};

var normalizeValue = function normalizeValue(property, value) {
  if (includes(REQUIRES_UNIT_VALUE, property) && value !== null) {
    value = '' + value;

    if (REGEX_DIGITS.test(value) && !REGEX_LEN_VAL.test(value) && !REGEX_SPACE.test(value)) {
      value += property === 'line-height' ? 'em' : 'px';
    }
  }

  return value;
};

var sort = function sort(array) {
  var great, i, len, less, pivot;

  if (array.length < 2) {
    return array;
  } else {
    pivot = array[0];
    less = [];
    great = [];
    len = array.length;
    i = 0;

    while (++i !== len) {
      if (array[i] <= pivot) {
        less.push(array[i]);
      } else {
        great.push(array[i]);
      }
    }

    return sort(less).concat(pivot, sort(great));
  }
};

var hash = function hash(string) {
  var hsh, i, length;
  hsh = 5381;
  i = -1;
  length = string.length;

  while (++i !== string.length) {
    hsh = (hsh << 5) - hsh + string.charCodeAt(i);
    hsh |= 0;
  }

  return '_' + (hsh < 0 ? hsh * -2 : hsh);
};

var ruleToString = function ruleToString(rule, important) {
  var j, len1, output, prop, property, props, value;
  output = '';
  props = sort(Object.keys(rule));

  for (j = 0, len1 = props.length; j < len1; j++) {
    prop = props[j];

    if (typeof rule[prop] === 'string' || typeof rule[prop] === 'number') {
      property = normalizeProperty(prop);
      value = normalizeValue(property, rule[prop]);

      if (important) {
        value += " !important";
      }

      output += "".concat(property, ":").concat(value, ";");
    }
  }

  return output;
};

var inlineStyleConfig = styleConfig = Object.create(null);

var inlineStyle = function inlineStyle(rule, valueToStore, level) {
  var config, styleEl;

  if (!(config = styleConfig[level])) {
    styleEl = document.createElement('style');
    styleEl.id = "quickcss".concat(level || '');
    document.head.appendChild(styleEl);
    styleConfig[level] = config = {
      el: styleEl,
      content: '',
      cache: Object.create(null)
    };
  }

  if (!config.cache[rule]) {
    config.cache[rule] = valueToStore || true;
    config.el.textContent = config.content += rule;
  }
};

var clearInlineStyle = function clearInlineStyle(level) {
  var config, j, key, keys, len1;

  if (config = styleConfig[level]) {
    if (!config.content) {
      return;
    }

    config.el.textContent = config.content = '';
    keys = Object.keys(config.cache);

    for (j = 0, len1 = keys.length; j < len1; j++) {
      key = keys[j];
      config.cache[key] = null;
    }
  }
};

var version = "1.4.3";

var _quickcss;

var index = _quickcss = function quickcss(targetEl, property, value, important) {
  var computedStyle, i, len, subEl, subProperty, subValue;

  switch (false) {
    case !isIterable(targetEl):
      for (i = 0, len = targetEl.length; i < len; i++) {
        subEl = targetEl[i];

        _quickcss(subEl, property, value);
      }

      break;

    case _typeof(property) !== 'object':
      // Passed a style map
      for (subProperty in property) {
        subValue = property[subProperty];

        _quickcss(targetEl, subProperty, subValue);
      }

      break;

    default:
      property = normalizeProperty(property);

      if (typeof value === 'undefined') {
        computedStyle = targetEl._computedStyle || (targetEl._computedStyle = getComputedStyle(targetEl));
        return computedStyle[property];
      } else if (property) {
        targetEl.style.setProperty(property, normalizeValue(property, value), important ? IMPORTANT : void 0);
      }

  }
};

_quickcss.animation = function (name$$1, frames) {
  var frame, generated, prefix, rules;

  if (name$$1 && typeof name$$1 === 'string' && frames && _typeof(frames) === 'object') {
    prefix = getPrefix('animation');
    generated = '';

    for (frame in frames) {
      rules = frames[frame];
      generated += "".concat(frame, " {").concat(ruleToString(rules), "}");
    }

    generated = "@".concat(prefix, "keyframes ").concat(name$$1, " {").concat(generated, "}");
    return inlineStyle(generated, true, 0);
  }
};

_quickcss.register = function (rule, level, important) {
  var className, ref, style;

  if (rule && _typeof(rule) === 'object') {
    level || (level = 0);
    rule = ruleToString(rule, important);

    if (!(className = (ref = inlineStyleConfig[level]) != null ? ref[rule] : void 0)) {
      className = hash(rule);
      style = ".".concat(className, " {").concat(rule, "}");
      inlineStyle(style, className, level);
    }

    return className;
  }
};

_quickcss.clearRegistered = function (level) {
  return clearInlineStyle(level || 0);
};
/* istanbul ignore next */


_quickcss.UNSET = function () {
  switch (false) {
    case !isValueSupported('display', 'unset'):
      return 'unset';

    case !isValueSupported('display', 'initial'):
      return 'initial';

    case !isValueSupported('display', 'inherit'):
      return 'inherit';
  }
}();

_quickcss.supports = isValueSupported;
_quickcss.supportsProperty = isPropSupported;
_quickcss.normalizeProperty = normalizeProperty;
_quickcss.normalizeValue = normalizeValue;
_quickcss.version = version;function _typeof$1(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$1 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$1(obj);
}

var _extend, isArray, isObject, _shouldDeepExtend;

isArray = function isArray(target) {
  return Array.isArray(target);
};

isObject = function isObject(target) {
  return target && Object.prototype.toString.call(target) === '[object Object]' || isArray(target);
};

_shouldDeepExtend = function shouldDeepExtend(options, target, parentKey) {
  if (options.deep) {
    if (options.notDeep) {
      return !options.notDeep[target];
    } else {
      return true;
    }
  } else if (options.deepOnly) {
    return options.deepOnly[target] || parentKey && _shouldDeepExtend(options, parentKey);
  }
}; // else false


var extend = _extend = function extend(options, target, sources, parentKey) {
  var i, key, len, source, sourceValue, subTarget, targetValue;

  if (!target || _typeof$1(target) !== 'object' && typeof target !== 'function') {
    target = {};
  }

  for (i = 0, len = sources.length; i < len; i++) {
    source = sources[i];

    if (source != null) {
      for (key in source) {
        sourceValue = source[key];
        targetValue = target[key];

        if (sourceValue === target || sourceValue === void 0 || sourceValue === null && !options.allowNull && !options.nullDeletes || options.keys && !options.keys[key] || options.notKeys && options.notKeys[key] || options.own && !source.hasOwnProperty(key) || options.globalFilter && !options.globalFilter(sourceValue, key, source) || options.filters && options.filters[key] && !options.filters[key](sourceValue, key, source)) {
          continue;
        }

        if (sourceValue === null && options.nullDeletes) {
          delete target[key];
          continue;
        }

        if (options.globalTransform) {
          sourceValue = options.globalTransform(sourceValue, key, source);
        }

        if (options.transforms && options.transforms[key]) {
          sourceValue = options.transforms[key](sourceValue, key, source);
        }

        switch (false) {
          case !(options.concat && isArray(sourceValue) && isArray(targetValue)):
            target[key] = targetValue.concat(sourceValue);
            break;

          case !(_shouldDeepExtend(options, key, parentKey) && isObject(sourceValue)):
            subTarget = isObject(targetValue) ? targetValue : isArray(sourceValue) ? [] : {};
            target[key] = _extend(options, subTarget, [sourceValue], key);
            break;

          default:
            target[key] = sourceValue;
        }
      }
    }
  }

  return target;
};

var version$1 = "1.7.4";
var modifiers, newBuilder, normalizeKeys, primaryBuilder;

normalizeKeys = function normalizeKeys(keys) {
  var i, key, len, output;

  if (keys) {
    output = {};

    if (_typeof$1(keys) !== 'object') {
      output[keys] = true;
    } else {
      if (!Array.isArray(keys)) {
        keys = Object.keys(keys);
      }

      for (i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        output[key] = true;
      }
    }

    return output;
  }
};

newBuilder = function newBuilder(isBase) {
  var _builder;

  _builder = function builder(target) {
    var theTarget;
    var $_len = arguments.length,
        $_i = -1,
        sources = new Array($_len);

    while (++$_i < $_len) sources[$_i] = arguments[$_i];

    if (_builder.options.target) {
      theTarget = _builder.options.target;
    } else {
      theTarget = target;
      sources.shift();
    }

    return extend(_builder.options, theTarget, sources);
  };

  if (isBase) {
    _builder.isBase = true;
  }

  _builder.options = {};
  Object.defineProperties(_builder, modifiers);
  return _builder;
};

modifiers = {
  'deep': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.deep = true;
      return _;
    }
  },
  'own': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.own = true;
      return _;
    }
  },
  'allowNull': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.allowNull = true;
      return _;
    }
  },
  'nullDeletes': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.nullDeletes = true;
      return _;
    }
  },
  'concat': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.concat = true;
      return _;
    }
  },
  'clone': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.target = {};
      return _;
    }
  },
  'notDeep': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (keys) {
        _.options.notDeep = normalizeKeys(keys);
        return _;
      };
    }
  },
  'deepOnly': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (keys) {
        _.options.deepOnly = normalizeKeys(keys);
        return _;
      };
    }
  },
  'keys': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (keys) {
        _.options.keys = normalizeKeys(keys);
        return _;
      };
    }
  },
  'notKeys': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (keys) {
        _.options.notKeys = normalizeKeys(keys);
        return _;
      };
    }
  },
  'transform': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (transform) {
        if (typeof transform === 'function') {
          _.options.globalTransform = transform;
        } else if (transform && _typeof$1(transform) === 'object') {
          _.options.transforms = transform;
        }

        return _;
      };
    }
  },
  'filter': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (filter) {
        if (typeof filter === 'function') {
          _.options.globalFilter = filter;
        } else if (filter && _typeof$1(filter) === 'object') {
          _.options.filters = filter;
        }

        return _;
      };
    }
  }
};
primaryBuilder = newBuilder(true);
primaryBuilder.version = version$1;
var primaryBuilder$1 = primaryBuilder;function _typeof$2(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$2 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$2(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var defined = function defined(subject) {
  return subject !== void 0;
};

var array = function array(subject) {
  return subject instanceof Array;
};

var object = function object(subject) {
  return _typeof$2(subject) === 'object' && subject; // 2nd check is to test against 'null' values
};

var objectPlain = function objectPlain(subject) {
  return object(subject) && Object.prototype.toString.call(subject) === '[object Object]' && subject.constructor === Object;
};

var string = function string(subject) {
  return typeof subject === 'string';
};

var number = function number(subject) {
  return typeof subject === 'number' && !isNaN(subject);
};

var numberLoose = function numberLoose(subject) {
  return number(subject) || string(subject) && number(Number(subject));
};

var iterable = function iterable(subject) {
  return object(subject) && number(subject.length);
};

var function_ = function function_(subject) {
  return typeof subject === 'function';
};

var natives =
/*#__PURE__*/
Object.freeze({
  defined: defined,
  array: array,
  object: object,
  objectPlain: objectPlain,
  string: string,
  number: number,
  numberLoose: numberLoose,
  iterable: iterable,
  function_: function_
});

var domDoc = function domDoc(subject) {
  return subject && subject.nodeType === 9;
};

var domEl = function domEl(subject) {
  return subject && subject.nodeType === 1;
};

var domText = function domText(subject) {
  return subject && subject.nodeType === 3;
};

var domNode = function domNode(subject) {
  return domEl(subject) || domText(subject);
};

var domTextarea = function domTextarea(subject) {
  return subject && subject.nodeName === 'TEXTAREA';
};

var domInput = function domInput(subject) {
  return subject && subject.nodeName === 'INPUT';
};

var domSelect = function domSelect(subject) {
  return subject && subject.nodeName === 'SELECT';
};

var domField = function domField(subject) {
  return domInput(subject) || domTextarea(subject) || domSelect(subject);
};

var dom =
/*#__PURE__*/
Object.freeze({
  domDoc: domDoc,
  domEl: domEl,
  domText: domText,
  domNode: domNode,
  domTextarea: domTextarea,
  domInput: domInput,
  domSelect: domSelect,
  domField: domField
});
var AVAIL_SETS, Checks;
AVAIL_SETS = {
  natives: natives,
  dom: dom
};

Checks =
/*#__PURE__*/
function () {
  _createClass(Checks, [{
    key: "create",
    value: function create() {
      var args;

      if (arguments.length) {
        args = Array.prototype.slice.call(arguments);
      }

      return new Checks(args);
    }
  }]);

  function Checks(sets) {
    _classCallCheck(this, Checks);

    var i, len, set;

    if (sets == null) {
      sets = ['natives'];
    }

    for (i = 0, len = sets.length; i < len; i++) {
      set = sets[i];

      if (AVAIL_SETS[set]) {
        this.load(AVAIL_SETS[set]);
      }
    }
  }

  _createClass(Checks, [{
    key: "load",
    value: function load(set) {
      var key, value;

      if (AVAIL_SETS.natives.string(set)) {
        set = AVAIL_SETS[set];
      }

      if (!AVAIL_SETS.natives.objectPlain(set)) {
        return;
      }

      for (key in set) {
        value = set[key];

        if (key === 'function_') {
          key = 'function';
        }

        this[key] = value;
      }
    }
  }]);

  return Checks;
}();

var index$1 = Checks.prototype.create();function _typeof$3(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$3 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$3(obj);
}

function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$1(Constructor, staticProps);
  return Constructor;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var template = ['id', 'name', 'type', 'href', 'selected', 'checked', 'className']; // To copy from DOM Elements

var element = ['id', 'ref', 'type', 'name', 'text', 'style', 'class', 'className', 'url', 'href', 'selected', 'checked', 'props', 'attrs', 'passStateToChildren', 'stateTriggers', 'unpassableStates']; // Used in QuickElement::toJSON
// 'relatedInstance'

var IS;
IS = index$1.create('natives', 'dom');
IS.load({
  quickDomEl: function quickDomEl(subject) {
    return subject && subject.constructor.name === 'QuickElement';
  },
  template: function template(subject) {
    return subject && subject.constructor.name === 'QuickTemplate';
  }
}); // batch: (subject)-> subject and subject.constructor.name is 'QuickBatch'

var IS$1 = IS;

var QuickElement, QuickWindow, _quickdom;

QuickElement = null;
QuickWindow = null;

_quickdom = function quickdom() {
  var arg, args, element, i, j, len, prevCount;
  args = new Array(arguments.length);

  for (i = j = 0, len = arguments.length; j < len; i = ++j) {
    arg = arguments[i];
    args[i] = arg;
  }

  prevCount = QuickElement.count;
  element = _quickdom.create(args);

  if (element && element._postCreation && QuickElement.count !== prevCount) {
    element._postCreation();
  }

  return element;
};

_quickdom.create = function (args) {
  var argsLength, child, children, element, i, j, len, options, type;

  switch (false) {
    case !IS$1.array(args[0]):
      return _quickdom.apply(void 0, _toConsumableArray(args[0]));

    case !IS$1.template(args[0]):
      return args[0].spawn();

    case !IS$1.quickDomEl(args[0]):
      if (args[1]) {
        return args[0].updateOptions(args[1]);
      } else {
        return args[0];
      }

    case !(IS$1.domNode(args[0]) || IS$1.domDoc(args[0])):
      if (args[0]._quickElement) {
        return args[0]._quickElement;
      }

      type = args[0].nodeName.toLowerCase().replace('#', '');
      options = args[1] || {};
      options.existing = args[0];
      return new QuickElement(type, options);

    case args[0] !== window:
      return QuickWindow;

    case !IS$1.string(args[0]):
      type = args[0].toLowerCase();

      if (type === 'text') {
        options = IS$1.object(args[1]) ? args[1] : {
          text: args[1] || ''
        };
      } else {
        options = IS$1.object(args[1]) ? args[1] : {};
      }

      element = new QuickElement(type, options);

      if (args.length > 2) {
        children = new Array(argsLength = args.length);
        i = 1;

        while (++i < argsLength) {
          children[i + 1] = args[i];
        }

        for (j = 0, len = children.length; j < len; j++) {
          child = children[j];

          if (IS$1.string(child)) {
            child = _quickdom.text(child);
          }

          if (IS$1.array(child)) {
            child = _quickdom.apply(void 0, _toConsumableArray(child));
          }

          if (IS$1.quickDomEl(child)) {
            element.append(child);
          }
        }
      }

      return element;

    case !(args[0] && (IS$1.domNode(args[0][0]) || IS$1.domDoc(args[0][0]))):
      return _quickdom(args[0][0]);
  }
};

_quickdom.html = function (innerHTML) {
  var children, container;
  container = document.createElement('div');
  container.innerHTML = innerHTML;
  children = Array.prototype.slice.call(container.childNodes);
  return _quickdom.batch(children);
};

_quickdom.isQuickEl = function (target) {
  return IS$1.quickDomEl(target);
};

_quickdom.isEl = function (target) {
  return IS$1.domEl(target);
};

var init = function init(QuickElement_, QuickWindow_) {
  QuickElement = QuickElement_;
  QuickWindow = QuickWindow_;
  return _quickdom;
};

var includes$1 = function includes(target, item) {
  return target && target.indexOf(item) !== -1;
};

var removeItem = function removeItem(target, item) {
  var itemIndex;
  itemIndex = target.indexOf(item);

  if (itemIndex !== -1) {
    target.splice(itemIndex, 1);
  }

  return target;
};

var normalizeElementArg = function normalizeElementArg(targetEl) {
  switch (false) {
    case !IS$1.string(targetEl):
      return quickdom.text(targetEl);

    case !IS$1.domNode(targetEl):
      return quickdom(targetEl);

    case !IS$1.template(targetEl):
      return targetEl.spawn();

    default:
      return targetEl;
  }
};

var isStateStyle = function isStateStyle(string) {
  return string[0] === '$' || string[0] === '@';
};

var registerStyle = function registerStyle(rule, level, important) {
  var cached, i, len, output, prop, props;
  level || (level = 0);
  cached = styleCache.get(rule, level);

  if (cached) {
    return cached;
  }

  output = {
    className: [index.register(rule, level, important)],
    fns: [],
    rule: rule
  };
  props = Object.keys(rule);

  for (i = 0, len = props.length; i < len; i++) {
    prop = props[i];

    if (typeof rule[prop] === 'function') {
      output.fns.push([prop, rule[prop]]);
    }
  }

  return styleCache.set(rule, output, level);
};

var styleCache = new (
/*#__PURE__*/
function () {
  function _class() {
    _classCallCheck$1(this, _class);

    this.keys = Object.create(null);
    this.values = Object.create(null);
  }

  _createClass$1(_class, [{
    key: "get",
    value: function get(key, level) {
      var index$$1;

      if (this.keys[level]) {
        index$$1 = this.keys[level].indexOf(key);

        if (index$$1 !== -1) {
          return this.values[level][index$$1];
        }
      }
    }
  }, {
    key: "set",
    value: function set(key, value, level) {
      if (!this.keys[level]) {
        this.keys[level] = [];
        this.values[level] = [];
      }

      this.keys[level].push(key);
      this.values[level].push(value);
      return value;
    }
  }]);

  return _class;
}())();
var REGEX_WHITESPACE;
REGEX_WHITESPACE = /\s+/;

var on_ = function on_(eventNames, callback, useCapture, isPrivate) {
  var _this = this;

  var callbackRef, split;

  if (this._eventCallbacks == null) {
    this._eventCallbacks = {
      __refs: {}
    };
  }

  if (IS$1.string(eventNames) && IS$1.function(callback)) {
    split = eventNames.split('.');
    callbackRef = split[1];
    eventNames = split[0];

    if (eventNames === 'inserted' && this._inserted) {
      callback.call(this, this._parent);
      return this;
    }

    eventNames.split(REGEX_WHITESPACE).forEach(function (eventName) {
      var base;

      if (!_this._eventCallbacks[eventName]) {
        _this._eventCallbacks[eventName] = [];

        if (!isPrivate) {
          _this._listenTo(eventName, function (event) {
            return _this._invokeHandlers(eventName, event);
          }, useCapture);
        }
      }

      if (callbackRef) {
        if ((base = _this._eventCallbacks.__refs)[eventName] == null) {
          base[eventName] = {};
        }

        _this._eventCallbacks.__refs[eventName][callbackRef] = callback;
      }

      return _this._eventCallbacks[eventName].push(callback);
    });
  }

  return this;
};

var once = function once(eventNames, callback) {
  var _this2 = this;

  var _onceCallback;

  if (IS$1.string(eventNames) && IS$1.function(callback)) {
    this.on(eventNames, _onceCallback = function onceCallback(event) {
      _this2.off(eventNames, _onceCallback);

      return callback.call(_this2, event);
    });
  }

  return this;
};

var off_ = function off_(eventNames, callback) {
  var _this3 = this;

  var callbackRef, eventName, split;

  if (this._eventCallbacks == null) {
    this._eventCallbacks = {
      __refs: {}
    };
  }

  if (!IS$1.string(eventNames)) {
    for (eventName in this._eventCallbacks) {
      this.off(eventName);
    }
  } else {
    split = eventNames.split('.');
    callbackRef = split[1];
    eventNames = split[0];
    eventNames.split(REGEX_WHITESPACE).forEach(function (eventName) {
      var ref;

      if (_this3._eventCallbacks[eventName]) {
        if (callback == null) {
          callback = (ref = _this3._eventCallbacks.__refs[eventName]) != null ? ref[callbackRef] : void 0;
        }

        if (IS$1.function(callback)) {
          return removeItem(_this3._eventCallbacks[eventName], callback);
        } else if (!callbackRef) {
          return _this3._eventCallbacks[eventName].length = 0;
        }
      }
    });
  }

  return this;
};

var emit = function emit(eventName) {
  var bubbles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var cancelable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var data = arguments.length > 3 ? arguments[3] : undefined;
  var event;

  if (eventName && IS$1.string(eventName)) {
    event = document.createEvent('Event');
    event.initEvent(eventName, bubbles, cancelable);

    if (data && _typeof$3(data) === 'object') {
      primaryBuilder$1(event, data);
    }

    this.el.dispatchEvent(event);
  }

  return this;
};

var emitPrivate = function emitPrivate(eventName, arg) {
  var ref;

  if (eventName && IS$1.string(eventName) && ((ref = this._eventCallbacks) != null ? ref[eventName] : void 0)) {
    this._invokeHandlers(eventName, arg);
  }

  return this;
};

var _invokeHandlers = function _invokeHandlers(eventName, arg) {
  var callbacks, cb, i, len;
  callbacks = this._eventCallbacks[eventName].slice();

  for (i = 0, len = callbacks.length; i < len; i++) {
    cb = callbacks[i];
    cb.call(this, arg);
  }
};
/* istanbul ignore next */


var _listenTo = function _listenTo(eventName, callback, useCapture) {
  var eventNameToListenFor, listenMethod;
  listenMethod = this.el.addEventListener ? 'addEventListener' : 'attachEvent';
  eventNameToListenFor = this.el.addEventListener ? eventName : "on".concat(eventName);
  this.el[listenMethod](eventNameToListenFor, callback, useCapture);
  return this;
};

function events(QuickElement) {
  QuickElement.prototype.on = on_;
  QuickElement.prototype.once = once;
  QuickElement.prototype.off = off_;
  QuickElement.prototype.emit = emit;
  QuickElement.prototype.emitPrivate = emitPrivate;
  QuickElement.prototype._invokeHandlers = _invokeHandlers;
  return QuickElement.prototype._listenTo = _listenTo;
}
/**
* Sets/gets the value of a style property. In getter mode the computed property of
* the style will be returned unless the element is not inserted into the DOM. In
* webkit browsers all computed properties of a detached node are always an empty
* string but in gecko they reflect on the actual computed value, hence we need
* to "normalize" this behavior and make sure that even on gecko an empty string
* is returned
* @return {[type]} [description]
*/


var style = function style(property) {
  var _this = this;

  var args, i, key, keys, result, value;

  if (this.type === 'text') {
    return;
  }

  args = arguments;

  if (IS$1.string(property)) {
    value = typeof args[1] === 'function' ? args[1].call(this, this.related) : args[1];

    if (args[1] === null && IS$1.defined(this.currentStateStyle(property)) && !IS$1.function(this.currentStateStyle(property))) {
      value = index.UNSET;
    }

    if (value && typeof value.then === 'function') {
      value.then(function (value) {
        return index(_this.el, property, value, _this.options.forceStyle);
      });
    } else {
      result = index(this.el, property, value, this.options.forceStyle);
    }

    if (args.length === 1) {
      /* istanbul ignore next */
      if (this._inserted) {
        return result;
      } else if (!result) {
        return result;
      } else {
        return '';
      }
    }
  } else if (IS$1.object(property)) {
    keys = Object.keys(property);
    i = -1;

    while (key = keys[++i]) {
      this.style(key, property[key]);
    }
  }

  return this;
};
/**
* Attempts to resolve the value for a given property in the following order if each one isn't a valid value:
* 1. from computed style (for dom-inserted els)
* 2. from DOMElement.style object (for non-inserted els; if options.styleAfterInsert, will only have state styles)
* 3. from provided style options
* (for non-inserted els; checking only $base since state styles will always be applied to the style object even for non-inserted)
 */


var styleSafe = function styleSafe(property, skipComputed) {
  var computed, result, sample;

  if (this.type === 'text') {
    return;
  }

  sample = this.el.style[property];

  if (IS$1.string(sample) || IS$1.number(sample)) {
    computed = skipComputed ? 0 : this.style(property);
    result = computed || this.el.style[property] || this.currentStateStyle(property) || '';

    if (typeof result === 'function') {
      return result.call(this, this.related);
    } else {
      return result;
    }
  }

  return this;
};

var styleParsed = function styleParsed(property, skipComputed) {
  return parseFloat(this.styleSafe(property, skipComputed));
};

var recalcStyle = function recalcStyle(recalcChildren) {
  var child, j, len, ref, targetStyles;
  targetStyles = this._resolveFnStyles(this._getActiveStates(), true);
  this.style(targetStyles);

  if (recalcChildren) {
    ref = this._children;

    for (j = 0, len = ref.length; j < len; j++) {
      child = ref[j];
      child.recalcStyle();
    }
  }

  return this;
};

var currentStateStyle = function currentStateStyle(property) {
  var i, state, states;

  if (property) {
    if (this._state.length) {
      states = this._state.slice();

      if (this._stateShared && this._stateShared.length) {
        var _states;

        (_states = states).push.apply(_states, _toConsumableArray(this._stateShared));
      }

      i = states.length;

      while (state = states[--i]) {
        if (this._styles[state] && IS$1.defined(this._styles[state].rule[property])) {
          return this._styles[state].rule[property];
        }
      }
    }

    if (this._styles.base) {
      return this._styles.base.rule[property];
    }
  }
};

var hide = function hide() {
  return this.style('display', 'none');
};

var show = function show(display) {
  var ref;

  if (!display) {
    display = this.currentStateStyle('display');

    if (display === 'none' || !display) {
      display = 'block';
    }
  }

  if (display == null) {
    display = ((ref = this._styles.base) != null ? ref.display : void 0) || 'block';
  }

  return this.style('display', display);
};

var orientationGetter = {
  get: function get() {
    if (this.width > this.height) {
      return 'landscape';
    } else {
      return 'portrait';
    }
  }
};
var aspectRatioGetter = {
  get: function get() {
    return this.width / this.height;
  }
};

function style$1(QuickElement) {
  Object.defineProperties(QuickElement.prototype, {
    'orientation': orientationGetter,
    'aspectRatio': aspectRatioGetter,
    'rect': {
      get: function get() {
        return this.el.getBoundingClientRect();
      }
    },
    'width': {
      get: function get() {
        return parseFloat(this.style('width'));
      },
      set: function set(value) {
        return this.style('width', value);
      }
    },
    'height': {
      get: function get() {
        return parseFloat(this.style('height'));
      },
      set: function set(value) {
        return this.style('height', value);
      }
    }
  });
  QuickElement.prototype.style = style;
  QuickElement.prototype.styleSafe = styleSafe;
  QuickElement.prototype.styleParsed = styleParsed;
  QuickElement.prototype.recalcStyle = recalcStyle;
  QuickElement.prototype.currentStateStyle = currentStateStyle;
  QuickElement.prototype.hide = hide;
  return QuickElement.prototype.show = show;
}

var QuickWindow$1;
var QuickWindow$2 = QuickWindow$1 = {
  type: 'window',
  el: window,
  raw: window,
  _eventCallbacks: {
    __refs: {}
  }
};
QuickWindow$1.on = on_;
QuickWindow$1.off = off_;
QuickWindow$1.emit = emit;
QuickWindow$1.emitPrivate = emitPrivate;
QuickWindow$1._listenTo = _listenTo;
QuickWindow$1._invokeHandlers = _invokeHandlers;
Object.defineProperties(QuickWindow$1, {
  'width': {
    get: function get() {
      return window.innerWidth;
    }
  },
  'height': {
    get: function get() {
      return window.innerHeight;
    }
  },
  'orientation': orientationGetter,
  'aspectRatio': aspectRatioGetter
});
var MediaQuery, RULE_DEILIMITER;
RULE_DEILIMITER = /,\s*/;
var MediaQuery$1 = MediaQuery = new function () {
  var callbacks, testRule;
  callbacks = [];
  window.addEventListener('resize', function () {
    var callback, i, len;

    for (i = 0, len = callbacks.length; i < len; i++) {
      callback = callbacks[i];
      callback();
    }
  });

  this.parseQuery = function (target, queryString) {
    var querySplit, rules, source;
    querySplit = queryString.split('(');
    source = querySplit[0];

    source = function () {
      switch (source) {
        case 'window':
          return QuickWindow$2;

        case 'parent':
          return target.parent;

        case 'self':
          return target;

        default:
          return target.parentMatching(function (parent) {
            return parent.ref === source.slice(1);
          });
      }
    }();

    rules = querySplit[1].slice(0, -1).split(RULE_DEILIMITER).map(function (rule) {
      var getter, key, keyPrefix, max, min, split, value;
      split = rule.split(':');
      value = parseFloat(split[1]);

      if (isNaN(value)) {
        value = split[1];
      }

      key = split[0];
      keyPrefix = key.slice(0, 4);
      max = keyPrefix === 'max-';
      min = !max && keyPrefix === 'min-';

      if (max || min) {
        key = key.slice(4);
      }

      getter = function () {
        switch (key) {
          case 'orientation':
            return function () {
              return source.orientation;
            };

          case 'aspect-ratio':
            return function () {
              return source.aspectRatio;
            };

          case 'width':
          case 'height':
            return function () {
              return source[key];
            };

          default:
            return function () {
              var parsedValue, stringValue;
              stringValue = source.style(key);
              parsedValue = parseFloat(stringValue);

              if (isNaN(parsedValue)) {
                return stringValue;
              } else {
                return parsedValue;
              }
            };
        }
      }();

      return {
        key: key,
        value: value,
        min: min,
        max: max,
        getter: getter
      };
    });
    return {
      source: source,
      rules: rules
    };
  };

  this.register = function (target, queryString) {
    var callback, query;
    query = this.parseQuery(target, queryString);

    if (query.source) {
      callbacks.push(callback = function callback() {
        return testRule(target, query, queryString);
      });
      callback();
    }

    return query;
  };

  testRule = function testRule(target, query, queryString) {
    var currentValue, i, len, passed, ref, rule;
    passed = true;
    ref = query.rules;

    for (i = 0, len = ref.length; i < len; i++) {
      rule = ref[i];
      currentValue = rule.getter();

      passed = function () {
        switch (false) {
          case !rule.min:
            return currentValue >= rule.value;

          case !rule.max:
            return currentValue <= rule.value;

          default:
            return currentValue === rule.value;
        }
      }();

      if (!passed) {
        break;
      }
    }

    return target.state(queryString, passed);
  };

  return this;
}();
var StateChain;

var StateChain$1 = StateChain =
/*#__PURE__*/
function () {
  function StateChain(states) {
    _classCallCheck$1(this, StateChain);

    this.string = states.join('+');
    this.array = states.slice();
    this.length = states.length;
  }

  _createClass$1(StateChain, [{
    key: "includes",
    value: function includes(target) {
      var i, len, ref, state;
      ref = this.array;

      for (i = 0, len = ref.length; i < len; i++) {
        state = ref[i];

        if (state === target) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "without",
    value: function without(target) {
      return this.array.filter(function (state) {
        return state !== target;
      }).join('+');
    }
  }, {
    key: "isApplicable",
    value: function isApplicable(target, otherActive) {
      var active;
      active = this.array.filter(function (state) {
        return state === target || otherActive.indexOf(state) !== -1;
      });
      return active.length === this.array.length;
    }
  }]);

  return StateChain;
}();

var BASE_STATE_TRIGGERS, CACHED_FN_INSERTED;
BASE_STATE_TRIGGERS = {
  'hover': {
    on: 'mouseenter',
    off: 'mouseleave',
    bubbles: true
  },
  'focus': {
    on: 'focus',
    off: 'blur',
    bubbles: true
  }
};

var _normalizeOptions = function _normalizeOptions() {
  var base1, base2, base3, base4, base5;

  if (this.options.relatedInstance) {
    (base1 = this.options).related || (base1.related = this.options.relatedInstance);
    this.options.relatedInstance = null;
  }

  this.related = (base2 = this.options).related != null ? base2.related : base2.related = this;

  if (this.options.class) {
    this.options.className = this.options.class;
  }

  if (this.options.url) {
    this.options.href = this.options.url;
  }

  if ((base3 = this.options).unpassableStates == null) {
    base3.unpassableStates = [];
  }

  if ((base4 = this.options).passStateToChildren == null) {
    base4.passStateToChildren = true;
  }

  if ((base5 = this.options).passDataToChildren == null) {
    base5.passDataToChildren = true;
  }

  this.options.stateTriggers = this.options.stateTriggers ? primaryBuilder$1.clone.deep(BASE_STATE_TRIGGERS, this.options.stateTriggers) : BASE_STATE_TRIGGERS;

  if (this.type === 'text') {
    primaryBuilder$1(this, this._parseTexts(this.options.text, this._texts));
  } else {
    primaryBuilder$1(this, this._parseStyles(this.options.style, this._styles));
  }
};

var _parseStyles = function _parseStyles(styles, store) {
  var _mediaStates, _providedStates, _providedStatesShared, _stateShared, _styles, base, _flattenNestedStates, forceStyle, i, keys, len, specialStates, state, stateStyles, state_, states;

  if (!IS$1.objectPlain(styles)) {
    return;
  }

  keys = Object.keys(styles);
  states = keys.filter(function (key) {
    return isStateStyle(key);
  });
  specialStates = removeItem(states.slice(), '$base');
  _mediaStates = states.filter(function (key) {
    return key[0] === '@';
  }).map(function (state) {
    return state.slice(1);
  });
  _providedStates = states.map(function (state) {
    return state.slice(1); // Remove '$' prefix
  });
  _styles = store || {};
  _stateShared = _providedStatesShared = void 0;
  base = !includes$1(states, '$base') ? styles : styles.$base;
  _styles.base = registerStyle(base, 0, forceStyle = this.options.forceStyle);

  if (specialStates.length) {
    _flattenNestedStates = function flattenNestedStates(styleObject, chain, level) {
      var hasNonStateProps, i, len, output, state, stateChain, state_, styleKeys;
      styleKeys = Object.keys(styleObject);
      output = {};
      hasNonStateProps = false;

      for (i = 0, len = styleKeys.length; i < len; i++) {
        state = styleKeys[i];

        if (!isStateStyle(state)) {
          hasNonStateProps = true;
          output[state] = styleObject[state];
        } else {
          chain.push(state_ = state.slice(1));
          stateChain = new StateChain$1(chain);

          if (_stateShared == null) {
            _stateShared = [];
          }

          if (_providedStatesShared == null) {
            _providedStatesShared = [];
          }

          _providedStatesShared.push(stateChain);

          if (state[0] === '@') {
            _mediaStates.push(state_);
          }

          _styles[stateChain.string] = registerStyle(_flattenNestedStates(styleObject[state], chain, level + 1), level + 1, forceStyle);
        }
      }

      if (hasNonStateProps) {
        return output;
      }
    };

    for (i = 0, len = specialStates.length; i < len; i++) {
      state = specialStates[i];
      state_ = state.slice(1);
      stateStyles = _flattenNestedStates(styles[state], [state_], 1);

      if (stateStyles) {
        _styles[state_] = registerStyle(stateStyles, 1);
      }
    }
  }

  return {
    _styles: _styles,
    _mediaStates: _mediaStates,
    _stateShared: _stateShared,
    _providedStates: _providedStates,
    _providedStatesShared: _providedStatesShared
  };
};

var _parseTexts = function _parseTexts(texts, store) {
  var _providedStates, _texts, i, len, state, states;

  if (!IS$1.objectPlain(texts)) {
    return;
  }

  states = Object.keys(texts).map(function (state) {
    return state.slice(1);
  });
  _providedStates = states.filter(function (state) {
    return state !== 'base';
  });
  _texts = store || {};
  _texts = {
    base: ''
  };

  for (i = 0, len = states.length; i < len; i++) {
    state = states[i];
    _texts[state] = texts['$' + state];
  }

  return {
    _texts: _texts,
    _providedStates: _providedStates
  };
};

var _applyOptions = function _applyOptions() {
  var _this = this;

  var event, handler, method, ref, ref1, ref2, value;

  if (ref = this.options.id || this.options.ref) {
    this.attr('data-ref', this.ref = ref);
  }

  if (this.options.id) {
    this.el.id = this.options.id;
  }

  if (this.options.className) {
    this.el.className = this.options.className;
  }

  if (this.options.src) {
    this.el.src = this.options.src;
  }

  if (this.options.href) {
    this.el.href = this.options.href;
  }

  if (this.options.type) {
    this.el.type = this.options.type;
  }

  if (this.options.name) {
    this.el.name = this.options.name;
  }

  if (this.options.value) {
    this.el.value = this.options.value;
  }

  if (this.options.selected) {
    this.el.selected = this.options.selected;
  }

  if (this.options.checked) {
    this.el.checked = this.options.checked;
  }

  if (this.options.props) {
    this.prop(this.options.props);
  }

  if (this.options.attrs) {
    this.attr(this.options.attrs);
  }

  this._applyRegisteredStyle(this._styles.base, null, null, this.options.styleAfterInsert);

  if (this._texts) {
    this.text = this._texts.base;
  }

  this.on('inserted', CACHED_FN_INSERTED, false, true);

  if (this.options.invokeComputersOnce) {
    this._invokedComputers = {};
  }

  if (this.options.recalcOnResize) {
    window.addEventListener('resize', function () {
      return _this.recalcStyle();
    });
  }

  if (this.options.events) {
    ref1 = this.options.events;

    for (event in ref1) {
      handler = ref1[event];
      this.on(event, handler);
    }
  }

  if (this.options.methods) {
    ref2 = this.options.methods;

    for (method in ref2) {
      value = ref2[method];

      if (!this[method]) {
        if (IS$1.function(value)) {
          this[method] = value;
        } else if (IS$1.object(value)) {
          Object.defineProperty(this, method, {
            configurable: true,
            get: value.get,
            set: value.set
          });
        }
      }
    }
  }

  if (this.type !== 'text' && IS$1.object(this.options.text)) {
    this.append(_quickdom('text', {
      text: this.options.text
    }));
  }
};

var _postCreation = function _postCreation(data) {
  if (this.options.computers) {
    if (data && this.options.data) {
      data = primaryBuilder$1.clone(this.options.data, data);
    }

    data || (data = this.options.data);
    this.applyData(data, false);

    if (this.options.computers._init) {
      this._runComputer('_init', data);
    }
  }

  if (this.options.state) {
    this.state(this.options.state);
  }
};

var _attachStateEvents = function _attachStateEvents(force) {
  var _this2 = this;

  var states;
  states = Object.keys(this.options.stateTriggers);
  states.forEach(function (state) {
    var disabler, enabler, trigger;
    trigger = _this2.options.stateTriggers[state];

    if (!includes$1(_this2._providedStates, state) && !force && !trigger.force) {
      return;
    }

    enabler = IS$1.string(trigger) ? trigger : trigger.on;

    if (IS$1.object(trigger)) {
      disabler = trigger.off;
    }

    _this2._listenTo(enabler, function () {
      return _this2.state(state, true, trigger.bubbles);
    });

    if (disabler) {
      return _this2._listenTo(disabler, function () {
        return _this2.state(state, false, trigger.bubbles);
      });
    }
  });
};

var _proxyParent = function _proxyParent() {
  var parent;
  parent = void 0;
  return Object.defineProperty(this, '_parent', {
    get: function get() {
      return parent;
    },
    set: function set(newParent) {
      var _this3 = this;

      var lastParent;

      if (parent = newParent) {
        lastParent = this.parents.slice(-1)[0];

        if (lastParent.raw === document.documentElement) {
          this._unproxyParent(newParent);
        } else {
          parent.on('inserted', function () {
            if (parent === newParent) {
              return _this3._unproxyParent(newParent);
            }
          });
        }
      }
    }
  });
};

var _unproxyParent = function _unproxyParent(newParent) {
  delete this._parent;
  this._parent = newParent;
  this.emitPrivate('inserted', newParent);
};

CACHED_FN_INSERTED = function CACHED_FN_INSERTED() {
  var i, len, mediaStates, queryString, results;
  this._inserted = this;

  if (this.options.styleAfterInsert) {
    this.recalcStyle();
  }

  if ((mediaStates = this._mediaStates) && this._mediaStates.length) {
    this._mediaStates = Object.create(null);
    results = [];

    for (i = 0, len = mediaStates.length; i < len; i++) {
      queryString = mediaStates[i];
      results.push(this._mediaStates[queryString] = MediaQuery$1.register(this, queryString));
    }

    return results;
  }
};

function init$1(QuickElement) {
  QuickElement.prototype._normalizeOptions = _normalizeOptions;
  QuickElement.prototype._parseStyles = _parseStyles;
  QuickElement.prototype._parseTexts = _parseTexts;
  QuickElement.prototype._applyOptions = _applyOptions;
  QuickElement.prototype._postCreation = _postCreation;
  QuickElement.prototype._attachStateEvents = _attachStateEvents;
  QuickElement.prototype._proxyParent = _proxyParent;
  return QuickElement.prototype._unproxyParent = _unproxyParent;
}

function aliases(QuickElement) {
  return Object.defineProperties(QuickElement.prototype, {
    'raw': {
      get: function get() {
        return this.el;
      }
    },
    '0': {
      get: function get() {
        return this.el;
      }
    },
    'css': {
      get: function get() {
        return this.style;
      }
    },
    'replaceWith': {
      get: function get() {
        return this.replace;
      }
    },
    'removeListener': {
      get: function get() {
        return this.off;
      }
    }
  });
}

var parentsUntil = function parentsUntil(filter) {
  return _getParents(this, filter);
};

var parentMatching = function parentMatching(filter) {
  var isRef, nextParent;

  if (IS$1.function(filter) || (isRef = IS$1.string(filter))) {
    nextParent = this.parent;

    while (nextParent) {
      if (isRef) {
        if (nextParent.ref === filter) {
          return nextParent;
        }
      } else {
        if (filter(nextParent)) {
          return nextParent;
        }
      }

      nextParent = nextParent.parent;
    }
  }
};

var query = function query(selector) {
  return _quickdom(this.raw.querySelector(selector));
};

var queryAll = function queryAll(selector) {
  var i, item, len, output, result;
  result = this.raw.querySelectorAll(selector);
  output = [];

  for (i = 0, len = result.length; i < len; i++) {
    item = result[i];
    output.push(item);
  }

  return _quickdom.batch(output);
};

var _getParents = function _getParents(targetEl, filter) {
  var isRef, nextParent, parents;

  if (!IS$1.function(filter) && !(isRef = IS$1.string(filter))) {
    filter = void 0;
  }

  parents = [];
  nextParent = targetEl.parent;

  while (nextParent) {
    parents.push(nextParent);
    nextParent = nextParent.parent;

    if (isRef) {
      if (nextParent && nextParent.ref === filter) {
        nextParent = null;
      }
    } else if (filter) {
      if (filter(nextParent)) {
        nextParent = null;
      }
    }
  }

  return parents;
};

var _getChildRefs = function _getChildRefs(target, freshCopy) {
  var child, childRefs, children, el, i, len, ref, refs;

  if (freshCopy || !target._childRefs) {
    target._childRefs = {};
  }

  refs = target._childRefs;

  if (target.ref) {
    refs[target.ref] = target;
  }

  children = target.children;

  if (children.length) {
    for (i = 0, len = children.length; i < len; i++) {
      child = children[i];
      childRefs = _getChildRefs(child, freshCopy);

      for (ref in childRefs) {
        el = childRefs[ref];
        refs[ref] || (refs[ref] = el);
      }
    }
  }

  return refs;
};

var _getIndexByProp = function _getIndexByProp(main, prop) {
  var parent;

  if (!(parent = main.parent)) {
    return null;
  } else {
    return parent.children.filter(function (child) {
      return child[prop] === main[prop];
    }).indexOf(main);
  }
};

var _filterElements = function _filterElements(array) {
  var i, item, len, output;

  if (!array.length) {
    return array;
  } else {
    output = [];

    for (i = 0, len = array.length; i < len; i++) {
      item = array[i];

      if (item.type !== 'text') {
        output.push(item);
      }
    }

    return output;
  }
};

function traversing(QuickElement) {
  QuickElement.prototype.parentsUntil = parentsUntil;
  QuickElement.prototype.parentMatching = parentMatching;
  QuickElement.prototype.query = query;
  QuickElement.prototype.queryAll = queryAll;
  return Object.defineProperties(QuickElement.prototype, {
    'children': {
      get: function get() {
        var child, i, len, ref1;

        if (this.el.childNodes.length !== this._children.length) {
          // Re-collect children	
          this._children.length = 0; // Empty out children array

          ref1 = this.el.childNodes;

          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];

            if (child.nodeType < 4) {
              this._children.push(_quickdom(child));
            }
          }
        }

        return this._children;
      }
    },
    'elementChildren': {
      get: function get() {
        return _filterElements(this.children);
      }
    },
    'parent': {
      get: function get() {
        if ((!this._parent || this._parent.el !== this.el.parentNode) && !IS$1.domDoc(this.el.parentNode)) {
          this._parent = _quickdom(this.el.parentNode);
        }

        return this._parent;
      }
    },
    'parents': {
      get: function get() {
        return _getParents(this);
      }
    },
    'next': {
      get: function get() {
        return _quickdom(this.el.nextSibling);
      }
    },
    'nextEl': {
      get: function get() {
        return _quickdom(this.el.nextElementSibling);
      }
    },
    'nextElAll': {
      get: function get() {
        return _filterElements(this.nextAll);
      }
    },
    'nextAll': {
      get: function get() {
        var nextSibling, siblings;
        siblings = [];
        nextSibling = _quickdom(this.el.nextSibling);

        while (nextSibling) {
          siblings.push(nextSibling);
          nextSibling = nextSibling.next;
        }

        return siblings;
      }
    },
    'prev': {
      get: function get() {
        return _quickdom(this.el.previousSibling);
      }
    },
    'prevEl': {
      get: function get() {
        return _quickdom(this.el.previousElementSibling);
      }
    },
    'prevElAll': {
      get: function get() {
        return _filterElements(this.prevAll);
      }
    },
    'prevAll': {
      get: function get() {
        var prevSibling, siblings;
        siblings = [];
        prevSibling = _quickdom(this.el.previousSibling);

        while (prevSibling) {
          siblings.push(prevSibling);
          prevSibling = prevSibling.prev;
        }

        return siblings;
      }
    },
    'siblings': {
      get: function get() {
        return this.prevAll.reverse().concat(this.nextAll);
      }
    },
    'elementSiblings': {
      get: function get() {
        return _filterElements(this.siblings);
      }
    },
    'child': {
      get: function get() {
        return this._childRefs || _getChildRefs(this);
      }
    },
    'childf': {
      get: function get() {
        return _getChildRefs(this, true);
      }
    },
    'firstChild': {
      get: function get() {
        return this.children[0];
      }
    },
    'lastChild': {
      get: function get() {
        var children;
        children = this.children;
        return children[children.length - 1];
      }
    },
    'index': {
      get: function get() {
        var parent;

        if (!(parent = this.parent)) {
          return null;
        } else {
          return parent.children.indexOf(this);
        }
      }
    },
    'indexType': {
      get: function get() {
        return _getIndexByProp(this, 'type');
      }
    },
    'indexRef': {
      get: function get() {
        return _getIndexByProp(this, 'ref');
      }
    }
  });
}

_quickdom.query = function (target) {
  return _quickdom(document).query(target);
};

_quickdom.queryAll = function (target) {
  return _quickdom(document).queryAll(target);
};

var DUMMY_ARRAY;
DUMMY_ARRAY = [];

var state = function state(targetState, value, bubbles, source) {
  var activeStates, child, desiredValue, i, j, key, keys, len, prop, ref, toggle;

  if (arguments.length === 0) {
    return this._state.slice();
  }

  if (arguments.length === 1) {
    if (IS$1.string(targetState)) {
      return includes$1(this._state, targetState);
    } else if (IS$1.object(targetState)) {
      keys = Object.keys(targetState);
      i = -1;

      while (key = keys[++i]) {
        this.state(key, targetState[key]);
      }

      return this;
    }
  } else if (this._statePipeTarget && source !== this) {
    this._statePipeTarget.state(targetState, value, bubbles, this);

    return this;
  } else if (IS$1.string(targetState)) {
    if (targetState[0] === '$') {
      targetState = targetState.slice(1);
    }

    if (targetState === 'base') {
      return this;
    }

    desiredValue = !!value; // Convert the value to a boolean

    activeStates = this._getActiveStates(targetState, false); // ==== Toggle styles for this state =================================================================================

    if (this.state(targetState) !== desiredValue) {
      prop = this.type === 'text' ? 'Text' : 'Style';

      if (desiredValue) {
        //is on
        this._state.push(targetState);

        toggle = 'ON';
      } else {
        removeItem(this._state, targetState);
        toggle = 'OFF';
      }

      this['_turn' + prop + toggle](targetState, activeStates);
      this.emitPrivate("stateChange:".concat(targetState), desiredValue);
    } // ==== Pass state to parent/children =================================================================================


    if (!includes$1(this.options.unpassableStates, targetState)) {
      if (bubbles) {
        if (this.parent) {
          this._parent.state(targetState, value, true, source || this);
        }
      } else if (this.options.passStateToChildren) {
        ref = this._children;

        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          child.state(targetState, value, false, source || this);
        }
      }
    }

    return this;
  }
};

var toggleState = function toggleState(targetState) {
  return this.state(targetState, !this.state(targetState));
};

var resetState = function resetState() {
  var activeState, j, len, ref;
  ref = this._state.slice();

  for (j = 0, len = ref.length; j < len; j++) {
    activeState = ref[j];
    this.state(activeState, false);
  }

  return this;
};

var pipeState = function pipeState(targetEl) {
  var activeState, j, len, ref;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl) && targetEl !== this) {
      this._statePipeTarget = targetEl;
      ref = this._state;

      for (j = 0, len = ref.length; j < len; j++) {
        activeState = ref[j];
        targetEl.state(activeState, true);
      }
    }
  } else if (targetEl === false) {
    delete this._statePipeTarget;
  }

  return this;
};

var _applyRegisteredStyle = function _applyRegisteredStyle(targetStyle, superiorStates, includeBase, skipFns) {
  var className, entry, j, k, len, len1, ref, ref1, superiorStyles;

  if (targetStyle) {
    ref = targetStyle.className;

    for (j = 0, len = ref.length; j < len; j++) {
      className = ref[j];
      this.addClass(className);
    }

    if (targetStyle.fns.length && !skipFns) {
      if (superiorStates) {
        superiorStyles = this._resolveFnStyles(superiorStates, includeBase);
      }

      ref1 = targetStyle.fns;

      for (k = 0, len1 = ref1.length; k < len1; k++) {
        entry = ref1[k];

        if (!(superiorStyles && superiorStyles[entry[0]])) {
          this.style(entry[0], entry[1]);
        }
      }
    }
  }
};

var _removeRegisteredStyle = function _removeRegisteredStyle(targetStyle, superiorStates, includeBase) {
  var className, entry, j, k, len, len1, ref, ref1, resetValue, superiorStyles;
  ref = targetStyle.className;

  for (j = 0, len = ref.length; j < len; j++) {
    className = ref[j];
    this.removeClass(className);
  }

  if (targetStyle.fns.length) {
    if (superiorStates) {
      superiorStyles = this._resolveFnStyles(superiorStates, includeBase);
    }

    ref1 = targetStyle.fns;

    for (k = 0, len1 = ref1.length; k < len1; k++) {
      entry = ref1[k];
      resetValue = superiorStyles && superiorStyles[entry[0]] || null;
      this.style(entry[0], resetValue);
    }
  }
};

var _turnStyleON = function _turnStyleON(targetState, activeStates) {
  var j, len, sharedStates, skipFns, stateChain;
  skipFns = this.options.styleAfterInsert && !this._inserted;

  if (this._styles[targetState]) {
    this._applyRegisteredStyle(this._styles[targetState], this._getSuperiorStates(targetState, activeStates), false, skipFns);
  }

  if (this._providedStatesShared) {
    sharedStates = this._getSharedStates(targetState);

    for (j = 0, len = sharedStates.length; j < len; j++) {
      stateChain = sharedStates[j];

      if (!includes$1(this._stateShared, stateChain.string)) {
        this._stateShared.push(stateChain.string);
      }

      this._applyRegisteredStyle(this._styles[stateChain.string], null, null, skipFns);
    }
  }
};

var _turnStyleOFF = function _turnStyleOFF(targetState, activeStates) {
  var activeSharedStates, j, len, sharedStates, stateChain, targetStyle;

  if (this._styles[targetState]) {
    this._removeRegisteredStyle(this._styles[targetState], activeStates, true);
  }

  if (this._providedStatesShared) {
    sharedStates = this._getSharedStates(targetState);

    if (sharedStates.length === 0) {
      return;
    }

    for (j = 0, len = sharedStates.length; j < len; j++) {
      stateChain = sharedStates[j];
      removeItem(this._stateShared, stateChain.string);
      targetStyle = this._styles[stateChain.string];

      if (targetStyle.fns.length && this._stateShared.length && !activeSharedStates) {
        activeSharedStates = this._stateShared.filter(function (state) {
          return !includes$1(state, targetState);
        });
        activeStates = activeStates.concat(activeSharedStates);
      }

      this._removeRegisteredStyle(targetStyle, activeStates, true);
    }
  }
};

var _turnTextON = function _turnTextON(targetState, activeStates) {
  var superiorStates, targetText;

  if (this._texts && IS$1.string(targetText = this._texts[targetState])) {
    superiorStates = this._getSuperiorStates(targetState, activeStates);

    if (!superiorStates.length) {
      this.text = targetText;
    }
  }
};

var _turnTextOFF = function _turnTextOFF(targetState, activeStates) {
  var targetText;

  if (this._texts && IS$1.string(targetText = this._texts[targetState])) {
    activeStates = activeStates.filter(function (state) {
      return state !== targetState;
    });
    targetText = this._texts[activeStates[activeStates.length - 1]];

    if (targetText == null) {
      targetText = this._texts.base;
    }

    this.text = targetText;
  }
};

var _getActiveStates = function _getActiveStates(stateToExclude) {
  var includeSharedStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var activeStates, j, len, plainStates;

  if (!this._providedStates) {
    return DUMMY_ARRAY;
  }

  activeStates = plainStates = this._state;

  if (stateToExclude) {
    plainStates = [];

    for (j = 0, len = activeStates.length; j < len; j++) {
      state = activeStates[j];

      if (state !== stateToExclude) {
        plainStates.push(state);
      }
    }
  }

  if (!includeSharedStates || !this._providedStatesShared) {
    return plainStates;
  } else {
    return plainStates.concat(this._stateShared);
  }
};

var _getSuperiorStates = function _getSuperiorStates(targetState, activeStates) {
  var candidate, j, len, superior, targetStateIndex;
  targetStateIndex = this._providedStates.indexOf(targetState);

  if (targetStateIndex === this._providedStates.length - 1) {
    return DUMMY_ARRAY;
  }

  superior = [];

  for (j = 0, len = activeStates.length; j < len; j++) {
    candidate = activeStates[j];

    if (this._providedStates.indexOf(candidate) > targetStateIndex) {
      superior.push(candidate);
    }
  }

  return superior;
};

var _getSharedStates = function _getSharedStates(targetState) {
  var activeStates, j, len, ref, sharedStates, stateChain;
  activeStates = this._state;
  sharedStates = [];
  ref = this._providedStatesShared;

  for (j = 0, len = ref.length; j < len; j++) {
    stateChain = ref[j];

    if (stateChain.includes(targetState) && stateChain.isApplicable(targetState, activeStates)) {
      sharedStates.push(stateChain);
    }
  }

  return sharedStates;
};

var _resolveFnStyles = function _resolveFnStyles(states, includeBase) {
  var entry, j, k, len, len1, output, ref;

  if (includeBase) {
    states = ['base'].concat(states);
  }

  output = {};

  for (j = 0, len = states.length; j < len; j++) {
    state = states[j];

    if (this._styles[state] && this._styles[state].fns.length) {
      ref = this._styles[state].fns;

      for (k = 0, len1 = ref.length; k < len1; k++) {
        entry = ref[k];
        output[entry[0]] = entry[1];
      }
    }
  }

  return output;
};

function state$1(QuickElement) {
  QuickElement.prototype.state = state;
  QuickElement.prototype.toggleState = toggleState;
  QuickElement.prototype.resetState = resetState;
  QuickElement.prototype.pipeState = pipeState;
  QuickElement.prototype._applyRegisteredStyle = _applyRegisteredStyle;
  QuickElement.prototype._removeRegisteredStyle = _removeRegisteredStyle;
  QuickElement.prototype._turnStyleON = _turnStyleON;
  QuickElement.prototype._turnStyleOFF = _turnStyleOFF;
  QuickElement.prototype._turnTextON = _turnTextON;
  QuickElement.prototype._turnTextOFF = _turnTextOFF;
  QuickElement.prototype._getActiveStates = _getActiveStates;
  QuickElement.prototype._getSuperiorStates = _getSuperiorStates;
  QuickElement.prototype._getSharedStates = _getSharedStates;
  return QuickElement.prototype._resolveFnStyles = _resolveFnStyles;
}

var toTemplate = function toTemplate() {
  return _quickdom.template(this);
};

var clone = function clone() {
  var activeState, callback, callbacks, child, elClone, eventName, i, j, k, len, len1, len2, newEl, options, ref, ref1, ref2;
  elClone = this.el.cloneNode(false);
  options = primaryBuilder$1.clone(this.options, {
    existing: elClone
  });
  newEl = new this.constructor(this.type, options);
  ref = this._state;

  for (i = 0, len = ref.length; i < len; i++) {
    activeState = ref[i];
    newEl.state(activeState, true);
  }

  ref1 = this.children;

  for (j = 0, len1 = ref1.length; j < len1; j++) {
    child = ref1[j];
    newEl.append(child.clone());
  }

  ref2 = this._eventCallbacks;

  for (eventName in ref2) {
    callbacks = ref2[eventName];

    for (k = 0, len2 = callbacks.length; k < len2; k++) {
      callback = callbacks[k];
      newEl.on(eventName, callback);
    }
  }

  return newEl;
};

var append = function append(targetEl) {
  var prevParent;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      prevParent = targetEl.parent;

      if (prevParent) {
        prevParent._removeChild(targetEl);
      }

      this._children.push(targetEl);

      this.el.appendChild(targetEl.el);

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var appendTo = function appendTo(targetEl) {
  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      targetEl.append(this);
    }
  }

  return this;
};

var prepend = function prepend(targetEl) {
  var prevParent;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      prevParent = targetEl.parent;

      if (prevParent) {
        prevParent._removeChild(targetEl);
      }

      this._children.unshift(targetEl);

      this.el.insertBefore(targetEl.el, this.el.firstChild);

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var prependTo = function prependTo(targetEl) {
  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      targetEl.prepend(this);
    }
  }

  return this;
};

var after = function after(targetEl) {
  var myIndex;

  if (targetEl && this.parent) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      myIndex = this.parent._children.indexOf(this);

      this.parent._children.splice(myIndex + 1, 0, targetEl);

      this.el.parentNode.insertBefore(targetEl.el, this.el.nextSibling);

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var insertAfter = function insertAfter(targetEl) {
  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      targetEl.after(this);
    }
  }

  return this;
};

var before = function before(targetEl) {
  var myIndex;

  if (targetEl && this.parent) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      myIndex = this.parent._children.indexOf(this);

      this.parent._children.splice(myIndex, 0, targetEl);

      this.el.parentNode.insertBefore(targetEl.el, this.el);

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var insertBefore = function insertBefore(targetEl) {
  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      targetEl.before(this);
    }
  }

  return this;
};

var detach = function detach() {
  var ref;

  if ((ref = this.parent) != null) {
    ref._removeChild(this);
  }

  return this;
};

var remove = function remove() {
  var eventName;
  this.detach();
  this.resetState();

  if (this._eventCallbacks) {
    for (eventName in this._eventCallbacks) {
      this._eventCallbacks[eventName].length = 0;
    }
  }

  return this;
};

var empty = function empty() {
  var child, i, len, ref;
  ref = this.children.slice();

  for (i = 0, len = ref.length; i < len; i++) {
    child = ref[i];

    this._removeChild(child);
  }

  return this;
};

var wrap = function wrap(targetEl) {
  var currentParent;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);
    currentParent = this.parent;

    if (IS$1.quickDomEl(targetEl) && targetEl !== this && targetEl !== this.parent) {
      if (currentParent) {
        currentParent._removeChild(this, !targetEl.parent ? targetEl : void 0);
      }

      targetEl.append(this);
    }
  }

  return this;
};

var unwrap = function unwrap() {
  var grandParent, parent, parentChildren, parentSibling;
  parent = this.parent;

  if (parent) {
    parentChildren = _quickdom.batch(parent.children);
    parentSibling = parent.next;
    grandParent = parent.parent;

    if (grandParent) {
      parent.detach();

      if (parentSibling) {
        parentChildren.insertBefore(parentSibling);
      } else {
        parentChildren.appendTo(grandParent);
      }
    }
  }

  return this;
};

var replace = function replace(targetEl) {
  var ref;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl) && targetEl !== this) {
      targetEl.detach();

      if ((ref = this.parent) != null) {
        ref._removeChild(this, targetEl);
      }

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var hasClass = function hasClass(target) {
  return includes$1(this.classList, target);
};

var addClass = function addClass(target) {
  var classList, targetIndex;
  classList = this.classList;
  targetIndex = classList.indexOf(target);

  if (targetIndex === -1) {
    classList.push(target);
    this.className = classList.length > 1 ? classList.join(' ') : classList[0];
  }

  return this;
};

var removeClass = function removeClass(target) {
  var classList, targetIndex;
  classList = this.classList;
  targetIndex = classList.indexOf(target);

  if (targetIndex !== -1) {
    classList.splice(targetIndex, 1);
    this.className = classList.length ? classList.join(' ') : '';
  }

  return this;
};

var toggleClass = function toggleClass(target) {
  if (this.hasClass(target)) {
    this.removeClass(target);
  } else {
    this.addClass(target);
  }

  return this;
};

var setRef = function setRef(target) {
  this.ref = this.options.ref = target;
  this.attr('data-ref', target);
  return this;
};

var _refreshParent = function _refreshParent() {
  return this.parent;
};

var _removeChild = function _removeChild(targetChild, replacementChild) {
  var indexOfChild;
  indexOfChild = this.children.indexOf(targetChild);

  if (indexOfChild !== -1) {
    if (replacementChild) {
      this.el.replaceChild(replacementChild.el, targetChild.el);

      this._children.splice(indexOfChild, 1, replacementChild);
    } else {
      this.el.removeChild(targetChild.el);

      this._children.splice(indexOfChild, 1);
    }
  }

  return this;
};

function manipulation(QuickElement) {
  Object.defineProperties(QuickElement.prototype, {
    'html': {
      get: function get() {
        return this.el.innerHTML;
      },
      set: function set(newValue) {
        return this.el.innerHTML = newValue;
      }
    },
    'text': {
      get: function get() {
        return this.el.textContent;
      },
      set: function set(newValue) {
        return this.el.textContent = newValue;
      }
    },
    'className': {
      get: function get() {
        if (this.svg) {
          return this.attr('class') || '';
        } else {
          return this.raw.className;
        }
      },
      set: function set(newValue) {
        if (this.svg) {
          return this.attr('class', newValue);
        } else {
          return this.raw.className = newValue;
        }
      }
    },
    'classList': {
      get: function get() {
        var list;
        list = this.className.split(/\s+/);

        if (list[list.length - 1] === '') {
          list.pop();
        }

        if (list[0] === '') {
          list.shift();
        }

        return list;
      }
    }
  });
  QuickElement.prototype.toTemplate = toTemplate;
  QuickElement.prototype.clone = clone;
  QuickElement.prototype.append = append;
  QuickElement.prototype.appendTo = appendTo;
  QuickElement.prototype.prepend = prepend;
  QuickElement.prototype.prependTo = prependTo;
  QuickElement.prototype.after = after;
  QuickElement.prototype.insertAfter = insertAfter;
  QuickElement.prototype.before = before;
  QuickElement.prototype.insertBefore = insertBefore;
  QuickElement.prototype.detach = detach;
  QuickElement.prototype.remove = remove;
  QuickElement.prototype.empty = empty;
  QuickElement.prototype.wrap = wrap;
  QuickElement.prototype.unwrap = unwrap;
  QuickElement.prototype.replace = replace;
  QuickElement.prototype.hasClass = hasClass;
  QuickElement.prototype.addClass = addClass;
  QuickElement.prototype.removeClass = removeClass;
  QuickElement.prototype.toggleClass = toggleClass;
  QuickElement.prototype.setRef = setRef;
  QuickElement.prototype._refreshParent = _refreshParent;
  return QuickElement.prototype._removeChild = _removeChild;
}

var updateOptions = function updateOptions(options) {
  if (IS$1.object(options)) {
    this.options = options;

    this._normalizeOptions();

    this._applyOptions(this.options);
  }

  return this;
};

var updateStateStyles = function updateStateStyles(styles) {
  var i, len, parsed, state, updatedStates;

  if (IS$1.objectPlain(styles)) {
    primaryBuilder$1.deep.concat(this, parsed = this._parseStyles(styles));

    if (parsed._styles) {
      updatedStates = Object.keys(parsed._styles);

      for (i = 0, len = updatedStates.length; i < len; i++) {
        state = updatedStates[i];

        if (this.state(state) || state === 'base') {
          this._applyRegisteredStyle(this._styles[state], this._getActiveStates(state), false);
        }
      }
    }
  }

  return this;
};

var updateStateTexts = function updateStateTexts(texts) {
  var parsed;

  if (IS$1.objectPlain(texts)) {
    primaryBuilder$1.deep.concat(this, parsed = this._parseTexts(texts));
  }

  return this;
};

var applyData = function applyData(data, passThrough) {
  var child, computers, defaults, i, j, key, keys, len, len1, ref;

  if (this.options.passDataToChildren && this._children.length && (passThrough != null ? passThrough : passThrough = true)) {
    ref = this._children;

    for (i = 0, len = ref.length; i < len; i++) {
      child = ref[i];
      child.applyData(data);
    }
  }

  if (computers = this.options.computers) {
    defaults = this.options.defaults;
    keys = Object.keys(computers);

    for (j = 0, len1 = keys.length; j < len1; j++) {
      key = keys[j];

      if (this.options.invokeComputersOnce) {
        if (this._invokedComputers[key]) {
          continue;
        }

        this._invokedComputers[key] = 1;
      }

      if (data && data.hasOwnProperty(key)) {
        this._runComputer(key, data[key], data);
      } else if (defaults && defaults.hasOwnProperty(key)) {
        this._runComputer(key, defaults[key], data);
      }
    }
  }

  return this;
};

var _runComputer = function _runComputer(computer, arg, data) {
  return this.options.computers[computer].call(this, arg, data);
};

function application(QuickElement) {
  QuickElement.prototype.updateOptions = updateOptions;
  QuickElement.prototype.updateStateStyles = updateStateStyles;
  QuickElement.prototype.updateStateTexts = updateStateTexts;
  QuickElement.prototype.applyData = applyData;
  return QuickElement.prototype._runComputer = _runComputer;
}

var attr = function attr(target, newValue) {
  var i, key, keys;

  if (arguments.length === 1) {
    if (typeof target === 'string') {
      return this.el.getAttribute(target);
    }

    if (IS$1.object(target)) {
      keys = Object.keys(target);
      i = -1;

      while (key = keys[++i]) {
        this.attr(key, target[key]);
      }
    }
  } else if (newValue === null) {
    return this.el.removeAttribute(target);
  } else {
    this.el.setAttribute(target, newValue);
  }

  return this;
};

var prop = function prop(target, newValue) {
  var i, key, keys;

  if (arguments.length === 1) {
    if (typeof target === 'string') {
      return this.el[target];
    }

    if (IS$1.object(target)) {
      keys = Object.keys(target);
      i = -1;

      while (key = keys[++i]) {
        this.prop(key, target[key]);
      }
    }
  } else {
    this.el[target] = newValue;
  }

  return this;
};

function attributesAndProperties(QuickElement) {
  QuickElement.prototype.attr = attr;
  return QuickElement.prototype.prop = prop;
}

var QuickElement$1, svgNamespace;
svgNamespace = 'http://www.w3.org/2000/svg';

var QuickElement$2 = QuickElement$1 = function () {
  var QuickElement =
  /*#__PURE__*/
  function () {
    function QuickElement(type, options) {
      _classCallCheck$1(this, QuickElement);

      this.type = type;
      this.options = options;
      QuickElement.count++;

      if (this.type[0] === '*') {
        this.svg = true;
      }

      this.el = this.options.existing || (this.type === 'text' ? document.createTextNode(typeof this.options.text === 'string' ? this.options.text : '') : this.svg ? document.createElementNS(svgNamespace, this.type.slice(1)) : document.createElement(this.type));

      if (this.type === 'text') {
        this.append = this.prepend = this.attr = function () {};
      } // @_texts = {} # defined conditionally


      this._parent = null;
      this._styles = {};
      this._state = [];
      this._children = []; // @_providedStates = []				# defined conditionally
      // @_providedStatesShared = []		# defined conditionally
      // @_eventCallbacks = {__refs:{}}	# defined conditionally

      this._normalizeOptions();

      this._applyOptions();

      this._attachStateEvents();

      this._proxyParent();

      if (this.options.existing) {
        this._refreshParent();
      }

      this.el._quickElement = this;
    }

    _createClass$1(QuickElement, [{
      key: "toJSON",
      value: function toJSON() {
        var child, children, i, len, output;
        output = [this.type, primaryBuilder$1.clone.keys(element)(this.options)];
        children = this.children;

        for (i = 0, len = children.length; i < len; i++) {
          child = children[i];
          output.push(child.toJSON());
        }

        return output;
      }
    }]);

    return QuickElement;
  }();

  QuickElement.count = 0;
  return QuickElement;
}.call(undefined);
/* istanbul ignore next */


if (QuickElement$1.name == null) {
  QuickElement$1.name = 'QuickElement';
}

init$1(QuickElement$1);
aliases(QuickElement$1);
traversing(QuickElement$1);
events(QuickElement$1);
state$1(QuickElement$1);
style$1(QuickElement$1);
manipulation(QuickElement$1);
application(QuickElement$1);
attributesAndProperties(QuickElement$1);
var schema = {
  type: 'div',
  ref: void 0,
  options: {},
  children: []
};

var matchesSchema = function matchesSchema(object) {
  return typeof object.type !== 'undefined' || typeof object.ref !== 'undefined' || typeof object.options !== 'undefined' || typeof object.children !== 'undefined';
};

var PARSE_ERROR_PREFIX, parseTree;
PARSE_ERROR_PREFIX = 'Template Parse Error: expected';

var parseTree$1 = parseTree = function parseTree(tree, parseChildren) {
  var output;

  switch (false) {
    case !IS$1.array(tree):
      output = {};

      if (!IS$1.string(tree[0])) {
        throw new Error("".concat(PARSE_ERROR_PREFIX, " string for 'type', got '").concat(String(tree[0]), "'"));
      } else {
        output.type = tree[0];
      }

      if (tree.length > 1 && !IS$1.object(tree[1]) && tree[1] !== null) {
        throw new Error("".concat(PARSE_ERROR_PREFIX, " object for 'options', got '").concat(String(tree[1]), "'"));
      } else {
        output.options = tree[1] ? primaryBuilder$1.deep.clone(tree[1]) : schema.options;

        if (tree[1]) {
          output.ref = tree[1].id || tree[1].ref;
        }
      }

      output.children = tree.slice(2);

      if (parseChildren === false) {
        if (tree.length === 3 && IS$1.objectPlain(tree[2]) && !IS$1.template(tree[2])) {
          output.children = tree[2];
        }
      } else {
        output.children = output.children.map(quickdom.template);
      }

      return output;

    case !(IS$1.string(tree) || IS$1.domText(tree)):
      return {
        type: 'text',
        options: {
          text: tree.textContent || tree
        },
        children: schema.children
      };

    case !IS$1.domEl(tree):
      return {
        type: tree.nodeName.toLowerCase(),
        ref: tree.id,
        options: primaryBuilder$1.clone.keys(template)(tree),
        children: schema.children.map.call(tree.childNodes, quickdom.template)
      };

    case !IS$1.quickDomEl(tree):
      return {
        type: tree.type,
        ref: tree.ref,
        options: primaryBuilder$1.clone.deep.notKeys(['relatedInstance', 'related'])(tree.options),
        children: tree.children.map(quickdom.template)
      };

    case !IS$1.template(tree):
      return tree;

    default:
      throw new Error("".concat(PARSE_ERROR_PREFIX, " (array || string || domEl || quickDomEl || template), got ").concat(String(tree)));
  }
};

var NOT_DEEP_KEYS, NOT_KEYS, _extendByRef, extendTemplate;

NOT_DEEP_KEYS = ['relatedInstance', 'related', 'data'];
NOT_KEYS = ['children', '_childRefs'];

var extendTemplate$1 = extendTemplate = function extendTemplate(currentOpts, newOpts, globalOpts) {
  var currentChild, currentChildren, globalOptsTransform, index$$1, maxLength, needsTemplateWrap, newChild, newChildProcessed, newChildren, noChanges, output, ref, remainingNewChildren;

  if (globalOpts) {
    globalOptsTransform = {
      options: function options(opts) {
        return primaryBuilder$1(opts, globalOpts);
      }
    };
  }

  if (IS$1.array(newOpts)) {
    newOpts = parseTree$1(newOpts, false);
  } else if (newOpts && !matchesSchema(newOpts)) {
    newOpts = {
      options: newOpts
    };
  }

  output = primaryBuilder$1.deep.nullDeletes.notKeys(NOT_KEYS).notDeep(NOT_DEEP_KEYS).transform(globalOptsTransform).clone(currentOpts, newOpts);
  currentChildren = currentOpts.children;
  newChildren = (newOpts != null ? newOpts.children : void 0) || [];
  output.children = [];
  /* istanbul ignore next */

  if (IS$1.array(newChildren)) {
    maxLength = Math.max(currentChildren.length, newChildren.length);
    index$$1 = -1;

    while (++index$$1 !== maxLength) {
      needsTemplateWrap = noChanges = false;
      currentChild = currentChildren[index$$1];
      newChild = newChildren[index$$1];

      newChildProcessed = function () {
        switch (false) {
          case !IS$1.template(newChild):
            return newChild;

          case !IS$1.array(newChild):
            return needsTemplateWrap = parseTree$1(newChild);

          case !IS$1.string(newChild):
            return needsTemplateWrap = {
              type: 'text',
              options: {
                text: newChild
              }
            };

          case !(!newChild && !globalOpts):
            return noChanges = true;

          default:
            return needsTemplateWrap = newChild || true;
        }
      }();

      if (noChanges) {
        newChildProcessed = currentChild;
      } else if (needsTemplateWrap) {
        newChildProcessed = currentChild ? currentChild.extend(newChildProcessed, globalOpts) : new QuickTemplate$1(primaryBuilder$1.clone(schema, newChildProcessed));
      }

      output.children.push(newChildProcessed);
    }
  } else if (IS$1.object(newChildren)) {
    newChildren = primaryBuilder$1.allowNull.clone(newChildren);
    output.children = _extendByRef(newChildren, currentChildren, globalOpts);
    remainingNewChildren = newChildren;

    for (ref in remainingNewChildren) {
      newChild = remainingNewChildren[ref];
      newChildProcessed = IS$1.objectPlain(newChild) && !IS$1.template(newChild) ? newChild : parseTree$1(newChild);
      output.children.push(new QuickTemplate$1(newChildProcessed));
      delete remainingNewChildren[ref];
    }
  }

  return output;
};

_extendByRef = function extendByRef(newChildrenRefs, currentChildren, globalOpts) {
  var currentChild, i, len, newChild, newChildProcessed, output;

  if (!currentChildren.length) {
    return currentChildren;
  } else {
    output = [];

    for (i = 0, len = currentChildren.length; i < len; i++) {
      currentChild = currentChildren[i];
      newChild = newChildrenRefs[currentChild.ref];

      if (newChild) {
        newChildProcessed = currentChild.extend(newChild, globalOpts);
        delete newChildrenRefs[currentChild.ref];
      } else if (newChild === null) {
        delete newChildrenRefs[currentChild.ref];
        continue;
      } else {
        newChildProcessed = function () {
          switch (false) {
            case !globalOpts:
              return currentChild.extend(null, globalOpts);

            case !Object.keys(newChildrenRefs).length:
              return currentChild.extend();

            default:
              return currentChild;
          }
        }();
      }

      newChildProcessed.children = _extendByRef(newChildrenRefs, newChildProcessed.children);
      output.push(newChildProcessed);
    }

    return output;
  }
};

var QuickTemplate;

var QuickTemplate$1 = QuickTemplate =
/*#__PURE__*/
function () {
  function QuickTemplate(config, isTree) {
    _classCallCheck$1(this, QuickTemplate);

    if (IS$1.template(config)) {
      return config;
    }

    config = isTree ? parseTree$1(config) : config;
    primaryBuilder$1(this, config);
  }

  _createClass$1(QuickTemplate, [{
    key: "extend",
    value: function extend$$1(newValues, globalOpts) {
      return new QuickTemplate(extendTemplate$1(this, newValues, globalOpts));
    }
  }, {
    key: "spawn",
    value: function spawn(newValues, globalOpts, data) {
      var child, childData, children, element, i, len, options, type;

      if (newValues && newValues.data) {
        data = newValues.data;

        if (Object.keys(newValues).length === 1) {
          newValues = null;
        }
      }

      if (newValues || globalOpts) {
        var _extendTemplate = extendTemplate$1(this, newValues, globalOpts);

        options = _extendTemplate.options;
        children = _extendTemplate.children;
        type = _extendTemplate.type;
      } else {
        options = this.options;
        children = this.children;
        type = this.type;
        options = primaryBuilder$1.clone(options);
      }

      element = _quickdom.create([type, options]);

      if (children) {
        childData = options.passDataToChildren ? data || options.data : void 0;

        for (i = 0, len = children.length; i < len; i++) {
          child = children[i];
          element.append(child.spawn(null, null, childData));
        }
      }

      element._postCreation(data);

      return element;
    }
  }]);

  return QuickTemplate;
}();
/* istanbul ignore next */


if (QuickTemplate.name == null) {
  QuickTemplate.name = 'QuickTemplate';
}

Object.defineProperty(QuickTemplate.prototype, 'child', {
  get: function get() {
    return this._childRefs || _getChildRefs(this);
  }
});

_quickdom.template = function (tree) {
  return new QuickTemplate(tree, true);
};

_quickdom.isTemplate = function (target) {
  return IS$1.template(target);
};

var QuickBatch;

var QuickBatch$1 = QuickBatch =
/*#__PURE__*/
function () {
  function QuickBatch(elements, returnResults1) {
    _classCallCheck$1(this, QuickBatch);

    this.returnResults = returnResults1;
    this.elements = elements.map(function (el) {
      return _quickdom(el);
    });
  }

  _createClass$1(QuickBatch, [{
    key: "reverse",
    value: function reverse() {
      this.elements = this.elements.reverse();
      return this;
    }
  }, {
    key: "return",
    value: function _return(returnNext) {
      if (returnNext) {
        this.returnResults = true;
        return this;
      } else {
        return this.lastResults;
      }
    }
  }]);

  return QuickBatch;
}();
/* istanbul ignore next */


if (QuickBatch.name == null) {
  QuickBatch.name = 'QuickBatch';
}

Object.keys(QuickElement$2.prototype).concat('css', 'replaceWith', 'html', 'text').forEach(function (method) {
  return QuickBatch.prototype[method] = function (newValue) {
    var element, results;

    results = this.lastResults = function () {
      var i, len, ref, results1;
      ref = this.elements;
      results1 = [];

      for (i = 0, len = ref.length; i < len; i++) {
        element = ref[i];

        if (method === 'html' || method === 'text') {
          if (newValue) {
            results1.push(element[method] = newValue);
          } else {
            results1.push(element[method]);
          }
        } else {
          var _element;

          results1.push((_element = element)[method].apply(_element, arguments));
        }
      }

      return results1;
    }.apply(this, arguments);

    if (this.returnResults) {
      return results;
    } else {
      return this;
    }
  };
});

_quickdom.batch = function (elements, returnResults) {
  if (!IS$1.iterable(elements)) {
    throw new Error("Batch: expected an iterable, got ".concat(String(elements)));
  }

  return new QuickBatch(elements, returnResults);
};

var version$2 = "1.0.93";
var SHORTCUTS, i, len, shortcut;
SHORTCUTS = ['link:a', 'anchor:a', 'a', 'text', 'div', 'span', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'footer', 'section', 'button', 'br', 'ul', 'ol', 'li', 'fieldset', 'input', 'textarea', 'select', 'option', 'form', 'frame', 'hr', 'iframe', 'img', 'picture', 'main', 'nav', 'meta', 'object', 'pre', 'style', 'table', 'tbody', 'th', 'tr', 'td', 'tfoot', // 'template'
'video'];

for (i = 0, len = SHORTCUTS.length; i < len; i++) {
  shortcut = SHORTCUTS[i];

  (function (shortcut) {
    var prop, split, type;
    prop = type = shortcut;

    if (includes$1(shortcut, ':')) {
      split = shortcut.split(':');
      prop = split[0];
      type = split[1];
    }

    return _quickdom[prop] = function () {
      return _quickdom.apply(void 0, [type].concat(Array.prototype.slice.call(arguments)));
    };
  })(shortcut);
}

init(QuickElement$2, QuickWindow$2);
_quickdom.QuickElement = QuickElement$2;
_quickdom.QuickTemplate = QuickTemplate$1;
_quickdom.QuickWindow = QuickWindow$2;
_quickdom.QuickBatch = QuickBatch$1;
_quickdom.version = version$2;
_quickdom.CSS = index;
var quickdom = _quickdom; // export {quickdom as default, QuickElement, QuickTemplate, QuickWindow, QuickBatch}
var restartSandbox;
var restartSandbox$1 = restartSandbox = function () {
  var field, id, ref;

  if (window.sandbox) {
    ref = quickfield.instances;

    for (id in ref) {
      field = ref[id];
      delete quickfield.instances[id];
    }

    window.sandbox.remove();
  }

  return window.sandbox = quickdom.div({
    id: 'sandbox',
    style: {
      border: '1px solid',
      padding: '20px',
      boxSizing: 'border-box'
    }
  }).appendTo(document.body);
};function addTitle (title, margin = 20) {
  return quickdom.div({
    ref: 'testTitle',
    style: {
      marginTop: margin,
      marginBottom: margin,
      fontSize: 16,
      fontWeight: 600,
      fontFamily: 'system-ui, sans-serif'
    }
  }, title).appendTo(sandbox);
}function addDivider () {
  var margin;
  margin = arguments[0];

  if (isNaN(margin)) {
    margin = 20;
  }

  return quickdom.div({
    ref: 'testTitle',
    style: {
      marginTop: margin,
      marginBottom: margin
    }
  }).appendTo(sandbox);
}function getBorderSides (el) {
  return {
    top: el.style('borderTopWidth'),
    bottom: el.style('borderBottomWidth'),
    left: el.style('borderLeftWidth'),
    right: el.style('borderRightWidth')
  };
}var pFinally = (promise, onFinally) => {
  onFinally = onFinally || (() => {});

  return promise.then(val => new Promise(resolve => {
    resolve(onFinally());
  }).then(() => val), err => new Promise(resolve => {
    resolve(onFinally());
  }).then(() => {
    throw err;
  }));
};class TimeoutError extends Error {
  constructor(message) {
    super(message);
    this.name = 'TimeoutError';
  }

}

var pTimeout = (promise, ms, fallback) => new Promise((resolve, reject) => {
  if (typeof ms !== 'number' && ms >= 0) {
    throw new TypeError('Expected `ms` to be a positive number');
  }

  const timer = setTimeout(() => {
    if (typeof fallback === 'function') {
      resolve(fallback());
      return;
    }

    const message = typeof fallback === 'string' ? fallback : `Promise timed out after ${ms} milliseconds`;
    const err = fallback instanceof Error ? fallback : new TimeoutError(message);
    reject(err);
  }, ms);
  pFinally(promise.then(resolve, reject), () => {
    clearTimeout(timer);
  });
});

var TimeoutError_1 = TimeoutError;
pTimeout.TimeoutError = TimeoutError_1;var pEvent = (emitter, event, opts) => {
  let cancel;
  const ret = new Promise((resolve, reject) => {
    if (typeof opts === 'function') {
      opts = {
        filter: opts
      };
    }

    opts = Object.assign({
      rejectionEvents: ['error'],
      multiArgs: false
    }, opts);
    let addListener = emitter.on || emitter.addListener || emitter.addEventListener;
    let removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;

    if (!addListener || !removeListener) {
      throw new TypeError('Emitter is not compatible');
    }

    addListener = addListener.bind(emitter);
    removeListener = removeListener.bind(emitter);

    const resolveHandler = function (value) {
      if (opts.multiArgs) {
        value = [].slice.apply(arguments);
      }

      if (opts.filter && !opts.filter(value)) {
        return;
      }

      cancel();
      resolve(value);
    };

    const rejectHandler = function (reason) {
      cancel();

      if (opts.multiArgs) {
        reject([].slice.apply(arguments));
      } else {
        reject(reason);
      }
    };

    cancel = () => {
      removeListener(event, resolveHandler);

      for (const rejectionEvent of opts.rejectionEvents) {
        removeListener(rejectionEvent, rejectHandler);
      }
    };

    addListener(event, resolveHandler);

    for (const rejectionEvent of opts.rejectionEvents) {
      addListener(rejectionEvent, rejectHandler);
    }
  });
  ret.cancel = cancel;

  if (typeof opts.timeout === 'number') {
    return pTimeout(ret, opts.timeout);
  }

  return ret;
};var COLORS = {
  red: '#cc4820',
  green: '#72c322',
  orange: '#ff9c00',
  black: '#181818',
  grey_dark: '#5e5e5e',
  grey: '#909090',
  grey_semi_light: '#bebebe',
  grey_light: '#d3d3d3',
  grey_light2: '#dddddd',
  grey_light3: '#f2f5f7',
  grey_light4: '#e5e5e5'
};var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */
function exclude() {
  var excludes = [].slice.call(arguments);

  function excludeProps(res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude() {
    var args = [].slice.call(arguments),
        i = 0,
        res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
}
/*!
 * Primary Exports
 */

var assertionError = AssertionError;
/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError(message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON'),
      props = extend(_props || {}); // default values

  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false; // copy from properties

  for (var key in props) {
    this[key] = props[key];
  } // capture stack trace


  ssf = ssf || arguments.callee;

  if (ssf && Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  } else {
    try {
      throw new Error();
    } catch (e) {
      this.stack = e.stack;
    }
  }
}
/*!
 * Inherit from Error.prototype
 */


AssertionError.prototype = Object.create(Error.prototype);
/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';
/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;
/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack'),
      props = extend({
    name: this.name
  }, this); // include stack if exists and not turned off

  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};/* !
 * Chai - pathval utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

/**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has own
 * or inherited from prototype chain named property.
 *
 * Basically does the same thing as the `in`
 * operator but works properly with null/undefined values
 * and other primitives.
 *
 *     var obj = {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty(obj, 'str');  // true
 *     hasProperty(obj, 'constructor');  // true
 *     hasProperty(obj, 'bar');  // false
 *
 *     hasProperty(obj.str, 'length'); // true
 *     hasProperty(obj.str, 1);  // true
 *     hasProperty(obj.str, 5);  // false
 *
 *     hasProperty(obj.arr, 'length');  // true
 *     hasProperty(obj.arr, 2);  // true
 *     hasProperty(obj.arr, 3);  // false
 *
 * @param {Object} object
 * @param {String|Symbol} name
 * @returns {Boolean} whether it exists
 * @namespace Utils
 * @name hasProperty
 * @api public
 */

function hasProperty(obj, name) {
  if (typeof obj === 'undefined' || obj === null) {
    return false;
  } // The `in` operator does not work with primitives.


  return name in Object(obj);
}
/* !
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `internalGetPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be infinitely deep and nested.
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */


function parsePath(path) {
  var str = path.replace(/([^\\])\[/g, '$1.[');
  var parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function mapMatches(value) {
    var regexp = /^\[(\d+)\]$/;
    var mArr = regexp.exec(value);
    var parsed = null;

    if (mArr) {
      parsed = {
        i: parseFloat(mArr[1])
      };
    } else {
      parsed = {
        p: value.replace(/\\([.\[\]])/g, '$1')
      };
    }

    return parsed;
  });
}
/* !
 * ## internalGetPathValue(obj, parsed[, pathDepth])
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(obj, parsed);
 *
 * @param {Object} object to search against
 * @param {Object} parsed definition from `parsePath`.
 * @param {Number} depth (nesting level) of the property we want to retrieve
 * @returns {Object|Undefined} value
 * @api private
 */


function internalGetPathValue(obj, parsed, pathDepth) {
  var temporaryValue = obj;
  var res = null;
  pathDepth = typeof pathDepth === 'undefined' ? parsed.length : pathDepth;

  for (var i = 0; i < pathDepth; i++) {
    var part = parsed[i];

    if (temporaryValue) {
      if (typeof part.p === 'undefined') {
        temporaryValue = temporaryValue[part.i];
      } else {
        temporaryValue = temporaryValue[part.p];
      }

      if (i === pathDepth - 1) {
        res = temporaryValue;
      }
    }
  }

  return res;
}
/* !
 * ## internalSetPathValue(obj, value, parsed)
 *
 * Companion function for `parsePath` that sets
 * the value located at a parsed address.
 *
 *  internalSetPathValue(obj, 'value', parsed);
 *
 * @param {Object} object to search and define on
 * @param {*} value to use upon set
 * @param {Object} parsed definition from `parsePath`
 * @api private
 */


function internalSetPathValue(obj, val, parsed) {
  var tempObj = obj;
  var pathDepth = parsed.length;
  var part = null; // Here we iterate through every part of the path

  for (var i = 0; i < pathDepth; i++) {
    var propName = null;
    var propVal = null;
    part = parsed[i]; // If it's the last part of the path, we set the 'propName' value with the property name

    if (i === pathDepth - 1) {
      propName = typeof part.p === 'undefined' ? part.i : part.p; // Now we set the property with the name held by 'propName' on object with the desired val

      tempObj[propName] = val;
    } else if (typeof part.p !== 'undefined' && tempObj[part.p]) {
      tempObj = tempObj[part.p];
    } else if (typeof part.i !== 'undefined' && tempObj[part.i]) {
      tempObj = tempObj[part.i];
    } else {
      // If the obj doesn't have the property we create one with that name to define it
      var next = parsed[i + 1]; // Here we set the name of the property which will be defined

      propName = typeof part.p === 'undefined' ? part.i : part.p; // Here we decide if this property will be an array or a new object

      propVal = typeof next.p === 'undefined' ? [] : {};
      tempObj[propName] = propVal;
      tempObj = tempObj[propName];
    }
  }
}
/**
 * ### .getPathInfo(object, path)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by `path`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise `undefined`
 * * exists - Whether the property exists or not
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} info
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */


function getPathInfo(obj, path) {
  var parsed = parsePath(path);
  var last = parsed[parsed.length - 1];
  var info = {
    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: internalGetPathValue(obj, parsed)
  };
  info.exists = hasProperty(info.parent, info.name);
  return info;
}
/**
 * ### .getPathValue(object, path)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue(obj, 'prop1.str'); // Hello
 *     getPathValue(obj, 'prop1.att[2]'); // b
 *     getPathValue(obj, 'prop2.arr[0].nested'); // Universe
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} value or `undefined`
 * @namespace Utils
 * @name getPathValue
 * @api public
 */


function getPathValue(obj, path) {
  var info = getPathInfo(obj, path);
  return info.value;
}
/**
 * ### .setPathValue(object, path, value)
 *
 * Define the value in an object at a given string path.
 *
 * ```js
 * var obj = {
 *     prop1: {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *   , prop2: {
 *         arr: [ { nested: 'Universe' } ]
 *       , str: 'Hello again!'
 *     }
 * };
 * ```
 *
 * The following would be acceptable.
 *
 * ```js
 * var properties = require('tea-properties');
 * properties.set(obj, 'prop1.str', 'Hello Universe!');
 * properties.set(obj, 'prop1.arr[2]', 'B');
 * properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });
 * ```
 *
 * @param {Object} object
 * @param {String} path
 * @param {Mixed} value
 * @api private
 */


function setPathValue(obj, path, val) {
  var parsed = parsePath(path);
  internalSetPathValue(obj, val, parsed);
  return obj;
}

var pathval = {
  hasProperty: hasProperty,
  getPathInfo: getPathInfo,
  getPathValue: getPathValue,
  setPathValue: setPathValue
};/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .flag(object, key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @namespace Utils
 * @name flag
 * @api private
 */
var flag = function flag(obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));

  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

/**
 * ### .test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name test
 */

var test$1 = function test(obj, args) {
  var negate = flag(obj, 'negate'),
      expr = args[0];
  return negate ? !expr : expr;
};var typeDetect = createCommonjsModule(function (module) {
  /* !
   * type-detect
   * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
   * MIT Licensed
   */

  var promiseExists = typeof Promise === 'function';
  var globalObject = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : self; // eslint-disable-line

  var isDom = 'location' in globalObject && 'document' in globalObject;
  var symbolExists = typeof Symbol !== 'undefined';
  var mapExists = typeof Map !== 'undefined';
  var setExists = typeof Set !== 'undefined';
  var weakMapExists = typeof WeakMap !== 'undefined';
  var weakSetExists = typeof WeakSet !== 'undefined';
  var dataViewExists = typeof DataView !== 'undefined';
  var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
  var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
  var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
  var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
  var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());
  var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());
  var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
  var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
  var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';
  var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
  var toStringLeftSliceLength = 8;
  var toStringRightSliceLength = -1;
  /**
   * ### typeOf (obj)
   *
   * Uses `Object.prototype.toString` to determine the type of an object,
   * normalising behaviour across engine versions & well optimised.
   *
   * @param {Mixed} object
   * @return {String} object type
   * @api public
   */

  module.exports = function typeDetect(obj) {
    /* ! Speed optimisation
     * Pre:
     *   string literal     x 3,039,035 ops/sec 1.62% (78 runs sampled)
     *   boolean literal    x 1,424,138 ops/sec 4.54% (75 runs sampled)
     *   number literal     x 1,653,153 ops/sec 1.91% (82 runs sampled)
     *   undefined          x 9,978,660 ops/sec 1.92% (75 runs sampled)
     *   function           x 2,556,769 ops/sec 1.73% (77 runs sampled)
     * Post:
     *   string literal     x 38,564,796 ops/sec 1.15% (79 runs sampled)
     *   boolean literal    x 31,148,940 ops/sec 1.10% (79 runs sampled)
     *   number literal     x 32,679,330 ops/sec 1.90% (78 runs sampled)
     *   undefined          x 32,363,368 ops/sec 1.07% (82 runs sampled)
     *   function           x 31,296,870 ops/sec 0.96% (83 runs sampled)
     */
    var typeofObj = typeof obj;

    if (typeofObj !== 'object') {
      return typeofObj;
    }
    /* ! Speed optimisation
     * Pre:
     *   null               x 28,645,765 ops/sec 1.17% (82 runs sampled)
     * Post:
     *   null               x 36,428,962 ops/sec 1.37% (84 runs sampled)
     */


    if (obj === null) {
      return 'null';
    }
    /* ! Spec Conformance
     * Test: `Object.prototype.toString.call(window)``
     *  - Node === "[object global]"
     *  - Chrome === "[object global]"
     *  - Firefox === "[object Window]"
     *  - PhantomJS === "[object Window]"
     *  - Safari === "[object Window]"
     *  - IE 11 === "[object Window]"
     *  - IE Edge === "[object Window]"
     * Test: `Object.prototype.toString.call(this)``
     *  - Chrome Worker === "[object global]"
     *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
     *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
     *  - IE 11 Worker === "[object WorkerGlobalScope]"
     *  - IE Edge Worker === "[object WorkerGlobalScope]"
     */


    if (obj === globalObject) {
      return 'global';
    }
    /* ! Speed optimisation
     * Pre:
     *   array literal      x 2,888,352 ops/sec 0.67% (82 runs sampled)
     * Post:
     *   array literal      x 22,479,650 ops/sec 0.96% (81 runs sampled)
     */


    if (Array.isArray(obj) && (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))) {
      return 'Array';
    }

    if (isDom) {
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/browsers.html#location)
       * WhatWG HTML$7.7.3 - The `Location` interface
       * Test: `Object.prototype.toString.call(window.location)``
       *  - IE <=11 === "[object Object]"
       *  - IE Edge <=13 === "[object Object]"
       */
      if (obj === globalObject.location) {
        return 'Location';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#document)
       * WhatWG HTML$3.1.1 - The `Document` object
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       *       WhatWG HTML states:
       *         > For historical reasons, Window objects must also have a
       *         > writable, configurable, non-enumerable property named
       *         > HTMLDocument whose value is the Document interface object.
       * Test: `Object.prototype.toString.call(document)``
       *  - Chrome === "[object HTMLDocument]"
       *  - Firefox === "[object HTMLDocument]"
       *  - Safari === "[object HTMLDocument]"
       *  - IE <=10 === "[object Document]"
       *  - IE 11 === "[object HTMLDocument]"
       *  - IE Edge <=13 === "[object HTMLDocument]"
       */


      if (obj === globalObject.document) {
        return 'Document';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
       * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
       * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
       *  - IE <=10 === "[object MSMimeTypesCollection]"
       */


      if (obj === (globalObject.navigator || {}).mimeTypes) {
        return 'MimeTypeArray';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
       * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
       * Test: `Object.prototype.toString.call(navigator.plugins)``
       *  - IE <=10 === "[object MSPluginsCollection]"
       */


      if (obj === (globalObject.navigator || {}).plugins) {
        return 'PluginArray';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
       * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
       * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
       *  - IE <=10 === "[object HTMLBlockElement]"
       */


      if (obj instanceof HTMLElement && obj.tagName === 'BLOCKQUOTE') {
        return 'HTMLQuoteElement';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#htmltabledatacellelement)
       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       * Test: Object.prototype.toString.call(document.createElement('td'))
       *  - Chrome === "[object HTMLTableCellElement]"
       *  - Firefox === "[object HTMLTableCellElement]"
       *  - Safari === "[object HTMLTableCellElement]"
       */


      if (obj instanceof HTMLElement && obj.tagName === 'TD') {
        return 'HTMLTableDataCellElement';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#htmltableheadercellelement)
       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       * Test: Object.prototype.toString.call(document.createElement('th'))
       *  - Chrome === "[object HTMLTableCellElement]"
       *  - Firefox === "[object HTMLTableCellElement]"
       *  - Safari === "[object HTMLTableCellElement]"
       */


      if (obj instanceof HTMLElement && obj.tagName === 'TH') {
        return 'HTMLTableHeaderCellElement';
      }
    }
    /* ! Speed optimisation
    * Pre:
    *   Float64Array       x 625,644 ops/sec 1.58% (80 runs sampled)
    *   Float32Array       x 1,279,852 ops/sec 2.91% (77 runs sampled)
    *   Uint32Array        x 1,178,185 ops/sec 1.95% (83 runs sampled)
    *   Uint16Array        x 1,008,380 ops/sec 2.25% (80 runs sampled)
    *   Uint8Array         x 1,128,040 ops/sec 2.11% (81 runs sampled)
    *   Int32Array         x 1,170,119 ops/sec 2.88% (80 runs sampled)
    *   Int16Array         x 1,176,348 ops/sec 5.79% (86 runs sampled)
    *   Int8Array          x 1,058,707 ops/sec 4.94% (77 runs sampled)
    *   Uint8ClampedArray  x 1,110,633 ops/sec 4.20% (80 runs sampled)
    * Post:
    *   Float64Array       x 7,105,671 ops/sec 13.47% (64 runs sampled)
    *   Float32Array       x 5,887,912 ops/sec 1.46% (82 runs sampled)
    *   Uint32Array        x 6,491,661 ops/sec 1.76% (79 runs sampled)
    *   Uint16Array        x 6,559,795 ops/sec 1.67% (82 runs sampled)
    *   Uint8Array         x 6,463,966 ops/sec 1.43% (85 runs sampled)
    *   Int32Array         x 5,641,841 ops/sec 3.49% (81 runs sampled)
    *   Int16Array         x 6,583,511 ops/sec 1.98% (80 runs sampled)
    *   Int8Array          x 6,606,078 ops/sec 1.74% (81 runs sampled)
    *   Uint8ClampedArray  x 6,602,224 ops/sec 1.77% (83 runs sampled)
    */


    var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];

    if (typeof stringTag === 'string') {
      return stringTag;
    }

    var objPrototype = Object.getPrototypeOf(obj);
    /* ! Speed optimisation
    * Pre:
    *   regex literal      x 1,772,385 ops/sec 1.85% (77 runs sampled)
    *   regex constructor  x 2,143,634 ops/sec 2.46% (78 runs sampled)
    * Post:
    *   regex literal      x 3,928,009 ops/sec 0.65% (78 runs sampled)
    *   regex constructor  x 3,931,108 ops/sec 0.58% (84 runs sampled)
    */

    if (objPrototype === RegExp.prototype) {
      return 'RegExp';
    }
    /* ! Speed optimisation
    * Pre:
    *   date               x 2,130,074 ops/sec 4.42% (68 runs sampled)
    * Post:
    *   date               x 3,953,779 ops/sec 1.35% (77 runs sampled)
    */


    if (objPrototype === Date.prototype) {
      return 'Date';
    }
    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
     * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
     * Test: `Object.prototype.toString.call(Promise.resolve())``
     *  - Chrome <=47 === "[object Object]"
     *  - Edge <=20 === "[object Object]"
     *  - Firefox 29-Latest === "[object Promise]"
     *  - Safari 7.1-Latest === "[object Promise]"
     */


    if (promiseExists && objPrototype === Promise.prototype) {
      return 'Promise';
    }
    /* ! Speed optimisation
    * Pre:
    *   set                x 2,222,186 ops/sec 1.31% (82 runs sampled)
    * Post:
    *   set                x 4,545,879 ops/sec 1.13% (83 runs sampled)
    */


    if (setExists && objPrototype === Set.prototype) {
      return 'Set';
    }
    /* ! Speed optimisation
    * Pre:
    *   map                x 2,396,842 ops/sec 1.59% (81 runs sampled)
    * Post:
    *   map                x 4,183,945 ops/sec 6.59% (82 runs sampled)
    */


    if (mapExists && objPrototype === Map.prototype) {
      return 'Map';
    }
    /* ! Speed optimisation
    * Pre:
    *   weakset            x 1,323,220 ops/sec 2.17% (76 runs sampled)
    * Post:
    *   weakset            x 4,237,510 ops/sec 2.01% (77 runs sampled)
    */


    if (weakSetExists && objPrototype === WeakSet.prototype) {
      return 'WeakSet';
    }
    /* ! Speed optimisation
    * Pre:
    *   weakmap            x 1,500,260 ops/sec 2.02% (78 runs sampled)
    * Post:
    *   weakmap            x 3,881,384 ops/sec 1.45% (82 runs sampled)
    */


    if (weakMapExists && objPrototype === WeakMap.prototype) {
      return 'WeakMap';
    }
    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
     * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
     * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
     *  - Edge <=13 === "[object Object]"
     */


    if (dataViewExists && objPrototype === DataView.prototype) {
      return 'DataView';
    }
    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
     * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
     * Test: `Object.prototype.toString.call(new Map().entries())``
     *  - Edge <=13 === "[object Object]"
     */


    if (mapExists && objPrototype === mapIteratorPrototype) {
      return 'Map Iterator';
    }
    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
     * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
     * Test: `Object.prototype.toString.call(new Set().entries())``
     *  - Edge <=13 === "[object Object]"
     */


    if (setExists && objPrototype === setIteratorPrototype) {
      return 'Set Iterator';
    }
    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
     * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
     * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
     *  - Edge <=13 === "[object Object]"
     */


    if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
      return 'Array Iterator';
    }
    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
     * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
     * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
     *  - Edge <=13 === "[object Object]"
     */


    if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
      return 'String Iterator';
    }
    /* ! Speed optimisation
    * Pre:
    *   object from null   x 2,424,320 ops/sec 1.67% (76 runs sampled)
    * Post:
    *   object from null   x 5,838,000 ops/sec 0.99% (84 runs sampled)
    */


    if (objPrototype === null) {
      return 'Object';
    }

    return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
  };

  module.exports.typeDetect = module.exports;
});
var typeDetect_1 = typeDetect.typeDetect;/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .expectTypes(obj, types)
 *
 * Ensures that the object being tested against is of a valid type.
 *
 *     utils.expectTypes(this, ['array', 'object', 'string']);
 *
 * @param {Mixed} obj constructed Assertion
 * @param {Array} type A list of allowed types for this assertion
 * @namespace Utils
 * @name expectTypes
 * @api public
 */

var expectTypes = function expectTypes(obj, types) {
  var flagMsg = flag(obj, 'message');
  var ssfi = flag(obj, 'ssfi');
  flagMsg = flagMsg ? flagMsg + ': ' : '';
  obj = flag(obj, 'object');
  types = types.map(function (t) {
    return t.toLowerCase();
  });
  types.sort(); // Transforms ['lorem', 'ipsum'] into 'a lorem, or an ipsum'

  var str = types.map(function (t, index) {
    var art = ~['a', 'e', 'i', 'o', 'u'].indexOf(t.charAt(0)) ? 'an' : 'a';
    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';
    return or + art + ' ' + t;
  }).join(', ');
  var objType = typeDetect(obj).toLowerCase();

  if (!types.some(function (expected) {
    return objType === expected;
  })) {
    throw new assertionError(flagMsg + 'object tested must be ' + str + ', but ' + objType + ' given', undefined, ssfi);
  }
};/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getActual
 */
var getActual = function getActual(obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};/* !
 * Chai - getFuncName utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getFuncName(constructorFn)
 *
 * Returns the name of a function.
 * When a non-function instance is passed, returns `null`.
 * This also includes a polyfill function if `aFunc.name` is not defined.
 *
 * @name getFuncName
 * @param {Function} funct
 * @namespace Utils
 * @api public
 */

var toString = Function.prototype.toString;
var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/;

function getFuncName(aFunc) {
  if (typeof aFunc !== 'function') {
    return null;
  }

  var name = '';

  if (typeof Function.prototype.name === 'undefined' && typeof aFunc.name === 'undefined') {
    // Here we run a polyfill if Function does not support the `name` property and if aFunc.name is not defined
    var match = toString.call(aFunc).match(functionNameMatch);

    if (match) {
      name = match[1];
    }
  } else {
    // If we've got a `name` property we just use it
    name = aFunc.name;
  }

  return name;
}

var getFuncName_1 = getFuncName;/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getProperties
 * @api public
 */
var getProperties = function getProperties(object) {
  var result = Object.getOwnPropertyNames(object);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(object);

  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getEnumerableProperties
 * @api public
 */
var getEnumerableProperties = function getEnumerableProperties(object) {
  var result = [];

  for (var name in object) {
    result.push(name);
  }

  return result;
};var config = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */
  includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */
  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */
  truncateThreshold: 40,

  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {Boolean}
   * @api public
   */
  useProxy: true,

  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @api public
   */
  proxyExcludedKeys: ['then', 'inspect', 'toJSON']
};var inspect_1 = createCommonjsModule(function (module, exports) {
  // This is (almost) directly from Node.js utils
  // https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js
  module.exports = inspect;
  /**
   * ### .inspect(obj, [showHidden], [depth], [colors])
   *
   * Echoes the value of a value. Tries to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
   *    properties of objects. Default is false.
   * @param {Number} depth Depth in which to descend in object. Default is 2.
   * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
   *    output. Default is false (no coloring).
   * @namespace Utils
   * @name inspect
   */

  function inspect(obj, showHidden, depth, colors) {
    var ctx = {
      showHidden: showHidden,
      seen: [],
      stylize: function (str) {
        return str;
      }
    };
    return formatValue(ctx, obj, typeof depth === 'undefined' ? 2 : depth);
  } // Returns true if object is a DOM element.


  var isDOMElement = function (object) {
    if (typeof HTMLElement === 'object') {
      return object instanceof HTMLElement;
    } else {
      return object && typeof object === 'object' && 'nodeType' in object && object.nodeType === 1 && typeof object.nodeName === 'string';
    }
  };

  function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' && // Filter out the util module, it's inspect function is special
    value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);

      if (typeof ret !== 'string') {
        ret = formatValue(ctx, ret, recurseTimes);
      }

      return ret;
    } // Primitive types cannot have properties


    var primitive = formatPrimitive(ctx, value);

    if (primitive) {
      return primitive;
    } // If this is a DOM element, try to get the outer HTML.


    if (isDOMElement(value)) {
      if ('outerHTML' in value) {
        return value.outerHTML; // This value does not have an outerHTML attribute,
        //   it could still be an XML element
      } else {
        // Attempt to serialize it
        try {
          if (document.xmlVersion) {
            var xmlSerializer = new XMLSerializer();
            return xmlSerializer.serializeToString(value);
          } else {
            // Firefox 11- do not support outerHTML
            //   It does, however, support innerHTML
            //   Use the following to render the element
            var ns = "http://www.w3.org/1999/xhtml";
            var container = document.createElementNS(ns, '_');
            container.appendChild(value.cloneNode(false));
            var html = container.innerHTML.replace('><', '>' + value.innerHTML + '<');
            container.innerHTML = '';
            return html;
          }
        } catch (err) {// This could be a non-native DOM implementation,
          //   continue with the normal flow:
          //   printing the element as if it is an object.
        }
      }
    } // Look up the keys of the object.


    var visibleKeys = getEnumerableProperties(value);
    var keys = ctx.showHidden ? getProperties(value) : visibleKeys;
    var name, nameSuffix; // Some type of object without properties can be shortcutted.
    // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
    // a `stack` plus `description` property; ignore those for consistency.

    if (keys.length === 0 || isError(value) && (keys.length === 1 && keys[0] === 'stack' || keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')) {
      if (typeof value === 'function') {
        name = getFuncName_1(value);
        nameSuffix = name ? ': ' + name : '';
        return ctx.stylize('[Function' + nameSuffix + ']', 'special');
      }

      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }

      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
      }

      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '',
        array = false,
        typedArray = false,
        braces = ['{', '}'];

    if (isTypedArray(value)) {
      typedArray = true;
      braces = ['[', ']'];
    } // Make Array say that they are Array


    if (isArray(value)) {
      array = true;
      braces = ['[', ']'];
    } // Make functions say that they are functions


    if (typeof value === 'function') {
      name = getFuncName_1(value);
      nameSuffix = name ? ': ' + name : '';
      base = ' [Function' + nameSuffix + ']';
    } // Make RegExps say that they are RegExps


    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    } // Make dates with properties first say the date


    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    } // Make error with message first say the error


    if (isError(value)) {
      return formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);
    var output;

    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else if (typedArray) {
      return formatTypedArray(value);
    } else {
      output = keys.map(function (key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }

    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }

  function formatPrimitive(ctx, value) {
    switch (typeof value) {
      case 'undefined':
        return ctx.stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');

      case 'number':
        if (value === 0 && 1 / value === -Infinity) {
          return ctx.stylize('-0', 'number');
        }

        return ctx.stylize('' + value, 'number');

      case 'boolean':
        return ctx.stylize('' + value, 'boolean');

      case 'symbol':
        return ctx.stylize(value.toString(), 'symbol');
    } // For some reason typeof null is "object", so special case here.


    if (value === null) {
      return ctx.stylize('null', 'null');
    }
  }

  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }

  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];

    for (var i = 0, l = value.length; i < l; ++i) {
      if (Object.prototype.hasOwnProperty.call(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
      } else {
        output.push('');
      }
    }

    keys.forEach(function (key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
      }
    });
    return output;
  }

  function formatTypedArray(value) {
    var str = '[ ';

    for (var i = 0; i < value.length; ++i) {
      if (str.length >= config.truncateThreshold - 7) {
        str += '...';
        break;
      }

      str += value[i] + ', ';
    }

    str += ' ]'; // Removing trailing `, ` if the array was not truncated

    if (str.indexOf(',  ]') !== -1) {
      str = str.replace(',  ]', ' ]');
    }

    return str;
  }

  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name;
    var propDescriptor = Object.getOwnPropertyDescriptor(value, key);
    var str;

    if (propDescriptor) {
      if (propDescriptor.get) {
        if (propDescriptor.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (propDescriptor.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
    }

    if (visibleKeys.indexOf(key) < 0) {
      name = '[' + key + ']';
    }

    if (!str) {
      if (ctx.seen.indexOf(value[key]) < 0) {
        if (recurseTimes === null) {
          str = formatValue(ctx, value[key], null);
        } else {
          str = formatValue(ctx, value[key], recurseTimes - 1);
        }

        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(function (line) {
              return '  ' + line;
            }).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(function (line) {
              return '   ' + line;
            }).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }

    if (typeof name === 'undefined') {
      if (array && key.match(/^\d+$/)) {
        return str;
      }

      name = JSON.stringify('' + key);

      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }

  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function (prev, cur) {
      if (cur.indexOf('\n') >= 0) ;
      return prev + cur.length + 1;
    }, 0);

    if (length > 60) {
      return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  }

  function isTypedArray(ar) {
    // Unfortunately there's no way to check if an object is a TypedArray
    // We have to check if it's one of these types
    return typeof ar === 'object' && /\w+Array]$/.test(objectToString(ar));
  }

  function isArray(ar) {
    return Array.isArray(ar) || typeof ar === 'object' && objectToString(ar) === '[object Array]';
  }

  function isRegExp(re) {
    return typeof re === 'object' && objectToString(re) === '[object RegExp]';
  }

  function isDate(d) {
    return typeof d === 'object' && objectToString(d) === '[object Date]';
  }

  function isError(e) {
    return typeof e === 'object' && objectToString(e) === '[object Error]';
  }

  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

/**
 * ### .objDisplay(object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @namespace Utils
 * @api public
 */

var objDisplay = function objDisplay(obj) {
  var str = inspect_1(obj),
      type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === '' ? '[Function]' : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj),
          kstr = keys.length > 2 ? keys.splice(0, 2).join(', ') + ', ...' : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getMessage
 * @api public
 */

var getMessage = function getMessage(obj, args) {
  var negate = flag(obj, 'negate'),
      val = flag(obj, 'object'),
      expected = args[3],
      actual = getActual(obj, args),
      msg = negate ? args[2] : args[1],
      flagMsg = flag(obj, 'message');
  if (typeof msg === "function") msg = msg();
  msg = msg || '';
  msg = msg.replace(/#\{this\}/g, function () {
    return objDisplay(val);
  }).replace(/#\{act\}/g, function () {
    return objDisplay(actual);
  }).replace(/#\{exp\}/g, function () {
    return objDisplay(expected);
  });
  return flagMsg ? flagMsg + ': ' + msg : msg;
};/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, `lockSsfi`,
 * and `message`) will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags to; usually a new assertion
 * @param {Boolean} includeAll
 * @namespace Utils
 * @name transferFlags
 * @api private
 */
var transferFlags = function transferFlags(assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll || flag !== 'object' && flag !== 'ssfi' && flag !== 'lockSsfi' && flag != 'message') {
      object.__flags[flag] = flags[flag];
    }
  }
};/* globals Symbol: false, Uint8Array: false, WeakMap: false */

/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


function FakeMap() {
  this._key = 'chai/deep-eql__' + Math.random() + Date.now();
}

FakeMap.prototype = {
  get: function getMap(key) {
    return key[this._key];
  },
  set: function setMap(key, value) {
    if (Object.isExtensible(key)) {
      Object.defineProperty(key, this._key, {
        value: value,
        configurable: true
      });
    }
  }
};
var MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;
/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/

function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return null;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);

    if (typeof result === 'boolean') {
      return result;
    }
  }

  return null;
}
/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/


function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    leftHandMap.set(rightHandOperand, result);
  } else {
    leftHandMap = new MemoizeMap();
    leftHandMap.set(rightHandOperand, result);
    memoizeMap.set(leftHandOperand, leftHandMap);
  }
}
/*!
 * Primary Export
 */


var deepEql = deepEqual;
var MemoizeMap_1 = MemoizeMap;
/**
 * Assert deeply nested sameValue equality between two objects of any type.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
 */

function deepEqual(leftHandOperand, rightHandOperand, options) {
  // If we have a comparator, we can't assume anything; so bail to its check first.
  if (options && options.comparator) {
    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
  }

  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);

  if (simpleResult !== null) {
    return simpleResult;
  } // Deeper comparisons are pushed through to a larger function


  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
}
/**
 * Many comparisons can be canceled out early via simple equality or primitive checks.
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @return {Boolean|null} equal match
 */


function simpleEqual(leftHandOperand, rightHandOperand) {
  // Equal references (except for Numbers) can be returned early
  if (leftHandOperand === rightHandOperand) {
    // Handle +-0 cases
    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
  } // handle NaN cases


  if (leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
  rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare
  ) {
      return true;
    } // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,
  // strings, and undefined, can be compared by reference.


  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    // Easy out b/c it would have passed the first equality check
    return false;
  }

  return null;
}
/*!
 * The main logic of the `deepEqual` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/


function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
  options = options || {};
  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
  var comparator = options && options.comparator; // Check if a memoized result exists.

  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);

  if (memoizeResultLeft !== null) {
    return memoizeResultLeft;
  }

  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);

  if (memoizeResultRight !== null) {
    return memoizeResultRight;
  } // If a comparator is present, use it.


  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand); // Comparators may return null, in which case we want to go back to default behavior.

    if (comparatorResult === false || comparatorResult === true) {
      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
      return comparatorResult;
    } // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide
    // what to do, we need to make sure to return the basic tests first before we move on.


    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);

    if (simpleResult !== null) {
      // Don't memoize this, it takes longer to set/retrieve than to just compare.
      return simpleResult;
    }
  }

  var leftHandType = typeDetect(leftHandOperand);

  if (leftHandType !== typeDetect(rightHandOperand)) {
    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
    return false;
  } // Temporarily set the operands in the memoize object to prevent blowing the stack


  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);
  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
  return result;
}

function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case 'String':
    case 'Number':
    case 'Boolean':
    case 'Date':
      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values
      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());

    case 'Promise':
    case 'Symbol':
    case 'function':
    case 'WeakMap':
    case 'WeakSet':
    case 'Error':
      return leftHandOperand === rightHandOperand;

    case 'Arguments':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'Array':
      return iterableEqual(leftHandOperand, rightHandOperand, options);

    case 'RegExp':
      return regexpEqual(leftHandOperand, rightHandOperand);

    case 'Generator':
      return generatorEqual(leftHandOperand, rightHandOperand, options);

    case 'DataView':
      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);

    case 'ArrayBuffer':
      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);

    case 'Set':
      return entriesEqual(leftHandOperand, rightHandOperand, options);

    case 'Map':
      return entriesEqual(leftHandOperand, rightHandOperand, options);

    default:
      return objectEqual(leftHandOperand, rightHandOperand, options);
  }
}
/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */


function regexpEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function entriesEqual(leftHandOperand, rightHandOperand, options) {
  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach
  if (leftHandOperand.size !== rightHandOperand.size) {
    return false;
  }

  if (leftHandOperand.size === 0) {
    return true;
  }

  var leftHandItems = [];
  var rightHandItems = [];
  leftHandOperand.forEach(function gatherEntries(key, value) {
    leftHandItems.push([key, value]);
  });
  rightHandOperand.forEach(function gatherEntries(key, value) {
    rightHandItems.push([key, value]);
  });
  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
}
/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function iterableEqual(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;

  if (length !== rightHandOperand.length) {
    return false;
  }

  if (length === 0) {
    return true;
  }

  var index = -1;

  while (++index < length) {
    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function generatorEqual(leftHandOperand, rightHandOperand, options) {
  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
}
/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} `true` if the object has an @@iterator function.
 */


function hasIteratorFunction(target) {
  return typeof Symbol !== 'undefined' && typeof target === 'object' && typeof Symbol.iterator !== 'undefined' && typeof target[Symbol.iterator] === 'function';
}
/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */


function getIteratorEntries(target) {
  if (hasIteratorFunction(target)) {
    try {
      return getGeneratorEntries(target[Symbol.iterator]());
    } catch (iteratorError) {
      return [];
    }
  }

  return [];
}
/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */


function getGeneratorEntries(generator) {
  var generatorResult = generator.next();
  var accumulator = [generatorResult.value];

  while (generatorResult.done === false) {
    generatorResult = generator.next();
    accumulator.push(generatorResult.value);
  }

  return accumulator;
}
/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */


function getEnumerableKeys(target) {
  var keys = [];

  for (var key in target) {
    keys.push(key);
  }

  return keys;
}
/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function keysEqual(leftHandOperand, rightHandOperand, keys, options) {
  var length = keys.length;

  if (length === 0) {
    return true;
  }

  for (var i = 0; i < length; i += 1) {
    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function objectEqual(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys(leftHandOperand);
  var rightHandKeys = getEnumerableKeys(rightHandOperand);

  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
    leftHandKeys.sort();
    rightHandKeys.sort();

    if (iterableEqual(leftHandKeys, rightHandKeys) === false) {
      return false;
    }

    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
  }

  var leftHandEntries = getIteratorEntries(leftHandOperand);
  var rightHandEntries = getIteratorEntries(rightHandOperand);

  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
    leftHandEntries.sort();
    rightHandEntries.sort();
    return iterableEqual(leftHandEntries, rightHandEntries, options);
  }

  if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
    return true;
  }

  return false;
}
/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */


function isPrimitive(value) {
  return value === null || typeof value !== 'object';
}
deepEql.MemoizeMap = MemoizeMap_1;/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .isProxyEnabled()
 *
 * Helper function to check if Chai's proxy protection feature is enabled. If
 * proxies are unsupported or disabled via the user's Chai config, then return
 * false. Otherwise, return true.
 *
 * @namespace Utils
 * @name isProxyEnabled
 */

var isProxyEnabled = function isProxyEnabled() {
  return config.useProxy && typeof Proxy !== 'undefined' && typeof Reflect !== 'undefined';
};/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addProperty(ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @namespace Utils
 * @name addProperty
 * @api public
 */

var addProperty = function addProperty(ctx, name, getter) {
  getter = getter === undefined ? function () {} : getter;
  Object.defineProperty(ctx, name, {
    get: function propertyGetter() {
      // Setting the `ssfi` flag to `propertyGetter` causes this function to
      // be the starting point for removing implementation frames from the
      // stack trace of a failed assertion.
      //
      // However, we only want to use this function as the starting point if
      // the `lockSsfi` flag isn't set and proxy protection is disabled.
      //
      // If the `lockSsfi` flag is set, then either this assertion has been
      // overwritten by another assertion, or this assertion is being invoked
      // from inside of another assertion. In the first case, the `ssfi` flag
      // has already been set by the overwriting assertion. In the second
      // case, the `ssfi` flag has already been set by the outer assertion.
      //
      // If proxy protection is enabled, then the `ssfi` flag has already been
      // set by the proxy getter.
      if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
        flag(this, 'ssfi', propertyGetter);
      }

      var result = getter.call(this);
      if (result !== undefined) return result;
      var newAssertion = new chai$1.Assertion();
      transferFlags(this, newAssertion);
      return newAssertion;
    },
    configurable: true
  });
};var fnLengthDesc = Object.getOwnPropertyDescriptor(function () {}, 'length');
/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addLengthGuard(fn, assertionName, isChainable)
 *
 * Define `length` as a getter on the given uninvoked method assertion. The
 * getter acts as a guard against chaining `length` directly off of an uninvoked
 * method assertion, which is a problem because it references `function`'s
 * built-in `length` property instead of Chai's `length` assertion. When the
 * getter catches the user making this mistake, it throws an error with a
 * helpful message.
 *
 * There are two ways in which this mistake can be made. The first way is by
 * chaining the `length` assertion directly off of an uninvoked chainable
 * method. In this case, Chai suggests that the user use `lengthOf` instead. The
 * second way is by chaining the `length` assertion directly off of an uninvoked
 * non-chainable method. Non-chainable methods must be invoked prior to
 * chaining. In this case, Chai suggests that the user consult the docs for the
 * given assertion.
 *
 * If the `length` property of functions is unconfigurable, then return `fn`
 * without modification.
 *
 * Note that in ES6, the function's `length` property is configurable, so once
 * support for legacy environments is dropped, Chai's `length` property can
 * replace the built-in function's `length` property, and this length guard will
 * no longer be necessary. In the mean time, maintaining consistency across all
 * environments is the priority.
 *
 * @param {Function} fn
 * @param {String} assertionName
 * @param {Boolean} isChainable
 * @namespace Utils
 * @name addLengthGuard
 */

var addLengthGuard = function addLengthGuard(fn, assertionName, isChainable) {
  if (!fnLengthDesc.configurable) return fn;
  Object.defineProperty(fn, 'length', {
    get: function () {
      if (isChainable) {
        throw Error('Invalid Chai property: ' + assertionName + '.length. Due' + ' to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.');
      }

      throw Error('Invalid Chai property: ' + assertionName + '.length. See' + ' docs for proper usage of "' + assertionName + '".');
    }
  });
  return fn;
};/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .proxify(object)
 *
 * Return a proxy of given object that throws an error when a non-existent
 * property is read. By default, the root cause is assumed to be a misspelled
 * property, and thus an attempt is made to offer a reasonable suggestion from
 * the list of existing properties. However, if a nonChainableMethodName is
 * provided, then the root cause is instead a failure to invoke a non-chainable
 * method prior to reading the non-existent property.
 * 
 * If proxies are unsupported or disabled via the user's Chai config, then
 * return object without modification.
 *
 * @param {Object} obj
 * @param {String} nonChainableMethodName
 * @namespace Utils
 * @name proxify
 */

var builtins = ['__flags', '__methods', '_obj', 'assert'];

var proxify = function proxify(obj, nonChainableMethodName) {
  if (!isProxyEnabled()) return obj;
  return new Proxy(obj, {
    get: function proxyGetter(target, property) {
      // This check is here because we should not throw errors on Symbol properties
      // such as `Symbol.toStringTag`.
      // The values for which an error should be thrown can be configured using
      // the `config.proxyExcludedKeys` setting.
      if (typeof property === 'string' && config.proxyExcludedKeys.indexOf(property) === -1 && !Reflect.has(target, property)) {
        // Special message for invalid property access of non-chainable methods.
        if (nonChainableMethodName) {
          throw Error('Invalid Chai property: ' + nonChainableMethodName + '.' + property + '. See docs for proper usage of "' + nonChainableMethodName + '".');
        }

        var orderedProperties = getProperties(target).filter(function (property) {
          return !Object.prototype.hasOwnProperty(property) && builtins.indexOf(property) === -1;
        }).sort(function (a, b) {
          return stringDistance(property, a) - stringDistance(property, b);
        });

        if (orderedProperties.length && stringDistance(orderedProperties[0], property) < 4) {
          // If the property is reasonably close to an existing Chai property,
          // suggest that property to the user.
          throw Error('Invalid Chai property: ' + property + '. Did you mean "' + orderedProperties[0] + '"?');
        } else {
          throw Error('Invalid Chai property: ' + property);
        }
      } // Use this proxy getter as the starting point for removing implementation
      // frames from the stack trace of a failed assertion. For property
      // assertions, this prevents the proxy getter from showing up in the stack
      // trace since it's invoked before the property getter. For method and
      // chainable method assertions, this flag will end up getting changed to
      // the method wrapper, which is good since this frame will no longer be in
      // the stack once the method is invoked. Note that Chai builtin assertion
      // properties such as `__flags` are skipped since this is only meant to
      // capture the starting point of an assertion. This step is also skipped
      // if the `lockSsfi` flag is set, thus indicating that this assertion is
      // being called from within another assertion. In that case, the `ssfi`
      // flag is already set to the outer assertion's starting point.


      if (builtins.indexOf(property) === -1 && !flag(target, 'lockSsfi')) {
        flag(target, 'ssfi', proxyGetter);
      }

      return Reflect.get(target, property);
    }
  });
};
/**
 * # stringDistance(strA, strB)
 * Return the Levenshtein distance between two strings.
 * @param {string} strA
 * @param {string} strB
 * @return {number} the string distance between strA and strB
 * @api private
 */


function stringDistance(strA, strB, memo) {
  if (!memo) {
    // `memo` is a two-dimensional array containing a cache of distances
    // memo[i][j] is the distance between strA.slice(0, i) and
    // strB.slice(0, j).
    memo = [];

    for (var i = 0; i <= strA.length; i++) {
      memo[i] = [];
    }
  }

  if (!memo[strA.length] || !memo[strA.length][strB.length]) {
    if (strA.length === 0 || strB.length === 0) {
      memo[strA.length][strB.length] = Math.max(strA.length, strB.length);
    } else {
      memo[strA.length][strB.length] = Math.min(stringDistance(strA.slice(0, -1), strB, memo) + 1, stringDistance(strA, strB.slice(0, -1), memo) + 1, stringDistance(strA.slice(0, -1), strB.slice(0, -1), memo) + (strA.slice(-1) === strB.slice(-1) ? 0 : 1));
    }
  }

  return memo[strA.length][strB.length];
}/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addMethod(ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @namespace Utils
 * @name addMethod
 * @api public
 */

var addMethod = function addMethod(ctx, name, method) {
  var methodWrapper = function () {
    // Setting the `ssfi` flag to `methodWrapper` causes this function to be the
    // starting point for removing implementation frames from the stack trace of
    // a failed assertion.
    //
    // However, we only want to use this function as the starting point if the
    // `lockSsfi` flag isn't set.
    //
    // If the `lockSsfi` flag is set, then either this assertion has been
    // overwritten by another assertion, or this assertion is being invoked from
    // inside of another assertion. In the first case, the `ssfi` flag has
    // already been set by the overwriting assertion. In the second case, the
    // `ssfi` flag has already been set by the outer assertion.
    if (!flag(this, 'lockSsfi')) {
      flag(this, 'ssfi', methodWrapper);
    }

    var result = method.apply(this, arguments);
    if (result !== undefined) return result;
    var newAssertion = new chai$1.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  addLengthGuard(methodWrapper, name, false);
  ctx[name] = proxify(methodWrapper, name);
};/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .overwriteProperty(ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @namespace Utils
 * @name overwriteProperty
 * @api public
 */

var overwriteProperty = function overwriteProperty(ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name),
      _super = function () {};

  if (_get && 'function' === typeof _get.get) _super = _get.get;
  Object.defineProperty(ctx, name, {
    get: function overwritingPropertyGetter() {
      // Setting the `ssfi` flag to `overwritingPropertyGetter` causes this
      // function to be the starting point for removing implementation frames
      // from the stack trace of a failed assertion.
      //
      // However, we only want to use this function as the starting point if
      // the `lockSsfi` flag isn't set and proxy protection is disabled.
      //
      // If the `lockSsfi` flag is set, then either this assertion has been
      // overwritten by another assertion, or this assertion is being invoked
      // from inside of another assertion. In the first case, the `ssfi` flag
      // has already been set by the overwriting assertion. In the second
      // case, the `ssfi` flag has already been set by the outer assertion.
      //
      // If proxy protection is enabled, then the `ssfi` flag has already been
      // set by the proxy getter.
      if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
        flag(this, 'ssfi', overwritingPropertyGetter);
      } // Setting the `lockSsfi` flag to `true` prevents the overwritten
      // assertion from changing the `ssfi` flag. By this point, the `ssfi`
      // flag is already set to the correct starting point for this assertion.


      var origLockSsfi = flag(this, 'lockSsfi');
      flag(this, 'lockSsfi', true);
      var result = getter(_super).call(this);
      flag(this, 'lockSsfi', origLockSsfi);

      if (result !== undefined) {
        return result;
      }

      var newAssertion = new chai$1.Assertion();
      transferFlags(this, newAssertion);
      return newAssertion;
    },
    configurable: true
  });
};/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .overwriteMethod(ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @namespace Utils
 * @name overwriteMethod
 * @api public
 */

var overwriteMethod = function overwriteMethod(ctx, name, method) {
  var _method = ctx[name],
      _super = function () {
    throw new Error(name + ' is not a function');
  };

  if (_method && 'function' === typeof _method) _super = _method;

  var overwritingMethodWrapper = function () {
    // Setting the `ssfi` flag to `overwritingMethodWrapper` causes this
    // function to be the starting point for removing implementation frames from
    // the stack trace of a failed assertion.
    //
    // However, we only want to use this function as the starting point if the
    // `lockSsfi` flag isn't set.
    //
    // If the `lockSsfi` flag is set, then either this assertion has been
    // overwritten by another assertion, or this assertion is being invoked from
    // inside of another assertion. In the first case, the `ssfi` flag has
    // already been set by the overwriting assertion. In the second case, the
    // `ssfi` flag has already been set by the outer assertion.
    if (!flag(this, 'lockSsfi')) {
      flag(this, 'ssfi', overwritingMethodWrapper);
    } // Setting the `lockSsfi` flag to `true` prevents the overwritten assertion
    // from changing the `ssfi` flag. By this point, the `ssfi` flag is already
    // set to the correct starting point for this assertion.


    var origLockSsfi = flag(this, 'lockSsfi');
    flag(this, 'lockSsfi', true);
    var result = method(_super).apply(this, arguments);
    flag(this, 'lockSsfi', origLockSsfi);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai$1.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  addLengthGuard(overwritingMethodWrapper, name, false);
  ctx[name] = proxify(overwritingMethodWrapper, name);
};/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/*!
 * Module variables
 */
// Check whether `Object.setPrototypeOf` is supported

var canSetPrototype = typeof Object.setPrototypeOf === 'function'; // Without `Object.setPrototypeOf` support, this module will need to add properties to a function.
// However, some of functions' own props are not configurable and should be skipped.

var testFn = function () {};

var excludeNames = Object.getOwnPropertyNames(testFn).filter(function (name) {
  var propDesc = Object.getOwnPropertyDescriptor(testFn, name); // Note: PhantomJS 1.x includes `callee` as one of `testFn`'s own properties,
  // but then returns `undefined` as the property descriptor for `callee`. As a
  // workaround, we perform an otherwise unnecessary type-check for `propDesc`,
  // and then filter it out if it's not an object as it should be.

  if (typeof propDesc !== 'object') return true;
  return !propDesc.configurable;
}); // Cache `Function` properties

var call = Function.prototype.call,
    apply = Function.prototype.apply;
/**
 * ### .addChainableMethod(ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @namespace Utils
 * @name addChainableMethod
 * @api public
 */

var addChainableMethod = function addChainableMethod(ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () {};
  }

  var chainableBehavior = {
    method: method,
    chainingBehavior: chainingBehavior
  }; // save the methods so we can overwrite them later, if we need to.

  if (!ctx.__methods) {
    ctx.__methods = {};
  }

  ctx.__methods[name] = chainableBehavior;
  Object.defineProperty(ctx, name, {
    get: function chainableMethodGetter() {
      chainableBehavior.chainingBehavior.call(this);

      var chainableMethodWrapper = function () {
        // Setting the `ssfi` flag to `chainableMethodWrapper` causes this
        // function to be the starting point for removing implementation
        // frames from the stack trace of a failed assertion.
        //
        // However, we only want to use this function as the starting point if
        // the `lockSsfi` flag isn't set.
        //
        // If the `lockSsfi` flag is set, then this assertion is being
        // invoked from inside of another assertion. In this case, the `ssfi`
        // flag has already been set by the outer assertion.
        //
        // Note that overwriting a chainable method merely replaces the saved
        // methods in `ctx.__methods` instead of completely replacing the
        // overwritten assertion. Therefore, an overwriting assertion won't
        // set the `ssfi` or `lockSsfi` flags.
        if (!flag(this, 'lockSsfi')) {
          flag(this, 'ssfi', chainableMethodWrapper);
        }

        var result = chainableBehavior.method.apply(this, arguments);

        if (result !== undefined) {
          return result;
        }

        var newAssertion = new chai$1.Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      };

      addLengthGuard(chainableMethodWrapper, name, true); // Use `Object.setPrototypeOf` if available

      if (canSetPrototype) {
        // Inherit all properties from the object by replacing the `Function` prototype
        var prototype = Object.create(this); // Restore the `call` and `apply` methods from `Function`

        prototype.call = call;
        prototype.apply = apply;
        Object.setPrototypeOf(chainableMethodWrapper, prototype);
      } // Otherwise, redefine all properties (slow!)
      else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (excludeNames.indexOf(asserterName) !== -1) {
              return;
            }

            var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
            Object.defineProperty(chainableMethodWrapper, asserterName, pd);
          });
        }

      transferFlags(this, chainableMethodWrapper);
      return proxify(chainableMethodWrapper);
    },
    configurable: true
  });
};/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.lengthOf(3);
 *     expect(myFoo).to.have.lengthOf.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @namespace Utils
 * @name overwriteChainableMethod
 * @api public
 */

var overwriteChainableMethod = function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];
  var _chainingBehavior = chainableBehavior.chainingBehavior;

  chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {
    var result = chainingBehavior(_chainingBehavior).call(this);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai$1.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  var _method = chainableBehavior.method;

  chainableBehavior.method = function overwritingChainableMethodWrapper() {
    var result = method(_method).apply(this, arguments);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai$1.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };
};/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

/**
 * ### .compareByInspect(mixed, mixed)
 *
 * To be used as a compareFunction with Array.prototype.sort. Compares elements
 * using inspect instead of default behavior of using toString so that Symbols
 * and objects with irregular/missing toString can still be sorted without a
 * TypeError.
 *
 * @param {Mixed} first element to compare
 * @param {Mixed} second element to compare
 * @returns {Number} -1 if 'a' should come before 'b'; otherwise 1 
 * @name compareByInspect
 * @namespace Utils
 * @api public
 */

var compareByInspect = function compareByInspect(a, b) {
  return inspect_1(a) < inspect_1(b) ? -1 : 1;
};/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getOwnEnumerablePropertySymbols(object)
 *
 * This allows the retrieval of directly-owned enumerable property symbols of an
 * object. This function is necessary because Object.getOwnPropertySymbols
 * returns both enumerable and non-enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerablePropertySymbols
 * @api public
 */
var getOwnEnumerablePropertySymbols = function getOwnEnumerablePropertySymbols(obj) {
  if (typeof Object.getOwnPropertySymbols !== 'function') return [];
  return Object.getOwnPropertySymbols(obj).filter(function (sym) {
    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
  });
};/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

/**
 * ### .getOwnEnumerableProperties(object)
 *
 * This allows the retrieval of directly-owned enumerable property names and
 * symbols of an object. This function is necessary because Object.keys only
 * returns enumerable property names, not enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerableProperties
 * @api public
 */

var getOwnEnumerableProperties = function getOwnEnumerableProperties(obj) {
  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
};/* !
 * Chai - checkError utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .checkError
 *
 * Checks that an error conforms to a given set of criteria and/or retrieves information about it.
 *
 * @api public
 */

/**
 * ### .compatibleInstance(thrown, errorLike)
 *
 * Checks if two instances are compatible (strict equal).
 * Returns false if errorLike is not an instance of Error, because instances
 * can only be compatible if they're both error instances.
 *
 * @name compatibleInstance
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */

function compatibleInstance(thrown, errorLike) {
  return errorLike instanceof Error && thrown === errorLike;
}
/**
 * ### .compatibleConstructor(thrown, errorLike)
 *
 * Checks if two constructors are compatible.
 * This function can receive either an error constructor or
 * an error instance as the `errorLike` argument.
 * Constructors are compatible if they're the same or if one is
 * an instance of another.
 *
 * @name compatibleConstructor
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */


function compatibleConstructor(thrown, errorLike) {
  if (errorLike instanceof Error) {
    // If `errorLike` is an instance of any error we compare their constructors
    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
  } else if (errorLike.prototype instanceof Error || errorLike === Error) {
    // If `errorLike` is a constructor that inherits from Error, we compare `thrown` to `errorLike` directly
    return thrown.constructor === errorLike || thrown instanceof errorLike;
  }

  return false;
}
/**
 * ### .compatibleMessage(thrown, errMatcher)
 *
 * Checks if an error's message is compatible with a matcher (String or RegExp).
 * If the message contains the String or passes the RegExp test,
 * it is considered compatible.
 *
 * @name compatibleMessage
 * @param {Error} thrown error
 * @param {String|RegExp} errMatcher to look for into the message
 * @namespace Utils
 * @api public
 */


function compatibleMessage(thrown, errMatcher) {
  var comparisonString = typeof thrown === 'string' ? thrown : thrown.message;

  if (errMatcher instanceof RegExp) {
    return errMatcher.test(comparisonString);
  } else if (typeof errMatcher === 'string') {
    return comparisonString.indexOf(errMatcher) !== -1; // eslint-disable-line no-magic-numbers
  }

  return false;
}
/**
 * ### .getFunctionName(constructorFn)
 *
 * Returns the name of a function.
 * This also includes a polyfill function if `constructorFn.name` is not defined.
 *
 * @name getFunctionName
 * @param {Function} constructorFn
 * @namespace Utils
 * @api private
 */


var functionNameMatch$1 = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\(\/]+)/;

function getFunctionName(constructorFn) {
  var name = '';

  if (typeof constructorFn.name === 'undefined') {
    // Here we run a polyfill if constructorFn.name is not defined
    var match = String(constructorFn).match(functionNameMatch$1);

    if (match) {
      name = match[1];
    }
  } else {
    name = constructorFn.name;
  }

  return name;
}
/**
 * ### .getConstructorName(errorLike)
 *
 * Gets the constructor name for an Error instance or constructor itself.
 *
 * @name getConstructorName
 * @param {Error|ErrorConstructor} errorLike
 * @namespace Utils
 * @api public
 */


function getConstructorName(errorLike) {
  var constructorName = errorLike;

  if (errorLike instanceof Error) {
    constructorName = getFunctionName(errorLike.constructor);
  } else if (typeof errorLike === 'function') {
    // If `err` is not an instance of Error it is an error constructor itself or another function.
    // If we've got a common function we get its name, otherwise we may need to create a new instance
    // of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.
    constructorName = getFunctionName(errorLike).trim() || getFunctionName(new errorLike()); // eslint-disable-line new-cap
  }

  return constructorName;
}
/**
 * ### .getMessage(errorLike)
 *
 * Gets the error message from an error.
 * If `err` is a String itself, we return it.
 * If the error has no message, we return an empty string.
 *
 * @name getMessage
 * @param {Error|String} errorLike
 * @namespace Utils
 * @api public
 */


function getMessage$1(errorLike) {
  var msg = '';

  if (errorLike && errorLike.message) {
    msg = errorLike.message;
  } else if (typeof errorLike === 'string') {
    msg = errorLike;
  }

  return msg;
}

var checkError = {
  compatibleInstance: compatibleInstance,
  compatibleConstructor: compatibleConstructor,
  compatibleMessage: compatibleMessage,
  getMessage: getMessage$1,
  getConstructorName: getConstructorName
};/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */

/**
 * ### .isNaN(value)
 *
 * Checks if the given value is NaN or not.
 *
 *     utils.isNaN(NaN); // true
 *
 * @param {Value} The value which has to be checked if it is NaN
 * @name isNaN
 * @api private
 */
function isNaN$1(value) {
  // Refer http://www.ecma-international.org/ecma-262/6.0/#sec-isnan-number
  // section's NOTE.
  return value !== value;
} // If ECMAScript 6's Number.isNaN is present, prefer that.


var _isNaN = Number.isNaN || isNaN$1;/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Dependencies that are used for multiple exports are required here only once
 */

/*!
 * test utility
 */

var test$2 = test$1;
/*!
 * type utility
 */

var type = typeDetect;
/*!
 * expectTypes utility
 */

var expectTypes$1 = expectTypes;
/*!
 * message utility
 */

var getMessage$2 = getMessage;
/*!
 * actual utility
 */

var getActual$1 = getActual;
/*!
 * Inspect util
 */

var inspect = inspect_1;
/*!
 * Object Display util
 */

var objDisplay$1 = objDisplay;
/*!
 * Flag utility
 */

var flag$1 = flag;
/*!
 * Flag transferring utility
 */

var transferFlags$1 = transferFlags;
/*!
 * Deep equal utility
 */

var eql = deepEql;
/*!
 * Deep path info
 */

var getPathInfo$1 = pathval.getPathInfo;
/*!
 * Check if a property exists
 */

var hasProperty$1 = pathval.hasProperty;
/*!
 * Function name
 */

var getName = getFuncName_1;
/*!
 * add Property
 */

var addProperty$1 = addProperty;
/*!
 * add Method
 */

var addMethod$1 = addMethod;
/*!
 * overwrite Property
 */

var overwriteProperty$1 = overwriteProperty;
/*!
 * overwrite Method
 */

var overwriteMethod$1 = overwriteMethod;
/*!
 * Add a chainable method
 */

var addChainableMethod$1 = addChainableMethod;
/*!
 * Overwrite chainable method
 */

var overwriteChainableMethod$1 = overwriteChainableMethod;
/*!
 * Compare by inspect method
 */

var compareByInspect$1 = compareByInspect;
/*!
 * Get own enumerable property symbols method
 */

var getOwnEnumerablePropertySymbols$1 = getOwnEnumerablePropertySymbols;
/*!
 * Get own enumerable properties method
 */

var getOwnEnumerableProperties$1 = getOwnEnumerableProperties;
/*!
 * Checks error against a given set of criteria
 */

var checkError$1 = checkError;
/*!
 * Proxify util
 */

var proxify$1 = proxify;
/*!
 * addLengthGuard util
 */

var addLengthGuard$1 = addLengthGuard;
/*!
 * isProxyEnabled helper
 */

var isProxyEnabled$1 = isProxyEnabled;
/*!
 * isNaN method
 */

var isNaN$2 = _isNaN;
var utils = {
  test: test$2,
  type: type,
  expectTypes: expectTypes$1,
  getMessage: getMessage$2,
  getActual: getActual$1,
  inspect: inspect,
  objDisplay: objDisplay$1,
  flag: flag$1,
  transferFlags: transferFlags$1,
  eql: eql,
  getPathInfo: getPathInfo$1,
  hasProperty: hasProperty$1,
  getName: getName,
  addProperty: addProperty$1,
  addMethod: addMethod$1,
  overwriteProperty: overwriteProperty$1,
  overwriteMethod: overwriteMethod$1,
  addChainableMethod: addChainableMethod$1,
  overwriteChainableMethod: overwriteChainableMethod$1,
  compareByInspect: compareByInspect$1,
  getOwnEnumerablePropertySymbols: getOwnEnumerablePropertySymbols$1,
  getOwnEnumerableProperties: getOwnEnumerableProperties$1,
  checkError: checkError$1,
  proxify: proxify$1,
  addLengthGuard: addLengthGuard$1,
  isProxyEnabled: isProxyEnabled$1,
  isNaN: isNaN$2
};/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var assertion = function (_chai, util) {
  /*!
   * Module dependencies.
   */
  var AssertionError = _chai.AssertionError,
      flag = util.flag;
  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;
  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   *   contain `numKittens` so that the `equal` assertion can reference it when
   *   needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   *   prepended to the error message that's generated by the assertion when it
   *   fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   *   contains a function reference that serves as the starting point for
   *   removing frames from the stack trace of the error that's created by the
   *   assertion when it fails. The goal is to provide a cleaner stack trace to
   *   end users by removing Chai's internal functions. Note that it only works
   *   in environments that support `Error.captureStackTrace`, and only when
   *   `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   *   should retain its current value, even as assertions are chained off of
   *   this object. This is usually set to `true` when creating a new assertion
   *   from within another assertion. It's also temporarily set to `true` before
   *   an overwritten assertion gets called by the overwriting assertion.
   *
   * @param {Mixed} obj target of the assertion
   * @param {String} msg (optional) custom error message
   * @param {Function} ssfi (optional) starting point for removing stack frames
   * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
   * @api private
   */

  function Assertion(obj, msg, ssfi, lockSsfi) {
    flag(this, 'ssfi', ssfi || Assertion);
    flag(this, 'lockSsfi', lockSsfi);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
    return util.proxify(this);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function () {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function (value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });
  Object.defineProperty(Assertion, 'showDiff', {
    get: function () {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function (value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };
  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String|Function} message or function that returns message to display if expression fails
   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @api private
   */


  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (false !== showDiff) showDiff = true;
    if (undefined === expected && undefined === _actual) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      msg = util.getMessage(this, arguments);
      var actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
        actual: actual,
        expected: expected,
        showDiff: showDiff
      }, config.includeStack ? this.assert : flag(this, 'ssfi'));
    }
  };
  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */


  Object.defineProperty(Assertion.prototype, '_obj', {
    get: function () {
      return flag(this, 'object');
    },
    set: function (val) {
      flag(this, 'object', val);
    }
  });
};/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var assertions = function (chai, _) {
  var Assertion = chai.Assertion,
      AssertionError = chai.AssertionError,
      flag = _.flag;
  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to improve the readability
   * of your assertions.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   * - but
   * - does
   *
   * @name language chains
   * @namespace BDD
   * @api public
   */

  ['to', 'be', 'been', 'is', 'and', 'has', 'have', 'with', 'that', 'which', 'at', 'of', 'same', 'but', 'does'].forEach(function (chain) {
    Assertion.addProperty(chain);
  });
  /**
   * ### .not
   *
   * Negates all assertions that follow in the chain.
   *
   *     expect(function () {}).to.not.throw();
   *     expect({a: 1}).to.not.have.property('b');
   *     expect([1, 2]).to.be.an('array').that.does.not.include(3);
   *
   * Just because you can negate any assertion with `.not` doesn't mean you
   * should. With great power comes great responsibility. It's often best to
   * assert that the one expected output was produced, rather than asserting
   * that one of countless unexpected outputs wasn't produced. See individual
   * assertions for specific guidance.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.equal(1); // Not recommended
   *
   * @name not
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });
  /**
   * ### .deep
   *
   * Causes all `.equal`, `.include`, `.members`, `.keys`, and `.property`
   * assertions that follow in the chain to use deep equality instead of strict
   * (`===`) equality. See the `deep-eql` project page for info on the deep
   * equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals `{a: 1}`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) includes `{a: 1}`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes `x: {a: 1}`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   *     // Target array deeply (but not strictly) has member `{a: 1}`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   *     // Target set deeply (but not strictly) has key `{a: 1}`
   *     expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);
   *
   *     // Target object deeply (but not strictly) has property `x: {a: 1}`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * @name deep
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });
  /**
   * ### .nested
   *
   * Enables dot- and bracket-notation in all `.property` and `.include`
   * assertions that follow in the chain.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
   *     expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\.a.\\[b\\]': 'x'});
   *
   * `.nested` cannot be combined with `.own`.
   *
   * @name nested
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('nested', function () {
    flag(this, 'nested', true);
  });
  /**
   * ### .own
   *
   * Causes all `.property` and `.include` assertions that follow in the chain
   * to ignore inherited properties.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.property('b').but.not.own.property('b'); 
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * `.own` cannot be combined with `.nested`.
   *
   * @name own
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('own', function () {
    flag(this, 'own', true);
  });
  /**
   * ### .ordered
   *
   * Causes all `.members` assertions that follow in the chain to require that
   * members be in the same order.
   *
   *     expect([1, 2]).to.have.ordered.members([1, 2])
   *       .but.not.have.ordered.members([2, 1]);
   *
   * When `.include` and `.ordered` are combined, the ordering begins at the
   * start of both arrays.
   *
   *     expect([1, 2, 3]).to.include.ordered.members([1, 2])
   *       .but.not.include.ordered.members([2, 3]);
   *
   * @name ordered
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ordered', function () {
    flag(this, 'ordered', true);
  });
  /**
   * ### .any
   *
   * Causes all `.keys` assertions that follow in the chain to only require that
   * the target have at least one of the given keys. This is the opposite of
   * `.all`, which requires that the target have all of the given keys.
   *
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   * See the `.keys` doc for guidance on when to use `.any` or `.all`.
   *
   * @name any
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('any', function () {
    flag(this, 'any', true);
    flag(this, 'all', false);
  });
  /**
   * ### .all
   *
   * Causes all `.keys` assertions that follow in the chain to require that the
   * target have all of the given keys. This is the opposite of `.any`, which
   * only requires that the target have at least one of the given keys.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   * Note that `.all` is used by default when neither `.all` nor `.any` are
   * added earlier in the chain. However, it's often best to add `.all` anyway
   * because it improves readability.
   *
   * See the `.keys` doc for guidance on when to use `.any` or `.all`.
   *
   * @name all
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('all', function () {
    flag(this, 'all', true);
    flag(this, 'any', false);
  });
  /**
   * ### .a(type[, msg])
   *
   * Asserts that the target's type is equal to the given string `type`. Types
   * are case insensitive. See the `type-detect` project page for info on the
   * type detection algorithm: https://github.com/chaijs/type-detect.
   *
   *     expect('foo').to.be.a('string');
   *     expect({a: 1}).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *     expect(new Error).to.be.an('error');
   *     expect(Promise.resolve()).to.be.a('promise');
   *     expect(new Float32Array).to.be.a('float32array');
   *     expect(Symbol()).to.be.a('symbol');
   *
   * `.a` supports objects that have a custom type set via `Symbol.toStringTag`.
   *
   *     var myObj = {
   *       [Symbol.toStringTag]: 'myCustomType'
   *     };
   *
   *     expect(myObj).to.be.a('myCustomType').but.not.an('object');
   *
   * It's often best to use `.a` to check a target's type before making more
   * assertions on the same target. That way, you avoid unexpected behavior from
   * any assertion that does different things based on the target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add `.not` earlier in the chain to negate `.a`. However, it's often best to
   * assert that the target is the expected type, rather than asserting that it
   * isn't one of many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.an('array'); // Not recommended
   *
   * `.a` accepts an optional `msg` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to `expect`.
   *
   *     expect(1).to.be.a('string', 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.a('string');
   *
   * `.a` can also be used as a language chain to improve the readability of
   * your assertions. 
   *
   *     expect({b: 2}).to.have.a.property('b');
   *
   * The alias `.an` can be used interchangeably with `.a`.
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function an(type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object'),
        article = ~['a', 'e', 'i', 'o', 'u'].indexOf(type.charAt(0)) ? 'an ' : 'a ';
    this.assert(type === _.type(obj).toLowerCase(), 'expected #{this} to be ' + article + type, 'expected #{this} not to be ' + article + type);
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);
  /**
   * ### .include(val[, msg])
   *
   * When the target is a string, `.include` asserts that the given string `val`
   * is a substring of the target.
   *
   *     expect('foobar').to.include('foo');
   *
   * When the target is an array, `.include` asserts that the given `val` is a
   * member of the target.
   *
   *     expect([1, 2, 3]).to.include(2);
   *
   * When the target is an object, `.include` asserts that the given object
   * `val`'s properties are a subset of the target's properties.
   *
   *     expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});
   *
   * When the target is a Set or WeakSet, `.include` asserts that the given `val` is a
   * member of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Set([1, 2])).to.include(2);
   *
   * When the target is a Map, `.include` asserts that the given `val` is one of
   * the values of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.include(2);
   *
   * Because `.include` does different things based on the target's type, it's
   * important to check the target's type before using `.include`. See the `.a`
   * doc for info on testing a target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *
   * By default, strict (`===`) equality is used to compare array members and
   * object properties. Add `.deep` earlier in the chain to use deep equality
   * instead (WeakSet targets are not supported). See the `deep-eql` project
   * page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) includes `{a: 1}`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes `x: {a: 1}`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   * By default, all of the target's properties are searched when working with
   * objects. This includes properties that are inherited and/or non-enumerable.
   * Add `.own` earlier in the chain to exclude the target's inherited
   * properties from the search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * Note that a target object is always only searched for `val`'s own
   * enumerable properties.
   *
   * `.deep` and `.own` can be combined.
   *
   *     expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});
   *
   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 2}}).to.nested.include({'\\.a.\\[b\\]': 2});
   *
   * `.deep` and `.nested` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});
   *
   * `.own` and `.nested` cannot be combined.
   *
   * Add `.not` earlier in the chain to negate `.include`.
   *
   *     expect('foobar').to.not.include('taco');
   *     expect([1, 2, 3]).to.not.include(4);
   * 
   * However, it's dangerous to negate `.include` when the target is an object.
   * The problem is that it creates uncertain expectations by asserting that the
   * target object doesn't have all of `val`'s key/value pairs but may or may
   * not have some of them. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target object isn't even expected to have `val`'s keys, it's
   * often best to assert exactly that.
   *
   *     expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended
   *     expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * When the target object is expected to have `val`'s keys, it's often best to
   * assert that each of the properties has its expected value, rather than
   * asserting that each property doesn't have one of many unexpected values.
   *
   *     expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended
   *     expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * `.include` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2, 3]).to.include(4, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.include(4);
   *
   * `.include` can also be used as a language chain, causing all `.members` and
   * `.keys` assertions that follow in the chain to require the target to be a
   * superset of the expected set, rather than an identical set. Note that
   * `.members` ignores duplicates in the subset when `.include` is added.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * Note that adding `.any` earlier in the chain causes the `.keys` assertion
   * to ignore `.include`.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *
   * The aliases `.includes`, `.contain`, and `.contains` can be used
   * interchangeably with `.include`.
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function SameValueZero(a, b) {
    return _.isNaN(a) && _.isNaN(b) || a === b;
  }

  function includeChainingBehavior() {
    flag(this, 'contains', true);
  }

  function include(val, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        objType = _.type(obj).toLowerCase(),
        flagMsg = flag(this, 'message'),
        negate = flag(this, 'negate'),
        ssfi = flag(this, 'ssfi'),
        isDeep = flag(this, 'deep'),
        descriptor = isDeep ? 'deep ' : '';

    flagMsg = flagMsg ? flagMsg + ': ' : '';
    var included = false;

    switch (objType) {
      case 'string':
        included = obj.indexOf(val) !== -1;
        break;

      case 'weakset':
        if (isDeep) {
          throw new AssertionError(flagMsg + 'unable to use .deep.include with WeakSet', undefined, ssfi);
        }

        included = obj.has(val);
        break;

      case 'map':
        var isEql = isDeep ? _.eql : SameValueZero;
        obj.forEach(function (item) {
          included = included || isEql(item, val);
        });
        break;

      case 'set':
        if (isDeep) {
          obj.forEach(function (item) {
            included = included || _.eql(item, val);
          });
        } else {
          included = obj.has(val);
        }

        break;

      case 'array':
        if (isDeep) {
          included = obj.some(function (item) {
            return _.eql(item, val);
          });
        } else {
          included = obj.indexOf(val) !== -1;
        }

        break;

      default:
        // This block is for asserting a subset of properties in an object.
        // `_.expectTypes` isn't used here because `.include` should work with
        // objects with a custom `@@toStringTag`.
        if (val !== Object(val)) {
          throw new AssertionError(flagMsg + 'object tested must be an array, a map, an object,' + ' a set, a string, or a weakset, but ' + objType + ' given', undefined, ssfi);
        }

        var props = Object.keys(val),
            firstErr = null,
            numErrs = 0;
        props.forEach(function (prop) {
          var propAssertion = new Assertion(obj);

          _.transferFlags(this, propAssertion, true);

          flag(propAssertion, 'lockSsfi', true);

          if (!negate || props.length === 1) {
            propAssertion.property(prop, val[prop]);
            return;
          }

          try {
            propAssertion.property(prop, val[prop]);
          } catch (err) {
            if (!_.checkError.compatibleConstructor(err, AssertionError)) {
              throw err;
            }

            if (firstErr === null) firstErr = err;
            numErrs++;
          }
        }, this); // When validating .not.include with multiple properties, we only want
        // to throw an assertion error if all of the properties are included,
        // in which case we throw the first property assertion error that we
        // encountered.

        if (negate && props.length > 1 && numErrs === props.length) {
          throw firstErr;
        }

        return;
    } // Assert inclusion in collection or substring in a string.


    this.assert(included, 'expected #{this} to ' + descriptor + 'include ' + _.inspect(val), 'expected #{this} to not ' + descriptor + 'include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);
  Assertion.addChainableMethod('contains', include, includeChainingBehavior);
  Assertion.addChainableMethod('includes', include, includeChainingBehavior);
  /**
   * ### .ok
   *
   * Asserts that the target is loosely (`==`) equal to `true`. However, it's
   * often best to assert that the target is strictly (`===`) or deeply equal to
   * its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.ok; // Not recommended
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.be.ok; // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.ok`.
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.not.be.ok; // Not recommended
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.ok; // Not recommended
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.be.ok; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.be.ok; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(false, 'nooo why fail??').to.be.ok;
   *
   * @name ok
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(flag(this, 'object'), 'expected #{this} to be truthy', 'expected #{this} to be falsy');
  });
  /**
   * ### .true
   *
   * Asserts that the target is strictly (`===`) equal to `true`.
   *
   *     expect(true).to.be.true;
   *
   * Add `.not` earlier in the chain to negate `.true`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `true`.
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.true; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.true; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(false, 'nooo why fail??').to.be.true;
   *
   * @name true
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(true === flag(this, 'object'), 'expected #{this} to be true', 'expected #{this} to be false', flag(this, 'negate') ? false : true);
  });
  /**
   * ### .false
   *
   * Asserts that the target is strictly (`===`) equal to `false`.
   *
   *     expect(false).to.be.false;
   *
   * Add `.not` earlier in the chain to negate `.false`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to `false`.
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.not.be.false; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.false; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(true, 'nooo why fail??').to.be.false;
   *
   * @name false
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(false === flag(this, 'object'), 'expected #{this} to be false', 'expected #{this} to be true', flag(this, 'negate') ? true : false);
  });
  /**
   * ### .null
   *
   * Asserts that the target is strictly (`===`) equal to `null`.
   *
   *     expect(null).to.be.null;
   *
   * Add `.not` earlier in the chain to negate `.null`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `null`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.null; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.null;
   *
   * @name null
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(null === flag(this, 'object'), 'expected #{this} to be null', 'expected #{this} not to be null');
  });
  /**
   * ### .undefined
   *
   * Asserts that the target is strictly (`===`) equal to `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *
   * Add `.not` earlier in the chain to negate `.undefined`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to `undefined`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.undefined; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.undefined;
   *
   * @name undefined
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(undefined === flag(this, 'object'), 'expected #{this} to be undefined', 'expected #{this} not to be undefined');
  });
  /**
   * ### .NaN
   *
   * Asserts that the target is exactly `NaN`.
   *
   *     expect(NaN).to.be.NaN;
   *
   * Add `.not` earlier in the chain to negate `.NaN`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `NaN`.
   *
   *     expect('foo').to.equal('foo'); // Recommended
   *     expect('foo').to.not.be.NaN; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.NaN;
   *
   * @name NaN
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('NaN', function () {
    this.assert(_.isNaN(flag(this, 'object')), 'expected #{this} to be NaN', 'expected #{this} not to be NaN');
  });
  /**
   * ### .exist
   *
   * Asserts that the target is not strictly (`===`) equal to either `null` or
   * `undefined`. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.exist; // Not recommended
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.exist; // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.exist`.
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.exist; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.exist; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(null, 'nooo why fail??').to.exist;
   *
   * @name exist
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('exist', function () {
    var val = flag(this, 'object');
    this.assert(val !== null && val !== undefined, 'expected #{this} to exist', 'expected #{this} to not exist');
  });
  /**
   * ### .empty
   *
   * When the target is a string or array, `.empty` asserts that the target's
   * `length` property is strictly (`===`) equal to `0`.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *
   * When the target is a map or set, `.empty` asserts that the target's `size`
   * property is strictly equal to `0`.
   *
   *     expect(new Set()).to.be.empty;
   *     expect(new Map()).to.be.empty;
   *
   * When the target is a non-function object, `.empty` asserts that the target
   * doesn't have any own enumerable properties. Properties with Symbol-based
   * keys are excluded from the count.
   *
   *     expect({}).to.be.empty;
   *
   * Because `.empty` does different things based on the target's type, it's
   * important to check the target's type before using `.empty`. See the `.a`
   * doc for info on testing a target's type.
   *
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add `.not` earlier in the chain to negate `.empty`. However, it's often
   * best to assert that the target contains its expected number of values,
   * rather than asserting that it's not empty.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.not.be.empty; // Not recommended
   *
   *     expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended
   *     expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended
   *
   *     expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended
   *     expect({a: 1}).to.not.be.empty; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect([1, 2, 3], 'nooo why fail??').to.be.empty;
   *
   * @name empty
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var val = flag(this, 'object'),
        ssfi = flag(this, 'ssfi'),
        flagMsg = flag(this, 'message'),
        itemsCount;
    flagMsg = flagMsg ? flagMsg + ': ' : '';

    switch (_.type(val).toLowerCase()) {
      case 'array':
      case 'string':
        itemsCount = val.length;
        break;

      case 'map':
      case 'set':
        itemsCount = val.size;
        break;

      case 'weakmap':
      case 'weakset':
        throw new AssertionError(flagMsg + '.empty was passed a weak collection', undefined, ssfi);

      case 'function':
        var msg = flagMsg + '.empty was passed a function ' + _.getName(val);

        throw new AssertionError(msg.trim(), undefined, ssfi);

      default:
        if (val !== Object(val)) {
          throw new AssertionError(flagMsg + '.empty was passed non-string primitive ' + _.inspect(val), undefined, ssfi);
        }

        itemsCount = Object.keys(val).length;
    }

    this.assert(0 === itemsCount, 'expected #{this} to be empty', 'expected #{this} not to be empty');
  });
  /**
   * ### .arguments
   *
   * Asserts that the target is an `arguments` object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   *     test();
   *
   * Add `.not` earlier in the chain to negate `.arguments`. However, it's often
   * best to assert which type the target is expected to be, rather than
   * asserting that its not an `arguments` object.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.arguments; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({}, 'nooo why fail??').to.be.arguments;
   *
   * The alias `.Arguments` can be used interchangeably with `.arguments`.
   *
   * @name arguments
   * @alias Arguments
   * @namespace BDD
   * @api public
   */

  function checkArguments() {
    var obj = flag(this, 'object'),
        type = _.type(obj);

    this.assert('Arguments' === type, 'expected #{this} to be arguments but got ' + type, 'expected #{this} to not be arguments');
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);
  /**
   * ### .equal(val[, msg])
   *
   * Asserts that the target is strictly (`===`) equal to the given `val`.
   *
   *     expect(1).to.equal(1);
   *     expect('foo').to.equal('foo');
   * 
   * Add `.deep` earlier in the chain to use deep equality instead. See the
   * `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals `{a: 1}`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) equals `[1, 2]`
   *     expect([1, 2]).to.deep.equal([1, 2]);
   *     expect([1, 2]).to.not.equal([1, 2]);
   *
   * Add `.not` earlier in the chain to negate `.equal`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to one of countless unexpected values.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.equal(2); // Not recommended
   *
   * `.equal` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.equal(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.equal(2);
   *
   * The aliases `.equals` and `eq` can be used interchangeably with `.equal`.
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertEqual(val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    if (flag(this, 'deep')) {
      return this.eql(val);
    } else {
      this.assert(val === obj, 'expected #{this} to equal #{exp}', 'expected #{this} to not equal #{exp}', val, this._obj, true);
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);
  /**
   * ### .eql(obj[, msg])
   *
   * Asserts that the target is deeply equal to the given `obj`. See the
   * `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object is deeply (but not strictly) equal to {a: 1}
   *     expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});
   *
   *     // Target array is deeply (but not strictly) equal to [1, 2]
   *     expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);
   *
   * Add `.not` earlier in the chain to negate `.eql`. However, it's often best
   * to assert that the target is deeply equal to its expected value, rather
   * than not deeply equal to one of countless unexpected values.
   *
   *     expect({a: 1}).to.eql({a: 1}); // Recommended
   *     expect({a: 1}).to.not.eql({b: 2}); // Not recommended
   *
   * `.eql` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.eql({b: 2});
   *
   * The alias `.eqls` can be used interchangeably with `.eql`.
   *
   * The `.deep.equal` assertion is almost identical to `.eql` but with one
   * difference: `.deep.equal` causes deep equality comparisons to also be used
   * for any other assertions that follow in the chain.
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} obj
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(_.eql(obj, flag(this, 'object')), 'expected #{this} to deeply equal #{exp}', 'expected #{this} to not deeply equal #{exp}', obj, this._obj, true);
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);
  /**
   * ### .above(n[, msg])
   *
   * Asserts that the target is a number or a date greater than the given number or date `n` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.above(1); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the value of the
   * target's `length` property is greater than the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.above(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.above`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(1).to.not.be.above(2); // Not recommended
   *
   * `.above` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.above(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.above(2);
   *
   * The aliases `.gt` and `.greaterThan` can be used interchangeably with
   * `.above`.
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertAbove(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        shouldThrow = true;

    if (doLength) {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to above must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to above must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var len = obj.length;
      this.assert(len > n, 'expected #{this} to have a length above #{exp} but got #{act}', 'expected #{this} to not have a length above #{exp}', n, len);
    } else {
      this.assert(obj > n, 'expected #{this} to be above #{exp}', 'expected #{this} to be at most #{exp}', n);
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);
  /**
   * ### .least(n[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date `n` respectively. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.at.least(1); // Not recommended
   *     expect(2).to.be.at.least(2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the value of the
   * target's `length` property is greater than or equal to the given number
   * `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.least(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.least`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.at.least(2); // Not recommended
   *
   * `.least` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.at.least(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.at.least(2);
   *
   * The alias `.gte` can be used interchangeably with `.least`.
   *
   * @name least
   * @alias gte
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertLeast(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        shouldThrow = true;

    if (doLength) {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to least must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to least must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var len = obj.length;
      this.assert(len >= n, 'expected #{this} to have a length at least #{exp} but got #{act}', 'expected #{this} to have a length below #{exp}', n, len);
    } else {
      this.assert(obj >= n, 'expected #{this} to be at least #{exp}', 'expected #{this} to be below #{exp}', n);
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);
  /**
   * ### .below(n[, msg])
   *
   * Asserts that the target is a number or a date less than the given number or date `n` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.below(2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the value of the
   * target's `length` property is less than the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.below(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.length(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.below`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.below(1); // Not recommended
   *
   * `.below` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(2).to.be.below(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.below(1);
   *
   * The aliases `.lt` and `.lessThan` can be used interchangeably with
   * `.below`.
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertBelow(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        shouldThrow = true;

    if (doLength) {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to below must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to below must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var len = obj.length;
      this.assert(len < n, 'expected #{this} to have a length below #{exp} but got #{act}', 'expected #{this} to not have a length below #{exp}', n, len);
    } else {
      this.assert(obj < n, 'expected #{this} to be below #{exp}', 'expected #{this} to be at least #{exp}', n);
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);
  /**
   * ### .most(n[, msg])
   *
   * Asserts that the target is a number or a date less than or equal to the given number
   * or date `n` respectively. However, it's often best to assert that the target is equal to its
   * expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.at.most(2); // Not recommended
   *     expect(1).to.be.at.most(1); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the value of the
   * target's `length` property is less than or equal to the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.most(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.most`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.at.most(1); // Not recommended
   *
   * `.most` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(2).to.be.at.most(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.at.most(1);
   *
   * The alias `.lte` can be used interchangeably with `.most`.
   *
   * @name most
   * @alias lte
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertMost(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        shouldThrow = true;

    if (doLength) {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to most must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to most must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var len = obj.length;
      this.assert(len <= n, 'expected #{this} to have a length at most #{exp} but got #{act}', 'expected #{this} to have a length above #{exp}', n, len);
    } else {
      this.assert(obj <= n, 'expected #{this} to be at most #{exp}', 'expected #{this} to be above #{exp}', n);
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);
  /**
   * ### .within(start, finish[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date `start`, and less than or equal to the given number or date `finish` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.within(1, 3); // Not recommended
   *     expect(2).to.be.within(2, 3); // Not recommended
   *     expect(2).to.be.within(1, 2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the value of the
   * target's `length` property is greater than or equal to the given number
   * `start`, and less than or equal to the given number `finish`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.within(2, 4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.within`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.within(2, 4); // Not recommended
   *
   * `.within` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(4).to.be.within(1, 3, 'nooo why fail??');
   *     expect(4, 'nooo why fail??').to.be.within(1, 3);
   *
   * @name within
   * @param {Number} start lower bound inclusive
   * @param {Number} finish upper bound inclusive
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        startType = _.type(start).toLowerCase(),
        finishType = _.type(finish).toLowerCase(),
        shouldThrow = true,
        range = startType === 'date' && finishType === 'date' ? start.toUTCString() + '..' + finish.toUTCString() : start + '..' + finish;

    if (doLength) {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && (startType !== 'date' || finishType !== 'date')) {
      errorMessage = msgPrefix + 'the arguments to within must be dates';
    } else if ((startType !== 'number' || finishType !== 'number') && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the arguments to within must be numbers';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var len = obj.length;
      this.assert(len >= start && len <= finish, 'expected #{this} to have a length within ' + range, 'expected #{this} to not have a length within ' + range);
    } else {
      this.assert(obj >= start && obj <= finish, 'expected #{this} to be within ' + range, 'expected #{this} to not be within ' + range);
    }
  });
  /**
   * ### .instanceof(constructor[, msg])
   *
   * Asserts that the target is an instance of the given `constructor`.
   *
   *     function Cat () { }
   *
   *     expect(new Cat()).to.be.an.instanceof(Cat);
   *     expect([1, 2]).to.be.an.instanceof(Array);
   *
   * Add `.not` earlier in the chain to negate `.instanceof`.
   *
   *     expect({a: 1}).to.not.be.an.instanceof(Array);
   *
   * `.instanceof` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1).to.be.an.instanceof(Array, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.an.instanceof(Array);
   *
   * Due to limitations in ES5, `.instanceof` may not always work as expected
   * when using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing built-in object such as
   * `Array`, `Error`, and `Map`. See your transpiler's docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * The alias `.instanceOf` can be used interchangeably with `.instanceof`.
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} msg _optional_
   * @alias instanceOf
   * @namespace BDD
   * @api public
   */

  function assertInstanceOf(constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var target = flag(this, 'object');
    var ssfi = flag(this, 'ssfi');
    var flagMsg = flag(this, 'message');

    try {
      var isInstanceOf = target instanceof constructor;
    } catch (err) {
      if (err instanceof TypeError) {
        flagMsg = flagMsg ? flagMsg + ': ' : '';
        throw new AssertionError(flagMsg + 'The instanceof assertion needs a constructor but ' + _.type(constructor) + ' was given.', undefined, ssfi);
      }

      throw err;
    }

    var name = _.getName(constructor);

    if (name === null) {
      name = 'an unnamed constructor';
    }

    this.assert(isInstanceOf, 'expected #{this} to be an instance of ' + name, 'expected #{this} to not be an instance of ' + name);
  }
  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);
  /**
   * ### .property(name[, val[, msg]])
   *
   * Asserts that the target has a property with the given key `name`.
   *
   *     expect({a: 1}).to.have.property('a');
   *
   * When `val` is provided, `.property` also asserts that the property's value
   * is equal to the given `val`.
   *
   *     expect({a: 1}).to.have.property('a', 1);
   *
   * By default, strict (`===`) equality is used. Add `.deep` earlier in the
   * chain to use deep equality instead. See the `deep-eql` project page for
   * info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) has property `x: {a: 1}`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * The target's enumerable and non-enumerable properties are always included
   * in the search. By default, both own and inherited properties are included.
   * Add `.own` earlier in the chain to exclude inherited properties from the
   * search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.own.property('a', 1);
   *     expect({a: 1}).to.have.property('b').but.not.own.property('b'); 
   *
   * `.deep` and `.own` can be combined.
   *
   *     expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});
   *
   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
   *
   * `.deep` and `.nested` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}})
   *       .to.have.deep.nested.property('a.b[0]', {c: 3});
   *
   * `.own` and `.nested` cannot be combined.
   *
   * Add `.not` earlier in the chain to negate `.property`.
   *
   *     expect({a: 1}).to.not.have.property('b');
   * 
   * However, it's dangerous to negate `.property` when providing `val`. The
   * problem is that it creates uncertain expectations by asserting that the
   * target either doesn't have a property with the given key `name`, or that it
   * does have a property with the given key `name` but its value isn't equal to
   * the given `val`. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property with the given key
   * `name`, it's often best to assert exactly that.
   *
   *     expect({b: 2}).to.not.have.property('a'); // Recommended
   *     expect({b: 2}).to.not.have.property('a', 1); // Not recommended
   *
   * When the target is expected to have a property with the given key `name`,
   * it's often best to assert that the property has its expected value, rather
   * than asserting that it doesn't have one of many unexpected values.
   *
   *     expect({a: 3}).to.have.property('a', 3); // Recommended
   *     expect({a: 3}).to.not.have.property('a', 1); // Not recommended
   *
   * `.property` changes the target of any assertions that follow in the chain
   * to be the value of the property from the original target object.
   *
   *     expect({a: 1}).to.have.property('a').that.is.a('number');
   *
   * `.property` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing `val`, only use the
   * second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);
   *     expect({a: 1}, 'nooo why fail??').to.have.property('b');
   *
   *     // Not recommended
   *     expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');
   * 
   * The above assertion isn't the same thing as not providing `val`. Instead,
   * it's asserting that the target object has a `b` property that's equal to
   * `undefined`.
   *
   * The assertions `.ownProperty` and `.haveOwnProperty` can be used
   * interchangeably with `.own.property`.
   *
   * @name property
   * @param {String} name
   * @param {Mixed} val (optional)
   * @param {String} msg _optional_
   * @returns value of property for chaining
   * @namespace BDD
   * @api public
   */

  function assertProperty(name, val, msg) {
    if (msg) flag(this, 'message', msg);
    var isNested = flag(this, 'nested'),
        isOwn = flag(this, 'own'),
        flagMsg = flag(this, 'message'),
        obj = flag(this, 'object'),
        ssfi = flag(this, 'ssfi');

    if (isNested && isOwn) {
      flagMsg = flagMsg ? flagMsg + ': ' : '';
      throw new AssertionError(flagMsg + 'The "nested" and "own" flags cannot be combined.', undefined, ssfi);
    }

    if (obj === null || obj === undefined) {
      flagMsg = flagMsg ? flagMsg + ': ' : '';
      throw new AssertionError(flagMsg + 'Target cannot be null or undefined.', undefined, ssfi);
    }

    var isDeep = flag(this, 'deep'),
        negate = flag(this, 'negate'),
        pathInfo = isNested ? _.getPathInfo(obj, name) : null,
        value = isNested ? pathInfo.value : obj[name];
    var descriptor = '';
    if (isDeep) descriptor += 'deep ';
    if (isOwn) descriptor += 'own ';
    if (isNested) descriptor += 'nested ';
    descriptor += 'property ';
    var hasProperty;
    if (isOwn) hasProperty = Object.prototype.hasOwnProperty.call(obj, name);else if (isNested) hasProperty = pathInfo.exists;else hasProperty = _.hasProperty(obj, name); // When performing a negated assertion for both name and val, merely having
    // a property with the given name isn't enough to cause the assertion to
    // fail. It must both have a property with the given name, and the value of
    // that property must equal the given val. Therefore, skip this assertion in
    // favor of the next.

    if (!negate || arguments.length === 1) {
      this.assert(hasProperty, 'expected #{this} to have ' + descriptor + _.inspect(name), 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (arguments.length > 1) {
      this.assert(hasProperty && (isDeep ? _.eql(val, value) : val === value), 'expected #{this} to have ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}', 'expected #{this} to not have ' + descriptor + _.inspect(name) + ' of #{act}', val, value);
    }

    flag(this, 'object', value);
  }

  Assertion.addMethod('property', assertProperty);

  function assertOwnProperty(name, value, msg) {
    flag(this, 'own', true);
    assertProperty.apply(this, arguments);
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);
  /**
   * ### .ownPropertyDescriptor(name[, descriptor[, msg]])
   *
   * Asserts that the target has its own property descriptor with the given key
   * `name`. Enumerable and non-enumerable properties are included in the
   * search.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a');
   *
   * When `descriptor` is provided, `.ownPropertyDescriptor` also asserts that
   * the property's descriptor is deeply equal to the given `descriptor`. See
   * the `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * Add `.not` earlier in the chain to negate `.ownPropertyDescriptor`.
   *
   *     expect({a: 1}).to.not.have.ownPropertyDescriptor('b');
   * 
   * However, it's dangerous to negate `.ownPropertyDescriptor` when providing
   * a `descriptor`. The problem is that it creates uncertain expectations by
   * asserting that the target either doesn't have a property descriptor with
   * the given key `name`, or that it does have a property descriptor with the
   * given key `name` but its not deeply equal to the given `descriptor`. It's
   * often best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property descriptor with the given
   * key `name`, it's often best to assert exactly that.
   *
   *     // Recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a');
   *
   *     // Not recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * When the target is expected to have a property descriptor with the given
   * key `name`, it's often best to assert that the property has its expected
   * descriptor, rather than asserting that it doesn't have one of many
   * unexpected descriptors.
   *
   *     // Recommended
   *     expect({a: 3}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 3,
   *     });
   *
   *     // Not recommended
   *     expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * `.ownPropertyDescriptor` changes the target of any assertions that follow
   * in the chain to be the value of the property descriptor from the original
   * target object.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a')
   *       .that.has.property('enumerable', true);
   *
   * `.ownPropertyDescriptor` accepts an optional `msg` argument which is a
   * custom error message to show when the assertion fails. The message can also
   * be given as the second argument to `expect`. When not providing
   * `descriptor`, only use the second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     }, 'nooo why fail??');
   *
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     });
   * 
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');
   *
   *     // Not recommended
   *     expect({a: 1})
   *       .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');
   *
   * The above assertion isn't the same thing as not providing `descriptor`.
   * Instead, it's asserting that the target object has a `b` property
   * descriptor that's deeply equal to `undefined`.
   *
   * The alias `.haveOwnPropertyDescriptor` can be used interchangeably with
   * `.ownPropertyDescriptor`.
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertOwnPropertyDescriptor(name, descriptor, msg) {
    if (typeof descriptor === 'string') {
      msg = descriptor;
      descriptor = null;
    }

    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);

    if (actualDescriptor && descriptor) {
      this.assert(_.eql(descriptor, actualDescriptor), 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor), 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor), descriptor, actualDescriptor, true);
    } else {
      this.assert(actualDescriptor, 'expected #{this} to have an own property descriptor for ' + _.inspect(name), 'expected #{this} to not have an own property descriptor for ' + _.inspect(name));
    }

    flag(this, 'object', actualDescriptor);
  }

  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);
  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);
  /**
   * ### .lengthOf(n[, msg])
   *
   * Asserts that the target's `length` property is equal to the given number
   * `n`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *     expect('foo').to.have.lengthOf(3);
   *
   * Add `.not` earlier in the chain to negate `.lengthOf`. However, it's often
   * best to assert that the target's `length` property is equal to its expected
   * value, rather than not equal to one of many unexpected values.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.not.have.lengthOf(4); // Not recommended
   *
   * `.lengthOf` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);
   *
   * `.lengthOf` can also be used as a language chain, causing all `.above`,
   * `.below`, `.least`, `.most`, and `.within` assertions that follow in the
   * chain to use the target's `length` property as the target. However, it's
   * often best to assert that the target's `length` property is equal to its
   * expected length, rather than asserting that its `length` property falls
   * within some range of values.
   *
   *     // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *
   *     // Not recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2);
   *     expect([1, 2, 3]).to.have.lengthOf.below(4);
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(3);
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(3);
   *     expect([1, 2, 3]).to.have.lengthOf.within(2,4);
   *
   * Due to a compatibility issue, the alias `.length` can't be chained directly
   * off of an uninvoked method such as `.a`. Therefore, `.length` can't be used
   * interchangeably with `.lengthOf` in every situation. It's recommended to
   * always use `.lengthOf` instead of `.length`.
   *
   *     expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error
   *     expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected
   *
   * @name lengthOf
   * @alias length
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertLengthChain() {
    flag(this, 'doLength', true);
  }

  function assertLength(n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    var len = obj.length;
    this.assert(len == n, 'expected #{this} to have a length of #{exp} but got #{act}', 'expected #{this} to not have a length of #{act}', n, len);
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addChainableMethod('lengthOf', assertLength, assertLengthChain);
  /**
   * ### .match(re[, msg])
   *
   * Asserts that the target matches the given regular expression `re`.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * Add `.not` earlier in the chain to negate `.match`.
   *
   *     expect('foobar').to.not.match(/taco/);
   *
   * `.match` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect('foobar').to.match(/taco/, 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.match(/taco/);
   *
   * The alias `.matches` can be used interchangeably with `.match`.
   *
   * @name match
   * @alias matches
   * @param {RegExp} re
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertMatch(re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(re.exec(obj), 'expected #{this} to match ' + re, 'expected #{this} not to match ' + re);
  }

  Assertion.addMethod('match', assertMatch);
  Assertion.addMethod('matches', assertMatch);
  /**
   * ### .string(str[, msg])
   *
   * Asserts that the target string contains the given substring `str`.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * Add `.not` earlier in the chain to negate `.string`.
   *
   *     expect('foobar').to.not.have.string('taco');
   *
   * `.string` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect('foobar').to.have.string(/taco/, 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.have.string(/taco/);
   *
   * @name string
   * @param {String} str
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).is.a('string');
    this.assert(~obj.indexOf(str), 'expected #{this} to contain ' + _.inspect(str), 'expected #{this} to not contain ' + _.inspect(str));
  });
  /**
   * ### .keys(key1[, key2[, ...]])
   *
   * Asserts that the target object, array, map, or set has the given keys. Only
   * the target's own inherited properties are included in the search. 
   *
   * When the target is an object or array, keys can be provided as one or more
   * string arguments, a single array argument, or a single object argument. In
   * the latter case, only the keys in the given object matter; the values are
   * ignored.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *     expect(['x', 'y']).to.have.all.keys(0, 1);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);
   *     expect(['x', 'y']).to.have.all.keys([0, 1]);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5
   *     expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5
   *
   * When the target is a map or set, each key must be provided as a separate
   * argument.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');
   *     expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');
   *
   * Because `.keys` does different things based on the target's type, it's
   * important to check the target's type before using `.keys`. See the `.a` doc
   * for info on testing a target's type.
   *
   *     expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');
   *
   * By default, strict (`===`) equality is used to compare keys of maps and
   * sets. Add `.deep` earlier in the chain to use deep equality instead. See
   * the `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target set deeply (but not strictly) has key `{a: 1}`
   *     expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);
   *
   * By default, the target must have all of the given keys and no more. Add
   * `.any` earlier in the chain to only require that the target have at least
   * one of the given keys. Also, add `.not` earlier in the chain to negate
   * `.keys`. It's often best to add `.any` when negating `.keys`, and to use
   * `.all` when asserting `.keys` without negation.
   *
   * When negating `.keys`, `.any` is preferred because `.not.any.keys` asserts
   * exactly what's expected of the output, whereas `.not.all.keys` creates
   * uncertain expectations.
   *
   *     // Recommended; asserts that target doesn't have any of the given keys
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   *     // Not recommended; asserts that target doesn't have all of the given
   *     // keys but may or may not have some of them
   *     expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');
   *
   * When asserting `.keys` without negation, `.all` is preferred because
   * `.all.keys` asserts exactly what's expected of the output, whereas
   * `.any.keys` creates uncertain expectations.
   *
   *     // Recommended; asserts that target has all the given keys
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   *     // Not recommended; asserts that target has at least one of the given
   *     // keys but may or may not have more of them
   *     expect({a: 1, b: 2}).to.have.any.keys('a', 'b');
   *
   * Note that `.all` is used by default when neither `.all` nor `.any` appear
   * earlier in the chain. However, it's often best to add `.all` anyway because
   * it improves readability.
   *
   *     // Both assertions are identical
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended
   *     expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended
   *
   * Add `.include` earlier in the chain to require that the target's keys be a
   * superset of the expected keys, rather than identical sets.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   * However, if `.any` and `.include` are combined, only the `.any` takes
   * effect. The `.include` is ignored in this case.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.have.key('b');
   *
   * The alias `.key` can be used interchangeably with `.keys`.
   *
   * @name keys
   * @alias key
   * @param {...String|Array|Object} keys
   * @namespace BDD
   * @api public
   */

  function assertKeys(keys) {
    var obj = flag(this, 'object'),
        objType = _.type(obj),
        keysType = _.type(keys),
        ssfi = flag(this, 'ssfi'),
        isDeep = flag(this, 'deep'),
        str,
        deepStr = '',
        ok = true,
        flagMsg = flag(this, 'message');

    flagMsg = flagMsg ? flagMsg + ': ' : '';
    var mixedArgsMsg = flagMsg + 'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';

    if (objType === 'Map' || objType === 'Set') {
      deepStr = isDeep ? 'deeply ' : '';
      actual = []; // Map and Set '.keys' aren't supported in IE 11. Therefore, use .forEach.

      obj.forEach(function (val, key) {
        actual.push(key);
      });

      if (keysType !== 'Array') {
        keys = Array.prototype.slice.call(arguments);
      }
    } else {
      actual = _.getOwnEnumerableProperties(obj);

      switch (keysType) {
        case 'Array':
          if (arguments.length > 1) {
            throw new AssertionError(mixedArgsMsg, undefined, ssfi);
          }

          break;

        case 'Object':
          if (arguments.length > 1) {
            throw new AssertionError(mixedArgsMsg, undefined, ssfi);
          }

          keys = Object.keys(keys);
          break;

        default:
          keys = Array.prototype.slice.call(arguments);
      } // Only stringify non-Symbols because Symbols would become "Symbol()"


      keys = keys.map(function (val) {
        return typeof val === 'symbol' ? val : String(val);
      });
    }

    if (!keys.length) {
      throw new AssertionError(flagMsg + 'keys required', undefined, ssfi);
    }

    var len = keys.length,
        any = flag(this, 'any'),
        all = flag(this, 'all'),
        expected = keys,
        actual;

    if (!any && !all) {
      all = true;
    } // Has any


    if (any) {
      ok = expected.some(function (expectedKey) {
        return actual.some(function (actualKey) {
          if (isDeep) {
            return _.eql(expectedKey, actualKey);
          } else {
            return expectedKey === actualKey;
          }
        });
      });
    } // Has all


    if (all) {
      ok = expected.every(function (expectedKey) {
        return actual.some(function (actualKey) {
          if (isDeep) {
            return _.eql(expectedKey, actualKey);
          } else {
            return expectedKey === actualKey;
          }
        });
      });

      if (!flag(this, 'contains')) {
        ok = ok && keys.length == actual.length;
      }
    } // Key string


    if (len > 1) {
      keys = keys.map(function (key) {
        return _.inspect(key);
      });
      var last = keys.pop();

      if (all) {
        str = keys.join(', ') + ', and ' + last;
      }

      if (any) {
        str = keys.join(', ') + ', or ' + last;
      }
    } else {
      str = _.inspect(keys[0]);
    } // Form


    str = (len > 1 ? 'keys ' : 'key ') + str; // Have / include

    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str; // Assertion

    this.assert(ok, 'expected #{this} to ' + deepStr + str, 'expected #{this} to not ' + deepStr + str, expected.slice(0).sort(_.compareByInspect), actual.sort(_.compareByInspect), true);
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);
  /**
   * ### .throw([errorLike], [errMsgMatcher], [msg])
   *
   * When no arguments are provided, `.throw` invokes the target function and
   * asserts that an error is thrown.
   * 
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw();
   *
   * When one argument is provided, and it's an error constructor, `.throw`
   * invokes the target function and asserts that an error is thrown that's an
   * instance of that error constructor.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError);
   *
   * When one argument is provided, and it's an error instance, `.throw` invokes
   * the target function and asserts that an error is thrown that's strictly
   * (`===`) equal to that error instance.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(err);
   *
   * When one argument is provided, and it's a string, `.throw` invokes the
   * target function and asserts that an error is thrown with a message that
   * contains that string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw('salmon');
   *
   * When one argument is provided, and it's a regular expression, `.throw`
   * invokes the target function and asserts that an error is thrown with a
   * message that matches that regular expression.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(/salmon/);
   *
   * When two arguments are provided, and the first is an error instance or
   * constructor, and the second is a string or regular expression, `.throw`
   * invokes the function and asserts that an error is thrown that fulfills both
   * conditions as described above.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon');
   *     expect(badFn).to.throw(TypeError, /salmon/);
   *     expect(badFn).to.throw(err, 'salmon');
   *     expect(badFn).to.throw(err, /salmon/);
   *
   * Add `.not` earlier in the chain to negate `.throw`.
   *     
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw();
   * 
   * However, it's dangerous to negate `.throw` when providing any arguments.
   * The problem is that it creates uncertain expectations by asserting that the
   * target either doesn't throw an error, or that it throws an error but of a
   * different type than the given type, or that it throws an error of the given
   * type but with a message that doesn't include the given string. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to throw an error, it's often best to assert
   * exactly that.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw(); // Recommended
   *     expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * When the target is expected to throw an error, it's often best to assert
   * that the error is of its expected type, and has a message that includes an
   * expected string, rather than asserting that it doesn't have one of many
   * unexpected types, and doesn't have a message that includes some string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon'); // Recommended
   *     expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * `.throw` changes the target of any assertions that follow in the chain to
   * be the error object that's thrown.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     err.code = 42;
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError).with.property('code', 42);
   *
   * `.throw` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`. When not providing two arguments, always use
   * the second form.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');
   *     expect(goodFn, 'nooo why fail??').to.throw();
   *
   * Due to limitations in ES5, `.throw` may not always work as expected when
   * using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing the built-in `Error` object and
   * then passing the subclassed constructor to `.throw`. See your transpiler's
   * docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * Beware of some common mistakes when using the `throw` assertion. One common
   * mistake is to accidentally invoke the function yourself instead of letting
   * the `throw` assertion invoke the function for you. For example, when
   * testing if a function named `fn` throws, provide `fn` instead of `fn()` as
   * the target for the assertion.
   *
   *     expect(fn).to.throw();     // Good! Tests `fn` as desired
   *     expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`
   *
   * If you need to assert that your function `fn` throws when passed certain
   * arguments, then wrap a call to `fn` inside of another function.
   *
   *     expect(function () { fn(42); }).to.throw();  // Function expression
   *     expect(() => fn(42)).to.throw();             // ES6 arrow function
   *
   * Another common mistake is to provide an object method (or any stand-alone
   * function that relies on `this`) as the target of the assertion. Doing so is
   * problematic because the `this` context will be lost when the function is
   * invoked by `.throw`; there's no way for it to know what `this` is supposed
   * to be. There are two ways around this problem. One solution is to wrap the
   * method or function call inside of another function. Another solution is to
   * use `bind`.
   *
   *     expect(function () { cat.meow(); }).to.throw();  // Function expression
   *     expect(() => cat.meow()).to.throw();             // ES6 arrow function
   *     expect(cat.meow.bind(cat)).to.throw();           // Bind
   *
   * Finally, it's worth mentioning that it's a best practice in JavaScript to
   * only throw `Error` and derivatives of `Error` such as `ReferenceError`,
   * `TypeError`, and user-defined objects that extend `Error`. No other type of
   * value will generate a stack trace when initialized. With that said, the
   * `throw` assertion does technically support any type of value being thrown,
   * not just `Error` and its derivatives.
   *
   * The aliases `.throws` and `.Throw` can be used interchangeably with
   * `.throw`.
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {Error|ErrorConstructor} errorLike
   * @param {String|RegExp} errMsgMatcher error message
   * @param {String} msg _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @namespace BDD
   * @api public
   */

  function assertThrows(errorLike, errMsgMatcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        ssfi = flag(this, 'ssfi'),
        flagMsg = flag(this, 'message'),
        negate = flag(this, 'negate') || false;
    new Assertion(obj, flagMsg, ssfi, true).is.a('function');

    if (errorLike instanceof RegExp || typeof errorLike === 'string') {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    var caughtErr;

    try {
      obj();
    } catch (err) {
      caughtErr = err;
    } // If we have the negate flag enabled and at least one valid argument it means we do expect an error
    // but we want it to match a given set of criteria


    var everyArgIsUndefined = errorLike === undefined && errMsgMatcher === undefined; // If we've got the negate flag enabled and both args, we should only fail if both aren't compatible
    // See Issue #551 and PR #683@GitHub

    var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
    var errorLikeFail = false;
    var errMsgMatcherFail = false; // Checking if error was thrown

    if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
      // We need this to display results correctly according to their types
      var errorLikeString = 'an error';

      if (errorLike instanceof Error) {
        errorLikeString = '#{exp}';
      } else if (errorLike) {
        errorLikeString = _.checkError.getConstructorName(errorLike);
      }

      this.assert(caughtErr, 'expected #{this} to throw ' + errorLikeString, 'expected #{this} to not throw an error but #{act} was thrown', errorLike && errorLike.toString(), caughtErr instanceof Error ? caughtErr.toString() : typeof caughtErr === 'string' ? caughtErr : caughtErr && _.checkError.getConstructorName(caughtErr));
    }

    if (errorLike && caughtErr) {
      // We should compare instances only if `errorLike` is an instance of `Error`
      if (errorLike instanceof Error) {
        var isCompatibleInstance = _.checkError.compatibleInstance(caughtErr, errorLike);

        if (isCompatibleInstance === negate) {
          // These checks were created to ensure we won't fail too soon when we've got both args and a negate
          // See Issue #551 and PR #683@GitHub
          if (everyArgIsDefined && negate) {
            errorLikeFail = true;
          } else {
            this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr && !negate ? ' but #{act} was thrown' : ''), errorLike.toString(), caughtErr.toString());
          }
        }
      }

      var isCompatibleConstructor = _.checkError.compatibleConstructor(caughtErr, errorLike);

      if (isCompatibleConstructor === negate) {
        if (everyArgIsDefined && negate) {
          errorLikeFail = true;
        } else {
          this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : ''), errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr));
        }
      }
    }

    if (caughtErr && errMsgMatcher !== undefined && errMsgMatcher !== null) {
      // Here we check compatible messages
      var placeholder = 'including';

      if (errMsgMatcher instanceof RegExp) {
        placeholder = 'matching';
      }

      var isCompatibleMessage = _.checkError.compatibleMessage(caughtErr, errMsgMatcher);

      if (isCompatibleMessage === negate) {
        if (everyArgIsDefined && negate) {
          errMsgMatcherFail = true;
        } else {
          this.assert(negate, 'expected #{this} to throw error ' + placeholder + ' #{exp} but got #{act}', 'expected #{this} to throw error not ' + placeholder + ' #{exp}', errMsgMatcher, _.checkError.getMessage(caughtErr));
        }
      }
    } // If both assertions failed and both should've matched we throw an error


    if (errorLikeFail && errMsgMatcherFail) {
      this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : ''), errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr));
    }

    flag(this, 'object', caughtErr);
  }
  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);
  /**
   * ### .respondTo(method[, msg])
   *
   * When the target is a non-function object, `.respondTo` asserts that the
   * target has a method with the given name `method`. The method can be own or
   * inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.respondTo('meow');
   *
   * When the target is a function, `.respondTo` asserts that the target's
   * `prototype` property has a method with the given name `method`. Again, the
   * method can be own or inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(Cat).to.respondTo('meow');
   *
   * Add `.itself` earlier in the chain to force `.respondTo` to treat the
   * target as a non-function object, even if it's a function. Thus, it asserts
   * that the target has a method with the given name `method`, rather than
   * asserting that the target's `prototype` property has a method with the
   * given name `method`.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * When not adding `.itself`, it's important to check the target's type before
   * using `.respondTo`. See the `.a` doc for info on checking a target's type.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.be.an('object').that.respondsTo('meow');
   *
   * Add `.not` earlier in the chain to negate `.respondTo`.
   *
   *     function Dog () {}
   *     Dog.prototype.bark = function () {};
   *
   *     expect(new Dog()).to.not.respondTo('meow');
   *
   * `.respondTo` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect({}).to.respondTo('meow', 'nooo why fail??');
   *     expect({}, 'nooo why fail??').to.respondTo('meow');
   *
   * The alias `.respondsTo` can be used interchangeably with `.respondTo`.
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function respondTo(method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        itself = flag(this, 'itself'),
        context = 'function' === typeof obj && !itself ? obj.prototype[method] : obj[method];
    this.assert('function' === typeof context, 'expected #{this} to respond to ' + _.inspect(method), 'expected #{this} to not respond to ' + _.inspect(method));
  }

  Assertion.addMethod('respondTo', respondTo);
  Assertion.addMethod('respondsTo', respondTo);
  /**
   * ### .itself
   *
   * Forces all `.respondTo` assertions that follow in the chain to behave as if
   * the target is a non-function object, even if it's a function. Thus, it
   * causes `.respondTo` to assert that the target has a method with the given
   * name, rather than asserting that the target's `prototype` property has a
   * method with the given name.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * @name itself
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });
  /**
   * ### .satisfy(matcher[, msg])
   *
   * Invokes the given `matcher` function with the target being passed as the
   * first argument, and asserts that the value returned is truthy.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 0; 
   *     });
   *
   * Add `.not` earlier in the chain to negate `.satisfy`.
   *
   *     expect(1).to.not.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * `.satisfy` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 2;
   *     }, 'nooo why fail??');
   *
   *     expect(1, 'nooo why fail??').to.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * The alias `.satisfies` can be used interchangeably with `.satisfy`.
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function satisfy(matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var result = matcher(obj);
    this.assert(result, 'expected #{this} to satisfy ' + _.objDisplay(matcher), 'expected #{this} to not satisfy' + _.objDisplay(matcher), flag(this, 'negate') ? false : true, result);
  }

  Assertion.addMethod('satisfy', satisfy);
  Assertion.addMethod('satisfies', satisfy);
  /**
   * ### .closeTo(expected, delta[, msg])
   *
   * Asserts that the target is a number that's within a given +/- `delta` range
   * of the given number `expected`. However, it's often best to assert that the
   * target is equal to its expected value.
   *
   *     // Recommended
   *     expect(1.5).to.equal(1.5);
   *
   *     // Not recommended
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *     expect(1.5).to.be.closeTo(2, 0.5);
   *     expect(1.5).to.be.closeTo(1, 1);
   *
   * Add `.not` earlier in the chain to negate `.closeTo`.
   *
   *     expect(1.5).to.equal(1.5); // Recommended
   *     expect(1.5).to.not.be.closeTo(3, 1); // Not recommended
   *
   * `.closeTo` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');
   *     expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);
   *
   * The alias `.approximately` can be used interchangeably with `.closeTo`.
   *
   * @name closeTo
   * @alias approximately
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function closeTo(expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).is.a('number');

    if (typeof expected !== 'number' || typeof delta !== 'number') {
      flagMsg = flagMsg ? flagMsg + ': ' : '';
      throw new AssertionError(flagMsg + 'the arguments to closeTo or approximately must be numbers', undefined, ssfi);
    }

    this.assert(Math.abs(obj - expected) <= delta, 'expected #{this} to be close to ' + expected + ' +/- ' + delta, 'expected #{this} not to be close to ' + expected + ' +/- ' + delta);
  }

  Assertion.addMethod('closeTo', closeTo);
  Assertion.addMethod('approximately', closeTo); // Note: Duplicates are ignored if testing for inclusion instead of sameness.

  function isSubsetOf(subset, superset, cmp, contains, ordered) {
    if (!contains) {
      if (subset.length !== superset.length) return false;
      superset = superset.slice();
    }

    return subset.every(function (elem, idx) {
      if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];

      if (!cmp) {
        var matchIdx = superset.indexOf(elem);
        if (matchIdx === -1) return false; // Remove match from superset so not counted twice if duplicate in subset.

        if (!contains) superset.splice(matchIdx, 1);
        return true;
      }

      return superset.some(function (elem2, matchIdx) {
        if (!cmp(elem, elem2)) return false; // Remove match from superset so not counted twice if duplicate in subset.

        if (!contains) superset.splice(matchIdx, 1);
        return true;
      });
    });
  }
  /**
   * ### .members(set[, msg])
   *
   * Asserts that the target array has the same members as the given array
   * `set`.
   *
   *     expect([1, 2, 3]).to.have.members([2, 1, 3]);
   *     expect([1, 2, 2]).to.have.members([2, 1, 2]);
   *
   * By default, members are compared using strict (`===`) equality. Add `.deep`
   * earlier in the chain to use deep equality instead. See the `deep-eql`
   * project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) has member `{a: 1}`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   * By default, order doesn't matter. Add `.ordered` earlier in the chain to
   * require that members appear in the same order.
   *
   *     expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);
   *     expect([1, 2, 3]).to.have.members([2, 1, 3])
   *       .but.not.ordered.members([2, 1, 3]);
   *
   * By default, both arrays must be the same size. Add `.include` earlier in
   * the chain to require that the target's members be a superset of the
   * expected members. Note that duplicates are ignored in the subset when
   * `.include` is added.
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * `.deep`, `.ordered`, and `.include` can all be combined. However, if
   * `.include` and `.ordered` are combined, the ordering begins at the start of
   * both arrays.
   *
   *     expect([{a: 1}, {b: 2}, {c: 3}])
   *       .to.include.deep.ordered.members([{a: 1}, {b: 2}])
   *       .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);
   *
   * Add `.not` earlier in the chain to negate `.members`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the target array doesn't have all of the same members as
   * the given array `set` but may or may not have some of them. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended
   *     expect([1, 2]).to.not.have.members([3, 4]); // Not recommended
   *
   * `.members` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');
   *     expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);
   *
   * @name members
   * @param {Array} set
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */


  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).to.be.an('array');
    new Assertion(subset, flagMsg, ssfi, true).to.be.an('array');
    var contains = flag(this, 'contains');
    var ordered = flag(this, 'ordered');
    var subject, failMsg, failNegateMsg;

    if (contains) {
      subject = ordered ? 'an ordered superset' : 'a superset';
      failMsg = 'expected #{this} to be ' + subject + ' of #{exp}';
      failNegateMsg = 'expected #{this} to not be ' + subject + ' of #{exp}';
    } else {
      subject = ordered ? 'ordered members' : 'members';
      failMsg = 'expected #{this} to have the same ' + subject + ' as #{exp}';
      failNegateMsg = 'expected #{this} to not have the same ' + subject + ' as #{exp}';
    }

    var cmp = flag(this, 'deep') ? _.eql : undefined;
    this.assert(isSubsetOf(subset, obj, cmp, contains, ordered), failMsg, failNegateMsg, subset, obj, true);
  });
  /**
   * ### .oneOf(list[, msg])
   *
   * Asserts that the target is a member of the given array `list`. However,
   * it's often best to assert that the target is equal to its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.oneOf([1, 2, 3]); // Not recommended
   *
   * Comparisons are performed using strict (`===`) equality.
   *
   * Add `.not` earlier in the chain to negate `.oneOf`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended
   *
   * `.oneOf` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);
   *
   * @name oneOf
   * @param {Array<*>} list
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function oneOf(list, msg) {
    if (msg) flag(this, 'message', msg);
    var expected = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(list, flagMsg, ssfi, true).to.be.an('array');
    this.assert(list.indexOf(expected) > -1, 'expected #{this} to be one of #{exp}', 'expected #{this} to not be one of #{exp}', list, expected);
  }

  Assertion.addMethod('oneOf', oneOf);
  /**
   * ### .change(subject[, prop[, msg]])
   *
   * When one argument is provided, `.change` asserts that the given function
   * `subject` returns a different value when it's invoked before the target
   * function compared to when it's invoked afterward. However, it's often best
   * to assert that `subject` is equal to its expected value.
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     // Recommended
   *     expect(getDots()).to.equal('');
   *     addDot();
   *     expect(getDots()).to.equal('.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(getDots);
   *
   * When two arguments are provided, `.change` asserts that the value of the
   * given object `subject`'s `prop` property is different before invoking the
   * target function compared to afterward.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     // Recommended
   *     expect(myObj).to.have.property('dots', '');
   *     addDot();
   *     expect(myObj).to.have.property('dots', '.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(myObj, 'dots');
   *
   * Strict (`===`) equality is used to compare before and after values.
   *
   * Add `.not` earlier in the chain to negate `.change`.
   *
   *     var dots = ''
   *       , noop = function () {}
   *       , getDots = function () { return dots; };
   *
   *     expect(noop).to.not.change(getDots);
   *
   *     var myObj = {dots: ''}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'dots');
   *
   * `.change` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     expect(addDot, 'nooo why fail??').to.not.change(getDots);
   *
   * `.change` also causes all `.by` assertions that follow in the chain to
   * assert how much a numeric subject was increased or decreased by. However,
   * it's dangerous to use `.change.by`. The problem is that it creates
   * uncertain expectations by asserting that the subject either increases by
   * the given delta, or that it decreases by the given delta. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * The alias `.changes` can be used interchangeably with `.change`.
   *
   * @name change
   * @alias changes
   * @param {String} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertChanges(subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');
    var initial;

    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    }

    fn();
    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop; // This gets flagged because of the .by(delta) assertion

    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'change');
    flag(this, 'realDelta', final !== initial);
    this.assert(initial !== final, 'expected ' + msgObj + ' to change', 'expected ' + msgObj + ' to not change');
  }

  Assertion.addMethod('change', assertChanges);
  Assertion.addMethod('changes', assertChanges);
  /**
   * ### .increase(subject[, prop[, msg]])
   *
   * When one argument is provided, `.increase` asserts that the given function
   * `subject` returns a greater number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. `.increase` also
   * causes all `.by` assertions that follow in the chain to assert how much
   * greater of a number is returned. It's often best to assert that the return
   * value increased by the expected amount, rather than asserting it increased
   * by any amount.
   *
   *     var val = 1
   *       , addTwo = function () { val += 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(addTwo).to.increase(getVal).by(2); // Recommended
   *     expect(addTwo).to.increase(getVal); // Not recommended
   *
   * When two arguments are provided, `.increase` asserts that the value of the
   * given object `subject`'s `prop` property is greater after invoking the
   * target function compared to beforehand.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.increase(myObj, 'val'); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.increase`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either decreases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to decrease, it's often best to assert that it
   * decreased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended
   * 
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.increase(myObj, 'val'); // Not recommended
   *
   * `.increase` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.increase(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.increase(getVal);
   *
   * The alias `.increases` can be used interchangeably with `.increase`.
   *
   * @name increase
   * @alias increases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertIncreases(subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');
    var initial;

    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    } // Make sure that the target is a number


    new Assertion(initial, flagMsg, ssfi, true).is.a('number');
    fn();
    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;
    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'increase');
    flag(this, 'realDelta', final - initial);
    this.assert(final - initial > 0, 'expected ' + msgObj + ' to increase', 'expected ' + msgObj + ' to not increase');
  }

  Assertion.addMethod('increase', assertIncreases);
  Assertion.addMethod('increases', assertIncreases);
  /**
   * ### .decrease(subject[, prop[, msg]])
   *
   * When one argument is provided, `.decrease` asserts that the given function
   * `subject` returns a lesser number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. `.decrease` also
   * causes all `.by` assertions that follow in the chain to assert how much
   * lesser of a number is returned. It's often best to assert that the return
   * value decreased by the expected amount, rather than asserting it decreased
   * by any amount.
   *
   *     var val = 1
   *       , subtractTwo = function () { val -= 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(subtractTwo).to.decrease(getVal).by(2); // Recommended
   *     expect(subtractTwo).to.decrease(getVal); // Not recommended
   *
   * When two arguments are provided, `.decrease` asserts that the value of the
   * given object `subject`'s `prop` property is lesser after invoking the
   * target function compared to beforehand. 
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.decrease`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either increases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to increase, it's often best to assert that it
   * increased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended
   * 
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.decrease(myObj, 'val'); // Not recommended
   *
   * `.decrease` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.decrease(getVal);
   *
   * The alias `.decreases` can be used interchangeably with `.decrease`.
   *
   * @name decrease
   * @alias decreases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertDecreases(subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');
    var initial;

    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    } // Make sure that the target is a number


    new Assertion(initial, flagMsg, ssfi, true).is.a('number');
    fn();
    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;
    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'decrease');
    flag(this, 'realDelta', initial - final);
    this.assert(final - initial < 0, 'expected ' + msgObj + ' to decrease', 'expected ' + msgObj + ' to not decrease');
  }

  Assertion.addMethod('decrease', assertDecreases);
  Assertion.addMethod('decreases', assertDecreases);
  /**
   * ### .by(delta[, msg])
   *
   * When following an `.increase` assertion in the chain, `.by` asserts that
   * the subject of the `.increase` assertion increased by the given `delta`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   * When following a `.decrease` assertion in the chain, `.by` asserts that the
   * subject of the `.decrease` assertion decreased by the given `delta`.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2);
   *
   * When following a `.change` assertion in the chain, `.by` asserts that the
   * subject of the `.change` assertion either increased or decreased by the
   * given `delta`. However, it's dangerous to use `.change.by`. The problem is
   * that it creates uncertain expectations. It's often best to identify the
   * exact output that's expected, and then write an assertion that only accepts
   * that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.by`. However, it's often best
   * to assert that the subject changed by its expected delta, rather than
   * asserting that it didn't change by one of countless unexpected deltas.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     // Recommended
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   *     // Not recommended
   *     expect(addTwo).to.increase(myObj, 'val').but.not.by(3);
   *
   * `.by` accepts an optional `msg` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to `expect`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');
   *     expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);
   *
   * @name by
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertDelta(delta, msg) {
    if (msg) flag(this, 'message', msg);
    var msgObj = flag(this, 'deltaMsgObj');
    var initial = flag(this, 'initialDeltaValue');
    var final = flag(this, 'finalDeltaValue');
    var behavior = flag(this, 'deltaBehavior');
    var realDelta = flag(this, 'realDelta');
    var expression;

    if (behavior === 'change') {
      expression = Math.abs(final - initial) === Math.abs(delta);
    } else {
      expression = realDelta === Math.abs(delta);
    }

    this.assert(expression, 'expected ' + msgObj + ' to ' + behavior + ' by ' + delta, 'expected ' + msgObj + ' to not ' + behavior + ' by ' + delta);
  }

  Assertion.addMethod('by', assertDelta);
  /**
   * ### .extensible
   *
   * Asserts that the target is extensible, which means that new properties can
   * be added to it. Primitives are never extensible.
   *
   *     expect({a: 1}).to.be.extensible;
   *
   * Add `.not` earlier in the chain to negate `.extensible`.
   *
   *     var nonExtensibleObject = Object.preventExtensions({})
   *       , sealedObject = Object.seal({})
   *       , frozenObject = Object.freeze({});
   *
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *     expect(1).to.not.be.extensible;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(1, 'nooo why fail??').to.be.extensible;
   *
   * @name extensible
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('extensible', function () {
    var obj = flag(this, 'object'); // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
    // The following provides ES6 behavior for ES5 environments.

    var isExtensible = obj === Object(obj) && Object.isExtensible(obj);
    this.assert(isExtensible, 'expected #{this} to be extensible', 'expected #{this} to not be extensible');
  });
  /**
   * ### .sealed
   *
   * Asserts that the target is sealed, which means that new properties can't be
   * added to it, and its existing properties can't be reconfigured or deleted.
   * However, it's possible that its existing properties can still be reassigned
   * to different values. Primitives are always sealed.
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect(1).to.be.sealed;
   *
   * Add `.not` earlier in the chain to negate `.sealed`.
   *
   *     expect({a: 1}).to.not.be.sealed;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.sealed;
   *
   * @name sealed
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('sealed', function () {
    var obj = flag(this, 'object'); // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
    // The following provides ES6 behavior for ES5 environments.

    var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;
    this.assert(isSealed, 'expected #{this} to be sealed', 'expected #{this} to not be sealed');
  });
  /**
   * ### .frozen
   *
   * Asserts that the target is frozen, which means that new properties can't be
   * added to it, and its existing properties can't be reassigned to different
   * values, reconfigured, or deleted. Primitives are always frozen.
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect(1).to.be.frozen;
   *
   * Add `.not` earlier in the chain to negate `.frozen`.
   *
   *     expect({a: 1}).to.not.be.frozen;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.frozen;
   *
   * @name frozen
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('frozen', function () {
    var obj = flag(this, 'object'); // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
    // The following provides ES6 behavior for ES5 environments.

    var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;
    this.assert(isFrozen, 'expected #{this} to be frozen', 'expected #{this} to not be frozen');
  });
  /**
   * ### .finite
   *
   * Asserts that the target is a number, and isn't `NaN` or positive/negative
   * `Infinity`.
   *
   *     expect(1).to.be.finite;
   *
   * Add `.not` earlier in the chain to negate `.finite`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either isn't a number, or that it's `NaN`, or
   * that it's positive `Infinity`, or that it's negative `Infinity`. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to be a number, it's often best to assert
   * that it's the expected type, rather than asserting that it isn't one of
   * many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.finite; // Not recommended
   *
   * When the target is expected to be `NaN`, it's often best to assert exactly
   * that.
   *
   *     expect(NaN).to.be.NaN; // Recommended
   *     expect(NaN).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be positive infinity, it's often best to
   * assert exactly that.
   *
   *     expect(Infinity).to.equal(Infinity); // Recommended
   *     expect(Infinity).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be negative infinity, it's often best to
   * assert exactly that.
   *
   *     expect(-Infinity).to.equal(-Infinity); // Recommended
   *     expect(-Infinity).to.not.be.finite; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect('foo', 'nooo why fail??').to.be.finite;
   *
   * @name finite
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('finite', function (msg) {
    var obj = flag(this, 'object');
    this.assert(typeof obj === "number" && isFinite(obj), 'expected #{this} to be a finite number', 'expected #{this} to not be a finite number');
  });
};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var expect = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };
  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace BDD
   * @api public
   */


  chai.expect.fail = function (actual, expected, message, operator) {
    message = message || 'expect.fail()';
    throw new chai.AssertionError(message, {
      actual: actual,
      expected: expected,
      operator: operator
    }, chai.expect.fail);
  };
};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var should = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould() {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol === 'function' && this instanceof Symbol) {
        return new Assertion(this.valueOf(), null, shouldGetter);
      }

      return new Assertion(this, null, shouldGetter);
    }

    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } // modify Object.prototype to have `should`


    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter,
      get: shouldGetter,
      configurable: true
    });
    var should = {};
    /**
     * ### .fail(actual, expected, [message], [operator])
     *
     * Throw a failure.
     *
     * @name fail
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @param {String} operator
     * @namespace BDD
     * @api public
     */

    should.fail = function (actual, expected, message, operator) {
      message = message || 'should.fail()';
      throw new chai.AssertionError(message, {
        actual: actual,
        expected: expected,
        operator: operator
      }, should.fail);
    };
    /**
     * ### .equal(actual, expected, [message])
     *
     * Asserts non-strict equality (`==`) of `actual` and `expected`.
     *
     *     should.equal(3, '3', '== coerces values to strings');
     *
     * @name equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */


    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };
    /**
     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])
     *
     * Asserts that `function` will throw an error that is an instance of
     * `constructor`, or alternately that it will throw an error with message
     * matching `regexp`.
     *
     *     should.throw(fn, 'function throws a reference error');
     *     should.throw(fn, /function throws a reference error/);
     *     should.throw(fn, ReferenceError);
     *     should.throw(fn, ReferenceError, 'function throws a reference error');
     *     should.throw(fn, ReferenceError, /function throws a reference error/);
     *
     * @name throw
     * @alias Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */


    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };
    /**
     * ### .exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var foo = 'hi';
     *
     *     should.exist(foo, 'foo exists');
     *
     * @name exist
     * @namespace Should
     * @api public
     */


    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }; // negation


    should.not = {};
    /**
     * ### .not.equal(actual, expected, [message])
     *
     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
     *
     *     should.not.equal(3, 4, 'these numbers are not equal');
     *
     * @name not.equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };
    /**
     * ### .throw(function, [constructor/regexp], [message])
     *
     * Asserts that `function` will _not_ throw an error that is an instance of
     * `constructor`, or alternately that it will not throw an error with message
     * matching `regexp`.
     *
     *     should.not.throw(fn, Error, 'function does not throw');
     *
     * @name not.throw
     * @alias not.Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */


    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };
    /**
     * ### .not.exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var bar = null;
     *
     *     should.not.exist(bar, 'bar does not exist');
     *
     * @name not.exist
     * @namespace Should
     * @api public
     */


    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    };

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];
    return should;
  }
  chai.should = loadShould;
  chai.Should = loadShould;
};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var assert = function (chai, util) {
  /*!
   * Chai dependencies.
   */
  var Assertion = chai.Assertion,
      flag = util.flag;
  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @namespace Assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert, true);
    test.assert(express, errmsg, '[ negation message unavailable ]');
  };
  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Assert
   * @api public
   */


  assert.fail = function (actual, expected, message, operator) {
    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
      actual: actual,
      expected: expected,
      operator: operator
    }, assert.fail);
  };
  /**
   * ### .isOk(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.isOk('everything', 'everything is ok');
   *     assert.isOk(false, 'this will fail');
   *
   * @name isOk
   * @alias ok
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isOk = function (val, msg) {
    new Assertion(val, msg, assert.isOk, true).is.ok;
  };
  /**
   * ### .isNotOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.isNotOk('everything', 'this will fail');
   *     assert.isNotOk(false, 'this will pass');
   *
   * @name isNotOk
   * @alias notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotOk = function (val, msg) {
    new Assertion(val, msg, assert.isNotOk, true).is.not.ok;
  };
  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal, true);
    test.assert(exp == flag(test, 'object'), 'expected #{this} to equal #{exp}', 'expected #{this} to not equal #{act}', exp, act, true);
  };
  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual, true);
    test.assert(exp != flag(test, 'object'), 'expected #{this} to not equal #{exp}', 'expected #{this} to equal #{act}', exp, act, true);
  };
  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);
  };
  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);
  };
  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @alias deepStrictEqual
   * @namespace Assert
   * @api public
   */


  assert.deepEqual = assert.deepStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);
  };
  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);
  };
  /**
  * ### .isAbove(valueToCheck, valueToBeAbove, [message])
  *
  * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`.
  *
  *     assert.isAbove(5, 2, '5 is strictly greater than 2');
  *
  * @name isAbove
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAbove
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isAbove = function (val, abv, msg) {
    new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);
  };
  /**
  * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
  *
  * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`.
  *
  *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');
  *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');
  *
  * @name isAtLeast
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAtLeast
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isAtLeast = function (val, atlst, msg) {
    new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);
  };
  /**
  * ### .isBelow(valueToCheck, valueToBeBelow, [message])
  *
  * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`.
  *
  *     assert.isBelow(3, 6, '3 is strictly less than 6');
  *
  * @name isBelow
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeBelow
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isBelow = function (val, blw, msg) {
    new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);
  };
  /**
  * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
  *
  * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`.
  *
  *     assert.isAtMost(3, 6, '3 is less than or equal to 6');
  *     assert.isAtMost(4, 4, '4 is less than or equal to 4');
  *
  * @name isAtMost
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAtMost
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isAtMost = function (val, atmst, msg) {
    new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);
  };
  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isTrue = function (val, msg) {
    new Assertion(val, msg, assert.isTrue, true).is['true'];
  };
  /**
   * ### .isNotTrue(value, [message])
   *
   * Asserts that `value` is not true.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotTrue(tea, 'great, time for tea!');
   *
   * @name isNotTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotTrue = function (val, msg) {
    new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);
  };
  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isFalse = function (val, msg) {
    new Assertion(val, msg, assert.isFalse, true).is['false'];
  };
  /**
   * ### .isNotFalse(value, [message])
   *
   * Asserts that `value` is not false.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotFalse(tea, 'great, time for tea!');
   *
   * @name isNotFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotFalse = function (val, msg) {
    new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);
  };
  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNull = function (val, msg) {
    new Assertion(val, msg, assert.isNull, true).to.equal(null);
  };
  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);
  };
  /**
   * ### .isNaN
   *
   * Asserts that value is NaN.
   *
   *     assert.isNaN(NaN, 'NaN is NaN');
   *
   * @name isNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNaN = function (val, msg) {
    new Assertion(val, msg, assert.isNaN, true).to.be.NaN;
  };
  /**
   * ### .isNotNaN
   *
   * Asserts that value is not NaN.
   *
   *     assert.isNotNaN(4, '4 is not NaN');
   *
   * @name isNotNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotNaN = function (val, msg) {
    new Assertion(val, msg, assert.isNotNaN, true).not.to.be.NaN;
  };
  /**
   * ### .exists
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi';
   *
   *     assert.exists(foo, 'foo is neither `null` nor `undefined`');
   *
   * @name exists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.exists = function (val, msg) {
    new Assertion(val, msg, assert.exists, true).to.exist;
  };
  /**
   * ### .notExists
   *
   * Asserts that the target is either `null` or `undefined`.
   *
   *     var bar = null
   *       , baz;
   *
   *     assert.notExists(bar);
   *     assert.notExists(baz, 'baz is either null or undefined');
   *
   * @name notExists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notExists = function (val, msg) {
    new Assertion(val, msg, assert.notExists, true).to.not.exist;
  };
  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg, assert.isUndefined, true).to.equal(undefined);
  };
  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isDefined = function (val, msg) {
    new Assertion(val, msg, assert.isDefined, true).to.not.equal(undefined);
  };
  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isFunction = function (val, msg) {
    new Assertion(val, msg, assert.isFunction, true).to.be.a('function');
  };
  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg, assert.isNotFunction, true).to.not.be.a('function');
  };
  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).
   * _The assertion does not match subclassed objects._
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isObject = function (val, msg) {
    new Assertion(val, msg, assert.isObject, true).to.be.a('object');
  };
  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg, assert.isNotObject, true).to.not.be.a('object');
  };
  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isArray = function (val, msg) {
    new Assertion(val, msg, assert.isArray, true).to.be.an('array');
  };
  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg, assert.isNotArray, true).to.not.be.an('array');
  };
  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isString = function (val, msg) {
    new Assertion(val, msg, assert.isString, true).to.be.a('string');
  };
  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotString = function (val, msg) {
    new Assertion(val, msg, assert.isNotString, true).to.not.be.a('string');
  };
  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNumber = function (val, msg) {
    new Assertion(val, msg, assert.isNumber, true).to.be.a('number');
  };
  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a('number');
  };
  /**
  * ### .isFinite(value, [message])
  *
  * Asserts that `value` is a finite number. Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.
  *
  *     var cups = 2;
  *     assert.isFinite(cups, 'how many cups');
  *
  *     assert.isFinite(NaN); // throws
  *
  * @name isFinite
  * @param {Number} value
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isFinite = function (val, msg) {
    new Assertion(val, msg, assert.isFinite, true).to.be.finite;
  };
  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg, assert.isBoolean, true).to.be.a('boolean');
  };
  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a('boolean');
  };
  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg, assert.typeOf, true).to.be.a(type);
  };
  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg, assert.notTypeOf, true).to.not.be.a(type);
  };
  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type);
  };
  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg, assert.notInstanceOf, true).to.not.be.instanceOf(type);
  };
  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Can be used to assert the
   * inclusion of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.include([1,2,3], 2, 'array contains value');
   *     assert.include('foobar', 'foo', 'string contains substring');
   *     assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');
   *
   * Strict equality (===) is used. When asserting the inclusion of a value in
   * an array, the array is searched for an element that's strictly equal to the
   * given value. When asserting a subset of properties in an object, the object
   * is searched for the given property keys, checking that each one is present
   * and stricty equal to the given property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.include([obj1, obj2], obj1);
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1});
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include, true).include(inc);
  };
  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Can be used to assert
   * the absence of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.notInclude([1,2,3], 4, 'array doesn't contain value');
   *     assert.notInclude('foobar', 'baz', 'string doesn't contain substring');
   *     assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');
   *
   * Strict equality (===) is used. When asserting the absence of a value in an
   * array, the array is searched to confirm the absence of an element that's
   * strictly equal to the given value. When asserting a subset of properties in
   * an object, the object is searched to confirm that at least one of the given
   * property keys is either not present or not strictly equal to the given
   * property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notInclude([obj1, obj2], {a: 1});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude, true).not.include(inc);
  };
  /**
   * ### .deepInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Can be used to assert the
   * inclusion of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.deepInclude([obj1, obj2], {a: 1});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});
   *
   * @name deepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);
  };
  /**
   * ### .notDeepInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Can be used to assert
   * the absence of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notDeepInclude([obj1, obj2], {a: 9});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});
   *
   * @name notDeepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);
  };
  /**
   * ### .nestedInclude(haystack, needle, [message])
   * 
   * Asserts that 'haystack' includes 'needle'. 
   * Can be used to assert the inclusion of a subset of properties in an 
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested 
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   * 
   *     assert.nestedInclude({'.a': {'b': 'x'}}, {'\\.a.[b]': 'x'});
   *     assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'x'});
   * 
   * @name nestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public 
   */


  assert.nestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);
  };
  /**
   * ### .notNestedInclude(haystack, needle, [message])
   * 
   * Asserts that 'haystack' does not include 'needle'. 
   * Can be used to assert the absence of a subset of properties in an 
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested 
   * properties. 
   * '[]' and '.' in property names can be escaped using double backslashes.
   * 
   *     assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\.a.b': 'y'});
   *     assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'y'});
   * 
   * @name notNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public 
   */


  assert.notNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notNestedInclude, true).not.nested.include(inc);
  };
  /**
   * ### .deepNestedInclude(haystack, needle, [message])
   * 
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an 
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested 
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   * 
   *     assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});
   *     assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {x: 1}});
   *    
   * @name deepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public 
   */


  assert.deepNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepNestedInclude, true).deep.nested.include(inc);
  };
  /**
   * ### .notDeepNestedInclude(haystack, needle, [message])
   * 
   * Asserts that 'haystack' does not include 'needle'.
   * Can be used to assert the absence of a subset of properties in an 
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested 
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   * 
   *     assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})
   *     assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {y: 2}});
   *    
   * @name notDeepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public 
   */


  assert.notDeepNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepNestedInclude, true).not.deep.nested.include(inc);
  };
  /**
   * ### .ownInclude(haystack, needle, [message])
   * 
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an 
   * object while ignoring inherited properties.
   * 
   *     assert.ownInclude({ a: 1 }, { a: 1 });
   * 
   * @name ownInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.ownInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);
  };
  /**
   * ### .notOwnInclude(haystack, needle, [message])
   * 
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the absence of a subset of properties in an 
   * object while ignoring inherited properties.
   * 
   *     Object.prototype.b = 2;
   * 
   *     assert.notOwnInclude({ a: 1 }, { b: 2 });
   * 
   * @name notOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notOwnInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);
  };
  /**
   * ### .deepOwnInclude(haystack, needle, [message])
   * 
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an 
   * object while ignoring inherited properties and checking for deep equality.
   * 
   *      assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});
   *      
   * @name deepOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepOwnInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepOwnInclude, true).deep.own.include(inc);
  };
  /**
  * ### .notDeepOwnInclude(haystack, needle, [message])
  * 
  * Asserts that 'haystack' includes 'needle'.
  * Can be used to assert the absence of a subset of properties in an 
  * object while ignoring inherited properties and checking for deep equality.
  * 
  *      assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});
  *      
  * @name notDeepOwnInclude
  * @param {Object} haystack
  * @param {Object} needle
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.notDeepOwnInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepOwnInclude, true).not.deep.own.include(inc);
  };
  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg, assert.match, true).to.match(re);
  };
  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg, assert.notMatch, true).to.not.match(re);
  };
  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *     assert.property({ tea: { green: 'matcha' }}, 'toString');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.property, true).to.have.property(prop);
  };
  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notProperty, true).to.not.have.property(prop);
  };
  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property` with a value given by `value`. Uses a strict equality check
   * (===).
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.propertyVal, true).to.have.property(prop, val);
  };
  /**
   * ### .notPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property` with value given by `value`. Uses a strict equality check
   * (===).
   *
   *     assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');
   *     assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');
   *
   * @name notPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notPropertyVal, true).to.not.have.property(prop, val);
  };
  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property` with a value given by `value`. Uses a deep equality check.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.deepPropertyVal, true).to.have.deep.property(prop, val);
  };
  /**
   * ### .notDeepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property` with value given by `value`. Uses a deep equality check.
   *
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *
   * @name notDeepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notDeepPropertyVal, true).to.not.have.deep.property(prop, val);
  };
  /**
   * ### .ownProperty(object, property, [message])
   *
   * Asserts that `object` has a direct property named by `property`. Inherited
   * properties aren't checked.
   *
   *     assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name ownProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */


  assert.ownProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.ownProperty, true).to.have.own.property(prop);
  };
  /**
   * ### .notOwnProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by
   * `property`. Inherited properties aren't checked.
   *
   *     assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');
   *     assert.notOwnProperty({}, 'toString');
   *
   * @name notOwnProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */


  assert.notOwnProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notOwnProperty, true).to.not.have.own.property(prop);
  };
  /**
   * ### .ownPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct property named by `property` and a value
   * equal to the provided `value`. Uses a strict equality check (===).
   * Inherited properties aren't checked.
   *
   *     assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');
   *
   * @name ownPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.ownPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.ownPropertyVal, true).to.have.own.property(prop, value);
  };
  /**
   * ### .notOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by `property`
   * with a value equal to the provided `value`. Uses a strict equality check
   * (===). Inherited properties aren't checked.
   *
   *     assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');
   *     assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.notOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.notOwnPropertyVal, true).to.not.have.own.property(prop, value);
  };
  /**
   * ### .deepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct property named by `property` and a value
   * equal to the provided `value`. Uses a deep equality check. Inherited
   * properties aren't checked.
   *
   *     assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.deepOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.deepOwnPropertyVal, true).to.have.deep.own.property(prop, value);
  };
  /**
   * ### .notDeepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by `property`
   * with a value equal to the provided `value`. Uses a deep equality check.
   * Inherited properties aren't checked.
   *
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *     assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notDeepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.notDeepOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.notDeepOwnPropertyVal, true).to.not.have.deep.own.property(prop, value);
  };
  /**
   * ### .nestedProperty(object, property, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property`, which can be a string using dot- and bracket-notation for
   * nested reference.
   *
   *     assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name nestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.nestedProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.nestedProperty, true).to.have.nested.property(prop);
  };
  /**
   * ### .notNestedProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for nested reference. The
   * property cannot exist on the object nor anywhere in its prototype chain.
   *
   *     assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notNestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notNestedProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notNestedProperty, true).to.not.have.nested.property(prop);
  };
  /**
   * ### .nestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for nested
   * reference. Uses a strict equality check (===).
   *
   *     assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name nestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.nestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.nestedPropertyVal, true).to.have.nested.property(prop, val);
  };
  /**
   * ### .notNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property` with
   * value given by `value`. `property` can use dot- and bracket-notation for
   * nested reference. Uses a strict equality check (===).
   *
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');
   *
   * @name notNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notNestedPropertyVal, true).to.not.have.nested.property(prop, val);
  };
  /**
   * ### .deepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with a value given
   * by `value`. `property` can use dot- and bracket-notation for nested
   * reference. Uses a deep equality check.
   *
   *     assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });
   *
   * @name deepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.deepNestedPropertyVal, true).to.have.deep.nested.property(prop, val);
  };
  /**
   * ### .notDeepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property` with
   * value given by `value`. `property` can use dot- and bracket-notation for
   * nested reference. Uses a deep equality check.
   *
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });
   *
   * @name notDeepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notDeepNestedPropertyVal, true).to.not.have.deep.nested.property(prop, val);
  };
  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 6, 'string has length of 6');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);
  };
  /**
   * ### .hasAnyKeys(object, [keys], [message])
   *
   * Asserts that `object` has at least one of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});
   *     assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAnyKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.hasAnyKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys);
  };
  /**
   * ### .hasAllKeys(object, [keys], [message])
   *
   * Asserts that `object` has all and only all of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);
   *     assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.hasAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys);
  };
  /**
   * ### .containsAllKeys(object, [keys], [message])
   *
   * Asserts that `object` has all of the `keys` provided but may have more keys not listed.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name containsAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.containsAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.containsAllKeys, true).to.contain.all.keys(keys);
  };
  /**
   * ### .doesNotHaveAnyKeys(object, [keys], [message])
   *
   * Asserts that `object` has none of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAnyKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.doesNotHaveAnyKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true).to.not.have.any.keys(keys);
  };
  /**
   * ### .doesNotHaveAllKeys(object, [keys], [message])
   *
   * Asserts that `object` does not have at least one of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.doesNotHaveAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAllKeys, true).to.not.have.all.keys(keys);
  };
  /**
   * ### .hasAnyDeepKeys(object, [keys], [message])
   *
   * Asserts that `object` has at least one of the `keys` provided.
   * Since Sets and Maps can have objects as keys you can use this assertion to perform
   * a deep comparison.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
   *
   * @name doesNotHaveAllKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.hasAnyDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAnyDeepKeys, true).to.have.any.deep.keys(keys);
  };
  /**
    * ### .hasAllDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` has all and only all of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});
    *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    *     assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});
    *     assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    *
    * @name hasAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.hasAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAllDeepKeys, true).to.have.all.deep.keys(keys);
  };
  /**
    * ### .containsAllDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` contains all of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
    *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
    *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    *
    * @name containsAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.containsAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.containsAllDeepKeys, true).to.contain.all.deep.keys(keys);
  };
  /**
    * ### .doesNotHaveAnyDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` has none of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    *
    * @name doesNotHaveAnyDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.doesNotHaveAnyDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, true).to.not.have.any.deep.keys(keys);
  };
  /**
    * ### .doesNotHaveAllDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` does not have at least one of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);
    *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);
    *
    * @name doesNotHaveAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.doesNotHaveAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, true).to.not.have.all.deep.keys(keys);
  };
  /**
    * ### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])
    *
    * If `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an
    * instance of `errorLike`.
    * If `errorLike` is an `Error` instance, asserts that the error thrown is the same
    * instance as `errorLike`.
    * If `errMsgMatcher` is provided, it also asserts that the error thrown will have a
    * message matching `errMsgMatcher`.
    *
    *     assert.throws(fn, 'function throws a reference error');
    *     assert.throws(fn, /function throws a reference error/);
    *     assert.throws(fn, ReferenceError);
    *     assert.throws(fn, errorInstance);
    *     assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');
    *     assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');
    *     assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);
    *     assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);
    *
    * @name throws
    * @alias throw
    * @alias Throw
    * @param {Function} fn
    * @param {ErrorConstructor|Error} errorLike
    * @param {RegExp|String} errMsgMatcher
    * @param {String} message
    * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
    * @namespace Assert
    * @api public
    */


  assert.throws = function (fn, errorLike, errMsgMatcher, msg) {
    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    var assertErr = new Assertion(fn, msg, assert.throws, true).to.throw(errorLike, errMsgMatcher);
    return flag(assertErr, 'object');
  };
  /**
   * ### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])
   *
   * If `errorLike` is an `Error` constructor, asserts that `fn` will _not_ throw an error that is an
   * instance of `errorLike`.
   * If `errorLike` is an `Error` instance, asserts that the error thrown is _not_ the same
   * instance as `errorLike`.
   * If `errMsgMatcher` is provided, it also asserts that the error thrown will _not_ have a
   * message matching `errMsgMatcher`.
   *
   *     assert.doesNotThrow(fn, 'Any Error thrown must not have this message');
   *     assert.doesNotThrow(fn, /Any Error thrown must not match this/);
   *     assert.doesNotThrow(fn, Error);
   *     assert.doesNotThrow(fn, errorInstance);
   *     assert.doesNotThrow(fn, Error, 'Error must not have this message');
   *     assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');
   *     assert.doesNotThrow(fn, Error, /Error must not match this/);
   *     assert.doesNotThrow(fn, errorInstance, /Error must not match this/);
   *
   * @name doesNotThrow
   * @param {Function} fn
   * @param {ErrorConstructor} errorLike
   * @param {RegExp|String} errMsgMatcher
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */


  assert.doesNotThrow = function (fn, errorLike, errMsgMatcher, msg) {
    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    new Assertion(fn, msg, assert.doesNotThrow, true).to.not.throw(errorLike, errMsgMatcher);
  };
  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.operator = function (val, operator, val2, msg) {
    var ok;

    switch (operator) {
      case '==':
        ok = val == val2;
        break;

      case '===':
        ok = val === val2;
        break;

      case '>':
        ok = val > val2;
        break;

      case '>=':
        ok = val >= val2;
        break;

      case '<':
        ok = val < val2;
        break;

      case '<=':
        ok = val <= val2;
        break;

      case '!=':
        ok = val != val2;
        break;

      case '!==':
        ok = val !== val2;
        break;

      default:
        msg = msg ? msg + ': ' : msg;
        throw new chai.AssertionError(msg + 'Invalid operator "' + operator + '"', undefined, assert.operator);
    }

    var test = new Assertion(ok, msg, assert.operator, true);
    test.assert(true === flag(test, 'object'), 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2), 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2));
  };
  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);
  };
  /**
   * ### .approximately(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');
   *
   * @name approximately
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.approximately = function (act, exp, delta, msg) {
    new Assertion(act, msg, assert.approximately, true).to.be.approximately(exp, delta);
  };
  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in any order. Uses a
   * strict equality check (===).
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameMembers, true).to.have.same.members(set2);
  };
  /**
   * ### .notSameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in any order.
   * Uses a strict equality check (===).
   *
   *     assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');
   *
   * @name notSameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameMembers, true).to.not.have.same.members(set2);
  };
  /**
   * ### .sameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in any order. Uses a
   * deep equality check.
   *
   *     assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');
   *
   * @name sameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameDeepMembers, true).to.have.same.deep.members(set2);
  };
  /**
   * ### .notSameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in any order.
   * Uses a deep equality check.
   *
   *     assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');
   *
   * @name notSameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameDeepMembers, true).to.not.have.same.deep.members(set2);
  };
  /**
   * ### .sameOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in the same order.
   * Uses a strict equality check (===).
   *
   *     assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');
   *
   * @name sameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameOrderedMembers, true).to.have.same.ordered.members(set2);
  };
  /**
   * ### .notSameOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in the same
   * order. Uses a strict equality check (===).
   *
   *     assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');
   *
   * @name notSameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameOrderedMembers, true).to.not.have.same.ordered.members(set2);
  };
  /**
   * ### .sameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in the same order.
   * Uses a deep equality check.
   *
   * assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');
   *
   * @name sameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameDeepOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameDeepOrderedMembers, true).to.have.same.deep.ordered.members(set2);
  };
  /**
   * ### .notSameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in the same
   * order. Uses a deep equality check.
   *
   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');
   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');
   *
   * @name notSameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameDeepOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameDeepOrderedMembers, true).to.not.have.same.deep.ordered.members(set2);
  };
  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeMembers, true).to.include.members(subset);
  };
  /**
   * ### .notIncludeMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');
   *
   * @name notIncludeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeMembers, true).to.not.include.members(subset);
  };
  /**
   * ### .includeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in any order. Uses a deep
   * equality check. Duplicates are ignored.
   *
   *     assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');
   *
   * @name includeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeDeepMembers, true).to.include.deep.members(subset);
  };
  /**
   * ### .notIncludeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in any order. Uses a
   * deep equality check. Duplicates are ignored.
   *
   *     assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');
   *
   * @name notIncludeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeDeepMembers, true).to.not.include.deep.members(subset);
  };
  /**
   * ### .includeOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a strict equality
   * check (===).
   *
   *     assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');
   *
   * @name includeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeOrderedMembers, true).to.include.ordered.members(subset);
  };
  /**
   * ### .notIncludeOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a strict equality
   * check (===).
   *
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');
   *
   * @name notIncludeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeOrderedMembers, true).to.not.include.ordered.members(subset);
  };
  /**
   * ### .includeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a deep equality
   * check.
   *
   *     assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');
   *
   * @name includeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeDeepOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeDeepOrderedMembers, true).to.include.deep.ordered.members(subset);
  };
  /**
   * ### .notIncludeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a deep equality
   * check.
   *
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');
   *
   * @name notIncludeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeDeepOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, true).to.not.include.deep.ordered.members(subset);
  };
  /**
   * ### .oneOf(inList, list, [message])
   *
   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.
   *
   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');
   *
   * @name oneOf
   * @param {*} inList
   * @param {Array<*>} list
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.oneOf = function (inList, list, msg) {
    new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);
  };
  /**
   * ### .changes(function, object, property, [message])
   *
   * Asserts that a function changes the value of a property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 22 };
   *     assert.changes(fn, obj, 'val');
   *
   * @name changes
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.changes = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changes, true).to.change(obj, prop);
  };
  /**
  * ### .changesBy(function, object, property, delta, [message])
  *
  * Asserts that a function changes the value of a property by an amount (delta).
  *
  *     var obj = { val: 10 };
  *     var fn = function() { obj.val += 2 };
  *     assert.changesBy(fn, obj, 'val', 2);
  *
  * @name changesBy
  * @param {Function} modifier function
  * @param {Object} object or getter function
  * @param {String} property name _optional_
  * @param {Number} change amount (delta)
  * @param {String} message _optional_
  * @namespace Assert
  * @api public
  */


  assert.changesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changesBy, true).to.change(obj, prop).by(delta);
  };
  /**
  * ### .doesNotChange(function, object, property, [message])
  *
  * Asserts that a function does not change the value of a property.
  *
  *     var obj = { val: 10 };
  *     var fn = function() { console.log('foo'); };
  *     assert.doesNotChange(fn, obj, 'val');
  *
  * @name doesNotChange
  * @param {Function} modifier function
  * @param {Object} object or getter function
  * @param {String} property name _optional_
  * @param {String} message _optional_
  * @namespace Assert
  * @api public
  */


  assert.doesNotChange = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotChange, true).to.not.change(obj, prop);
  };
  /**
   * ### .changesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not change the value of a property or of a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.changesButNotBy(fn, obj, 'val', 5);
   *
   * @name changesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.changesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changesButNotBy, true).to.change(obj, prop).but.not.by(delta);
  };
  /**
   * ### .increases(function, object, property, [message])
   *
   * Asserts that a function increases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 13 };
   *     assert.increases(fn, obj, 'val');
   *
   * @name increases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.increases = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.increases, true).to.increase(obj, prop);
  };
  /**
   * ### .increasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function increases a numeric object property or a function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.increasesBy(fn, obj, 'val', 10);
   *
   * @name increasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.increasesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.increasesBy, true).to.increase(obj, prop).by(delta);
  };
  /**
   * ### .doesNotIncrease(function, object, property, [message])
   *
   * Asserts that a function does not increase a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 8 };
   *     assert.doesNotIncrease(fn, obj, 'val');
   *
   * @name doesNotIncrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.doesNotIncrease = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotIncrease, true).to.not.increase(obj, prop);
  };
  /**
   * ### .increasesButNotBy(function, object, property, [message])
   *
   * Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.increasesButNotBy(fn, obj, 'val', 10);
   *
   * @name increasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.increasesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.increasesButNotBy, true).to.increase(obj, prop).but.not.by(delta);
  };
  /**
   * ### .decreases(function, object, property, [message])
   *
   * Asserts that a function decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreases(fn, obj, 'val');
   *
   * @name decreases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.decreases = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.decreases, true).to.decrease(obj, prop);
  };
  /**
   * ### .decreasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val -= 5 };
   *     assert.decreasesBy(fn, obj, 'val', 5);
   *
   * @name decreasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.decreasesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.decreasesBy, true).to.decrease(obj, prop).by(delta);
  };
  /**
   * ### .doesNotDecrease(function, object, property, [message])
   *
   * Asserts that a function does not decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.doesNotDecrease(fn, obj, 'val');
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.doesNotDecrease = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotDecrease, true).to.not.decrease(obj, prop);
  };
  /**
   * ### .doesNotDecreaseBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.doesNotDecreaseBy(fn, obj, 'val', 1);
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.doesNotDecreaseBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotDecreaseBy, true).to.not.decrease(obj, prop).by(delta);
  };
  /**
   * ### .decreasesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreasesButNotBy(fn, obj, 'val', 1);
   *
   * @name decreasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.decreasesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.decreasesButNotBy, true).to.decrease(obj, prop).but.not.by(delta);
  };
  /*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @namespace Assert
   * @api public
   */


  assert.ifError = function (val) {
    if (val) {
      throw val;
    }
  };
  /**
   * ### .isExtensible(object)
   *
   * Asserts that `object` is extensible (can have new properties added to it).
   *
   *     assert.isExtensible({});
   *
   * @name isExtensible
   * @alias extensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isExtensible = function (obj, msg) {
    new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;
  };
  /**
   * ### .isNotExtensible(object)
   *
   * Asserts that `object` is _not_ extensible.
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     assert.isNotExtensible(nonExtensibleObject);
   *     assert.isNotExtensible(sealedObject);
   *     assert.isNotExtensible(frozenObject);
   *
   * @name isNotExtensible
   * @alias notExtensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotExtensible = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;
  };
  /**
   * ### .isSealed(object)
   *
   * Asserts that `object` is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.seal({});
   *
   *     assert.isSealed(sealedObject);
   *     assert.isSealed(frozenObject);
   *
   * @name isSealed
   * @alias sealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isSealed = function (obj, msg) {
    new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;
  };
  /**
   * ### .isNotSealed(object)
   *
   * Asserts that `object` is _not_ sealed.
   *
   *     assert.isNotSealed({});
   *
   * @name isNotSealed
   * @alias notSealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotSealed = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;
  };
  /**
   * ### .isFrozen(object)
   *
   * Asserts that `object` is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *     assert.frozen(frozenObject);
   *
   * @name isFrozen
   * @alias frozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isFrozen = function (obj, msg) {
    new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;
  };
  /**
   * ### .isNotFrozen(object)
   *
   * Asserts that `object` is _not_ frozen.
   *
   *     assert.isNotFrozen({});
   *
   * @name isNotFrozen
   * @alias notFrozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotFrozen = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;
  };
  /**
   * ### .isEmpty(target)
   *
   * Asserts that the target does not contain any values.
   * For arrays and strings, it checks the `length` property.
   * For `Map` and `Set` instances, it checks the `size` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isEmpty([]);
   *     assert.isEmpty('');
   *     assert.isEmpty(new Map);
   *     assert.isEmpty({});
   *
   * @name isEmpty
   * @alias empty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isEmpty = function (val, msg) {
    new Assertion(val, msg, assert.isEmpty, true).to.be.empty;
  };
  /**
   * ### .isNotEmpty(target)
   *
   * Asserts that the target contains values.
   * For arrays and strings, it checks the `length` property.
   * For `Map` and `Set` instances, it checks the `size` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isNotEmpty([1, 2]);
   *     assert.isNotEmpty('34');
   *     assert.isNotEmpty(new Set([5, 6]));
   *     assert.isNotEmpty({ key: 7 });
   *
   * @name isNotEmpty
   * @alias notEmpty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotEmpty = function (val, msg) {
    new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;
  };
  /*!
   * Aliases.
   */


  (function alias(name, as) {
    assert[as] = assert[name];
    return alias;
  })('isOk', 'ok')('isNotOk', 'notOk')('throws', 'throw')('throws', 'Throw')('isExtensible', 'extensible')('isNotExtensible', 'notExtensible')('isSealed', 'sealed')('isNotSealed', 'notSealed')('isFrozen', 'frozen')('isNotFrozen', 'notFrozen')('isEmpty', 'empty')('isNotEmpty', 'notEmpty');
};var chai$1 = createCommonjsModule(function (module, exports) {
  /*!
   * chai
   * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   */
  var used = [];
  /*!
   * Chai version
   */

  exports.version = '4.1.2';
  /*!
   * Assertion Error
   */

  exports.AssertionError = assertionError;
  /*!
   * Utils for plugins (not exported)
   */

  /**
   * # .use(function)
   *
   * Provides a way to extend the internals of Chai.
   *
   * @param {Function}
   * @returns {this} for chaining
   * @api public
   */

  exports.use = function (fn) {
    if (!~used.indexOf(fn)) {
      fn(exports, utils);
      used.push(fn);
    }

    return exports;
  };
  /*!
   * Utility Functions
   */


  exports.util = utils;
  /*!
   * Configuration
   */

  exports.config = config;
  /*!
   * Primary `Assertion` prototype
   */

  exports.use(assertion);
  /*!
   * Core Assertions
   */

  exports.use(assertions);
  /*!
   * Expect interface
   */

  exports.use(expect);
  /*!
   * Should interface
   */

  exports.use(should);
  /*!
   * Assert interface
   */

  exports.use(assert);
});
var chai_1 = chai$1.version;
var chai_2 = chai$1.AssertionError;
var chai_3 = chai$1.use;
var chai_4 = chai$1.util;
var chai_5 = chai$1.config;var chai$2 = chai$1;var chaiDom = createCommonjsModule(function (module, exports) {
  (function (chaiDom) {
    if (typeof commonjsRequire === 'function' && 'object' === 'object' && 'object' === 'object') {
      module.exports = chaiDom;
    } else {
      chai.use(chaiDom);
    }
  })(function (chai, utils) {
    var flag = utils.flag,
        elToString = function (el) {
      var desc;

      if (el instanceof window.NodeList) {
        if (el.length === 0) return 'empty NodeList';
        desc = Array.prototype.slice.call(el, 0, 5).map(elToString).join(', ');
        return el.length > 5 ? desc + '... (+' + (el.length - 5) + ' more)' : desc;
      }

      if (!(el instanceof window.HTMLElement)) {
        return String(el);
      }

      desc = el.tagName.toLowerCase();

      if (el.id) {
        desc += '#' + el.id;
      }

      if (el.className) {
        desc += '.' + String(el.className).replace(/\s+/g, '.');
      }

      Array.prototype.forEach.call(el.attributes, function (attr) {
        if (attr.name !== 'class' && attr.name !== 'id') {
          desc += '[' + attr.name + (attr.value ? '="' + attr.value + '"]' : ']');
        }
      });
      return desc;
    },
        attrAssert = function (name, val) {
      var el = flag(this, 'object'),
          actual = el.getAttribute(name);

      if (!flag(this, 'negate') || undefined === val) {
        this.assert(!!el.attributes[name], 'expected ' + elToString(el) + ' to have an attribute #{exp}', 'expected ' + elToString(el) + ' not to have an attribute #{exp}', name);
      }

      if (undefined !== val) {
        this.assert(val === actual, 'expected ' + elToString(el) + ' to have an attribute ' + utils.inspect(name) + ' with the value #{exp}, but the value was #{act}', 'expected ' + elToString(el) + ' not to have an attribute ' + utils.inspect(name) + ' with the value #{act}', val, actual);
      }

      flag(this, 'object', actual);
    };

    utils.elToString = elToString;
    chai.Assertion.addMethod('attr', attrAssert);
    chai.Assertion.addMethod('attribute', attrAssert);
    chai.Assertion.addMethod('class', function (className) {
      var el = flag(this, 'object');
      this.assert(el.classList.contains(className), 'expected ' + elToString(el) + ' to have class #{exp}', 'expected ' + elToString(el) + ' not to have class #{exp}', className);
    });
    chai.Assertion.addMethod('id', function (id) {
      var el = flag(this, 'object');
      this.assert(el.id == id, 'expected ' + elToString(el) + ' to have id #{exp}', 'expected ' + elToString(el) + ' not to have id #{exp}', id);
    });
    chai.Assertion.addMethod('html', function (html) {
      var el = flag(this, 'object'),
          actual = flag(this, 'object').innerHTML;

      if (flag(this, 'contains')) {
        this.assert(actual.indexOf(html) >= 0, 'expected #{act} to contain HTML #{exp}', 'expected #{act} not to contain HTML #{exp}', html, actual);
      } else {
        this.assert(actual === html, 'expected ' + elToString(el) + ' to have HTML #{exp}, but the HTML was #{act}', 'expected ' + elToString(el) + ' not to have HTML #{exp}', html, actual);
      }
    });
    chai.Assertion.addMethod('text', function (text) {
      var obj = flag(this, 'object'),
          contains = flag(this, 'contains'),
          actual,
          result;

      if (obj instanceof window.NodeList) {
        actual = Array.prototype.map.call(obj, function (el) {
          return el.textContent;
        });

        if (Array.isArray(text)) {
          result = contains ? text[flag(this, 'negate') ? 'some' : 'every'](function (t) {
            return Array.prototype.some.call(obj, function (el) {
              return el.textContent === t;
            });
          }) : utils.eql(actual, text);
          actual = actual.join();
          text = text.join();
        } else {
          actual = actual.join('');
          result = contains ? actual.indexOf(text) >= 0 : actual === text;
        }
      } else {
        actual = flag(this, 'object').textContent;
        result = contains ? actual.indexOf(text) >= 0 : actual === text;
      }

      var objDesc = elToString(obj);

      if (contains) {
        this.assert(result, 'expected ' + objDesc + ' to contain #{exp}, but the text was #{act}', 'expected ' + objDesc + ' not to contain #{exp}, but the text was #{act}', text, actual);
      } else {
        this.assert(result, 'expected ' + objDesc + ' to have text #{exp}, but the text was #{act}', 'expected ' + objDesc + ' not to have text #{exp}', text, actual);
      }
    });
    chai.Assertion.addMethod('value', function (value) {
      var el = flag(this, 'object'),
          actual = flag(this, 'object').value;
      this.assert(flag(this, 'object').value === value, 'expected ' + elToString(el) + ' to have value #{exp}, but the value was #{act}', 'expected ' + elToString(el) + ' not to have value #{exp}', value, actual);
    });
    chai.Assertion.overwriteProperty('exist', function (_super) {
      return function () {
        var obj = flag(this, 'object');

        if (obj instanceof window.NodeList) {
          this.assert(obj.length > 0, 'expected an empty NodeList to have nodes', 'expected ' + elToString(obj) + ' to not exist');
        } else {
          _super.apply(this, arguments);
        }
      };
    });
    chai.Assertion.overwriteProperty('empty', function (_super) {
      return function () {
        var obj = flag(this, 'object');

        if (obj instanceof window.HTMLElement) {
          this.assert(obj.children.length === 0, 'expected ' + elToString(obj) + ' to be empty', 'expected ' + elToString(obj) + ' to not be empty');
        } else if (obj instanceof window.NodeList) {
          this.assert(obj.length === 0, 'expected ' + elToString(obj) + ' to be empty', 'expected ' + elToString(obj) + ' to not be empty');
        } else {
          _super.apply(this, arguments);
        }
      };
    });
    chai.Assertion.overwriteChainableMethod('length', function (_super) {
      return function (length) {
        var obj = flag(this, 'object');

        if (obj instanceof window.NodeList || obj instanceof window.HTMLElement) {
          var actualLength = obj.children ? obj.children.length : obj.length;
          this.assert(actualLength === length, 'expected ' + elToString(obj) + ' to have #{exp} children but it had #{act} children', 'expected ' + elToString(obj) + ' to not have #{exp} children', length, actualLength);
        } else {
          _super.apply(this, arguments);
        }
      };
    }, function (_super) {
      return function () {
        _super.call(this);
      };
    });
    chai.Assertion.overwriteMethod('match', function (_super) {
      return function (selector) {
        var obj = flag(this, 'object');

        if (obj instanceof window.HTMLElement) {
          this.assert(obj.matches(selector), 'expected ' + elToString(obj) + ' to match #{exp}', 'expected ' + elToString(obj) + ' to not match #{exp}', selector);
        } else if (obj instanceof window.NodeList) {
          this.assert(!!obj.length && Array.prototype.every.call(obj, function (el) {
            return el.matches(selector);
          }), 'expected ' + elToString(obj) + ' to match #{exp}', 'expected ' + elToString(obj) + ' to not match #{exp}', selector);
        } else {
          _super.apply(this, arguments);
        }
      };
    });
    chai.Assertion.overwriteChainableMethod('contain', function (_super) {
      return function (subitem) {
        var obj = flag(this, 'object');

        if (obj instanceof window.HTMLElement) {
          if (typeof subitem === 'string') {
            this.assert(!!obj.querySelector(subitem), 'expected ' + elToString(obj) + ' to contain #{exp}', 'expected ' + elToString(obj) + ' to not contain #{exp}', subitem);
          } else {
            this.assert(obj.contains(subitem), 'expected ' + elToString(obj) + ' to contain ' + elToString(subitem), 'expected ' + elToString(obj) + ' to not contain ' + elToString(subitem));
          }
        } else {
          _super.apply(this, arguments);
        }
      };
    }, function (_super) {
      return function () {
        _super.call(this);
      };
    });
    chai.Assertion.addProperty('displayed', function () {
      var el = flag(this, 'object'),
          actual = document.body.contains(el) ? window.getComputedStyle(el).display : el.style.display;
      this.assert(actual !== 'none', 'expected ' + elToString(el) + ' to be displayed, but it was not', 'expected ' + elToString(el) + ' to not be displayed, but it was as ' + actual, actual);
    });
  });
});var sources = chaiStyle;

function chaiStyle(chai, utils) {
  const {
    Assertion
  } = chai;
  const {
    flag
  } = utils;
  Assertion.addMethod('style', function (property, value = '') {
    const element = flag(this, 'object');
    const style = window.getComputedStyle(element);
    value = value.trim();
    const isNonColors = style[property] === 'rgba(0, 0, 0, 0)' // webkit
    || style[property] === 'transparent'; // firefox

    const propertyValue = isNonColors ? '' : style[property];
    const assertion = value ? compareCSSValue(propertyValue, value) : Boolean(propertyValue);
    const elementTag = element.tagName.toLowerCase();
    const throwMessage = `expect ${elementTag} to have {${property}: ${value}}, is receiving {${property}: ${propertyValue}}`;
    const throwMessageNegative = `expect ${elementTag} to not have {${property}: ${value}}, is receiving {${property}: ${propertyValue}}`;
    this.assert(assertion, throwMessage, throwMessageNegative, value);

    function compareCSSValue(computed, expected) {
      const propertyHifenCase = property.replace(/[A-Z]/g, match => '-' + match.toLowerCase());
      const fake = document.createElement('div');
      fake.style.fontSize = style.fontSize;
      fake.style.setProperty(propertyHifenCase, expected, 'important');
      const iframe = document.createElement('iframe');
      iframe.style.visibility = 'hidden';
      document.body.appendChild(iframe);
      iframe.appendChild(fake);
      const fakeStyle = window.getComputedStyle(fake);
      const value = fakeStyle[property];
      const hasAutoValue = value.includes('auto');
      const reg = new RegExp(escapeRegExp(value).replace(/auto/g, '(\\d+(.\\d+)?px|auto)'));
      return hasAutoValue ? reg.test(computed) : computed === value;
    }
  });
} // https://github.com/benjamingr/RegExp.escape/blob/master/polyfill.js


function escapeRegExp(value) {
  return String(value).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
}var typeDetect$1 = createCommonjsModule(function (module) {
  /* !
   * type-detect
   * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
   * MIT Licensed
   */

  var getPrototypeOfExists = typeof Object.getPrototypeOf === 'function';
  var promiseExists = typeof Promise === 'function';
  var globalObject = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : self; // eslint-disable-line

  var isDom = 'location' in globalObject && 'document' in globalObject;
  var htmlElementExists = typeof HTMLElement !== 'undefined';
  var isArrayExists = typeof Array.isArray === 'function';
  var symbolExists = typeof Symbol !== 'undefined';
  var mapExists = typeof Map !== 'undefined';
  var setExists = typeof Set !== 'undefined';
  var weakMapExists = typeof WeakMap !== 'undefined';
  var weakSetExists = typeof WeakSet !== 'undefined';
  var dataViewExists = typeof DataView !== 'undefined';
  var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
  var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
  var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
  var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
  var setIteratorPrototype = getPrototypeOfExists && setEntriesExists && Object.getPrototypeOf(new Set().entries());
  var mapIteratorPrototype = getPrototypeOfExists && mapEntriesExists && Object.getPrototypeOf(new Map().entries());
  var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
  var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
  var stringIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
  var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
  var toStringLeftSliceLength = 8;
  var toStringRightSliceLength = -1;
  /**
   * ### typeOf (obj)
   *
   * Uses `Object.prototype.toString` to determine the type of an object,
   * normalising behaviour across engine versions & well optimised.
   *
   * @param {Mixed} object
   * @return {String} object type
   * @api public
   */

  module.exports = function typeDetect(obj) {
    /* ! Speed optimisation
     * Pre:
     *   string literal     x 3,039,035 ops/sec 1.62% (78 runs sampled)
     *   boolean literal    x 1,424,138 ops/sec 4.54% (75 runs sampled)
     *   number literal     x 1,653,153 ops/sec 1.91% (82 runs sampled)
     *   undefined          x 9,978,660 ops/sec 1.92% (75 runs sampled)
     *   function           x 2,556,769 ops/sec 1.73% (77 runs sampled)
     * Post:
     *   string literal     x 38,564,796 ops/sec 1.15% (79 runs sampled)
     *   boolean literal    x 31,148,940 ops/sec 1.10% (79 runs sampled)
     *   number literal     x 32,679,330 ops/sec 1.90% (78 runs sampled)
     *   undefined          x 32,363,368 ops/sec 1.07% (82 runs sampled)
     *   function           x 31,296,870 ops/sec 0.96% (83 runs sampled)
     */
    var typeofObj = typeof obj;

    if (typeofObj !== 'object') {
      return typeofObj;
    }
    /* ! Speed optimisation
     * Pre:
     *   null               x 28,645,765 ops/sec 1.17% (82 runs sampled)
     * Post:
     *   null               x 36,428,962 ops/sec 1.37% (84 runs sampled)
     */


    if (obj === null) {
      return 'null';
    }
    /* ! Spec Conformance
     * Test: `Object.prototype.toString.call(window)``
     *  - Node === "[object global]"
     *  - Chrome === "[object global]"
     *  - Firefox === "[object Window]"
     *  - PhantomJS === "[object Window]"
     *  - Safari === "[object Window]"
     *  - IE 11 === "[object Window]"
     *  - IE Edge === "[object Window]"
     * Test: `Object.prototype.toString.call(this)``
     *  - Chrome Worker === "[object global]"
     *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
     *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
     *  - IE 11 Worker === "[object WorkerGlobalScope]"
     *  - IE Edge Worker === "[object WorkerGlobalScope]"
     */


    if (obj === globalObject) {
      return 'global';
    }
    /* ! Speed optimisation
     * Pre:
     *   array literal      x 2,888,352 ops/sec 0.67% (82 runs sampled)
     * Post:
     *   array literal      x 22,479,650 ops/sec 0.96% (81 runs sampled)
     */


    if (isArrayExists && Array.isArray(obj)) {
      return 'Array';
    }

    if (isDom) {
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/browsers.html#location)
       * WhatWG HTML$7.7.3 - The `Location` interface
       * Test: `Object.prototype.toString.call(window.location)``
       *  - IE <=11 === "[object Object]"
       *  - IE Edge <=13 === "[object Object]"
       */
      if (obj === globalObject.location) {
        return 'Location';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#document)
       * WhatWG HTML$3.1.1 - The `Document` object
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       *       WhatWG HTML states:
       *         > For historical reasons, Window objects must also have a
       *         > writable, configurable, non-enumerable property named
       *         > HTMLDocument whose value is the Document interface object.
       * Test: `Object.prototype.toString.call(document)``
       *  - Chrome === "[object HTMLDocument]"
       *  - Firefox === "[object HTMLDocument]"
       *  - Safari === "[object HTMLDocument]"
       *  - IE <=10 === "[object Document]"
       *  - IE 11 === "[object HTMLDocument]"
       *  - IE Edge <=13 === "[object HTMLDocument]"
       */


      if (obj === globalObject.document) {
        return 'Document';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
       * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
       * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
       *  - IE <=10 === "[object MSMimeTypesCollection]"
       */


      if (obj === (globalObject.navigator || {}).mimeTypes) {
        return 'MimeTypeArray';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
       * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
       * Test: `Object.prototype.toString.call(navigator.plugins)``
       *  - IE <=10 === "[object MSPluginsCollection]"
       */


      if (obj === (globalObject.navigator || {}).plugins) {
        return 'PluginArray';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
       * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
       * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
       *  - IE <=10 === "[object HTMLBlockElement]"
       */


      if (htmlElementExists && obj instanceof HTMLElement && obj.tagName === 'BLOCKQUOTE') {
        return 'HTMLQuoteElement';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#htmltabledatacellelement)
       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       * Test: Object.prototype.toString.call(document.createElement('td'))
       *  - Chrome === "[object HTMLTableCellElement]"
       *  - Firefox === "[object HTMLTableCellElement]"
       *  - Safari === "[object HTMLTableCellElement]"
       */


      if (htmlElementExists && obj instanceof HTMLElement && obj.tagName === 'TD') {
        return 'HTMLTableDataCellElement';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#htmltableheadercellelement)
       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       * Test: Object.prototype.toString.call(document.createElement('th'))
       *  - Chrome === "[object HTMLTableCellElement]"
       *  - Firefox === "[object HTMLTableCellElement]"
       *  - Safari === "[object HTMLTableCellElement]"
       */


      if (htmlElementExists && obj instanceof HTMLElement && obj.tagName === 'TH') {
        return 'HTMLTableHeaderCellElement';
      }
    }
    /* ! Speed optimisation
    * Pre:
    *   Float64Array       x 625,644 ops/sec 1.58% (80 runs sampled)
    *   Float32Array       x 1,279,852 ops/sec 2.91% (77 runs sampled)
    *   Uint32Array        x 1,178,185 ops/sec 1.95% (83 runs sampled)
    *   Uint16Array        x 1,008,380 ops/sec 2.25% (80 runs sampled)
    *   Uint8Array         x 1,128,040 ops/sec 2.11% (81 runs sampled)
    *   Int32Array         x 1,170,119 ops/sec 2.88% (80 runs sampled)
    *   Int16Array         x 1,176,348 ops/sec 5.79% (86 runs sampled)
    *   Int8Array          x 1,058,707 ops/sec 4.94% (77 runs sampled)
    *   Uint8ClampedArray  x 1,110,633 ops/sec 4.20% (80 runs sampled)
    * Post:
    *   Float64Array       x 7,105,671 ops/sec 13.47% (64 runs sampled)
    *   Float32Array       x 5,887,912 ops/sec 1.46% (82 runs sampled)
    *   Uint32Array        x 6,491,661 ops/sec 1.76% (79 runs sampled)
    *   Uint16Array        x 6,559,795 ops/sec 1.67% (82 runs sampled)
    *   Uint8Array         x 6,463,966 ops/sec 1.43% (85 runs sampled)
    *   Int32Array         x 5,641,841 ops/sec 3.49% (81 runs sampled)
    *   Int16Array         x 6,583,511 ops/sec 1.98% (80 runs sampled)
    *   Int8Array          x 6,606,078 ops/sec 1.74% (81 runs sampled)
    *   Uint8ClampedArray  x 6,602,224 ops/sec 1.77% (83 runs sampled)
    */


    var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];

    if (typeof stringTag === 'string') {
      return stringTag;
    }

    if (getPrototypeOfExists) {
      var objPrototype = Object.getPrototypeOf(obj);
      /* ! Speed optimisation
      * Pre:
      *   regex literal      x 1,772,385 ops/sec 1.85% (77 runs sampled)
      *   regex constructor  x 2,143,634 ops/sec 2.46% (78 runs sampled)
      * Post:
      *   regex literal      x 3,928,009 ops/sec 0.65% (78 runs sampled)
      *   regex constructor  x 3,931,108 ops/sec 0.58% (84 runs sampled)
      */

      if (objPrototype === RegExp.prototype) {
        return 'RegExp';
      }
      /* ! Speed optimisation
      * Pre:
      *   date               x 2,130,074 ops/sec 4.42% (68 runs sampled)
      * Post:
      *   date               x 3,953,779 ops/sec 1.35% (77 runs sampled)
      */


      if (objPrototype === Date.prototype) {
        return 'Date';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
       * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
       * Test: `Object.prototype.toString.call(Promise.resolve())``
       *  - Chrome <=47 === "[object Object]"
       *  - Edge <=20 === "[object Object]"
       *  - Firefox 29-Latest === "[object Promise]"
       *  - Safari 7.1-Latest === "[object Promise]"
       */


      if (promiseExists && objPrototype === Promise.prototype) {
        return 'Promise';
      }
      /* ! Speed optimisation
      * Pre:
      *   set                x 2,222,186 ops/sec 1.31% (82 runs sampled)
      * Post:
      *   set                x 4,545,879 ops/sec 1.13% (83 runs sampled)
      */


      if (setExists && objPrototype === Set.prototype) {
        return 'Set';
      }
      /* ! Speed optimisation
      * Pre:
      *   map                x 2,396,842 ops/sec 1.59% (81 runs sampled)
      * Post:
      *   map                x 4,183,945 ops/sec 6.59% (82 runs sampled)
      */


      if (mapExists && objPrototype === Map.prototype) {
        return 'Map';
      }
      /* ! Speed optimisation
      * Pre:
      *   weakset            x 1,323,220 ops/sec 2.17% (76 runs sampled)
      * Post:
      *   weakset            x 4,237,510 ops/sec 2.01% (77 runs sampled)
      */


      if (weakSetExists && objPrototype === WeakSet.prototype) {
        return 'WeakSet';
      }
      /* ! Speed optimisation
      * Pre:
      *   weakmap            x 1,500,260 ops/sec 2.02% (78 runs sampled)
      * Post:
      *   weakmap            x 3,881,384 ops/sec 1.45% (82 runs sampled)
      */


      if (weakMapExists && objPrototype === WeakMap.prototype) {
        return 'WeakMap';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
       * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
       * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
       *  - Edge <=13 === "[object Object]"
       */


      if (dataViewExists && objPrototype === DataView.prototype) {
        return 'DataView';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
       * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
       * Test: `Object.prototype.toString.call(new Map().entries())``
       *  - Edge <=13 === "[object Object]"
       */


      if (mapExists && objPrototype === mapIteratorPrototype) {
        return 'Map Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
       * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
       * Test: `Object.prototype.toString.call(new Set().entries())``
       *  - Edge <=13 === "[object Object]"
       */


      if (setExists && objPrototype === setIteratorPrototype) {
        return 'Set Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
       * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
       * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
       *  - Edge <=13 === "[object Object]"
       */


      if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
        return 'Array Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
       * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
       * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
       *  - Edge <=13 === "[object Object]"
       */


      if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
        return 'String Iterator';
      }
      /* ! Speed optimisation
      * Pre:
      *   object from null   x 2,424,320 ops/sec 1.67% (76 runs sampled)
      * Post:
      *   object from null   x 5,838,000 ops/sec 0.99% (84 runs sampled)
      */


      if (objPrototype === null) {
        return 'Object';
      }
    }

    return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
  };

  module.exports.typeDetect = module.exports;
});
var typeDetect_1$1 = typeDetect$1.typeDetect;/* globals Symbol: true, Uint8Array: true, WeakMap: true */

/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */


function FakeMap$1() {
  this.clear();
}

FakeMap$1.prototype = {
  clear: function clearMap() {
    this.keys = [];
    this.values = [];
    return this;
  },
  set: function setMap(key, value) {
    var index = this.keys.indexOf(key);

    if (index >= 0) {
      this.values[index] = value;
    } else {
      this.keys.push(key);
      this.values.push(value);
    }

    return this;
  },
  get: function getMap(key) {
    return this.values[this.keys.indexOf(key)];
  },
  delete: function deleteMap(key) {
    var index = this.keys.indexOf(key);

    if (index >= 0) {
      this.values = this.values.slice(0, index).concat(this.values.slice(index + 1));
      this.keys = this.keys.slice(0, index).concat(this.keys.slice(index + 1));
    }

    return this;
  }
};
var MemoizeMap$1 = null;

if (typeof WeakMap === 'function') {
  MemoizeMap$1 = WeakMap;
} else {
  MemoizeMap$1 = FakeMap$1;
}
/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/


function memoizeCompare$1(leftHandOperand, rightHandOperand, memoizeMap) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) {
    return null;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);

    if (typeof result === 'boolean') {
      return result;
    }
  }

  return null;
}
/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/


function memoizeSet$1(leftHandOperand, rightHandOperand, memoizeMap, result) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) {
    return;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    leftHandMap.set(rightHandOperand, result);
  } else {
    leftHandMap = new MemoizeMap$1();
    leftHandMap.set(rightHandOperand, result);
    memoizeMap.set(leftHandOperand, leftHandMap);
  }
}
/*!
 * Primary Export
 */


var deepEql$1 = deepEqual$1;
var MemoizeMap_1$1 = MemoizeMap$1;
/**
 * Assert deeply nested sameValue equality between two objects of any type.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
 */

function deepEqual$1(leftHandOperand, rightHandOperand, options) {
  // If we have a comparator, we can't assume anything; so bail to its check first.
  if (options && options.comparator) {
    return extensiveDeepEqual$1(leftHandOperand, rightHandOperand, options);
  }

  var simpleResult = simpleEqual$1(leftHandOperand, rightHandOperand);

  if (simpleResult !== null) {
    return simpleResult;
  } // Deeper comparisons are pushed through to a larger function


  return extensiveDeepEqual$1(leftHandOperand, rightHandOperand, options);
}
/**
 * Many comparisons can be canceled out early via simple equality or primitive checks.
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @return {Boolean|null} equal match
 */


function simpleEqual$1(leftHandOperand, rightHandOperand) {
  // Equal references (except for Numbers) can be returned early
  if (leftHandOperand === rightHandOperand) {
    // Handle +-0 cases
    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
  } // handle NaN cases


  if (leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
  rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare
  ) {
      return true;
    } // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,
  // strings, and undefined, can be compared by reference.


  if (isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) {
    // Easy out b/c it would have passed the first equality check
    return false;
  }

  return null;
}
/*!
 * The main logic of the `deepEqual` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/


function extensiveDeepEqual$1(leftHandOperand, rightHandOperand, options) {
  options = options || {};
  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap$1();
  var comparator = options && options.comparator; // Check if a memoized result exists.

  var memoizeResultLeft = memoizeCompare$1(leftHandOperand, rightHandOperand, options.memoize);

  if (memoizeResultLeft !== null) {
    return memoizeResultLeft;
  }

  var memoizeResultRight = memoizeCompare$1(rightHandOperand, leftHandOperand, options.memoize);

  if (memoizeResultRight !== null) {
    return memoizeResultRight;
  } // If a comparator is present, use it.


  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand); // Comparators may return null, in which case we want to go back to default behavior.

    if (comparatorResult === false || comparatorResult === true) {
      memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
      return comparatorResult;
    } // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide
    // what to do, we need to make sure to return the basic tests first before we move on.


    var simpleResult = simpleEqual$1(leftHandOperand, rightHandOperand);

    if (simpleResult !== null) {
      // Don't memoize this, it takes longer to set/retrieve than to just compare.
      return simpleResult;
    }
  }

  var leftHandType = typeDetect$1(leftHandOperand);

  if (leftHandType !== typeDetect$1(rightHandOperand)) {
    memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, false);
    return false;
  } // Temporarily set the operands in the memoize object to prevent blowing the stack


  memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, true);
  var result = extensiveDeepEqualByType$1(leftHandOperand, rightHandOperand, leftHandType, options);
  memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, result);
  return result;
}

function extensiveDeepEqualByType$1(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case 'String':
    case 'Number':
    case 'Boolean':
    case 'Date':
      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values
      return deepEqual$1(leftHandOperand.valueOf(), rightHandOperand.valueOf());

    case 'Promise':
    case 'Symbol':
    case 'function':
    case 'WeakMap':
    case 'WeakSet':
    case 'Error':
      return leftHandOperand === rightHandOperand;

    case 'Arguments':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'Array':
      return iterableEqual$1(leftHandOperand, rightHandOperand, options);

    case 'RegExp':
      return regexpEqual$1(leftHandOperand, rightHandOperand);

    case 'Generator':
      return generatorEqual$1(leftHandOperand, rightHandOperand, options);

    case 'DataView':
      return iterableEqual$1(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);

    case 'ArrayBuffer':
      return iterableEqual$1(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);

    case 'Set':
      return entriesEqual$1(leftHandOperand, rightHandOperand, options);

    case 'Map':
      return entriesEqual$1(leftHandOperand, rightHandOperand, options);

    default:
      return objectEqual$1(leftHandOperand, rightHandOperand, options);
  }
}
/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */


function regexpEqual$1(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function entriesEqual$1(leftHandOperand, rightHandOperand, options) {
  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach
  if (leftHandOperand.size !== rightHandOperand.size) {
    return false;
  }

  if (leftHandOperand.size === 0) {
    return true;
  }

  var leftHandItems = [];
  var rightHandItems = [];
  leftHandOperand.forEach(function gatherEntries(key, value) {
    leftHandItems.push([key, value]);
  });
  rightHandOperand.forEach(function gatherEntries(key, value) {
    rightHandItems.push([key, value]);
  });
  return iterableEqual$1(leftHandItems.sort(), rightHandItems.sort(), options);
}
/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function iterableEqual$1(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;

  if (length !== rightHandOperand.length) {
    return false;
  }

  if (length === 0) {
    return true;
  }

  var index = -1;

  while (++index < length) {
    if (deepEqual$1(leftHandOperand[index], rightHandOperand[index], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function generatorEqual$1(leftHandOperand, rightHandOperand, options) {
  return iterableEqual$1(getGeneratorEntries$1(leftHandOperand), getGeneratorEntries$1(rightHandOperand), options);
}
/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} `true` if the object has an @@iterator function.
 */


function hasIteratorFunction$1(target) {
  return typeof Symbol !== 'undefined' && typeof target === 'object' && typeof Symbol.iterator !== 'undefined' && typeof target[Symbol.iterator] === 'function';
}
/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */


function getIteratorEntries$1(target) {
  if (hasIteratorFunction$1(target)) {
    try {
      return getGeneratorEntries$1(target[Symbol.iterator]());
    } catch (iteratorError) {
      return [];
    }
  }

  return [];
}
/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */


function getGeneratorEntries$1(generator) {
  var generatorResult = generator.next();
  var accumulator = [generatorResult.value];

  while (generatorResult.done === false) {
    generatorResult = generator.next();
    accumulator.push(generatorResult.value);
  }

  return accumulator;
}
/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */


function getEnumerableKeys$1(target) {
  var keys = [];

  for (var key in target) {
    keys.push(key);
  }

  return keys;
}
/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function keysEqual$1(leftHandOperand, rightHandOperand, keys, options) {
  var length = keys.length;

  if (length === 0) {
    return true;
  }

  for (var i = 0; i < length; i += 1) {
    if (deepEqual$1(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function objectEqual$1(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys$1(leftHandOperand);
  var rightHandKeys = getEnumerableKeys$1(rightHandOperand);

  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
    leftHandKeys.sort();
    rightHandKeys.sort();

    if (iterableEqual$1(leftHandKeys, rightHandKeys) === false) {
      return false;
    }

    return keysEqual$1(leftHandOperand, rightHandOperand, leftHandKeys, options);
  }

  var leftHandEntries = getIteratorEntries$1(leftHandOperand);
  var rightHandEntries = getIteratorEntries$1(rightHandOperand);

  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
    leftHandEntries.sort();
    rightHandEntries.sort();
    return iterableEqual$1(leftHandEntries, rightHandEntries, options);
  }

  if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
    return true;
  }

  return false;
}
/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */


function isPrimitive$1(value) {
  return value === null || typeof value !== 'object';
}
deepEql$1.MemoizeMap = MemoizeMap_1$1;var DEFAULT_TOLERANCE = 1e-6;
/**
 * small utility functions
 */

function isNumber(val) {
  return typeDetect(val) === 'number';
}

function bothNumbers(left, right) {
  return isNumber(right) && isNumber(left);
}

function almostEqual(left, right, tol) {
  return Math.abs(left - right) <= tol;
}
/**
 * Makes a comparator function to be passed to deepEqual.
 * The returned function will return null if both arguments are not numbers,
 * indicating that deepEqual should proceed with other equality checks
 */


function comparator(tolerance) {
  return function (left, right) {
    if (bothNumbers(left, right)) {
      return almostEqual(left, right, tolerance);
    }

    return null;
  };
}
/**
 * Sets global tolerance and returns a function to be passed to chai.use
 * @see http://chaijs.com/guide/plugins/
 */


function chaiAlmost(customTolerance) {
  var standardTolerance = customTolerance || DEFAULT_TOLERANCE;
  return function (chai, utils) {
    var Assertion = chai.Assertion;
    var flag = utils.flag;
    /**
     * Returns a new shallow equality function to override
     * .equal, .equals, .eq that tests 'almost' equality
     * if both values are numbers and a 'tolerance' flag is set.
     * Sends to deep equality check if deep flag is set
     */

    function overrideAssertEqual(_super) {
      return function assertEqual(val, msg) {
        if (msg) flag(this, 'message', msg);
        var deep = flag(this, 'deep');
        var tolerance = flag(this, 'tolerance');

        if (deep) {
          return this.eql(val);
        } else if (tolerance && bothNumbers(val, this._obj)) {
          this.assert(almostEqual(val, this._obj, tolerance), 'expected #{this} to almost equal #{exp}', 'expected #{this} to not almost equal #{exp}', val, this._obj, true);
        } else {
          return _super.apply(this, arguments);
        }
      };
    }
    /**
     * Returns a new deep equality function to override
     * .eql, .eqls that tests 'almost' equality if both corresponding
     * values are numbers and tolerance flag is set
     */


    function overrideAssertEql(_super) {
      return function assertEql(val, msg) {
        if (msg) flag(this, 'message', msg);
        var tolerance = flag(this, 'tolerance');

        if (tolerance) {
          this.assert(deepEql$1(val, this._obj, {
            comparator: comparator(tolerance)
          }), 'expected #{this} to deeply almost equal #{exp}', 'expected #{this} to not deeply almost equal #{exp}', val, this._obj, true);
        } else {
          return _super.apply(this, arguments);
        }
      };
    }
    /**
     * .almost() method. To be used at the end of the chain like:
     * expect(4).to.not.be.almost(5, 1.5). Simply adds tolerance flag then calls
     * .equal. This will redirect to .eql if deep flag set
     */


    function method(val, toleranceOverride) {
      var tolerance = toleranceOverride || standardTolerance;
      flag(this, 'tolerance', tolerance);
      return this.equal(val);
    }
    /**
     * .almost chainable property to be used like:
     * expect(3.99999999).to.almost.equal(4). Simply adds
     * tolerance flag to be read by equality checking methods
     */


    function chainingBehavior() {
      flag(this, 'tolerance', standardTolerance);
    }

    Assertion.addChainableMethod('almost', method, chainingBehavior);
    Assertion.overwriteMethod('equal', overrideAssertEqual);
    Assertion.overwriteMethod('equals', overrideAssertEqual);
    Assertion.overwriteMethod('eq', overrideAssertEqual);
    Assertion.overwriteMethod('eql', overrideAssertEql);
    Assertion.overwriteMethod('eqls', overrideAssertEql);
  };
}

var chaiAlmost_1 = chaiAlmost;var checkTypes = createCommonjsModule(function (module) {
  /*globals define, module, Symbol */

  /*jshint -W056 */
  (function (globals) {

    var strings, messages, predicates, functions, assert, not, maybe, collections, slice, neginf, posinf, isArray, haveSymbols;
    strings = {
      v: 'value',
      n: 'number',
      s: 'string',
      b: 'boolean',
      o: 'object',
      t: 'type',
      a: 'array',
      al: 'array-like',
      i: 'iterable',
      d: 'date',
      f: 'function',
      l: 'length'
    };
    messages = {};
    predicates = {};
    [{
      n: 'equal',
      f: equal,
      s: 'v'
    }, {
      n: 'undefined',
      f: isUndefined,
      s: 'v'
    }, {
      n: 'null',
      f: isNull,
      s: 'v'
    }, {
      n: 'assigned',
      f: assigned,
      s: 'v'
    }, {
      n: 'primitive',
      f: primitive,
      s: 'v'
    }, {
      n: 'includes',
      f: includes,
      s: 'v'
    }, {
      n: 'zero',
      f: zero
    }, {
      n: 'infinity',
      f: infinity
    }, {
      n: 'number',
      f: number
    }, {
      n: 'integer',
      f: integer
    }, {
      n: 'even',
      f: even
    }, {
      n: 'odd',
      f: odd
    }, {
      n: 'greater',
      f: greater
    }, {
      n: 'less',
      f: less
    }, {
      n: 'between',
      f: between
    }, {
      n: 'greaterOrEqual',
      f: greaterOrEqual
    }, {
      n: 'lessOrEqual',
      f: lessOrEqual
    }, {
      n: 'inRange',
      f: inRange
    }, {
      n: 'positive',
      f: positive
    }, {
      n: 'negative',
      f: negative
    }, {
      n: 'string',
      f: string,
      s: 's'
    }, {
      n: 'emptyString',
      f: emptyString,
      s: 's'
    }, {
      n: 'nonEmptyString',
      f: nonEmptyString,
      s: 's'
    }, {
      n: 'contains',
      f: contains,
      s: 's'
    }, {
      n: 'match',
      f: match,
      s: 's'
    }, {
      n: 'boolean',
      f: boolean,
      s: 'b'
    }, {
      n: 'object',
      f: object,
      s: 'o'
    }, {
      n: 'emptyObject',
      f: emptyObject,
      s: 'o'
    }, {
      n: 'nonEmptyObject',
      f: nonEmptyObject,
      s: 'o'
    }, {
      n: 'instanceStrict',
      f: instanceStrict,
      s: 't'
    }, {
      n: 'instance',
      f: instance,
      s: 't'
    }, {
      n: 'like',
      f: like,
      s: 't'
    }, {
      n: 'array',
      f: array,
      s: 'a'
    }, {
      n: 'emptyArray',
      f: emptyArray,
      s: 'a'
    }, {
      n: 'nonEmptyArray',
      f: nonEmptyArray,
      s: 'a'
    }, {
      n: 'arrayLike',
      f: arrayLike,
      s: 'al'
    }, {
      n: 'iterable',
      f: iterable,
      s: 'i'
    }, {
      n: 'date',
      f: date,
      s: 'd'
    }, {
      n: 'function',
      f: isFunction,
      s: 'f'
    }, {
      n: 'hasLength',
      f: hasLength,
      s: 'l'
    }].map(function (data) {
      var n = data.n;
      messages[n] = 'Invalid ' + strings[data.s || 'n'];
      predicates[n] = data.f;
    });
    functions = {
      apply: apply,
      map: map,
      all: all,
      any: any
    };
    collections = ['array', 'arrayLike', 'iterable', 'object'];
    slice = Array.prototype.slice;
    neginf = Number.NEGATIVE_INFINITY;
    posinf = Number.POSITIVE_INFINITY;
    isArray = Array.isArray;
    haveSymbols = typeof Symbol === 'function';
    functions = mixin(functions, predicates);
    assert = createModifiedPredicates(assertModifier, assertImpl);
    not = createModifiedPredicates(notModifier, notImpl);
    maybe = createModifiedPredicates(maybeModifier, maybeImpl);
    assert.not = createModifiedModifier(assertModifier, not);
    assert.maybe = createModifiedModifier(assertModifier, maybe);
    collections.forEach(createOfPredicates);
    createOfModifiers(assert, assertModifier);
    createOfModifiers(not, notModifier);
    collections.forEach(createMaybeOfModifiers);
    exportFunctions(mixin(functions, {
      assert: assert,
      not: not,
      maybe: maybe
    }));
    /**
     * Public function `equal`.
     *
     * Returns true if `lhs` and `rhs` are strictly equal, without coercion.
     * Returns false otherwise.
     */

    function equal(lhs, rhs) {
      return lhs === rhs;
    }
    /**
     * Public function `undefined`.
     *
     * Returns true if `data` is undefined, false otherwise.
     */


    function isUndefined(data) {
      return data === undefined;
    }
    /**
     * Public function `null`.
     *
     * Returns true if `data` is null, false otherwise.
     */


    function isNull(data) {
      return data === null;
    }
    /**
     * Public function `assigned`.
     *
     * Returns true if `data` is not null or undefined, false otherwise.
     */


    function assigned(data) {
      return data !== undefined && data !== null;
    }
    /**
     * Public function `primitive`.
     *
     * Returns true if `data` is a primitive type, false otherwise.
     */


    function primitive(data) {
      var type;

      switch (data) {
        case null:
        case undefined:
        case false:
        case true:
          return true;
      }

      type = typeof data;
      return type === 'string' || type === 'number' || haveSymbols && type === 'symbol';
    }
    /**
     * Public function `zero`.
     *
     * Returns true if `data` is zero, false otherwise.
     */


    function zero(data) {
      return data === 0;
    }
    /**
     * Public function `infinity`.
     *
     * Returns true if `data` is positive or negative infinity, false otherwise.
     */


    function infinity(data) {
      return data === neginf || data === posinf;
    }
    /**
     * Public function `number`.
     *
     * Returns true if `data` is a number, false otherwise.
     */


    function number(data) {
      return typeof data === 'number' && data > neginf && data < posinf;
    }
    /**
     * Public function `integer`.
     *
     * Returns true if `data` is an integer, false otherwise.
     */


    function integer(data) {
      return typeof data === 'number' && data % 1 === 0;
    }
    /**
     * Public function `even`.
     *
     * Returns true if `data` is an even number, false otherwise.
     */


    function even(data) {
      return typeof data === 'number' && data % 2 === 0;
    }
    /**
     * Public function `odd`.
     *
     * Returns true if `data` is an odd number, false otherwise.
     */


    function odd(data) {
      return integer(data) && data % 2 !== 0;
    }
    /**
     * Public function `greater`.
     *
     * Returns true if `lhs` is a number greater than `rhs`, false otherwise.
     */


    function greater(lhs, rhs) {
      return number(lhs) && lhs > rhs;
    }
    /**
     * Public function `less`.
     *
     * Returns true if `lhs` is a number less than `rhs`, false otherwise.
     */


    function less(lhs, rhs) {
      return number(lhs) && lhs < rhs;
    }
    /**
     * Public function `between`.
     *
     * Returns true if `data` is a number between `x` and `y`, false otherwise.
     */


    function between(data, x, y) {
      if (x < y) {
        return greater(data, x) && data < y;
      }

      return less(data, x) && data > y;
    }
    /**
     * Public function `greaterOrEqual`.
     *
     * Returns true if `lhs` is a number greater than or equal to `rhs`, false
     * otherwise.
     */


    function greaterOrEqual(lhs, rhs) {
      return number(lhs) && lhs >= rhs;
    }
    /**
     * Public function `lessOrEqual`.
     *
     * Returns true if `lhs` is a number less than or equal to `rhs`, false
     * otherwise.
     */


    function lessOrEqual(lhs, rhs) {
      return number(lhs) && lhs <= rhs;
    }
    /**
     * Public function `inRange`.
     *
     * Returns true if `data` is a number in the range `x..y`, false otherwise.
     */


    function inRange(data, x, y) {
      if (x < y) {
        return greaterOrEqual(data, x) && data <= y;
      }

      return lessOrEqual(data, x) && data >= y;
    }
    /**
     * Public function `positive`.
     *
     * Returns true if `data` is a positive number, false otherwise.
     */


    function positive(data) {
      return greater(data, 0);
    }
    /**
     * Public function `negative`.
     *
     * Returns true if `data` is a negative number, false otherwise.
     */


    function negative(data) {
      return less(data, 0);
    }
    /**
     * Public function `string`.
     *
     * Returns true if `data` is a string, false otherwise.
     */


    function string(data) {
      return typeof data === 'string';
    }
    /**
     * Public function `emptyString`.
     *
     * Returns true if `data` is the empty string, false otherwise.
     */


    function emptyString(data) {
      return data === '';
    }
    /**
     * Public function `nonEmptyString`.
     *
     * Returns true if `data` is a non-empty string, false otherwise.
     */


    function nonEmptyString(data) {
      return string(data) && data !== '';
    }
    /**
     * Public function `contains`.
     *
     * Returns true if `data` is a string that contains `substring`, false
     * otherwise.
     */


    function contains(data, substring) {
      return string(data) && data.indexOf(substring) !== -1;
    }
    /**
     * Public function `match`.
     *
     * Returns true if `data` is a string that matches `regex`, false otherwise.
     */


    function match(data, regex) {
      return string(data) && !!data.match(regex);
    }
    /**
     * Public function `boolean`.
     *
     * Returns true if `data` is a boolean value, false otherwise.
     */


    function boolean(data) {
      return data === false || data === true;
    }
    /**
     * Public function `object`.
     *
     * Returns true if `data` is a plain-old JS object, false otherwise.
     */


    function object(data) {
      return Object.prototype.toString.call(data) === '[object Object]';
    }
    /**
     * Public function `emptyObject`.
     *
     * Returns true if `data` is an empty object, false otherwise.
     */


    function emptyObject(data) {
      return object(data) && Object.keys(data).length === 0;
    }
    /**
     * Public function `nonEmptyObject`.
     *
     * Returns true if `data` is a non-empty object, false otherwise.
     */


    function nonEmptyObject(data) {
      return object(data) && Object.keys(data).length > 0;
    }
    /**
     * Public function `instanceStrict`.
     *
     * Returns true if `data` is an instance of `prototype`, false otherwise.
     */


    function instanceStrict(data, prototype) {
      try {
        return data instanceof prototype;
      } catch (error) {
        return false;
      }
    }
    /**
     * Public function `instance`.
     *
     * Returns true if `data` is an instance of `prototype`, false otherwise.
     * Falls back to testing constructor.name and Object.prototype.toString
     * if the initial instanceof test fails.
     */


    function instance(data, prototype) {
      try {
        return instanceStrict(data, prototype) || data.constructor.name === prototype.name || Object.prototype.toString.call(data) === '[object ' + prototype.name + ']';
      } catch (error) {
        return false;
      }
    }
    /**
     * Public function `like`.
     *
     * Tests whether `data` 'quacks like a duck'. Returns true if `data` has all
     * of the properties of `archetype` (the 'duck'), false otherwise.
     */


    function like(data, archetype) {
      var name;

      for (name in archetype) {
        if (archetype.hasOwnProperty(name)) {
          if (data.hasOwnProperty(name) === false || typeof data[name] !== typeof archetype[name]) {
            return false;
          }

          if (object(data[name]) && like(data[name], archetype[name]) === false) {
            return false;
          }
        }
      }

      return true;
    }
    /**
     * Public function `array`.
     *
     * Returns true if `data` is an array, false otherwise.
     */


    function array(data) {
      return isArray(data);
    }
    /**
     * Public function `emptyArray`.
     *
     * Returns true if `data` is an empty array, false otherwise.
     */


    function emptyArray(data) {
      return array(data) && data.length === 0;
    }
    /**
     * Public function `nonEmptyArray`.
     *
     * Returns true if `data` is a non-empty array, false otherwise.
     */


    function nonEmptyArray(data) {
      return array(data) && greater(data.length, 0);
    }
    /**
     * Public function `arrayLike`.
     *
     * Returns true if `data` is an array-like object, false otherwise.
     */


    function arrayLike(data) {
      return assigned(data) && greaterOrEqual(data.length, 0);
    }
    /**
     * Public function `iterable`.
     *
     * Returns true if `data` is an iterable, false otherwise.
     */


    function iterable(data) {
      if (!haveSymbols) {
        // Fall back to `arrayLike` predicate in pre-ES6 environments.
        return arrayLike(data);
      }

      return assigned(data) && isFunction(data[Symbol.iterator]);
    }
    /**
     * Public function `includes`.
     *
     * Returns true if `data` contains `value`, false otherwise.
     */


    function includes(data, value) {
      var iterator, iteration, keys, length, i;

      if (!assigned(data)) {
        return false;
      }

      if (haveSymbols && data[Symbol.iterator] && isFunction(data.values)) {
        iterator = data.values();

        do {
          iteration = iterator.next();

          if (iteration.value === value) {
            return true;
          }
        } while (!iteration.done);

        return false;
      }

      keys = Object.keys(data);
      length = keys.length;

      for (i = 0; i < length; ++i) {
        if (data[keys[i]] === value) {
          return true;
        }
      }

      return false;
    }
    /**
     * Public function `hasLength`.
     *
     * Returns true if `data` has a length property that equals `length`, false
     * otherwise.
     */


    function hasLength(data, length) {
      return assigned(data) && data.length === length;
    }
    /**
     * Public function `date`.
     *
     * Returns true if `data` is a valid date, false otherwise.
     */


    function date(data) {
      return instanceStrict(data, Date) && integer(data.getTime());
    }
    /**
     * Public function `function`.
     *
     * Returns true if `data` is a function, false otherwise.
     */


    function isFunction(data) {
      return typeof data === 'function';
    }
    /**
     * Public function `apply`.
     *
     * Maps each value from the `data` to the corresponding predicate and returns
     * the result array. If the same function is to be applied across all of the
     * data, a single predicate function may be passed in.
     *
     */


    function apply(data, predicates) {
      assert.array(data);

      if (isFunction(predicates)) {
        return data.map(function (value) {
          return predicates(value);
        });
      }

      assert.array(predicates);
      assert.hasLength(data, predicates.length);
      return data.map(function (value, index) {
        return predicates[index](value);
      });
    }
    /**
     * Public function `map`.
     *
     * Maps each value from the `data` to the corresponding predicate and returns
     * the result object. Supports nested objects. If the `data` is not nested and
     * the same function is to be applied across all of it, a single predicate
     * function may be passed in.
     *
     */


    function map(data, predicates) {
      assert.object(data);

      if (isFunction(predicates)) {
        return mapSimple(data, predicates);
      }

      assert.object(predicates);
      return mapComplex(data, predicates);
    }

    function mapSimple(data, predicate) {
      var result = {};
      Object.keys(data).forEach(function (key) {
        result[key] = predicate(data[key]);
      });
      return result;
    }

    function mapComplex(data, predicates) {
      var result = {};
      Object.keys(predicates).forEach(function (key) {
        var predicate = predicates[key];

        if (isFunction(predicate)) {
          if (not.assigned(data)) {
            result[key] = !!predicate.m;
          } else {
            result[key] = predicate(data[key]);
          }
        } else if (object(predicate)) {
          result[key] = mapComplex(data[key], predicate);
        }
      });
      return result;
    }
    /**
     * Public function `all`
     *
     * Check that all boolean values are true
     * in an array (returned from `apply`)
     * or object (returned from `map`).
     *
     */


    function all(data) {
      if (array(data)) {
        return testArray(data, false);
      }

      assert.object(data);
      return testObject(data, false);
    }

    function testArray(data, result) {
      var i;

      for (i = 0; i < data.length; i += 1) {
        if (data[i] === result) {
          return result;
        }
      }

      return !result;
    }

    function testObject(data, result) {
      var key, value;

      for (key in data) {
        if (data.hasOwnProperty(key)) {
          value = data[key];

          if (object(value) && testObject(value, result) === result) {
            return result;
          }

          if (value === result) {
            return result;
          }
        }
      }

      return !result;
    }
    /**
     * Public function `any`
     *
     * Check that at least one boolean value is true
     * in an array (returned from `apply`)
     * or object (returned from `map`).
     *
     */


    function any(data) {
      if (array(data)) {
        return testArray(data, true);
      }

      assert.object(data);
      return testObject(data, true);
    }

    function mixin(target, source) {
      Object.keys(source).forEach(function (key) {
        target[key] = source[key];
      });
      return target;
    }
    /**
     * Public modifier `assert`.
     *
     * Throws if `predicate` returns false.
     */


    function assertModifier(predicate, defaultMessage) {
      return function () {
        return assertPredicate(predicate, arguments, defaultMessage);
      };
    }

    function assertPredicate(predicate, args, defaultMessage) {
      var argCount = predicate.l || predicate.length;
      var message = args[argCount];
      var ErrorType = args[argCount + 1];
      assertImpl(predicate.apply(null, args), nonEmptyString(message) ? message : defaultMessage, isFunction(ErrorType) ? ErrorType : TypeError);
      return args[0];
    }

    function assertImpl(value, message, ErrorType) {
      if (value) {
        return value;
      }

      throw new (ErrorType || Error)(message || 'Assertion failed');
    }
    /**
     * Public modifier `not`.
     *
     * Negates `predicate`.
     */


    function notModifier(predicate) {
      var modifiedPredicate = function () {
        return notImpl(predicate.apply(null, arguments));
      };

      modifiedPredicate.l = predicate.length;
      return modifiedPredicate;
    }

    function notImpl(value) {
      return !value;
    }
    /**
     * Public modifier `maybe`.
     *
     * Returns true if predicate argument is  null or undefined,
     * otherwise propagates the return value from `predicate`.
     */


    function maybeModifier(predicate) {
      var modifiedPredicate = function () {
        if (not.assigned(arguments[0])) {
          return true;
        }

        return predicate.apply(null, arguments);
      };

      modifiedPredicate.l = predicate.length; // Hackishly indicate that this is a maybe.xxx predicate.
      // Without this flag, the alternative would be to iterate
      // through the maybe predicates or use indexOf to check,
      // which would be time-consuming.

      modifiedPredicate.m = true;
      return modifiedPredicate;
    }

    function maybeImpl(value) {
      if (assigned(value) === false) {
        return true;
      }

      return value;
    }
    /**
     * Public modifier `of`.
     *
     * Applies the chained predicate to members of the collection.
     */


    function ofModifier(target, type, predicate) {
      var modifiedPredicate = function () {
        var collection, args;
        collection = arguments[0];

        if (target === 'maybe' && not.assigned(collection)) {
          return true;
        }

        if (!type(collection)) {
          return false;
        }

        collection = coerceCollection(type, collection);
        args = slice.call(arguments, 1);

        try {
          collection.forEach(function (item) {
            if ((target !== 'maybe' || assigned(item)) && !predicate.apply(null, [item].concat(args))) {
              // TODO: Replace with for...of when ES6 is required.
              throw 0;
            }
          });
        } catch (ignore) {
          return false;
        }

        return true;
      };

      modifiedPredicate.l = predicate.length;
      return modifiedPredicate;
    }

    function coerceCollection(type, collection) {
      switch (type) {
        case arrayLike:
          return slice.call(collection);

        case object:
          return Object.keys(collection).map(function (key) {
            return collection[key];
          });

        default:
          return collection;
      }
    }

    function createModifiedPredicates(modifier, object) {
      return createModifiedFunctions([modifier, predicates, object]);
    }

    function createModifiedFunctions(args) {
      var modifier, object, functions, result;
      modifier = args.shift();
      object = args.pop();
      functions = args.pop();
      result = object || {};
      Object.keys(functions).forEach(function (key) {
        Object.defineProperty(result, key, {
          configurable: false,
          enumerable: true,
          writable: false,
          value: modifier.apply(null, args.concat(functions[key], messages[key]))
        });
      });
      return result;
    }

    function createModifiedModifier(modifier, modified) {
      return createModifiedFunctions([modifier, modified, null]);
    }

    function createOfPredicates(key) {
      predicates[key].of = createModifiedFunctions([ofModifier.bind(null, null), predicates[key], predicates, null]);
    }

    function createOfModifiers(base, modifier) {
      collections.forEach(function (key) {
        base[key].of = createModifiedModifier(modifier, predicates[key].of);
      });
    }

    function createMaybeOfModifiers(key) {
      maybe[key].of = createModifiedFunctions([ofModifier.bind(null, 'maybe'), predicates[key], predicates, null]);
      assert.maybe[key].of = createModifiedModifier(assertModifier, maybe[key].of);
      assert.not[key].of = createModifiedModifier(assertModifier, not[key].of);
    }

    function exportFunctions(functions) {
      if (module !== null && module.exports) {
        module.exports = functions;
      } else {
        globals.check = functions;
      }
    }
  })(commonjsGlobal);
});var asserttype = chai => {
  const types = ['number', 'string', 'boolean', 'object', 'array', 'date', 'function'];
  types.forEach(type => {
    chai.Assertion.addMethod(type, function () {
      this.assert(checkTypes[type](this._obj), `expected #{this} to be ${type}`, `expected #{this} not to be ${type}`);
    });
  });
};var chaiEvents = createCommonjsModule(function (module, exports) {
  function plugin(chai, utils) {
    var Assertion = chai.Assertion;
    /**
     * Checks if a given entry is an event emitter.
     * Uses EventEmitter or EventTarget if available to quickly check `instanceof`.  Otherwise, checks that common methods
     * to event emitters are available.
     *
     * Gracefully handles custom implementations of event emitters even if EventEmitter or EventTarget are available,
     * checking methods if the emitter doesn't inherit from the global emitter.
    */

    function isEmitter() {
      // Easy check: if Node's EventEmitter or window.EventEmitter exist, check if this is an instance of it.
      if (typeof EventEmitter !== "undefined" && EventEmitter !== null && this._obj instanceof EventEmitter) {
        return this.assert(true, "", "expected #{this} to not be an EventEmitter");
      } // Easy check: if the browser's EventTarget exists, check if this is an instance of it.


      if (typeof EventTarget !== "undefined" && EventTarget !== null && this._obj instanceof EventTarget) {
        return this.assert(true, "", "expected #{this} to not be an EventTarget");
      }

      var obj = this._obj; // Check for Node.js style event emitters with "on", "emit", etc.

      var node = ["on", "emit"].every(function (method) {
        return typeof obj[method] === "function";
      });

      if (node) {
        return this.assert(true, "", "expected #{this} to not be an EventEmitter");
      } // Check for Browser-based event emitters with "addEventListener", etc.


      var browser = ["addEventListener", "dispatchEvent", "removeEventListener"].every(function (method) {
        return typeof obj[method] === "function";
      });

      if (browser) {
        return this.assert(true, "", "expected #{this} to not be an EventEmitter");
      }

      this.assert(false, "expected #{this} to be an EventEmitter", "");
    }
    Assertion.addProperty("emitter", isEmitter);
    Assertion.addProperty("target", isEmitter);
    Assertion.addMethod("emit", function (name, args) {
      new Assertion(this._obj).to.be.an.emitter;
      new Assertion(name).to.be.a("string");
      var obj = this._obj;

      var _this = this;

      var assert = function () {
        _this.assert.apply(_this, arguments);
      };

      var timeout = utils.flag(this, 'timeout') || 1500;

      if (utils.flag(this, 'negate')) {
        // Ensure that the event doesn't fire before timeout
        return new Promise(function (resolve, reject) {
          var done = false;
          obj.on(name, function () {
            if (done) {
              return;
            }

            done = true;
            assert(false, "expected #{this} to not emit " + name + ".");
            resolve();
          });
          setTimeout(function () {
            if (done) {
              return;
            }

            done = true;
            resolve();
          }, timeout);
        });
      } else {
        // Ensure that the event fires
        return new Promise(function (resolve, reject) {
          var done = false;
          obj.on(name, function () {
            if (done) {
              return;
            }

            done = true;
            resolve();
          });
          setTimeout(function () {
            if (done) {
              return;
            }

            done = true;
            assert(false, "expected #{this} to emit " + name + ".");
            resolve();
          }, timeout);
        });
      }
    });
  }

  if (typeof commonjsRequire === "function" && 'object' === "object" && 'object' === "object") {
    module.exports = plugin;
  } else {
    // Other environment (usually <script> tag): plug in to global chai instance directly.
    chai.use(plugin);
  }
});var registered;
registered = false;

function registerAnimations() {
  if (registered) {
    return;
  }

  registered = true;
  index.animation('checkmarkAnimateSuccessTip', {
    '0%, 54%': {
      width: 0,
      left: 0,
      top: 3
    },
    '70%': {
      width: 14,
      left: -2,
      top: 8
    },
    '84%': {
      width: 5,
      left: 5,
      top: 10
    },
    '100%': {
      width: 8,
      left: 3,
      top: 10
    }
  });
  index.animation('checkmarkAnimateSuccessLong', {
    '0%, 65%': {
      width: 0,
      right: 12,
      top: 12
    },
    '84%': {
      width: 14,
      right: 0,
      top: 7
    },
    '100%': {
      width: 12,
      right: 2,
      top: 8
    }
  });
  index.animation('checkmarkAnimateError', {
    '0%, 65%': {
      transform: 'scale(0.4)',
      opacity: 0
    },
    '84%': {
      transform: 'scale(1.15)'
    },
    '100%': {
      transform: 'scale(1)'
    }
  });
  index.animation('checkmarkRotatePlaceholder', {
    '0%, 5%': {
      transform: 'rotate(-45deg)'
    },
    '12%, 100%': {
      transform: 'rotate(-405deg)'
    }
  });
  return index.animation('fieldErrorShake', {
    '0%, 50%': {
      transform: 'translateX(-10px)'
    },
    '25%, 75%': {
      transform: 'translateX(10px)'
    },
    '100%': {
      transform: 'translateX(0px)'
    }
  });
}var IS$2;
IS$2 = index$1.create('natives', 'dom');
IS$2.load({
  // field: (target)-> target and target instanceof Field
  regex: function (target) {
    return target instanceof RegExp;
  },
  objectable: function (target) {
    return IS$2.object(target) || IS$2.function(target);
  }
});
var IS$1$1 = IS$2;/* istanbul ignore next */
if (window.console == null) {
  window.console = {};
}
/* istanbul ignore next */


if (console.log == null) {
  console.log = function () {};
}
/* istanbul ignore next */


if (console.warn == null) {
  console.warn = console.log;
}var simplybind = createCommonjsModule(function (module) {
  (function (t) {
    if (t = function (e, i, s) {
      return function (n) {
        if (!i[n]) throw Error(n + " is not a module");
        return e[n] ? e[n].exports : (e[n] = {
          exports: {}
        }, e[n].exports = i[n].call(s, t, e[n], e[n].exports));
      };
    }({}, {
      0: function (t, e, i) {
        var s = 0,
            n = "push pop shift unshift splice reverse sort".split(" "),
            r = {},
            h = {},
            o = ["{{", "}}"],
            u = Object.create({
          silent: !1
        }, {
          placeholder: {
            get: function () {
              return o;
            },
            set: function (t) {
              O.iA(t) && 2 === t.length && (o = t, C());
            }
          }
        }),
            c = {
          delay: !1,
          throttle: !1,
          simpleSelector: !1,
          promiseTransforms: !1,
          dispatchEvents: !1,
          sendArrayCopies: !1,
          updateEvenIfSame: !1,
          updateOnBind: !0
        },
            a = Object.defineProperty,
            f = Object.getOwnPropertyDescriptor,
            l = null,
            p = function () {
          if (!l) {
            var t = l = document.createEvent("Event");
            t.initEvent("change", !0, !1), t._sb = !0;
          }

          return l;
        },
            d = !("className" in Element.prototype && f(Element.prototype, "className").get),
            v = "innerWidth innerHeight outerWidth outerHeight scrollX scrollY pageXOffset pageYOffset screenX screenY screenLeft screenTop".split(" "),
            b = function (t, e) {
          return this.uAS(e || this);
        },
            g = function () {
          return "" + ++s;
        },
            y = function () {
          return Object.create(null);
        },
            _ = function (t, e) {
          return function (i, s, n) {
            return H(i, s, n, t, e);
          };
        },
            m = function (t, e) {
          return t.sU || (t.sU = new R(function () {
            return e ? t.sV(t.fDV(), t, !0) : t.uAS(t);
          }, "Func", {}));
        },
            D = function (t, e) {
          return t && -1 !== t.indexOf(e);
        },
            O = {
          iD: function (t) {
            return void 0 !== t;
          },
          iA: function (t) {
            return t instanceof Array;
          },
          iO: function (t) {
            return "object" == typeof t && t;
          },
          iS: function (t) {
            return "string" == typeof t;
          },
          iN: function (t) {
            return "number" == typeof t;
          },
          iF: function (t) {
            return "function" == typeof t;
          },
          iBI: function (t) {
            return t instanceof X;
          },
          iB: function (t) {
            return t instanceof R;
          },
          isI: function (t) {
            return O.iO(t) && O.iN(t.length);
          },
          DM: function (t) {
            return t.nodeName && 1 === t.nodeType;
          },
          dI: function (t) {
            return "INPUT" === (t = t.nodeName) || "TEXTAREA" === t || "SELECT" === t;
          },
          dR: function (t) {
            return "radio" === t.type;
          },
          dC: function (t) {
            return "checkbox" === t.type;
          },
          eC: function (t) {
            return t instanceof NodeList || t instanceof HTMLCollection || window.jQuery && t instanceof jQuery;
          },
          eAS: function (t) {
            var e = t[0].type;
            return [].filter.call(t, function (t) {
              return t.type === e;
            }).length === t.length;
          },
          dN: function (t) {
            return O.DM(t) || t === window || t === document;
          }
        },
            M = function (t, e, i) {
          var s;
          return (s = f(t, e)) ? (i && (s.configurable = !0), s) : (t = Object.getPrototypeOf(t)) ? M(t, e, !0) : void 0;
        },
            I = function (t, e, i) {
          var s;
          if (t.OD || (t.OD = M(e, t.pr)), i) n.forEach(function (i) {
            return a(e, i, {
              configurable: !0,
              value: function () {
                var s = Array.prototype[i].apply(e, arguments);
                return t.uAS(t), s;
              }
            });
          });else if ("Proxy" === t.type) {
            var h = t.oR = t.value;

            if (t.value = {
              result: null,
              args: null
            }, O.iF(h)) {
              var o = [].slice,
                  u = s = function () {
                var i = o.call(arguments);
                return t.value.args = i = t.tfS ? t.tfS(i) : i, t.value.result = i = h.apply(e, i), t.uAS(t), i;
              };

              a(e, t.pr, {
                configurable: t.isL = !0,
                get: function () {
                  return u;
                },
                set: function (e) {
                  O.iF(e) ? e !== h && (e !== s && (h = t.oR = e), u !== s && (u = s)) : u = e;
                }
              });
            }
          } else if (!(D(t.type, "DOM") || t.object === window && D(v, t.pr))) {
            (i = t.OD || r).get && (t.OG = i.get.bind(e)), i.set && (t.OS = i.set.bind(e));
            var c = (c = i.configurable) && e.constructor !== CSSStyleDeclaration;

            if (d && t.DM && t.pr in e.cloneNode(!1) && (t.OD = c = !1, t.isL = !0, t.OG = function () {
              return t.object[t.pr];
            }, t.OS = function (e) {
              return t.object[t.pr] = e;
            }), c) {
              c = "Array" === t.type;
              var f = !t.OS && !c;
              a(e, t.pr, {
                configurable: t.isL = !0,
                enumerable: i.enumerable,
                get: t.OG || function () {
                  return t.value;
                },
                set: function (e) {
                  t.sV(e, t, f);
                }
              }), c && I(t, e[t.pr], !0);
            }
          }
        },
            j = function (t, e, i) {
          if (i) {
            var s = [];

            for (t = 0, i = n.length; t < i; t++) {
              var r = n[t];
              s.push(delete e[r]);
            }

            return s;
          }

          return (i = t.OD).set || i.get || (i.value = t.oR || t.value), a(e, t.pr, i);
        },
            S = function (t) {
          var e,
              i = y();

          for (e in t) i[e] = t[e];

          return i;
        },
            E = function (t, e) {
          var i,
              s = Object.keys(e),
              n = 0;

          for (i = s.length; n < i; n++) {
            var r = s[n];
            t[r] = e[r];
          }
        },
            P = {
          get: function (t, e, i, s) {
            return e ? h[t._sb_ID] : s && t[0]._sb_map && (e = h[t[0]._sb_map[i]]).gB ? e.gB : t._sb_map && t._sb_map[i] ? h[t._sb_map[i]] : void 0;
          },
          set: function (t, e) {
            if (e) a(t.object, "_sb_ID", {
              configurable: !0,
              value: t.ID
            });else {
              var i = t.se;
              t.object._sb_map ? t.object._sb_map[i] = t.ID : (e = {}, e[i] = t.ID, a(t.object, "_sb_map", {
                configurable: !0,
                value: e
              }));
            }
          }
        },
            V,
            N = /[.*+?^${}()|[\]\\]/g,
            A = V = null,
            C = function () {
          var t = u.placeholder[0].replace(N, "\\$&"),
              e = u.placeholder[1].replace(N, "\\$&"),
              i = "[^" + e + "]+";
          A = new RegExp(t + "(" + i + ")" + e, "g"), V = new RegExp("" + t + i + e, "g");
        };

        C();

        var x = function (t, e, i) {
          var s,
              n,
              r = "",
              h = s = 0;

          for (n = t.length; s < n; h = ++s) r += t[h], i[h] && (r += e[i[h]]);

          return r;
        },
            k = function (t, e, i) {
          null == t[i] && (t[i] = []), t[i].push(e);
        },
            B = function (t, e) {
          var i,
              s,
              n,
              r = 0;

          for (s = (t = Array.prototype.slice.call(t.childNodes)).length; r < s; r++) {
            var h = t[r];
            if (3 !== h.nodeType) B(h, e);else if (h.textContent.match(V)) {
              var o = h.textContent.split(A);
              if (3 === o.length && "" === o[0] + o[2]) k(e, h, o[1]);else {
                var u = document.createDocumentFragment(),
                    c = i = 0;

                for (n = o.length; i < n; c = ++i) {
                  var a = o[c],
                      f = u.appendChild(document.createTextNode(a));
                  c % 2 && k(e, f, a);
                }

                h.parentNode.replaceChild(u, h);
              }
            }
          }
        },
            F = function (t) {
          throw Error("SimplyBind: " + (T[t] || t));
        },
            G = function (t, e) {
          u.silent || (e = L(e), t = T[t], console.warn("SimplyBind: " + t + "\n\n" + e));
        },
            w = function (t) {
          F("Invalid argument/s (" + t + ")", !0);
        },
            L = function (t) {
          return (Error().stack || "").split("\n").slice(t + 3).join("\n");
        },
            T = {
          erIP: "SimplyBind() and .to() only accept a function, an array, a bound object, a string, or a number.",
          erFN: "Only functions are allowed for .transform/.condition/All()",
          erEV: "Invalid argument number in .ofEvent()",
          emptyList: "Empty collection provided",
          erOD: "You can only pass a single DOM element to a binding",
          erMX: "'checked' of Mixed list of element cannot be bound"
        },
            H = function (t, e, i, s, n) {
          return (t || 0 === t) && (O.iS(t) || O.iN(t) || O.iF(t) || t instanceof Array) || O.iBI(t) || F("erIP"), !O.iO(t) || t instanceof Array ? (e = new X(e), e.so = i, e.IS = s, e.cC = n, t = O.iF(t) ? e.sS(t, !0) : e.sP(t)) : t = n ? n(t) : t.sC(), t;
        };

        H.version = "1.15.8", H.settings = u, H.defaultOptions = c, H.unBindAll = function (t, e) {
          var i;

          if (t && (O.iO(t) || O.iF(t))) {
            O.isI(t) && !t._sb_ID && t[0] && O.DM(t[0]) && (t = t[0]);
            var s = t._sb_map;
            if (t._sb_ID && h[t._sb_ID].rAS(e), s) for (i in s) t = s[i], h[t].rAS(e);
          }
        };

        var R = function (t, e, i) {
          return E(this, i), this.oD = this.so ? this.options : c, this.type = e, this.object = t, this.ID = g(), this.subs = [], this.sM = y(), this.pM = y(), this.atEV = [], "Proxy" === this.type && (this.sV = b), this.mC && (this.cH = y(), this.object.forEach(function (t) {
            return function (e) {
              var i = t.cH[e.value] = H("checked").of(e)._;

              i.aS(t), i.sM[t.ID].tF = function () {
                return i;
              }, i.gB = t;
            };
          }(this))), "Event" === this.type || "Func" === this.type && this.IS || ("Pholder" === this.type ? (e = this.de && !D(this.de, "multi") ? this.de + ":" + this.pr : this.pr, (t = this.pB = H(e).of(t)._).sPH(), this.value = t.pVL[this.Ph], t.txN && (this.txN = t.txN[this.Ph])) : (this.value = t = this.fDV(), "ObjectProp" !== this.type || O.iD(t) || f(this.object, this.pr) || (this.object[this.pr] = t), I(this, this.object))), this.aEV(), h[this.ID] = this;
        };

        R.prototype = {
          aS: function (t, e, i, s) {
            var n;

            if (t.isMulti) {
              var r = t.bindings;

              for (t = 0, n = r.length; t < n; t++) {
                var h = r[t];
                this.aS(h, e, i, s);
              }
            } else if (this.sM[t.ID]) var o = !0;else t.pM[this.ID] = this, this.subs.unshift(t), (n = this.sM[t.ID] = y()).uO = i, n.opts = S(e), (s || "Event" === this.type || "Proxy" === this.type || "Array" === this.type) && (n.opts.updateEvenIfSame = !0), n.VR = "Func" === t.type ? "ps" : "value";

            return o;
          },
          rS: function (t, e) {
            var i;

            if (t.isMulti) {
              var s = t.bindings;

              for (t = 0, i = s.length; t < i; t++) {
                var n = s[t];
                this.rS(n, e);
              }
            } else this.sM[t.ID] && (this.subs.splice(this.subs.indexOf(t), 1), delete this.sM[t.ID], delete t.pM[this.ID]), e && (t.rS(this), delete this.pM[t.ID]);

            0 === this.subs.length && 0 === Object.keys(this.pM).length && this.DES();
          },
          rAS: function (t) {
            var e,
                i = this.subs.slice(),
                s = 0;

            for (e = i.length; s < e; s++) {
              var n = i[s];
              this.rS(n, t);
            }
          },
          DES: function () {
            var t;

            if (delete h[this.ID], this.rPI(), "Event" === this.type) {
              var e = this.atEV,
                  i = 0;

              for (t = e.length; i < t; i++) {
                var s = e[i];
                this.urEVE(s);
              }
            } else "Func" === this.type && delete this.object._sb_ID;

            this.isL && this.OD && j(this, this.object), "Array" === this.type && j(this, this.value, !0), this.object._sb_map && (delete this.object._sb_map[this.se], 0 === Object.keys(this.object._sb_map).length && delete this.object._sb_map);
          },
          fDV: function () {
            var t,
                e = this.type;

            switch (!1) {
              case "Func" !== e:
                return this.object();

              case "DOMAttr" !== e:
                return this.object.getAttribute(this.pr) || "";

              case !this.mC:
                var i = [],
                    s = this.cH;

                for (t in s) if (s[t].object.checked) {
                  if ("DOMRadio" === e) return t;
                  i.push(t);
                }

                return i;

              default:
                return this.object[this.pr];
            }
          },
          sV: function (t, e, i, s) {
            if (e || (e = this), this.tfS && (t = this.tfS(t)), !i) switch (this.type) {
              case "ObjectProp":
                if (this.isL) {
                  if (this.dI) {
                    if (s) {
                      if (t !== this.OG()) {
                        var n = this.object.selectionStart;
                        this.OS(t), n && this.object.setSelectionRange(n, n);
                      }
                    } else this.OS(t), u.dispatchEvents && this.object.dispatchEvent(p());
                  } else this.OS && this.OS(t);
                } else t !== this.value && (this.object[this.pr] = t);
                break;

              case "Pholder":
                if (s = this.pB, s.pVL[this.Ph] = t, n = x(s.pCT, s.pVL, s.pIM), this.txN && t !== this.value) {
                  var r = this.txN,
                      h = 0;

                  for (i = r.length; h < i; h++) {
                    var o = r[h];
                    o.textContent = t;
                  }
                }

                "textContent" !== this.pr && s.sV(n, e);
                break;

              case "Array":
                t !== this.value && (O.iA(t) || (t = Array.prototype.concat(t)), j(this, this.value, !0), I(this, t = t.slice(), !0), this.OS && this.OS(t));
                break;

              case "Func":
                n = this.ps, this.ps = t, t = this.object(t, n);
                break;

              case "Event":
                this.iE = !0, this.eE(t), this.iE = !1;
                break;

              case "DOMRadio":
                if (this.mC) {
                  if (s = O.iB(t) ? t : this.cH[t]) for (h in t = s.object.value, n = this.cH) (i = n[h]).sV(i.ID === s.ID, e);else t = this.value;
                } else {
                  if ((t = !!t) === this.value) return;
                  this.object.checked !== t && (this.object.checked = t), t && u.dispatchEvents && this.object.dispatchEvent(p());
                }
                break;

              case "DOMCheckbox":
                if (this.mC) {
                  for (h = !O.iB(t), i = s = 0, r = (t = [].concat(t)).length; s < r; i = ++s) o = t[i], t[i] = O.iB(o) ? o : this.cH[o];

                  r = [], o = this.cH;

                  for (n in o) i = o[n], s = h ? D(t, i) : i.value, i.sV(s, e), s && r.push(n);

                  t = r;
                } else {
                  if ((t = !!t) === this.value) return;
                  this.object.checked !== t && (this.object.checked = t, u.dispatchEvents && this.object.dispatchEvent(p()));
                }

                break;

              case "DOMAttr":
                this.object.setAttribute(this.pr, t);
            }
            this.value = t, this.uAS(e);
          },
          uAS: function (t) {
            var e, i;
            if (i = (e = this.subs).length) for (; i--;) this.uS(e[i], t);
          },
          uS: function (t, e, i) {
            var s;

            if (!(e === t || e !== this && e.sM[t.ID])) {
              var n = this.sM[t.ID];

              if (!n.dL || !n.dL[e.ID]) {
                if (n.opts.throttle) {
                  var r = (i = +new Date()) - n.lU;
                  if (r < n.opts.throttle) return clearTimeout(n.uT), n.uT = setTimeout(function (i) {
                    return function () {
                      if (i.sM[t.ID]) return i.uS(t, e);
                    };
                  }(this), n.opts.throttle - r);
                  n.lU = i;
                } else if (n.opts.delay && !i) return setTimeout(function (i) {
                  return function () {
                    if (i.sM[t.ID]) return i.uS(t, e, !0);
                  };
                }(this), n.opts.delay);

                i = "Array" === this.type && n.opts.sendArrayCopies ? this.value.slice() : this.value, r = t[n.VR], (i = (s = n.tF) ? s(i, r, t.object) : i) === r && !n.opts.updateEvenIfSame || n.cN && !n.cN(i, r, t.object) || (n.opts.promiseTransforms && i && O.iF(i.then) ? i.then(function (i) {
                  t.sV(i, e);
                }) : t.sV(i, e), n.uO && this.rS(t));
              }
            }
          },
          aM: function (t, e, i, s) {
            var n, r;

            if (O.iF(i)) {
              var h = 0;

              for (r = e.length; h < r; h++) {
                var o = e[h],
                    u = o._ || o;
                u.isMulti ? this.aM(t, u.bindings, i, s) : (o = this.sM[u.ID], o[t] = i, s = s && !o.uO, this.pM[u.ID] && ((n = u.sM[this.ID])[t] || (n[t] = i)), !s && "Func" !== this.type || "tF" !== t || this.uS(u, this));
              }

              return !0;
            }

            return G("erFN", 2);
          },
          ss: function (t, e) {
            this.tfS = t, e && this.sV(this.value);
          },
          aD: function (t, e) {
            var i;
            (null != (i = this.sM[t.ID]).dL ? i.dL : i.dL = y())[e.ID] = 1;
          },
          sPH: function () {
            if (!this.pVL) {
              if (this.pVL = y(), this.pIM = y(), this.pCT = [], O.iS(this.value)) {
                this.pCT = this.value.split(V);
                var t = 0;
                this.value = this.value.replace(A, function (e) {
                  return function (i, s) {
                    return e.pIM[t++] = s, e.pVL[s] = s;
                  };
                }(this));
              }

              this.DM && "textContent" === this.pr && B(this.object, this.txN = y());
            }
          },
          aPI: function (t) {
            if ("Event" !== this.type) return this.rPI(), this.PI = setInterval(function (t) {
              return function () {
                var e = t.fDV();
                return t.sV(e, t, !0);
              };
            }(this), t);
          },
          rPI: function () {
            return clearInterval(this.PI), this.PI = null;
          },
          aUV: function (t, e) {
            this.object.addEventListener(t, function (t) {
              return function (i) {
                i._sb || (i = t.tfS && t.dI, t.sV(t.object[e], null, !i, !0));
              };
            }(this), !1);
          },
          aEV: function () {
            this.evN ? this.rEVE(this.evN) : this.dI ? (this.aUV("input", "value"), this.aUV("change", "value")) : this.mC || "DOMRadio" !== this.type && "DOMCheckbox" !== this.type || this.aUV("change", "checked");
          },
          rEVE: function (t) {
            this.atEV.push(t), this.evH || (this.evH = U.bind(this)), this.object[this.eM.listen](t, this.evH);
          },
          urEVE: function (t) {
            this.atEV.splice(this.atEV.indexOf(t), 1), this.object[this.eM.remove](t, this.evH);
          },
          eE: function (t) {
            var e = this.evN;
            "dispatchEvent" === this.eM.emit && (this.evO || (this.evO = document.createEvent("Event"), this.evO.initEvent(this.evN, !0, !0)), this.evO.bindingData = t, e = this.evO), this.object[this.eM.emit](e, t);
          }
        };

        var U = function () {
          this.iE || this.sV(arguments[this.pr], null, !0);
        },
            X = function (t, e) {
          var i;
          if (e) E(this, e), this.sG = 1;else for (i in this.sG = 0, this.subs = [], this.oP = t || (t = {}), this.options = {}, c) this.options[i] = null != t[i] ? t[i] : c[i];
          return this;
        };

        t = {
          sC: function () {
            return new X(null, this);
          },
          dM: function (t) {
            return this._ = t, Object.defineProperties(this, {
              value: {
                get: function () {
                  return t.value;
                }
              },
              original: {
                get: function () {
                  return t.objects || t.object;
                }
              },
              subscribers: {
                get: function () {
                  return t.subs.slice().map(function (t) {
                    return t.object;
                  });
                }
              }
            });
          },
          createBP: function (t, e, i, s) {
            var n;
            return this.object = t, (n = P.get(t, s, this.se, this.mC)) ? this.patchCachedBP(n) : (t = new R(t, e, i), P.set(t, s), t);
          },
          patchCachedBP: function (t) {
            var e;

            if ("ObjectProp" !== t.type || this.pr in this.object || I(t, this.object), this.so) {
              var i = this.oP;

              for (n in i) {
                var s = i[n];
                t.oD[n] = s;
              }
            }

            var n = t.oD;

            for (e in n) s = n[e], this.options[e] = O.iD(this.oP[e]) ? this.oP[e] : s;

            return t;
          },
          sP: function (t) {
            if (O.iN(t) && (t = t.toString()), this.se = this.pr = t, !this.options.simpleSelector) {
              if (D(t, ":")) {
                var e = t.split(":");
                this.de = e.slice(0, -1).join(":"), this.pr = e[e.length - 1];
              }

              D(t, ".") && (e = this.pr.split("."), this.pr = e[0], this.Ph = e.slice(1).join(".")), D(this.de, "event") && (D(t, "#") ? (e = this.pr.split("#"), this.evN = e[0], this.pr = e[1]) : (this.evN = this.pr, this.pr = 0), isNaN(parseInt(this.pr)) && G("erEV", 1));
            }

            return this;
          },
          sS: function (t, e) {
            this.sG = 1;
            var i,
                s = (i = t !== window && O.isI(t) && !t.nodeType) ? t[0] : t;

            if (s) {
              if (this.DM = O.DM(s)) {
                if ("checked" === this.pr) var n = s && O.dR(s),
                    r = !n && s && O.dC(s);else "value" === this.pr && (this.dI = O.dI(s));
                if (i && !D(this.de, "multi")) if (1 === t.length) t = t[0];else {
                  if ((n || r) && !O.eAS(t)) return G("erMX", 3);
                  n || r ? (this.mC = !0, t = [].slice.call(t)) : (t = t[0], G("erOD", 3));
                }
              }
            } else i && O.eC(t) && F("emptyList");

            switch (!1) {
              case !e:
                r = "Func";
                break;

              case !this.Ph:
                r = "Pholder";
                break;

              case !(D(this.de, "array") && O.iA(t[this.pr])):
                r = "Array";
                break;

              case !D(this.de, "event"):
                r = "Event", this.eM = {
                  listen: this.oP.listenMethod,
                  remove: this.oP.removeMethod,
                  emit: this.oP.emitMethod
                }, t[this.eM.listen] || (this.eM.listen = O.dN(t) ? "addEventListener" : "on"), t[this.eM.remove] || (this.eM.remove = O.dN(t) ? "removeEventListener" : "removeListener"), t[this.eM.emit] || (this.eM.emit = O.dN(t) ? "dispatchEvent" : "emit");
                break;

              case !D(this.de, "func"):
                r = "Proxy";
                break;

              case !n:
                r = "DOMRadio";
                break;

              case !r:
                r = "DOMCheckbox";
                break;

              case !D(this.de, "attr"):
                r = "DOMAttr";
                break;

              default:
                r = "ObjectProp";
            }

            return D(this.de, "multi") ? (t.length || F("emptyList"), this.dM(new nt(this, t, r))) : this.dM(this.createBP(t, r, this, e)), D(this._.type, "Event") || D(this._.type, "Proxy") ? this.options.updateOnBind = !1 : D(this._.type, "Func") && (this.options.updateOnBind = !0), this.cC ? this.cC(this) : this;
          },
          aP: function (t) {
            var e;
            t.sG = 2, t.subs.push(this);

            var i = t._.aS(this._, t.options, t.uO);

            if (t.uO) delete t.uO;else if (t.options.updateOnBind && !i) if (this._.isMulti) {
              var s = this._.bindings,
                  n = 0;

              for (e = s.length; n < e; n++) i = s[n], t._.uS(i, t._);
            } else t._.uS(this._, t._);
          }
        }, X.prototype = Object.create(t, {
          of: {
            get: function () {
              if (!this.sG) return W;
            }
          },
          set: {
            get: function () {
              if (this.sG) return $;
            }
          },
          chainTo: {
            get: function () {
              if (2 === this.sG) return Y;
            }
          },
          transformSelf: {
            get: function () {
              if (1 === this.sG) return Q;
            }
          },
          transform: {
            get: function () {
              if (2 === this.sG) return q;
            }
          },
          transformAll: {
            get: function () {
              if (2 === this.sG) return z;
            }
          },
          condition: {
            get: function () {
              if (2 === this.sG) return J;
            }
          },
          conditionAll: {
            get: function () {
              if (2 === this.sG) return K;
            }
          },
          bothWays: {
            get: function () {
              if (2 === this.sG) return Z;
            }
          },
          unBind: {
            get: function () {
              if (2 === this.sG) return tt;
            }
          },
          pollEvery: {
            get: function () {
              if (this.sG) return et;
            }
          },
          stopPolling: {
            get: function () {
              if (this.sG) return it;
            }
          },
          setOption: {
            get: function () {
              if (2 === this.sG) return st;
            }
          },
          disallowFrom: {
            get: function () {
              var t;
              if (2 === this.sG && (t = this)) return _(!1, function (e) {
                return t._.aD(t.subs[t.subs.length - 1]._, e._), t;
              });
            }
          },
          updateOn: {
            get: function () {
              var t;
              if (this.sG && (t = this)) return _(!1, function (e) {
                return e._ !== t._ && (t._.pM[e._.ID] = e._, e._.aS(m(t._, !0), e.options, !1, !0)), t;
              });
            }
          },
          removeUpdater: {
            get: function () {
              var t, e;
              if (this.sG && (e = this) && (t = this._.sU)) return _(!1, function (i) {
                i._.sM[t.ID] && (delete e._.pM[i._.ID], i._.rS(t));
              });
            }
          },
          to: {
            get: function () {
              var t;
              if (1 === this.sG && (t = this)) return _(!0, function (e) {
                return e._ !== t._ && e.aP(t), t;
              });
            }
          },
          and: {
            get: function () {
              var t = this.sC();
              if (2 === this.sG) return t;

              if (1 === this.sG) {
                if (!t._.isMulti) {
                  var e = t._;
                  t._ = t._ = new nt(t), t._.addBP(e);
                }

                return _(!1, function (e) {
                  return t._.addBP(e._), t;
                });
              }
            }
          },
          once: {
            get: function () {
              if (1 === this.sG) {
                var t = this.sC();
                return t.uO = !0, t;
              }
            }
          },
          update: {
            get: function () {
              return this.set;
            }
          },
          twoWay: {
            get: function () {
              return this.bothWays;
            }
          },
          pipe: {
            get: function () {
              return this.chainTo;
            }
          }
        });

        var W = function (t) {
          return O.iO(t) || O.iF(t) || w(t), O.iBI(t) && (t = t.object), this.sG = 1, this.sS(t);
        },
            Y = function (t, e, i) {
          return H(this.subs[this.subs.length - 1]).to(t, e, i);
        },
            $ = function (t) {
          return this._.sV(t), this;
        },
            Q = function (t) {
          return O.iF(t) ? this._.ss(t, this.options.updateOnBind) : G("erFN", 1), this;
        },
            q = function (t) {
          return this._.aM("tF", this.subs.slice(-1), t, this.options.updateOnBind), this;
        },
            z = function (t) {
          return this._.aM("tF", this.subs, t, this.options.updateOnBind), this;
        },
            J = function (t) {
          return this._.aM("cN", this.subs.slice(-1), t), this;
        },
            K = function (t) {
          return this._.aM("cN", this.subs, t), this;
        },
            Z = function (t) {
          var e,
              i = this.subs[this.subs.length - 1],
              s = i._,
              n = this._.isMulti ? this._.bindings : [this._];

          for (s.aS(this._, i.options), i = 0, e = n.length; i < e; i++) {
            var r = n[i],
                h = r.sM[s.ID].tF;
            r = r.sM[s.ID].cN, (h || t) && (h = O.iF(t) ? t : h) && !1 !== t && (s.sM[this._.ID].tF = h), r && (s.sM[this._.ID].cN = r);
          }

          return this;
        },
            tt = function (t) {
          var e,
              i = this.subs,
              s = 0;

          for (e = i.length; s < e; s++) {
            var n = i[s];

            this._.rS(n._, t);
          }

          return this;
        },
            et = function (t) {
          return this._.aPI(t), this;
        },
            it = function () {
          return this._.rPI(), this;
        },
            st = function (t, e) {
          return this._.sM[this.subs[this.subs.length - 1]._.ID].opts[t] = e, this;
        },
            nt = function (t, e, i) {
          var s, n;
          if (t.se = t.se.slice(6), E(this, this.In = t), this.isMulti = !0, this.bindings = s = [], e) for (t = 0, n = e.length; t < n; t++) {
            var r = e[t];
            this.addBP(r, i);
          }
          return Object.defineProperties(this, {
            type: {
              get: function () {
                return s.map(function (t) {
                  return t.type;
                });
              }
            },
            value: {
              get: function () {
                return s.map(function (t) {
                  return t.value;
                });
              }
            }
          });
        },
            rt = nt.prototype = Object.create(t);

        return Object.keys(R.prototype).forEach(function (t) {
          return rt[t] = function (e, i, s, n) {
            var r,
                h = this.bindings,
                o = 0;

            for (r = h.length; o < r; o++) {
              var u = h[o];
              "uS" === t && (i = u), u[t](e, i, s, n);
            }
          };
        }), rt.addBP = function (t, e) {
          this.bindings.push(e ? this.createBP(t, e, this.In) : t);
        }, e.exports = H, e.exports;
      }
    }, this), "function" == typeof undefined && undefined.umd) ;else {
      if (!module.exports) return this.simplybind = t(0);
      module.exports = t(0);
    }
  }).call(commonjsGlobal, null);
});var REGEX = {
  any: /./,
  whiteSpace: /\s+/,
  numeric: /^\d$/,
  letter: /^[a-zA-Z]$/,
  // alphanumeric: /[\da-zA-Z]/
  widenumeric: /^[0-9\!#\$\%\*\+\/\=\?\^\{\|\}\(\)\~\-\.]$/,
  alphanumeric: /^[0-9A-Za-z\!#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\(\)\~\-\ ]$/,
  email: /^[\w\-\.]+@[\w\-\.]+\.[A-Za-z]{2,10}$/
};var noop = function () {};

var includes$2 = function (target, item) {
  return target && target.indexOf(item) !== -1;
};

var repeat = function (string, count) {
  var i;
  return function () {
    var j, ref, results1;
    results1 = [];

    for (i = j = 1, ref = count; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
      results1.push(string);
    }

    return results1;
  }().join('');
};

var removeItem$1 = function (target, item) {
  var itemIndex;
  itemIndex = target.indexOf(item);

  if (itemIndex !== -1) {
    return target.splice(itemIndex, 1);
  }
};

var insertAfter$1 = function (target, item, newItem) {
  var itemIndex;
  itemIndex = target.indexOf(item);

  if (itemIndex !== -1) {
    return target.splice(itemIndex, 0, newItem);
  }
};

var hexToRGBA = function (hex, alpha) {
  var B, G, R;

  if (hex[0] === '#') {
    hex = hex.slice(1);
  }

  R = parseInt(hex.slice(0, 2), 16);
  G = parseInt(hex.slice(2, 4), 16);
  B = parseInt(hex.slice(4, 6), 16);
  return `rgba(${R}, ${G}, ${B}, ${alpha})`;
};

var defaultColor = function (color, defaultColor) {
  if (color === 'transparent' || !color) {
    return defaultColor;
  } else {
    return color;
  }
};

var calcPadding = function (desiredHeight, fontSize) {
  return Math.ceil((desiredHeight - fontSize * 1.231) / 2);
};

var unlockScroll = function (excludedEl) {
  window._isLocked = false;
  return quickdom(window).off('wheel.lock');
};

var lockScroll = function (excludedEl) {
  if (!window._isLocked) {
    window._isLocked = true;
    return quickdom(window).on('wheel.lock', function (event) {
      if (event.target === excludedEl.raw || quickdom(event.target).parentMatching(function (parent) {
        return parent === excludedEl;
      })) {
        if (event.wheelDelta > 0 && excludedEl.raw.scrollTop === 0) {
          return event.preventDefault();
        }

        if (event.wheelDelta < 0 && excludedEl.raw.scrollHeight - excludedEl.raw.scrollTop === excludedEl.raw.clientHeight) {
          return event.preventDefault();
        }
      } else {
        return event.preventDefault();
      }
    });
  }
};

var fuzzyMatch = function (needle, haystack, caseSensitive) {
  var hI, hLength, matchedCount, nI, nLength, needleChar;
  nLength = needle.length;
  hLength = haystack.length;

  if (!caseSensitive) {
    needle = needle.toUpperCase();
    haystack = haystack.toUpperCase();
  }

  if (nLength > hLength) {
    return false;
  }

  if (nLength === hLength) {
    return needle === haystack;
  }

  nI = hI = matchedCount = 0;

  while (nI < nLength) {
    needleChar = needle[nI++];

    while (hI < hLength) {
      if (haystack[hI++] === needleChar) {
        matchedCount++;
        break;
      }
    }
  }

  return matchedCount === nLength;
};

var startsWith = function (needle, haystack, caseSensitive) {
  var i;

  if (!caseSensitive) {
    needle = needle.toUpperCase();
    haystack = haystack.toUpperCase();
  }

  if (needle.length > haystack.length) {
    return false;
  }

  if (needle.length === haystack.length) {
    return needle === haystack;
  }

  i = -1;

  while (needle[++i]) {
    if (needle[i] !== haystack[i]) {
      return false;
    }
  }

  return true;
};

var getIndexOfFirstDiff = function (sourceString, compareString) {
  var currentPos, maxLength;
  currentPos = 0;
  maxLength = Math.max(sourceString.length, compareString.length);

  while (currentPos < maxLength) {
    if (sourceString[currentPos] !== compareString[currentPos]) {
      return currentPos;
    }

    currentPos++;
  }

  return null;
};

var parseCssShorthandValue = function (string) {
  var result, values;
  values = string.split(REGEX.whiteSpace).map(parseFloat);
  result = {};

  switch (values.length) {
    case 1:
      result.top = result.right = result.bottom = result.left = values[0];
      break;

    case 2:
      result.top = result.bottom = values[0];
      result.right = result.left = values[1];
      break;

    case 3:
      result.top = values[0];
      result.right = result.left = values[1];
      result.bottom = values[2];
      break;

    case 4:
      result.top = values[0];
      result.right = values[1];
      result.bottom = values[2];
      result.left = values[3];
  }

  return result;
};

var shorthandSideValue = function (value, side) {
  var values;

  switch (typeof value) {
    case 'number':
      return value;

    case 'string':
      values = parseCssShorthandValue(value);
      return values[side];

    default:
      return 0;
  }
};

var updateShorthandValue = function (value, side, newValue) {
  var values;
  values = parseCssShorthandValue('' + (value || 0));

  switch (side) {
    case 'top':
      values.top += newValue;
      break;

    case 'right':
      values.right += newValue;
      break;

    case 'bottom':
      values.bottom += newValue;
      break;

    case 'left':
      values.left += newValue;
      break;

    default:
      Object.keys(values).forEach(function (side) {
        return values[side] += newValue;
      });
  }

  return `${values.top}px ${values.right}px ${values.bottom}px ${values.left}px`;
};

var inheritProto = function (child, parent, keys) {
  var j, key, len, ref;
  ref = Object.getOwnPropertyNames(parent.prototype);

  for (j = 0, len = ref.length; j < len; j++) {
    key = ref[j];

    if (keys && !keys.includes(key)) {
      continue;
    }

    if (!child.prototype[key]) {
      child.prototype[key] = parent.prototype[key];
    }
  }

  return child;
};var REQUIRED_FIELD_METHODS = ['_getValue', '_setValue', '_validate'];var fastdom = createCommonjsModule(function (module) {
  !function (win) {
    /**
     * Mini logger
     *
     * @return {Function}
     */

    var debug = function () {};
    /**
     * Normalized rAF
     *
     * @type {Function}
     */

    var raf = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.msRequestAnimationFrame || function (cb) {
      return setTimeout(cb, 16);
    };
    /**
     * Initialize a `FastDom`.
     *
     * @constructor
     */


    function FastDom() {
      var self = this;
      self.reads = [];
      self.writes = [];
      self.raf = raf.bind(win); // test hook
    }

    FastDom.prototype = {
      constructor: FastDom,

      /**
       * Adds a job to the read batch and
       * schedules a new frame if need be.
       *
       * @param  {Function} fn
       * @public
       */
      measure: function (fn, ctx) {
        var task = !ctx ? fn : fn.bind(ctx);
        this.reads.push(task);
        scheduleFlush(this);
        return task;
      },

      /**
       * Adds a job to the
       * write batch and schedules
       * a new frame if need be.
       *
       * @param  {Function} fn
       * @public
       */
      mutate: function (fn, ctx) {
        var task = !ctx ? fn : fn.bind(ctx);
        this.writes.push(task);
        scheduleFlush(this);
        return task;
      },

      /**
       * Clears a scheduled 'read' or 'write' task.
       *
       * @param {Object} task
       * @return {Boolean} success
       * @public
       */
      clear: function (task) {
        return remove(this.reads, task) || remove(this.writes, task);
      },

      /**
       * Extend this FastDom with some
       * custom functionality.
       *
       * Because fastdom must *always* be a
       * singleton, we're actually extending
       * the fastdom instance. This means tasks
       * scheduled by an extension still enter
       * fastdom's global task queue.
       *
       * The 'super' instance can be accessed
       * from `this.fastdom`.
       *
       * @example
       *
       * var myFastdom = fastdom.extend({
       *   initialize: function() {
       *     // runs on creation
       *   },
       *
       *   // override a method
       *   measure: function(fn) {
       *     // do extra stuff ...
       *
       *     // then call the original
       *     return this.fastdom.measure(fn);
       *   },
       *
       *   ...
       * });
       *
       * @param  {Object} props  properties to mixin
       * @return {FastDom}
       */
      extend: function (props) {
        if (typeof props != 'object') throw new Error('expected object');
        var child = Object.create(this);
        mixin(child, props);
        child.fastdom = this; // run optional creation hook

        if (child.initialize) child.initialize();
        return child;
      },
      // override this with a function
      // to prevent Errors in console
      // when tasks throw
      catch: null
    };
    /**
     * Schedules a new read/write
     * batch if one isn't pending.
     *
     * @private
     */

    function scheduleFlush(fastdom) {
      if (!fastdom.scheduled) {
        fastdom.scheduled = true;
        fastdom.raf(flush.bind(null, fastdom));
      }
    }
    /**
     * Runs queued `read` and `write` tasks.
     *
     * Errors are caught and thrown by default.
     * If a `.catch` function has been defined
     * it is called instead.
     *
     * @private
     */


    function flush(fastdom) {
      var writes = fastdom.writes;
      var reads = fastdom.reads;
      var error;

      try {
        debug('flushing reads', reads.length);
        runTasks(reads);
        debug('flushing writes', writes.length);
        runTasks(writes);
      } catch (e) {
        error = e;
      }

      fastdom.scheduled = false; // If the batch errored we may still have tasks queued

      if (reads.length || writes.length) scheduleFlush(fastdom);

      if (error) {
        debug('task errored', error.message);
        if (fastdom.catch) fastdom.catch(error);else throw error;
      }
    }
    /**
     * We run this inside a try catch
     * so that if any jobs error, we
     * are able to recover and continue
     * to flush the batch until it's empty.
     *
     * @private
     */


    function runTasks(tasks) {
      var task;

      while (task = tasks.shift()) task();
    }
    /**
     * Remove an item from an Array.
     *
     * @param  {Array} array
     * @param  {*} item
     * @return {Boolean}
     */


    function remove(array, item) {
      var index = array.indexOf(item);
      return !!~index && !!array.splice(index, 1);
    }
    /**
     * Mixin own properties of source
     * object into the target.
     *
     * @param  {Object} target
     * @param  {Object} source
     */


    function mixin(target, source) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) target[key] = source[key];
      }
    } // There should never be more than
    // one instance of `FastDom` in an app


    var exports = win.fastdom = win.fastdom || new FastDom(); // jshint ignore:line
    // Expose to CJS & AMD

    module.exports = exports;
  }(typeof window !== 'undefined' ? window : commonjsGlobal);
});var Condition;
Condition = class Condition {
  constructor(field1, settings, callback1) {
    var property, target;
    this.field = field1;
    this.settings = settings;
    this.callback = callback1;
    this.satisfied = false;
    this.value = this.settings.value;
    this.property = this.settings.property || '_value';

    if (this.settings.property === 'value') {
      this.property = '_value';
    }

    target = this.field.allFields[this.settings.target];

    if (target) {
      this.target = target;
    } else {
      return console.warn(`condition target not found for the provided ID '${this.settings.target}'`, this.field);
    }

    property = IS$1$1.array(this.target[this.property]) ? `array:${this.property}` : this.property;
    simplybind(property, {
      updateOnBind: false
    }).of(this.target).and('visible').of(this.target.state).to(this.callback);
    simplybind('satisfied', {
      updateOnBind: false
    }).of(this).to((newValue, oldValue) => {
      var base;

      if (oldValue != null) {
        return typeof (base = this.field).emit === "function" ? base.emit('conditionChange', this) : void 0;
      }
    });
  }

  test() {
    var comparison, comparisonOperators, passedComparisons, ref, targetValue;

    if (!((ref = this.target) != null ? ref.state.visible : void 0)) {
      return false;
    }

    comparison = function () {
      switch (false) {
        case !IS$1$1.objectPlain(this.value):
          return this.value;

        case !IS$1$1.regex(this.value):
          return {
            '$regex': this.value
          };

        case !(this.value === 'valid' && !this.settings.property || !IS$1$1.defined(this.value)):
          return 'valid';

        default:
          return {
            '$eq': this.value
          };
      }
    }.call(this);

    if (comparison === 'valid') {
      return this.target.validate();
    }

    targetValue = (() => {
      var nestedObject, propertyChain;

      if (this.property === '_value') {
        return this.target.value;
      }

      propertyChain = this.property.split('.');

      switch (false) {
        case propertyChain.length !== 1:
          return this.target[this.property];

        case !IS$1$1.defined(this.target[this.property]):
          return this.target[this.property];

        default:
          nestedObject = this.target;

          while (IS$1$1.object(nestedObject)) {
            nestedObject = nestedObject[propertyChain.pop()];
          }

          return nestedObject;
      }
    })();

    comparisonOperators = Object.keys(comparison);
    passedComparisons = comparisonOperators.filter(function (operator) {
      var seekedValue;
      seekedValue = comparison[operator];

      switch (operator) {
        case '$eq':
          return targetValue === seekedValue;

        case '$ne':
          return targetValue !== seekedValue;

        case '$gt':
          return targetValue > seekedValue;

        case '$gte':
          return targetValue >= seekedValue;

        case '$lt':
          return targetValue < seekedValue;

        case '$lte':
          return targetValue <= seekedValue;

        case '$ct':
          return helpers.includes(targetValue, seekedValue);

        case '$nct':
          return !helpers.includes(targetValue, seekedValue);

        case '$regex':
          return seekedValue.test(targetValue);

        case '$nregex':
          return !seekedValue.test(targetValue);

        case '$mask':
          return helpers.testMask(targetValue, seekedValue);

        default:
          return false;
      }
    });
    return passedComparisons.length === comparisonOperators.length;
  }

  static validate(conditions) {
    var validConditions;

    if (conditions) {
      validConditions = conditions.filter(function (condition) {
        return condition.satisfied = condition.test();
      });
      return validConditions.length === conditions.length;
    }
  }

  static init(field, conditions, callback) {
    return setTimeout(() => {
      if (callback == null) {
        callback = () => {
          return field.validateConditions();
        };
      }

      field.conditions = conditions.map(function (condition) {
        return new Condition(field, condition, callback);
      });
      return callback();
    });
  }

};
var Condition$1 = Condition;var transformSettings = {
  conditions: function (conditions) {
    var results, target, value;

    if (IS$1$1.objectPlain(conditions)) {
      results = [];

      for (target in conditions) {
        value = conditions[target];
        results.push({
          target,
          value
        });
      }

      return results;
    } else if (IS$1$1.array(conditions)) {
      return conditions.map(function (item) {
        if (IS$1$1.string(item)) {
          return {
            target: item
          };
        } else {
          return item;
        }
      });
    }
  },
  choices: function (choices) {
    var label, results, value;

    if (IS$1$1.objectPlain(choices)) {
      results = [];

      for (label in choices) {
        value = choices[label];
        results.push({
          label,
          value
        });
      }

      return results;
    } else if (IS$1$1.array(choices)) {
      return choices.map(function (item) {
        if (!IS$1$1.objectPlain(item)) {
          return {
            label: item,
            value: item
          };
        } else {
          return item;
        }
      });
    }
  },
  validWhenRegex: function (regex) {
    if (IS$1$1.string(regex)) {
      return new RegExp(regex);
    } else {
      return regex;
    }
  }
};var globalDefaults = {
  fontFamily: 'system-ui, sans-serif',
  templates: {},
  events: null,
  label: false,
  error: '',
  help: '',
  required: false,
  disabled: false,
  defaultValue: null,
  width: '100%',
  mobileWidth: null,
  mobileThreshold: 736,
  border: 1,
  margin: null,
  padding: null,
  distance: null,
  inputPadding: 12,
  fontSize: 14,
  labelSize: null,
  icon: null,
  iconSize: 22,
  getter: null,
  setter: null,
  validator: null,
  clearErrorOnValid: true,
  makeRoomForHelp: true
};var Field, currentID;
currentID = 0;

Field = function () {
  class Field {
    constructor(settings, builder, settingOverrides, templateOverrides) {
      var ref, shallowSettings, transformSettings_;
      this.builder = builder;

      if (settingOverrides) {
        if (settingOverrides.globalDefaults) {
          this.globalDefaults = settingOverrides.globalDefaults;
        }

        if (settingOverrides[settings.type]) {
          this.defaults = settingOverrides[settings.type];
        }
      }

      if (templateOverrides && templateOverrides[settings.type]) {
        this.templates = templateOverrides[settings.type];
        this.template = templateOverrides[settings.type].default;
      }

      shallowSettings = this.shallowSettings ? Field.shallowSettings.concat(this.shallowSettings) : Field.shallowSettings;
      transformSettings_ = this.transformSettings ? Field.transformSettings.concat(this.transformSettings) : Field.transformSettings;
      this.settings = primaryBuilder$1.deep.clone.notDeep(shallowSettings).transform(transformSettings_)(this.globalDefaults, this.defaults, settings);
      this.ID = this.settings.ID || currentID++ + '';
      this.type = settings.type;
      this.name = settings.name;
      this.allFields = this.settings.fieldInstances || Field.instances;
      this._value = null;
      this._eventCallbacks = {};
      this.state = {
        valid: true,
        visible: true,
        focused: false,
        hovered: false,
        filled: false,
        interacted: false,
        isMobile: false,
        disabled: this.settings.disabled,
        margin: this.settings.margin,
        padding: this.settings.padding,
        width: this.settings.width,
        showLabel: this.settings.label,
        label: this.settings.label,
        showHelp: this.settings.help,
        help: this.settings.help,
        showError: false,
        error: this.settings.error
      };

      if (IS$1$1.defined(this.settings.placeholder)) {
        this.state.placeholder = this.settings.placeholder;
      }

      if (IS$1$1.number(this.settings.width) && this.settings.width <= 1) {
        this.state.width = `${this.settings.width * 100}%`;
      }

      if ((ref = this.settings.conditions) != null ? ref.length : void 0) {
        this.state.visible = false;
        Condition$1.init(this, this.settings.conditions);
      }

      if (this.allFields[this.ID]) {
        if (typeof console !== "undefined" && console !== null) {
          console.warn(`Duplicate field IDs found: '${this.ID}'`);
        }
      }

      this.allFields[this.ID] = this;
    }

    _constructorEnd() {
      var base, handler, ref, target;
      this.el.childf; //.field.on 'inserted', ()=> @emit('inserted')

      if (this.settings.ID) {
        this.el.raw.id = this.ID;
      }

      if (this.settings.value != null) {
        if ((base = this.settings).defaultValue == null) {
          base.defaultValue = this.settings.value;
        }
      }

      if (this.settings.defaultValue != null) {
        this.value = this.settings.multiple ? [].concat(this.settings.defaultValue) : this.settings.defaultValue;
      }

      simplybind('showError', {
        updateOnBind: false
      }).of(this.state).to('help').of(this.state).transform(show => {
        if (show && this.state.error && IS$1$1.string(this.state.error)) {
          return this.state.error;
        } else {
          return this.settings.help || this.state.help;
        }
      });
      simplybind('error', {
        updateOnBind: false
      }).of(this.state).to('help').of(this.state).condition(error => {
        return error && this.state.showError;
      });
      simplybind('help').of(this.state).to('html').of(this.el.child.help).and.to('showHelp').of(this.state);
      simplybind('label').of(this.state).to('text').of(this.el.child.label).and.to('showLabel').of(this.state);
      simplybind('margin').of(this.state).to(this.el.style.bind(this.el, 'margin'));
      simplybind('padding').of(this.state).to(this.el.style.bind(this.el, 'padding'));
      simplybind('showHelp').of(this.state).to((show, prevShow) => {
        var changeAmount;

        if (this.settings.makeRoomForHelp) {
          changeAmount = !!show === !!prevShow ? 0 : show ? 25 : prevShow ? -25 : void 0;

          if (changeAmount) {
            return this.state.margin = updateShorthandValue(this.state.margin, 'bottom', changeAmount);
          }
        }
      });
      simplybind('focused', {
        updateOnBind: false
      }).of(this.state).to(focused => {
        return this.emit(focused ? 'focus' : 'blur');
      });

      if (this.settings.mobileWidth) {
        simplybind(() => {
          return fastdom.measure(() => {
            return this.state.isMobile = window.innerWidth <= this.settings.mobileThreshold;
          });
        }).updateOn('event:resize').of(window);
      }

      if (IS$1$1.object(this.settings.events)) {
        ref = this.settings.events;

        for (target in ref) {
          handler = ref[target];
          this.on(target, handler);
        }
      }

      this.emit('created', this);
      return this.el.raw._quickField = this;
    }

    _formatWidth(width) {
      width = this.state.isMobile ? this.settings.mobileWidth || width : width;

      if (this.settings.distance && width !== '100%') {
        width = `calc(${width} - ${this.settings.distance}px)`;
      }

      return width;
    }

    appendTo(target) {
      this.el.appendTo(target);
      return this;
    }

    prependTo(target) {
      this.el.prependTo(target);
      return this;
    }

    insertAfter(target) {
      this.el.insertAfter(target);
      return this;
    }

    insertBefore(target) {
      this.el.insertBefore(target);
      return this;
    }

    detach(target) {
      this.el.detach(target);
      return this;
    }

    remove() {
      this.el.remove();
      return this.destroy(false);
    }

    destroy(removeFromDOM = true) {
      var child, i, len, ref;
      simplybind.unBindAll(this);
      simplybind.unBindAll(this.state);
      simplybind.unBindAll(this.el);
      ref = this.el.child;

      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        simplybind.unBindAll(child);
      }

      if (removeFromDOM) {
        this.el.remove();
      }

      if (this._destroy) {
        this._destroy();
      }

      delete this.allFields[this.ID];
      return true;
    }

    on(eventNames, callback, useCapture) {
      this.el.on.call(this.el, eventNames, callback, useCapture, true);
      return this;
    }

    once(eventNames, callback, useCapture) {
      return this.on(eventNames, () => {
        this.off(eventNames, callback);
        return callback.apply(this.el, arguments);
      }, useCapture);
    }

    off() {
      this.el.off.apply(this.el, arguments);
      return this;
    }

    emit() {
      this.el.emitPrivate.apply(this.el, arguments);
      return this;
    }

    validate(providedValue = this[this.coreValueProp], testUnrequired, report) {
      var isValid;

      isValid = function () {
        switch (false) {
          case !this.settings.validator:
            return this.settings.validator(providedValue);

          case !(!this.settings.required && !testUnrequired):
            return true;

          case this._validate(providedValue, testUnrequired, report) !== false:
            return false;

          case !this.settings.required:
            switch (false) {
              case !this.settings.multiple:
                return !!(providedValue != null ? providedValue.length : void 0);

              case typeof providedValue !== 'string':
                return !!providedValue;

              default:
                return providedValue != null;
            }

            break;

          default:
            return true;
        }
      }.call(this);

      if (isValid && this.settings.clearErrorOnValid) {
        this.state.showError = false;
      }

      return isValid;
    }

    validateConditions(conditions) {
      var passedConditions, toggleVisibility;

      if (conditions) {
        toggleVisibility = false;
      } else {
        conditions = this.conditions;
        toggleVisibility = true;
      }

      passedConditions = Condition$1.validate(conditions);

      if (toggleVisibility) {
        return this.state.visible = passedConditions;
      } else {
        return passedConditions;
      }
    }

    validateAndReport(providedValue, testUnrequired) {
      var isValid;
      isValid = this.validate(providedValue, testUnrequired, true);
      this.state.showError = !isValid;
      return isValid;
    }

  }

  Field.instances = Object.create(null);
  Field.shallowSettings = ['templates', 'fieldInstances', 'value', 'defaultValue'];
  Field.transformSettings = transformSettings;
  Field.prototype.globalDefaults = globalDefaults;
  Field.prototype.coreValueProp = '_value';
  Object.defineProperties(Field.prototype, {
    'removeListener': {
      get: function () {
        return this.off;
      }
    },
    'els': {
      get: function () {
        return this.el.child;
      }
    },
    'valueRaw': {
      get: function () {
        return this._value;
      }
    },
    'value': {
      get: function () {
        if (this.settings.getter) {
          return this.settings.getter(this._getValue());
        } else {
          return this._getValue();
        }
      },
      set: function (value) {
        return this._setValue(this.settings.setter ? this.settings.setter(value) : value);
      }
    }
  });
  return Field;
}.call(undefined);

var Field$1 = Field;var keyCodes;
var KEYCODES = keyCodes = {
  delete: 8,
  enter: 13,
  esc: 27,
  ctrl: 17,
  alt: 18,
  shift: 16,
  super: 91,
  super2: 93,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  hyphen: 45,
  underscore: 95,
  question: 63,
  exclamation: 33,
  frontslash: 47,
  backslash: 92,
  comma: 44,
  period: 46,
  space: 32,
  anyArrow: function (code) {
    return code === keyCodes.up || code === keyCodes.down || code === keyCodes.left || code === keyCodes.right;
  },
  anyModifier: function (code) {
    return code === keyCodes.ctrl || code === keyCodes.alt || code === keyCodes.shift || code === keyCodes.super || code === keyCodes.super2;
  },
  anyAlpha: function (code) {
    return 97 <= code && code <= 122 || 65 <= code && code <= 90;
  },
  anyNumeric: function (code) {
    return 48 <= code && code <= 57;
  },
  anyAlphaNumeric: function (code) {
    return keyCodes.anyAlpha(code) || keyCodes.anyNumeric(code);
  },
  anyPrintable: function (code) {
    return keyCodes.anyAlpha(code) || keyCodes.anyNumeric(code) || code === keyCodes.hyphen || code === keyCodes.underscore || code === keyCodes.question || code === keyCodes.exclamation || code === keyCodes.frontslash || code === keyCodes.backslash || code === keyCodes.comma || code === keyCodes.period || code === keyCodes.space;
  }
};var checkmark = quickdom.template(['*svg', {
  attrs: {
    width: '12px',
    height: '12px',
    viewBox: '5 7 12 12',
    tabindex: -1,
    focusable: false
  },
  style: {
    width: '9px',
    height: '9px'
  }
}, ['*polyline', {
  attrs: {
    'stroke-width': '2',
    'stroke-linecap': 'round',
    'stroke-linejoin': 'round',
    fill: 'none',
    points: '7 13.8888889 9.66666667 17 15 9',
    tabindex: -1,
    focusable: false
  }
}]]);var angleDown = quickdom.template(['*svg', {
  attrs: {
    width: '1792px',
    height: '1792px',
    viewBox: '0 0 1792 1792',
    tabindex: -1,
    focusable: false
  },
  style: {
    width: '100%',
    height: '100%',
    outline: 'none'
  }
}, ['*path', {
  attrs: {
    tabindex: -1,
    focusable: false,
    d: 'M1395 736q0 13-10 23l-466 466q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l50-50q10-10 23-10t23 10l393 393 393-393q10-10 23-10t23 10l50 50q10 10 10 23z'
  }
}]]);var caretUp = quickdom.template(['*svg', {
  attrs: {
    viewBox: '0 0 512 512',
    tabindex: -1,
    focusable: false
  },
  style: {
    width: '100%',
    height: '100%',
    outline: 'none'
  }
}, ['*path', {
  attrs: {
    tabindex: -1,
    focusable: false,
    d: 'M402 347c0 5-2 10-5 13-4 4-8 6-13 6h-256c-5 0-9-2-13-6-3-3-5-8-5-13s2-9 5-12l128-128c4-4 8-6 13-6s9 2 13 6l128 128c3 3 5 7 5 12z'
  }
}]]);var caretDown = quickdom.template(['*svg', {
  attrs: {
    viewBox: '0 0 512 512',
    tabindex: -1,
    focusable: false
  },
  style: {
    width: '100%',
    height: '100%',
    outline: 'none'
  }
}, ['*path', {
  attrs: {
    tabindex: -1,
    focusable: false,
    d: 'M402 201c0 5-2 9-5 13l-128 128c-4 4-8 5-13 5s-9-1-13-5l-128-128c-3-4-5-8-5-13s2-9 5-13c4-3 8-5 13-5h256c5 0 9 2 13 5 3 4 5 8 5 13z'
  }
}]]);var plus = quickdom.template(['*svg', {
  attrs: {
    viewBox: '0 0 15 15',
    tabindex: -1,
    focusable: false
  },
  style: {
    width: '100%',
    height: '100%',
    outline: 'none'
  }
}, ['*polygon', {
  attrs: {
    tabindex: -1,
    focusable: false,
    points: '9 0 6 0 6 6 0 6 0 9 6 9 6 15 9 15 9 9 15 9 15 6 9 6'
  }
}]]);var clone$1 = quickdom.template(['*svg', {
  attrs: {
    viewBox: '0 0 18 20',
    tabindex: -1,
    focusable: false
  },
  style: {
    width: '100%',
    height: '100%',
    outline: 'none'
  }
}, ['*path', {
  attrs: {
    tabindex: -1,
    focusable: false,
    d: 'M13.414,0 L6,0 C4.897,0 4,0.898 4,2 L4,14 C4,15.103 4.897,16 6,16 L16,16 C17.103,16 18,15.103 18,14 L18,4.586 L13.414,0 Z M16.001,14 L6,14 L6,2 L12,2 L12,6 L16,6 L16.001,14 Z'
  }
}], ['*path', {
  attrs: {
    tabindex: -1,
    focusable: false,
    d: 'M2,6.42379282 L0,6.42379282 L0,18 C0,19.103 0.897,20 2,20 L14,20 L14,18 L2,18 L2,6.42379282 Z'
  }
}]]);var remove$1 = plus.extend({
  options: {
    style: {
      transform: 'rotate(45deg)'
    }
  }
});var template$1 = quickdom.template(['div', {
  ref: 'dropdown',
  styleAfterInsert: true,
  style: {
    position: 'absolute',
    zIndex: 10,
    overflow: 'hidden',
    top: function (dropdown) {
      if (dropdown.field.type === 'text') {
        return this.parent.raw.style.height;
      } else {
        return '-7px';
      }
    },
    left: function () {
      if (this.parent.rect.left - 5 < 0) {
        return 0;
      } else {
        return -5;
      }
    },
    display: 'none',
    // backgroundColor: hexToRGBA('f6f6f6', 0.9)
    backgroundColor: '#f6f6f6',
    boxShadow: `0px 6px 10px ${hexToRGBA('000000', 0.32)}`,
    borderWidth: '1px',
    borderStyle: 'solid',
    borderColor: '#d1d1d1',
    borderRadius: '5px',
    boxSizing: 'border-box',
    padding: '4px 0',
    $isOpen: {
      $hasVisibleChoices: {
        display: 'block'
      }
    }
  }
}]);
var list = quickdom.template(['div', {
  ref: 'list',
  passStateToChildren: false,
  style: {
    position: 'relative',
    overflow: 'scroll',
    overflowScrolling: 'touch',
    overflowStyle: '-ms-autohiding-scrollbar'
  }
}]);
var choice = quickdom.template(['div', {
  style: {
    display: 'none',
    fontSize: '0',
    color: '#000000',
    userSelect: 'none',
    lineHeight: '1em',
    cursor: 'pointer',
    $visible: {
      display: 'block'
    },
    $unavailable: {
      display: 'none'
    },
    $hover: {
      color: '#ffffff',
      backgroundColor: '#4C96FF'
    }
  }
}, ['div', // Checkmark
{
  style: {
    display: 'inline-block',
    verticalAlign: 'top',
    width: '20px',
    // height: ()-> @parent.raw.style.height
    // lineHeight: ()-> @parent.style('height')
    // fontSize: ()-> @parent.style('height')
    lineHeight: '20px',
    fontSize: '13px',
    textAlign: 'center',
    color: 'inherit',
    stroke: 'currentColor',
    visibility: 'hidden',
    $selected: {
      visibility: 'visible'
    }
  }
}, checkmark], ['div', // Text
{
  styleAfterInsert: true,
  style: {
    display: 'inline-block',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap',
    wordWrap: 'normal',
    maxWidth: function () {
      return `calc(100% - ${this.prev.styleSafe('width', true)})`;
    },
    paddingRight: '10px',
    lineHeight: '20px',
    fontSize: '11px',
    fontFamily: function (dropdown) {
      return dropdown.settings.fontFamily;
    },
    color: 'inherit',
    boxSizing: 'border-box'
  }
}]]);
var scrollIndicatorUp = quickdom.template(['div', {
  ref: 'scrollIndicatorUp',
  style: {
    position: 'absolute',
    top: 0,
    left: 0,
    display: 'none',
    width: '100%',
    height: '20px',
    backgroundColor: '#f6f6f6',
    color: '#000000',
    textAlign: 'center',
    $visible: {
      display: 'block'
    }
  }
}, ['div', {
  style: {
    position: 'absolute',
    top: '50%',
    left: 0,
    right: 0,
    width: '15px',
    height: '15px',
    display: 'block',
    margin: '0 auto',
    transform: 'translateY(-50%)'
  }
}, caretUp]]);
var scrollIndicatorDown = quickdom.template(['div', {
  ref: 'scrollIndicatorDown',
  style: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    display: 'none',
    width: '100%',
    height: '20px',
    backgroundColor: '#f6f6f6',
    color: '#000000',
    textAlign: 'center',
    $visible: {
      display: 'block'
    }
  }
}, ['div', {
  style: {
    position: 'absolute',
    top: '50%',
    left: 0,
    right: 0,
    width: '15px',
    height: '15px',
    display: 'block',
    margin: '0 auto',
    transform: 'translateY(-50%)'
  }
}, caretDown]]);
var help = quickdom.template(['div', {
  ref: 'help',
  style: {
    display: 'none',
    borderTop: '2px solid rgba(0,0,0,0.05)',
    padding: '4px 12px 1px',
    color: 'rgba(0,0,0,0.5)',
    fontWeight: '500',
    fontSize: '11px',
    userSelect: 'none',
    $showHelp: {
      display: 'block'
    }
  }
}]);
var template$1$1 =
/*#__PURE__*/
Object.freeze({
  default: template$1,
  list: list,
  choice: choice,
  scrollIndicatorUp: scrollIndicatorUp,
  scrollIndicatorDown: scrollIndicatorDown,
  help: help
});var defaults = {
  maxHeight: 300,
  multiple: false,
  lockScroll: true,
  typeBuffer: false,
  help: '',
  templates: {}
};var Choice, Dropdown, List;

Dropdown = function () {
  class Dropdown {
    constructor(initialChoices, field) {
      this.initialChoices = initialChoices;
      this.field = field;
      this.isOpen = false;
      this.typeBuffer = '';
      this.settings = primaryBuilder$1.deep.clone.filter(this._settingFilters)(globalDefaults, this.defaults, this.field.settings.dropdown);
      this.selected = this.settings.multiple ? [] : null;
      this.lastSelected = null;
      this.choices = [];
      this.currentHighlighted = null;
      this.visibleChoicesCount = 0;
      this.visibleChoices = [];
      this.els = {};
      this._selectedCallback = noop;

      this._createElements();

      this._attachBindings();

      return this;
    }

    _createElements() {
      var choice$$1, globalOpts, i, len, ref;
      globalOpts = {
        relatedInstance: this
      };
      this.els.container = this.template.default.spawn(this.settings.templates.default, primaryBuilder$1({
        passStateToChildren: false
      }, globalOpts));
      this.els.list = this.template.list.spawn(this.settings.templates.list, globalOpts).appendTo(this.els.container);
      this.els.help = this.template.help.spawn(this.settings.templates.help, globalOpts).appendTo(this.els.container);
      this.els.scrollIndicatorUp = this.template.scrollIndicatorUp.spawn(this.settings.templates.scrollIndicatorUp, globalOpts).appendTo(this.els.container);
      this.els.scrollIndicatorDown = this.template.scrollIndicatorDown.spawn(this.settings.templates.scrollIndicatorDown, globalOpts).appendTo(this.els.container);
      this.list = new List(this);
      ref = this.initialChoices;

      for (i = 0, len = ref.length; i < len; i++) {
        choice$$1 = ref[i];
        this.addChoice(choice$$1);
      }
    }

    _attachBindings() {
      this._attachBindings_elState();

      this._attachBindings_display();

      return this._attachBindings_scrollIndicators();
    }

    _attachBindings_elState() {
      simplybind('help').of(this.settings).to('text').of(this.els.help).and.to(showHelp => {
        return this.els.help.state('showHelp', showHelp);
      });
      simplybind('visibleChoicesCount').of(this).to(count => {
        return this.els.container.state('hasVisibleChoices', !!count);
      });
      return simplybind('currentHighlighted').of(this).to((current, prev) => {
        if (prev) {
          prev.el.state('hover', false);
        }

        if (current) {
          return current.el.state('hover', true);
        }
      });
    }

    _attachBindings_display() {
      simplybind('isOpen', {
        updateOnBind: false
      }).of(this).to(isOpen => {
        this.els.container.state('isOpen', isOpen);

        if (!isOpen) {
          this.currentHighlighted = null;
        }

        if (this.settings.lockScroll) {
          if (isOpen) {
            lockScroll(this.els.list);
          } else {
            unlockScroll();
          }
        }

        if (isOpen) {
          this.list.appendChoices();
          this.list.calcDisplay();

          if (this.selected && !this.settings.multiple) {
            return this.list.scrollToChoice(this.selected);
          }
        } else {
          return this.list.setTranslate(0);
        }
      });
      simplybind('lastSelected', {
        updateOnBind: false,
        updateEvenIfSame: true
      }).of(this).to((newChoice, prevChoice) => {
        return this._selectedCallback(newChoice, prevChoice);
      });
      simplybind('focused', {
        updateOnBind: false
      }).of(this.field.state).to(focused => {
        if (!focused) {
          return this.field.el.child.input.off('keydown.dropdownNav');
        } else {
          return this.field.el.child.input.on('keydown.dropdownNav', event => {
            if (this.isOpen) {
              switch (event.keyCode) {
                case KEYCODES.up:
                  event.preventDefault();
                  return this.highlightPrev();

                case KEYCODES.down:
                  event.preventDefault();
                  return this.highlightNext();

                case KEYCODES.enter:
                  event.preventDefault();

                  if (this.currentHighlighted) {
                    return this.lastSelected = this.currentHighlighted;
                  }

                  break;

                case KEYCODES.esc:
                  event.preventDefault();
                  return this.isOpen = false;
              }
            }
          });
        }
      });

      if (!this.settings.typeBuffer) {
        return;
      }

      simplybind('focused', {
        updateOnBind: false
      }).of(this.field.state).to(focused => {
        if (!focused) {
          return quickdom(document).off('keypress.dropdownTypeBuffer');
        } else {
          return quickdom(document).on('keypress.dropdownTypeBuffer', event => {
            if (this.isOpen) {
              event.preventDefault();

              if (!KEYCODES.anyPrintable(event.keyCode)) {
                return;
              }

              return this.typeBuffer += event.key;
            }
          });
        }
      });
      return simplybind('typeBuffer', {
        updateOnBind: false
      }).of(this).to(() => {
        clearTimeout(this.typeBufferTimeout);
        return this.typeBufferTimeout = setTimeout(() => {
          return this.typeBuffer = '';
        }, 1500);
      }).and.to(buffer => {
        var choice$$1, i, len, ref;

        if (buffer) {
          ref = this.visibleChoices;

          for (i = 0, len = ref.length; i < len; i++) {
            choice$$1 = ref[i];

            if (startsWith(buffer, choice$$1.label)) {
              this.currentHighlighted = choice$$1;

              if (!this.list.choiceInView(choice$$1)) {
                this.list.scrollToChoice(choice$$1);
              }

              return;
            }
          }
        }
      });
    }

    _attachBindings_scrollIndicators() {
      simplybind('scrollTop', {
        updateEvenIfSame: true
      }).of(this.els.list.raw).to(scrollTop => {
        var showBottomIndicator, showTopIndicator;
        showTopIndicator = scrollTop > 0;
        showBottomIndicator = this.els.list.raw.scrollHeight - this.els.list.raw.clientHeight > scrollTop;
        this.els.scrollIndicatorUp.state('visible', showTopIndicator);
        return this.els.scrollIndicatorDown.state('visible', showBottomIndicator);
      }).condition(() => {
        return this.isOpen && !this.settings.help && this.els.list.raw.scrollHeight !== this.els.list.raw.clientHeight && this.els.list.raw.clientHeight >= 100;
      }).updateOn('event:scroll').of(this.els.list.raw).updateOn('isOpen').of(this);
      this.els.scrollIndicatorUp.on('mouseenter', () => {
        return this.list.startScrolling('up');
      });
      this.els.scrollIndicatorUp.on('mouseleave', () => {
        return this.list.stopScrolling();
      });
      this.els.scrollIndicatorDown.on('mouseenter', () => {
        return this.list.startScrolling('down');
      });
      return this.els.scrollIndicatorDown.on('mouseleave', () => {
        return this.list.stopScrolling();
      });
    }

    addChoice(config) {
      var i, item, len, newChoice;

      if (IS$1$1.array(config)) {
        for (i = 0, len = config.length; i < len; i++) {
          item = config[i];
          this.addChoice(item);
        }

        return;
      } else if (IS$1$1.string(config)) {
        config = {
          label: config,
          value: config
        };
      } else if (IS$1$1.objectPlain(config)) {
        if (config.value == null) {
          config.value = config.label;
        }

        if (config.label == null) {
          config.label = config.value;
        }
      } else {
        return;
      }

      newChoice = new Choice(this, config, this.list, this.choices.length);

      if (this.list.appendedChoices) {
        newChoice.init();
      }

      this.choices.push(newChoice);
      return newChoice;
    }

    removeChoice(choice$$1) {
      var i, item, len;

      if (IS$1$1.array(choice$$1)) {
        for (i = 0, len = choice$$1.length; i < len; i++) {
          item = choice$$1[i];
          this.removeChoice(item);
        }

        return;
      } else {
        choice$$1 = this.findChoiceAny(choice$$1);
      }

      if (!choice$$1) {
        return;
      }

      return choice$$1.remove();
    }

    replaceChoices(newChoices) {
      this.removeChoice(this.choices.slice());
      this.addChoice(newChoices);
    }

    appendTo(target) {
      return this.els.container.appendTo(target);
    }

    onSelected(callback) {
      return this._selectedCallback = callback;
    }

    findChoice(providedValue, byLabel) {
      var matches;
      matches = this.choices.filter(function (choice$$1) {
        switch (false) {
          case !IS$1$1.object(providedValue):
            return providedValue === choice$$1;

          case !byLabel:
            return providedValue === choice$$1.label;

          default:
            return providedValue === choice$$1.value;
        }
      });
      return matches[0];
    }

    findChoiceAny(providedValue) {
      return this.findChoice(providedValue) || this.findChoice(providedValue, true);
    }

    highlightPrev() {
      var choice$$1, currentIndex;
      currentIndex = this.visibleChoices.indexOf(this.currentHighlighted);

      if (currentIndex > 0) {
        this.currentHighlighted = choice$$1 = this.visibleChoices[currentIndex - 1];

        if (!this.list.choiceInView(choice$$1)) {
          return this.list.scrollUp(choice$$1);
        }
      } else {
        this.currentHighlighted = choice$$1 = this.visibleChoices[this.visibleChoices.length - 1];

        if (!this.list.choiceInView(choice$$1)) {
          return this.list.scrollToChoice(choice$$1, 1);
        }
      }
    }

    highlightNext() {
      var choice$$1, currentIndex;
      currentIndex = this.visibleChoices.indexOf(this.currentHighlighted);

      if (currentIndex < this.visibleChoices.length - 1) {
        this.currentHighlighted = choice$$1 = this.visibleChoices[currentIndex + 1];

        if (!this.list.choiceInView(choice$$1)) {
          return this.list.scrollDown(choice$$1);
        }
      } else {
        this.currentHighlighted = choice$$1 = this.visibleChoices[0];

        if (!this.list.choiceInView(choice$$1)) {
          return this.list.scrollToChoice(choice$$1, 1);
        }
      }
    }

  }

  Dropdown.prototype.template = template$1$1;
  Dropdown.prototype.defaults = defaults;
  Dropdown.prototype._settingFilters = {
    maxHeight: function (value) {
      return IS$1$1.number(value);
    }
  };
  return Dropdown;
}.call(undefined);

List = class List {
  constructor(dropdown) {
    this.choiceInView = this.choiceInView.bind(this);
    this.dropdown = dropdown;
    ({
      els: this.els,
      field: this.field,
      settings: this.settings
    } = this.dropdown);
    this.el = this.els.list;
    this.container = this.els.container;
    this.appendedChoices = false;
  }

  appendChoices() {
    var choice$$1, i, len, ref;

    if (this.appendedChoices) {
      return;
    }

    ref = this.dropdown.choices;

    for (i = 0, len = ref.length; i < len; i++) {
      choice$$1 = ref[i];
      choice$$1.init();
    }

    return this.appendedChoices = true;
  }

  calcDisplay() {
    var bottomCutoff, clippingParent, clippingRect, cutoff, height, isBottomCutoff, isTopCutoff, needsNewHeight, padding, scrollHeight, selfRect, topCutoff, translation, windowCutoff, windowHeight;
    windowHeight = window.innerHeight;
    translation = this.translation || 0;
    clippingParent = this.container.parentMatching(function (parent) {
      var overflow;
      overflow = parent.style('overflowY');
      return overflow === 'hidden' || overflow === 'scroll';
    });
    scrollHeight = this.el.raw.scrollHeight || 2e308;
    selfRect = primaryBuilder$1.clone(this.container.rect);
    padding = selfRect.height - this.el.height;
    height = Math.min(scrollHeight, this.settings.maxHeight, window.innerHeight - 40);
    selfRect.bottom = selfRect.top + height;

    if (clippingParent) {
      clippingRect = clippingParent.rect;
      bottomCutoff = selfRect.bottom - clippingRect.bottom;
      topCutoff = clippingRect.top - selfRect.top;
      isBottomCutoff = bottomCutoff > 0;
      isTopCutoff = topCutoff > 0;

      if (selfRect.top >= clippingRect.bottom || clippingRect.top >= selfRect.bottom) {
        console.warn(`The dropdown for element '${this.field.ID}' cannot be displayed as it's hidden by the parent overflow`);
      } else if (isBottomCutoff || isTopCutoff) {
        needsNewHeight = true;

        if (selfRect.top - bottomCutoff > clippingRect.top && !isTopCutoff) {
          translation = bottomCutoff;
          selfRect.top -= translation;
          selfRect.bottom -= translation;
          cutoff = clippingRect.top - selfRect.top;
        } else if (selfRect.bottom - topCutoff < clippingRect.bottom) {
          translation = topCutoff * -1;
          selfRect.top += translation;
          selfRect.bottom += translation;
          cutoff = selfRect.bottom - clippingRect.bottom;
        }

        if (needsNewHeight = cutoff > 0) {
          height = cutoff - padding;
        }
      }
    }

    windowCutoff = selfRect.top + height - windowHeight;

    if (windowCutoff > 0 && height < windowHeight) {
      translation += windowCutoff + 10;
    }

    this.setDimensions(height, this.field.el.child.innerwrap.width + 10);
    return this.setTranslate(translation);
  }

  setDimensions(height, width) {
    if (height != null) {
      this.el.style('maxHeight', height);
    }

    if (width != null) {
      return this.el.style('minWidth', width);
    }
  }

  setTranslate(translation) {
    this.translation = translation;
    translation *= -1;
    return this.container.style('transform', `translateY(${translation}px)`);
  }

  scrollToChoice(choice$$1, offset = 3) {
    var distaneFromTop, selectedHeight;
    distaneFromTop = choice$$1.el.raw.offsetTop;
    selectedHeight = choice$$1.el.height;
    return this.el.raw.scrollTop = distaneFromTop - selectedHeight * offset;
  }

  scrollDown(choice$$1) {
    return this.el.raw.scrollTop += choice$$1.el.height;
  }

  scrollUp(choice$$1) {
    return this.el.raw.scrollTop -= choice$$1.el.height;
  }

  choiceInView(choice$$1) {
    var choiceRect, downPadding, listRect, upPadding;
    choiceRect = choice$$1.el.rect;
    listRect = this.el.rect;
    upPadding = this.els.scrollIndicatorUp.state('visible') ? parseFloat(this.els.scrollIndicatorUp.styleSafe('height', true)) : void 0;
    downPadding = this.els.scrollIndicatorDown.state('visible') ? parseFloat(this.els.scrollIndicatorDown.styleSafe('height', true)) : void 0;
    return choiceRect.bottom <= listRect.bottom - downPadding && choiceRect.top >= listRect.top + upPadding;
  }

  startScrolling(direction) {
    return this.scrollIntervalID = setInterval(() => {
      return this.el.raw.scrollTop += direction === 'up' ? -20 : 20;
    }, 50);
  }

  stopScrolling() {
    return clearInterval(this.scrollIntervalID);
  }

};
Choice = class Choice {
  constructor(dropdown, settings, list$$1, index) {
    var ref;
    this.dropdown = dropdown;
    this.settings = settings;
    this.list = list$$1;
    this.index = index;
    ({
      label: this.label,
      value: this.value,
      conditions: this.conditions
    } = this.settings);

    if (this.label == null) {
      this.label = this.value;
    }

    if (this.value == null) {
      this.value = this.label;
    }

    this.field = this.dropdown.field;
    this.visible = true;
    this.selected = false;
    this.unavailable = false;
    this.initialized = false;

    if ((ref = this.conditions) != null ? ref.length : void 0) {
      this.unavailable = true;
      this.allFields = this.field.allFields;
      Condition$1.init(this, this.conditions, () => {
        return this.unavailable = !Condition$1.validate(this.conditions);
      });
    }
  }

  init() {
    if (this.initialized) {
      return;
    }

    this.initialized = true;
    this.el = this.dropdown.template.choice.spawn(null, {
      relatedInstance: this.dropdown
    });
    this.el.children[1].text = this.label;
    this.el.appendTo(this.list.el);
    return this._attachBindings();
  }

  remove() {
    if (!this.initialized) {
      return;
    }

    return this.el.remove();
  }

  _attachBindings() {
    return (() => {
      simplybind('visible').of(this).to((visible, prev) => {
        this.dropdown.visibleChoicesCount += visible ? 1 : -1;
        this.el.state('visible', visible);

        if (visible) {
          this.dropdown.visibleChoices.push(this);

          if (IS$1$1.defined(prev)) {
            // indicates state has changed
            return this.dropdown.visibleChoices.sort(function (a$$1, b) {
              return a$$1.index - b.index;
            });
          }
        } else {
          return removeItem$1(this.dropdown.visibleChoices, this);
        }
      });
      simplybind('selected').of(this).to(selected => {
        return this.el.state('selected', selected);
      });
      simplybind('unavailable').of(this).to(unavailable => {
        return this.el.state('unavailable', unavailable);
      }).and.to(unavailable => {
        if (unavailable) {
          return this.toggle(false, true);
        }
      });
      simplybind('event:click').of(this.el).to(() => {
        return this.dropdown.lastSelected = this;
      });
      simplybind('event:mousedown').of(this.el).to(event => {
        event.preventDefault();
        return event.stopPropagation();
      });
      return simplybind('event:mouseenter').of(this.el).to(() => {
        return this.dropdown.currentHighlighted = this;
      });
    })();
  }

  toggle(newValue, unavailable) {
    var newState, prevState, ref, wasSelected;
    prevState = this.selected;
    newState = IS$1$1.defined(newValue) ? newValue : !this.selected;

    if (!newState) {
      if (this.dropdown.settings.multiple && prevState) {
        this.selected = newState;
        return removeItem$1(this.field._value, this);
      } else {
        wasSelected = this.selected;

        if (IS$1$1.defined(newValue)) {
          this.selected = newState;
        }

        if (unavailable && wasSelected) {
          return this.field._value = null;
        }
      }
    } else {
      this.selected = newState;

      if (this.field.settings.multiple) {
        this.field._value.push(this);
      } else {
        if ((ref = this.field._value) != null) {
          ref.toggle(false);
        }

        this.field._value = this;
      }

      return this.field.lastSelected = this;
    }
  }

};
var Dropdown$1 = Dropdown;var textMaskCore = createCommonjsModule(function (module, exports) {
  !function (e, r) {
    module.exports = r();
  }(commonjsGlobal, function () {
    return function (e) {
      function r(n) {
        if (t[n]) return t[n].exports;
        var o = t[n] = {
          exports: {},
          id: n,
          loaded: !1
        };
        return e[n].call(o.exports, o, o.exports, r), o.loaded = !0, o.exports;
      }

      var t = {};
      return r.m = e, r.c = t, r.p = "", r(0);
    }([function (e, r, t) {

      function n(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      });
      var o = t(3);
      Object.defineProperty(r, "conformToMask", {
        enumerable: !0,
        get: function () {
          return n(o).default;
        }
      });
      var i = t(2);
      Object.defineProperty(r, "adjustCaretPosition", {
        enumerable: !0,
        get: function () {
          return n(i).default;
        }
      });
      var a = t(5);
      Object.defineProperty(r, "createTextMaskInputElement", {
        enumerable: !0,
        get: function () {
          return n(a).default;
        }
      });
    }, function (e, r) {

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.placeholderChar = "_";
    }, function (e, r) {

      function t(e) {
        var r = e.previousConformedValue,
            t = void 0 === r ? o : r,
            i = e.previousPlaceholder,
            a = void 0 === i ? o : i,
            u = e.currentCaretPosition,
            l = void 0 === u ? 0 : u,
            s = e.conformedValue,
            f = e.rawValue,
            d = e.placeholderChar,
            c = e.placeholder,
            v = e.indexesOfPipedChars,
            p = void 0 === v ? n : v,
            h = e.caretTrapIndexes,
            g = void 0 === h ? n : h;
        if (0 === l) return 0;
        var m = f.length,
            y = t.length,
            b = c.length,
            C = s.length,
            P = m - y,
            x = P > 0,
            O = 0 === y,
            k = P > 1 && !x && !O;
        if (k) return l;
        var j = x && (t === s || s === c),
            M = 0,
            T = void 0,
            w = void 0;
        if (j) M = l - P;else {
          var _ = s.toLowerCase(),
              V = f.toLowerCase(),
              S = V.substr(0, l).split(o),
              N = S.filter(function (e) {
            return _.indexOf(e) !== -1;
          });

          w = N[N.length - 1];
          var E = a.substr(0, N.length).split(o).filter(function (e) {
            return e !== d;
          }).length,
              A = c.substr(0, N.length).split(o).filter(function (e) {
            return e !== d;
          }).length,
              R = A !== E,
              I = void 0 !== a[N.length - 1] && void 0 !== c[N.length - 2] && a[N.length - 1] !== d && a[N.length - 1] !== c[N.length - 1] && a[N.length - 1] === c[N.length - 2];
          !x && (R || I) && E > 0 && c.indexOf(w) > -1 && void 0 !== f[l] && (T = !0, w = f[l]);

          for (var J = p.map(function (e) {
            return _[e];
          }), q = J.filter(function (e) {
            return e === w;
          }).length, F = N.filter(function (e) {
            return e === w;
          }).length, L = c.substr(0, c.indexOf(d)).split(o).filter(function (e, r) {
            return e === w && f[r] !== e;
          }).length, W = L + F + q + (T ? 1 : 0), z = 0, B = 0; B < C; B++) {
            var D = _[B];
            if (M = B + 1, D === w && z++, z >= W) break;
          }
        }

        if (x) {
          for (var G = M, H = M; H <= b; H++) if (c[H] === d && (G = H), c[H] === d || g.indexOf(H) !== -1 || H === b) return G;
        } else if (T) {
          for (var K = M - 1; K >= 0; K--) if (s[K] === w || g.indexOf(K) !== -1 || 0 === K) return K;
        } else for (var Q = M; Q >= 0; Q--) if (c[Q - 1] === d || g.indexOf(Q) !== -1 || 0 === Q) return Q;
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = t;
      var n = [],
          o = "";
    }, function (e, r, t) {

      function n() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : a,
            t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
            n = t.guide,
            u = void 0 === n || n,
            l = t.previousConformedValue,
            s = void 0 === l ? a : l,
            f = t.placeholderChar,
            d = void 0 === f ? i.placeholderChar : f,
            c = t.placeholder,
            v = void 0 === c ? (0, o.convertMaskToPlaceholder)(r, d) : c,
            p = t.currentCaretPosition,
            h = t.keepCharPositions,
            g = u === !1 && void 0 !== s,
            m = e.length,
            y = s.length,
            b = v.length,
            C = r.length,
            P = m - y,
            x = P > 0,
            O = p + (x ? -P : 0),
            k = O + Math.abs(P);

        if (h === !0 && !x) {
          for (var j = a, M = O; M < k; M++) v[M] === d && (j += d);

          e = e.slice(0, O) + j + e.slice(O, m);
        }

        for (var T = e.split(a).map(function (e, r) {
          return {
            char: e,
            isNew: r >= O && r < k
          };
        }), w = m - 1; w >= 0; w--) {
          var _ = T[w].char;

          if (_ !== d) {
            var V = w >= O && y === C;
            _ === v[V ? w - P : w] && T.splice(w, 1);
          }
        }

        var S = a,
            N = !1;

        e: for (var E = 0; E < b; E++) {
          var A = v[E];

          if (A === d) {
            if (T.length > 0) for (; T.length > 0;) {
              var R = T.shift(),
                  I = R.char,
                  J = R.isNew;

              if (I === d && g !== !0) {
                S += d;
                continue e;
              }

              if (r[E].test(I)) {
                if (h === !0 && J !== !1 && s !== a && u !== !1 && x) {
                  for (var q = T.length, F = null, L = 0; L < q; L++) {
                    var W = T[L];
                    if (W.char !== d && W.isNew === !1) break;

                    if (W.char === d) {
                      F = L;
                      break;
                    }
                  }

                  null !== F ? (S += I, T.splice(F, 1)) : E--;
                } else S += I;

                continue e;
              }

              N = !0;
            }
            g === !1 && (S += v.substr(E, b));
            break;
          }

          S += A;
        }

        if (g && x === !1) {
          for (var z = null, B = 0; B < S.length; B++) v[B] === d && (z = B);

          S = null !== z ? S.substr(0, z + 1) : a;
        }

        return {
          conformedValue: S,
          meta: {
            someCharsRejected: N
          }
        };
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.default = n;
      var o = t(4),
          i = t(1),
          a = "";
    }, function (e, r, t) {

      function n() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : u.placeholderChar;
        if (e.indexOf(r) !== -1) throw new Error("Placeholder character must not be used as part of the mask. Please specify a character that is not present in your mask as your placeholder character.\n\n" + ("The placeholder character that was received is: " + JSON.stringify(r) + "\n\n") + ("The mask that was received is: " + JSON.stringify(e)));
        return e.map(function (e) {
          return e instanceof RegExp ? r : e;
        }).join("");
      }

      function o(e) {
        return "string" == typeof e || e instanceof String;
      }

      function i(e) {
        return "number" == typeof e && void 0 === e.length && !isNaN(e);
      }

      function a(e) {
        for (var r = [], t = void 0; t = e.indexOf(s), t !== -1;) r.push(t), e.splice(t, 1);

        return {
          maskWithoutCaretTraps: e,
          indexes: r
        };
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.convertMaskToPlaceholder = n, r.isString = o, r.isNumber = i, r.processCaretTraps = a;
      var u = t(1),
          l = [],
          s = "[]";
    }, function (e, r, t) {

      function n(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      function o(e) {
        var r = {
          previousConformedValue: void 0,
          previousPlaceholder: void 0
        };
        return {
          state: r,
          update: function (t) {
            var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e,
                o = n.inputElement,
                s = n.mask,
                d = n.guide,
                m = n.pipe,
                b = n.placeholderChar,
                C = void 0 === b ? p.placeholderChar : b,
                P = n.keepCharPositions,
                x = void 0 !== P && P,
                O = n.showMask,
                k = void 0 !== O && O;

            if ("undefined" == typeof t && (t = o.value), t !== r.previousConformedValue) {
              ("undefined" == typeof s ? "undefined" : l(s)) === y && void 0 !== s.pipe && void 0 !== s.mask && (m = s.pipe, s = s.mask);
              var j = void 0,
                  M = void 0;

              if (s instanceof Array && (j = (0, v.convertMaskToPlaceholder)(s, C)), s !== !1) {
                var T = a(t),
                    w = o.selectionEnd,
                    _ = r.previousConformedValue,
                    V = r.previousPlaceholder,
                    S = void 0;

                if (("undefined" == typeof s ? "undefined" : l(s)) === h) {
                  if (M = s(T, {
                    currentCaretPosition: w,
                    previousConformedValue: _,
                    placeholderChar: C
                  }), M === !1) return;
                  var N = (0, v.processCaretTraps)(M),
                      E = N.maskWithoutCaretTraps,
                      A = N.indexes;
                  M = E, S = A, j = (0, v.convertMaskToPlaceholder)(M, C);
                } else M = s;

                var R = {
                  previousConformedValue: _,
                  guide: d,
                  placeholderChar: C,
                  pipe: m,
                  placeholder: j,
                  currentCaretPosition: w,
                  keepCharPositions: x
                },
                    I = (0, c.default)(T, M, R),
                    J = I.conformedValue,
                    q = ("undefined" == typeof m ? "undefined" : l(m)) === h,
                    F = {};
                q && (F = m(J, u({
                  rawValue: T
                }, R)), F === !1 ? F = {
                  value: _,
                  rejected: !0
                } : (0, v.isString)(F) && (F = {
                  value: F
                }));
                var L = q ? F.value : J,
                    W = (0, f.default)({
                  previousConformedValue: _,
                  previousPlaceholder: V,
                  conformedValue: L,
                  placeholder: j,
                  rawValue: T,
                  currentCaretPosition: w,
                  placeholderChar: C,
                  indexesOfPipedChars: F.indexesOfPipedChars,
                  caretTrapIndexes: S
                }),
                    z = L === j && 0 === W,
                    B = k ? j : g,
                    D = z ? B : L;
                r.previousConformedValue = D, r.previousPlaceholder = j, o.value !== D && (o.value = D, i(o, W));
              }
            }
          }
        };
      }

      function i(e, r) {
        document.activeElement === e && (b ? C(function () {
          return e.setSelectionRange(r, r, m);
        }, 0) : e.setSelectionRange(r, r, m));
      }

      function a(e) {
        if ((0, v.isString)(e)) return e;
        if ((0, v.isNumber)(e)) return String(e);
        if (void 0 === e || null === e) return g;
        throw new Error("The 'value' provided to Text Mask needs to be a string or a number. The value received was:\n\n " + JSON.stringify(e));
      }

      Object.defineProperty(r, "__esModule", {
        value: !0
      });

      var u = Object.assign || function (e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = arguments[r];

          for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
        }

        return e;
      },
          l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e;
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      };

      r.default = o;
      var s = t(2),
          f = n(s),
          d = t(3),
          c = n(d),
          v = t(4),
          p = t(1),
          h = "function",
          g = "",
          m = "none",
          y = "object",
          b = "undefined" != typeof navigator && /Android/i.test(navigator.userAgent),
          C = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : setTimeout;
    }]);
  });
});
var maskCore = unwrapExports(textMaskCore);
var textMaskCore_1 = textMaskCore.textMaskCore;var textMaskAddons = createCommonjsModule(function (module, exports) {
  !function (e, t) {
    module.exports = t();
  }(commonjsGlobal, function () {
    return function (e) {
      function t(r) {
        if (n[r]) return n[r].exports;
        var o = n[r] = {
          exports: {},
          id: r,
          loaded: !1
        };
        return e[r].call(o.exports, o, o.exports, t), o.loaded = !0, o.exports;
      }

      var n = {};
      return t.m = e, t.c = n, t.p = "", t(0);
    }([function (e, t, n) {

      function r(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      var o = n(1);
      Object.defineProperty(t, "createAutoCorrectedDatePipe", {
        enumerable: !0,
        get: function () {
          return r(o).default;
        }
      });
      var i = n(2);
      Object.defineProperty(t, "createNumberMask", {
        enumerable: !0,
        get: function () {
          return r(i).default;
        }
      });
      var u = n(3);
      Object.defineProperty(t, "emailMask", {
        enumerable: !0,
        get: function () {
          return r(u).default;
        }
      });
    }, function (e, t) {

      function n() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "mm dd yyyy";
        return function (t) {
          var n = [],
              r = e.split(/[^dmy]+/),
              o = {
            dd: 31,
            mm: 12,
            yy: 99,
            yyyy: 9999
          },
              i = {
            dd: 1,
            mm: 1,
            yy: 0,
            yyyy: 1
          },
              u = t.split("");
          r.forEach(function (t) {
            var r = e.indexOf(t),
                i = parseInt(o[t].toString().substr(0, 1), 10);
            parseInt(u[r], 10) > i && (u[r + 1] = u[r], u[r] = 0, n.push(r));
          });
          var c = r.some(function (n) {
            var r = e.indexOf(n),
                u = n.length,
                c = t.substr(r, u).replace(/\D/g, ""),
                l = parseInt(c, 10);
            return l > o[n] || c.length === u && l < i[n];
          });
          return !c && {
            value: u.join(""),
            indexesOfPipedChars: n
          };
        };
      }

      Object.defineProperty(t, "__esModule", {
        value: !0
      }), t.default = n;
    }, function (e, t) {

      function n() {
        function e() {
          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : c,
              t = e.length;
          if (e === c || e[0] === h[0] && 1 === t) return h.split(c).concat([v]).concat(m.split(c));
          if (e === S && M) return h.split(c).concat(["0", S, v]).concat(m.split(c));
          var n = e.lastIndexOf(S),
              u = n !== -1,
              l = e[0] === s && I,
              a = void 0,
              g = void 0,
              b = void 0;

          if (e.slice(V * -1) === m && (e = e.slice(0, V * -1)), u && (M || D) ? (a = e.slice(e.slice(0, $) === h ? $ : 0, n), g = e.slice(n + 1, t), g = r(g.replace(f, c))) : a = e.slice(0, $) === h ? e.slice($) : e, N && ("undefined" == typeof N ? "undefined" : i(N)) === p) {
            var O = "." === _ ? "[.]" : "" + _,
                j = (a.match(new RegExp(O, "g")) || []).length;
            a = a.slice(0, N + j * q);
          }

          return a = a.replace(f, c), A || (a = a.replace(/^0+(0$|[^0])/, "$1")), a = x ? o(a, _) : a, b = r(a), (u && M || D === !0) && (e[n - 1] !== S && b.push(y), b.push(S, y), g && (("undefined" == typeof C ? "undefined" : i(C)) === p && (g = g.slice(0, C)), b = b.concat(g)), D === !0 && e[n - 1] === S && b.push(v)), $ > 0 && (b = h.split(c).concat(b)), l && (b.length === $ && b.push(v), b = [d].concat(b)), m.length > 0 && (b = b.concat(m.split(c))), b;
        }

        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
            n = t.prefix,
            h = void 0 === n ? u : n,
            g = t.suffix,
            m = void 0 === g ? c : g,
            b = t.includeThousandsSeparator,
            x = void 0 === b || b,
            O = t.thousandsSeparatorSymbol,
            _ = void 0 === O ? l : O,
            j = t.allowDecimal,
            M = void 0 !== j && j,
            P = t.decimalSymbol,
            S = void 0 === P ? a : P,
            w = t.decimalLimit,
            C = void 0 === w ? 2 : w,
            k = t.requireDecimal,
            D = void 0 !== k && k,
            E = t.allowNegative,
            I = void 0 !== E && E,
            R = t.allowLeadingZeroes,
            A = void 0 !== R && R,
            L = t.integerLimit,
            N = void 0 === L ? null : L,
            $ = h && h.length || 0,
            V = m && m.length || 0,
            q = _ && _.length || 0;

        return e.instanceOf = "createNumberMask", e;
      }

      function r(e) {
        return e.split(c).map(function (e) {
          return v.test(e) ? v : e;
        });
      }

      function o(e, t) {
        return e.replace(/\B(?=(\d{3})+(?!\d))/g, t);
      }

      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e;
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      };
      t.default = n;
      var u = "$",
          c = "",
          l = ",",
          a = ".",
          s = "-",
          d = /-/,
          f = /\D+/g,
          p = "number",
          v = /\d/,
          y = "[]";
    }, function (e, t, n) {

      function r(e) {
        return e && e.__esModule ? e : {
          default: e
        };
      }

      function o(e, t) {
        e = e.replace(O, v);
        var n = t.placeholderChar,
            r = t.currentCaretPosition,
            o = e.indexOf(y),
            s = e.lastIndexOf(p),
            d = s < o ? -1 : s,
            f = i(e, o + 1, y),
            h = i(e, d - 1, p),
            g = u(e, o, n),
            m = c(e, o, d, n),
            b = l(e, d, n, r);
        g = a(g), m = a(m), b = a(b, !0);
        var x = g.concat(f).concat(m).concat(h).concat(b);
        return x;
      }

      function i(e, t, n) {
        var r = [];
        return e[t] === n ? r.push(n) : r.push(h, n), r.push(h), r;
      }

      function u(e, t) {
        return t === -1 ? e : e.slice(0, t);
      }

      function c(e, t, n, r) {
        var o = v;
        return t !== -1 && (o = n === -1 ? e.slice(t + 1, e.length) : e.slice(t + 1, n)), o = o.replace(new RegExp("[\\s" + r + "]", m), v), o === y ? f : o.length < 1 ? g : o[o.length - 1] === p ? o.slice(0, o.length - 1) : o;
      }

      function l(e, t, n, r) {
        var o = v;
        return t !== -1 && (o = e.slice(t + 1, e.length)), o = o.replace(new RegExp("[\\s" + n + ".]", m), v), 0 === o.length ? e[t - 1] === p && r !== e.length ? f : v : o;
      }

      function a(e, t) {
        return e.split(v).map(function (e) {
          return e === g ? e : t ? x : b;
        });
      }

      Object.defineProperty(t, "__esModule", {
        value: !0
      });
      var s = n(4),
          d = r(s),
          f = "*",
          p = ".",
          v = "",
          y = "@",
          h = "[]",
          g = " ",
          m = "g",
          b = /[^\s]/,
          x = /[^.\s]/,
          O = /\s/g;
      t.default = {
        mask: o,
        pipe: d.default
      };
    }, function (e, t) {

      function n(e, t) {
        var n = t.currentCaretPosition,
            i = t.rawValue,
            f = t.previousConformedValue,
            p = t.placeholderChar,
            v = e;
        v = r(v);
        var y = v.indexOf(c),
            h = null === i.match(new RegExp("[^@\\s." + p + "]"));
        if (h) return u;
        if (v.indexOf(a) !== -1 || y !== -1 && n !== y + 1 || i.indexOf(o) === -1 && f !== u && i.indexOf(l) !== -1) return !1;
        var g = v.indexOf(o),
            m = v.slice(g + 1, v.length);
        return (m.match(d) || s).length > 1 && v.substr(-1) === l && n !== i.length && (v = v.slice(0, v.length - 1)), v;
      }

      function r(e) {
        var t = 0;
        return e.replace(i, function () {
          return t++, 1 === t ? o : u;
        });
      }

      Object.defineProperty(t, "__esModule", {
        value: !0
      }), t.default = n;
      var o = "@",
          i = /@/g,
          u = "",
          c = "@.",
          l = ".",
          a = "..",
          s = [],
          d = /\./g;
    }]);
  });
});
var maskAddons = unwrapExports(textMaskAddons);
var textMaskAddons_1 = textMaskAddons.textMaskAddons;var Mask, defaultPatternChars;
defaultPatternChars = {
  '1': REGEX.numeric,
  '#': REGEX.widenumeric,
  'a': REGEX.letter,
  '*': REGEX.any
};
Mask = class Mask {
  constructor(field, config) {
    this.field = field;
    this.config = config;
    this.value = '';
    this.prevValue = '';
    this.cursor = 0;
    this.prevCursor = 0;
    this.pattern = this.patternRaw = this.config.pattern;
    this.patternSetter = this.config.setter;
    this.placeholderChar = this.config.placeholder;
    this.placeholderRegex = new RegExp('\\' + (this.placeholderChar || '_'), 'g');
    this.guide = this.config.guide;
    this.keepCharPositions = this.config.keepCharPositions;
    this.chars = primaryBuilder$1.clone(defaultPatternChars, this.config.customPatterns);
    this.setPattern(this.pattern);
  }

  getState(pattern, rawValue) {
    return {
      rawValue,
      guide: this.guide,
      placeholderChar: this.placeholderChar,
      keepCharPositions: this.keepCharPositions,
      currentCaretPosition: this.field.el ? this.field.selection().end : this.cursor,
      previousConformedValue: this.prevValue,
      placeholder: this.getPlaceholder(pattern)
    };
  }

  getPlaceholder(pattern) {
    var char, j, len, placeholder;
    if (IS$1$1.function(pattern)) ;else {
      placeholder = '';

      for (j = 0, len = pattern.length; j < len; j++) {
        char = pattern[j];

        if (IS$1$1.regex(char)) {
          placeholder += this.placeholderChar;
        } else {
          placeholder += char;
        }
      }

      return placeholder;
    }
  }

  resolvePattern(pattern, input, state) {
    var char, copy, i, j, len, offset, trapIndexes;
    pattern = typeof pattern === 'function' ? pattern(input, this.getState(pattern, input)) : pattern;
    offset = 0;
    trapIndexes = [];
    copy = pattern.slice();

    for (i = j = 0, len = copy.length; j < len; i = ++j) {
      char = copy[i];

      if (!(char === '[]')) {
        continue;
      }

      trapIndexes.push(i - offset);
      pattern.splice(i - offset, 1);
      offset++;
    }

    this.prevPattern = this.resolvedPattern;
    this.resolvedPattern = pattern;
    return {
      pattern,
      caretTrapIndexes: trapIndexes
    };
  }

  setPattern(string, updateValue = true, updateField) {
    this.patternRaw = string;
    this.pattern = this.parsePattern(string);
    this.transform = this.parseTransform(string);

    if (updateValue) {
      this.value = this.setValue(this.value);

      if (updateField) {
        return this.field.value = this.value;
      }
    }
  }

  parsePattern(string) {
    var char, escaped, i, j, len, pattern;

    switch (false) {
      case string !== 'EMAIL':
        return maskAddons.emailMask.mask;

      case string !== 'PHONE':
        this.patternSetter = function (value) {
          return repeat('#', Math.max(7, value.length));
        };

        this.guide = false;
        return '#';

      case string !== 'NAME':
        this.patternSetter = function (value) {
          value = value.replace(this.placeholderRegex, '').trim();
          return repeat('a', Math.max(2, value.length));
        };

        return 'a';

      case string !== 'FULLNAME':
        this.patternSetter = function (value) {
          var split;

          if (value[value.length - 1] === ' ') {
            value += 'x';
          }

          split = value.replace(this.placeholderRegex, '').trim().split(/\s+/);

          if (split.length === 4) {
            return;
          }

          return split.map(function (part) {
            return repeat('a', Math.max(2, part.length));
          }).join(' ');
        };

        return 'a';

      case string !== 'DATE':
        return [/\d/, /\d/, '/', /\d/, /\d/, '/', /\d/, /\d/, /\d/, /\d/];

      case !(string[0] === 'DATE' && IS$1$1.string(string[1])):
        return string[1].split('').map(char => {
          if (REGEX.letter.test(char)) {
            return /\d/;
          } else {
            return char;
          }
        });

      case string !== 'NUMBER':
        return maskAddons.createNumberMask({
          prefix: this.config.prefix || '',
          suffix: this.config.suffix || '',
          includeThousandsSeparator: this.config.sep ? true : false,
          thousandsSeparatorSymbol: IS$1$1.string(this.config.sep) ? this.config.sep : void 0,
          allowDecimal: this.config.decimal,
          decimalLimit: IS$1$1.number(this.config.decimal) ? this.config.decimal : void 0,
          integerLimit: IS$1$1.number(this.config.limit) ? this.config.limit : void 0
        });

      case !IS$1$1.array(string):
        return string;

      default:
        pattern = [];

        for (i = j = 0, len = string.length; j < len; i = ++j) {
          char = string[i];

          if (char === '\\') {
            escaped = true;
            continue;
          }

          pattern.push(escaped ? char : this.chars[char] || char);
          escaped = false;
        }

        return pattern;
    }
  }

  parseTransform(string) {
    switch (false) {
      case string !== 'EMAIL':
        return maskAddons.emailMask.pipe;

      case string !== 'DATE':
        return maskAddons.createAutoCorrectedDatePipe('mm/dd/yyyy');

      case !(string[0] === 'DATE' && IS$1$1.string(string[1])):
        return maskAddons.createAutoCorrectedDatePipe(string[1]);

      case !this.config.transform:
        return this.config.transform;
    }
  }

  setValue(input) {
    var caretTrapIndexes, conformedValue, indexesOfPipedChars, newPattern, pattern, state, transformed;

    if (this.patternSetter) {
      newPattern = this.patternSetter(input) || this.pattern;

      if (newPattern !== this.patternRaw && newPattern !== this.pattern) {
        this.setPattern(newPattern, false);
      }
    }

    ({
      caretTrapIndexes,
      pattern
    } = this.resolvePattern(this.pattern, input));

    if (pattern === false) {
      return this.value;
    }

    this.prevValue = this.value;
    this.prevCursor = this.cursor;
    state = this.getState(pattern, input);
    ({
      conformedValue
    } = maskCore.conformToMask(input, pattern, state));

    if (this.transform) {
      transformed = this.transform(conformedValue, state);
    }

    if (transformed === false) {
      return this.value;
    }

    if (IS$1$1.string(transformed)) {
      conformedValue = transformed;
    } else if (IS$1$1.object(transformed)) {
      indexesOfPipedChars = transformed.indexesOfPipedChars;
      conformedValue = transformed.value;
    }

    this.cursor = maskCore.adjustCaretPosition(primaryBuilder$1(state, {
      indexesOfPipedChars,
      caretTrapIndexes,
      conformedValue
    }));
    return this.value = conformedValue;
  }

  validate(input) {
    var char, i, j, len, pattern;

    if (input !== this.value && this.patternSetter) {
      pattern = this.patternSetter(input) || this.pattern;
    } else {
      pattern = this.resolvedPattern;

      if (!pattern) {
        ({
          pattern
        } = this.resolvePattern(this.pattern, input));
      }
    }

    if (pattern === false) {
      return true;
    }

    for (i = j = 0, len = pattern.length; j < len; i = ++j) {
      char = pattern[i];

      switch (false) {
        case !!input[i]:
          return false;

        case !(IS$1$1.regex(char) && !char.test(input[i])):
          return false;

        case !(IS$1$1.string(char) && input[i] !== char):
          return false;
      }
    }

    return true;
  }

  isEmpty() {
    var char, i, input, j, len, pattern;
    input = this.value;
    pattern = this.resolvedPattern;

    if (!pattern) {
      if (this.patternSetter) {
        pattern = this.patternSetter(input);
      }

      ({
        pattern
      } = this.resolvePattern(pattern || this.pattern, input));
    }

    if (input === this.config.prefix || input === this.config.suffix) {
      return true;
    }

    for (i = j = 0, len = pattern.length; j < len; i = ++j) {
      char = pattern[i];

      switch (false) {
        case !!input[i]:
          return true;

        case !IS$1$1.regex(char):
          return !char.test(input[i]);
      }
    }

    return false;
  }

};
var Mask$1 = Mask;var COLORS$1 = {
  red: '#cc4820',
  green: '#72c322',
  orange: '#ff9c00',
  black: '#181818',
  grey_dark: '#5e5e5e',
  grey: '#909090',
  grey_semi_light: '#bebebe',
  grey_light: '#d3d3d3',
  grey_light2: '#dddddd',
  grey_light3: '#f2f5f7',
  grey_light4: '#e5e5e5'
};var textFieldTemplate = quickdom.template(['div', {
  ref: 'field',
  style: {
    position: 'relative',
    verticalAlign: 'top',
    display: 'none',
    boxSizing: 'border-box',
    fontFamily: function (field) {
      return field.settings.fontFamily;
    },
    textAlign: 'left',
    $visible: {
      display: 'inline-block'
    },
    $showError: {
      animation: '0.2s fieldErrorShake'
    }
  }
}, ['div', {
  ref: 'label',
  styleAfterInsert: true,
  style: {
    position: 'absolute',
    zIndex: 1,
    top: function (field) {
      return this.styleParsed('fontSize', true) * 0.7;
    },
    left: function (field) {
      var ref;
      return shorthandSideValue(field.settings.padding, 'left') + (((ref = field.el.child.icon) != null ? ref.width : void 0) || 0);
    },
    padding: function (field) {
      return `0 ${field.settings.inputPadding}px`;
    },
    fontFamily: 'inherit',
    fontSize: function (field) {
      return field.settings.labelSize || field.settings.fontSize * (11 / 14);
    },
    fontWeight: 600,
    lineHeight: 1,
    color: COLORS$1.grey,
    opacity: 0,
    transition: 'opacity 0.2s, color 0.2s',
    whiteSpace: 'nowrap',
    userSelect: 'none',
    cursor: 'default',
    pointerEvents: 'none',
    $filled: {
      $showLabel: {
        opacity: 1
      }
    },
    $focus: {
      color: COLORS$1.orange
    },
    $showError: {
      color: COLORS$1.red
    }
  }
}], ['div', {
  ref: 'innerwrap',
  style: {
    position: 'relative',
    height: function (field) {
      return field.settings.height;
    },
    backgroundColor: 'white',
    borderWidth: function (field) {
      return field.settings.border;
    },
    borderStyle: 'solid',
    borderColor: COLORS$1.grey_light,
    borderRadius: '2px',
    boxSizing: 'border-box',
    fontFamily: 'inherit',
    transition: 'border-color 0.2s',
    $focus: {
      borderColor: COLORS$1.orange
    },
    $showError: {
      borderColor: COLORS$1.red
    },
    $disabled: {
      borderColor: COLORS$1.grey_light,
      backgroundColor: COLORS$1.grey_light
    }
  }
}, ['input', {
  ref: 'input',
  type: 'text',
  styleAfterInsert: true,
  style: {
    position: 'relative',
    zIndex: 3,
    display: 'inline-block',
    verticalAlign: 'top',
    height: function () {
      return this.parent.styleSafe('height', 1) || this.parent.styleSafe('height');
    },
    width: function (field) {
      var iconSibling, inputSibling, padding, paddingLeft, paddingRight, subtract, width;

      if (!field.settings.autoWidth) {
        subtract = 0;

        if (iconSibling = field.el.child.icon) {
          subtract += iconSibling.width;
        }

        if (inputSibling = field.el.child[field.settings.inputSibling]) {
          width = inputSibling.styleParsed('width', 1) || 0;
          padding = inputSibling.styleParsed('padding', 1) || 0;
          paddingLeft = inputSibling.styleParsed('paddingLeft', 1) || padding || 0;
          paddingRight = inputSibling.styleParsed('paddingRight', 1) || padding || 0;
          subtract += width + paddingLeft + paddingRight;
        }

        return `calc(100% - ${subtract}px)`;
      }
    },
    padding: function (field) {
      if (this.padding == null) {
        this.padding = Math.max(0, calcPadding(field.settings.height, 14) - 3);
      }

      return `${this.padding}px ${field.settings.inputPadding}px`;
    },
    margin: '0',
    backgroundColor: 'transparent',
    appearance: 'none',
    border: 'none',
    outline: 'none',
    fontFamily: 'inherit',
    fontSize: function (field) {
      return field.settings.fontSize;
    },
    color: COLORS$1.black,
    boxSizing: 'border-box',
    boxShadow: 'none',
    whiteSpace: 'nowrap',
    backgroundClip: 'content-box',
    // semi-fix for yellow autofill background
    transform: 'translateY(0)',
    transition: 'transform 0.2s, -webkit-transform 0.2s',
    $disabled: {
      cursor: 'not-allowed'
    },
    $filled: {
      $showLabel: {
        transform: function (field) {
          var label, totalHeight, translation, workableHeight;

          if (this.translation != null || !(label = field.el.child.label) || label.styleSafe('position', 1) !== 'absolute') {
            return this.translation;
          }

          totalHeight = this.parent.styleParsed('height', 1);
          workableHeight = totalHeight - (label.styleParsed('fontSize', 1) + label.styleParsed('top', 1) * 2);
          translation = Math.max(0, Math.floor((totalHeight - workableHeight) / 4));
          return `translateY(${translation}px)`;
        }
      }
    }
  }
}], ['div', {
  ref: 'placeholder',
  styleAfterInsert: true,
  style: {
    position: 'absolute',
    zIndex: 2,
    top: '0px',
    left: function (field) {
      var ref;
      return ((ref = field.el.child.icon) != null ? ref.width : void 0) || 0;
    },
    fontFamily: function (field) {
      return field.el.child.input.styleSafe('fontFamily', 1);
    },
    fontSize: function (field) {
      return field.el.child.input.styleSafe('fontSize', 1);
    },
    padding: function (field) {
      var horiz, verti;
      verti = field.el.child.input.styleParsed('paddingTop', 1) || field.el.child.input.styleParsed('paddingTop');
      horiz = field.el.child.input.styleParsed('paddingLeft', 1) || field.el.child.input.styleParsed('paddingLeft');
      return `${verti + 3}px ${horiz}px`;
    },
    color: COLORS$1.black,
    opacity: 0.5,
    pointerEvents: 'none',
    userSelect: 'none',
    whiteSpace: 'nowrap',
    transform: 'translateY(0)',
    transition: 'transform 0.2s, -webkit-transform 0.2s',
    $filled: {
      visibility: 'hidden',
      $showLabel: {
        transform: function (field) {
          return field.el.child.input.raw.style.transform;
        }
      }
    }
  }
}]], ['div', {
  ref: 'help',
  styleAfterInsert: true,
  style: {
    position: 'absolute',
    top: '110%',
    left: function (field) {
      return shorthandSideValue(field.settings.padding, 'left');
    },
    fontFamily: 'inherit',
    fontSize: '11px',
    color: COLORS$1.grey,
    display: 'none',
    $showError: {
      color: COLORS$1.red
    },
    $showHelp: {
      display: 'block'
    }
  }
}]]);
var icon = quickdom.template(['div', {
  ref: 'icon',
  styleAfterInsert: true,
  style: {
    position: 'relative',
    zIndex: 2,
    display: 'inline-block',
    boxSizing: 'border-box',
    width: function (field) {
      return field.settings.iconSize;
    },
    height: function (field) {
      return field.settings.iconSize;
    },
    fontSize: function (field) {
      return field.settings.iconSize;
    },
    paddingLeft: function (field) {
      return field.settings.inputPadding;
    },
    paddingTop: function (field) {
      return this.parent.styleParsed('height', 1) / 2 - field.settings.iconSize / 2;
    },
    lineHeight: '1em',
    userSelect: 'none'
  },
  methods: {
    width: {
      get: function () {
        if (this._inserted) {
          return this.raw.offsetWidth;
        } else {
          return this.styleParsed('width', 1) || this.related.settings.iconSize;
        }
      }
    }
  }
}]); // @styleParsed('width',1) or @raw.offsetWidth or @related.settings.iconSize or 0

var checkmark$1 = quickdom.template(['div', {
  ref: 'checkmark',
  styleAfterInsert: true,
  style: {
    position: 'relative',
    zIndex: 4,
    display: 'none',
    width: 26,
    height: '100%',
    paddingTop: function () {
      return this.parent.styleParsed('height', 1) / 2 - 13;
    },
    paddingRight: function (field) {
      return field.settings.inputPadding;
    },
    verticalAlign: 'top',
    $filled: {
      display: 'inline-block'
    }
  }
}, ['div', {
  ref: 'checkmark_innerwrap',
  style: {
    width: '20px',
    height: '20px',
    borderRadius: '50%',
    borderWidth: '3px',
    borderStyle: 'solid',
    borderColor: COLORS$1.green,
    transform: 'scale(0.8)',
    // transformOrigin: '100% 0'
    $showError: {
      borderColor: COLORS$1.red
    }
  }
}, ['div', {
  ref: 'checkmark_mask1',
  styleAfterInsert: true,
  style: {
    position: 'absolute',
    top: '-4px',
    left: '-10px',
    width: '15px',
    height: '30px',
    borderRadius: '30px 0 0 30px',
    backgroundColor: function (field) {
      return defaultColor(field.els.innerwrap.styleSafe('backgroundColor', 1), 'white');
    },
    transform: 'rotate(-45deg)',
    transformOrigin: '15px 15px 0'
  }
}], ['div', {
  ref: 'checkmark_mask2',
  styleAfterInsert: true,
  style: {
    position: 'absolute',
    top: '-5px',
    left: '8px',
    width: '15px',
    height: '30px',
    borderRadius: '0 30px 30px 0',
    backgroundColor: function (field) {
      return defaultColor(field.els.innerwrap.styleSafe('backgroundColor', 1), 'white');
    },
    transform: 'rotate(-45deg)',
    transformOrigin: '0 15px 0',
    $filled: {
      animation: '4.25s ease-in checkmarkRotatePlaceholder',
      $invalid: {
        animation: ''
      }
    }
  }
}], ['div', {
  ref: 'checkmark_lineWrapper',
  style: {
    $filled: {
      $invalid: {
        position: 'relative',
        zIndex: 2,
        animation: '0.55s checkmarkAnimateError',
        transformOrigin: '50% 10px'
      }
    }
  }
}, ['div', {
  ref: 'checkmark_lineShort',
  style: {
    position: 'absolute',
    zIndex: 2,
    top: '10px',
    left: '3px',
    display: 'block',
    width: '8px',
    height: '3px',
    borderRadius: '2px',
    backgroundColor: COLORS$1.green,
    transform: 'rotate(45deg)',
    $filled: {
      animation: '0.75s checkmarkAnimateSuccessTip'
    },
    $invalid: {
      backgroundColor: COLORS$1.red,
      left: '4px',
      top: '8px',
      width: '12px',
      $filled: {
        animation: ''
      }
    }
  }
}], ['div', {
  ref: 'checkmark_lineLong',
  style: {
    position: 'absolute',
    zIndex: 2,
    top: '8px',
    right: '2px',
    display: 'block',
    width: '12px',
    height: '3px',
    borderRadius: '2px',
    backgroundColor: COLORS$1.green,
    transform: 'rotate(-45deg)',
    $filled: {
      animation: '0.75s checkmarkAnimateSuccessLong'
    },
    $invalid: {
      backgroundColor: COLORS$1.red,
      top: '8px',
      left: '4px',
      right: 'auto',
      $filled: {
        animation: ''
      }
    }
  }
}]], ['div', {
  ref: 'checkmark_placeholder',
  style: {
    position: 'absolute',
    zIndex: 2,
    top: '-4px',
    left: '-3px',
    width: '20px',
    height: '20px',
    borderRadius: '50%',
    borderWidth: '3px',
    borderStyle: 'solid',
    borderColor: hexToRGBA(COLORS$1.green, 0.4),
    $invalid: {
      borderColor: hexToRGBA(COLORS$1.red, 0.4)
    }
  }
}], ['div', {
  ref: 'checkmark_patch',
  styleAfterInsert: true,
  style: {
    position: 'absolute',
    zIndex: 1,
    top: '-2px',
    left: '6px',
    width: '4px',
    height: '28px',
    backgroundColor: function (field) {
      return defaultColor(field.els.innerwrap.styleSafe('backgroundColor', 1), 'white');
    },
    transform: 'rotate(-45deg)'
  }
}]]]);
var templates =
/*#__PURE__*/
Object.freeze({
  default: textFieldTemplate,
  icon: icon,
  checkmark: checkmark$1
});var defaults$1 = {
  placeholder: true,
  validWhenIsChoice: false,
  validWhenRegex: false,
  autoWidth: false,
  maxWidth: '100%',
  minWidth: 2,
  height: 46,
  checkmark: true,
  keyboard: 'text',
  dropdown: {
    lockScroll: false
  },
  choices: null,
  minLength: null,
  maxLength: null,
  inputSibling: 'checkmark',
  mask: {
    pattern: false,
    placeholder: '_',
    guide: true,
    customPatterns: false
  }
};var TextField;

TextField = function () {
  class TextField extends Field$1 {
    constructor() {
      super(...arguments);

      if (this._value == null) {
        this._value = '';
      }

      this.state.typing = false;
      this.cursor = {
        prev: 0,
        current: 0
      };

      if (!this.settings.validWhenRegex) {
        if (this.settings.keyboard === 'email' && this.settings.required) {
          this.settings.validWhenRegex = REGEX.email;
        } else if (this.settings.mask === 'NAME' || this.settings.mask.pattern === 'NAME') {
          this.settings.validWhenRegex = /^[a-zA-Z]{2}/;
        } else if (this.settings.mask === 'FULLNAME' || this.settings.mask.pattern === 'FULLNAME') {
          this.settings.validWhenRegex = /^[a-zA-Z]+\s+[a-zA-Z]+/;
        }
      }

      if (!this.settings.mask.pattern) {
        if (IS$1$1.string(this.settings.mask)) {
          this.settings.mask = primaryBuilder$1.deep.clone(this.defaults.mask, {
            pattern: this.settings.mask
          });
        } else if (IS$1$1.object(this.settings.mask)) {
          this.settings.mask.pattern = function () {
            switch (this.settings.keyboard) {
              case 'date':
                return 'DATE';

              case 'number':
                return 'NUMBER';

              case 'phone':
              case 'tel':
                return 'PHONE';

              case 'email':
                return 'EMAIL';
            }
          }.call(this);
        }
      }

      if (this.settings.mask.pattern) {
        this.mask = new Mask$1(this, this.settings.mask);
      }

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      if (this.dropdown && this.selected && this._value === this.selected.label) {
        return this.selected.value;
      } else {
        return this._value;
      }
    }

    _setValue(newValue) {
      if (IS$1$1.string(newValue) || IS$1$1.number(newValue)) {
        newValue = String(newValue);
        return this._value = this.mask ? this.mask.setValue(newValue) : newValue;
      }
    }

    _recalcDisplay() {
      if (this.settings.autoWidth) {
        return this._value = this._value;
      }
    }

    _createElements() {
      var globalOpts;
      globalOpts = {
        relatedInstance: this
      };
      this.el = this.template.spawn(this.settings.templates.default, globalOpts);

      if (this.settings.choices) {
        this.dropdown = new Dropdown$1(this.settings.choices, this);
        this.dropdown.appendTo(this.el.child.innerwrap);
      }

      if (this.settings.icon) {
        this.templates.icon.spawn(this.settings.templates.icon, globalOpts).append(this.settings.icon).insertBefore(this.el.child.input);
      }

      if (this.settings.checkmark) {
        this.templates.checkmark.spawn(this.settings.templates.checkmark, globalOpts).insertAfter(this.el.child.input);
      }

      this.el.child.input.prop('type', function () {
        switch (this.settings.keyboard) {
          case 'number':
          case 'tel':
          case 'phone':
            return 'tel';

          case 'password':
            return 'password';

          case 'url':
            return 'url';

          default:
            // when 'email' then 'email'
            return 'text';
        }
      }.call(this));
      this.el.state('hasLabel', this.settings.label);
      this.el.child.innerwrap.raw._quickField = this.el.child.input.raw._quickField = this;
      return this.el.childf;
    }

    _attachBindings() {
      this._attachBindings_elState();

      this._attachBindings_display();

      this._attachBindings_display_autoWidth();

      this._attachBindings_value();

      this._attachBindings_autocomplete();

      this._attachBindings_stateTriggers();
    }

    _attachBindings_elState() {
      simplybind('visible').of(this.state).to(visible => {
        return this.el.state('visible', visible);
      });
      simplybind('hovered').of(this.state).to(hovered => {
        return this.el.state('hover', hovered);
      });
      simplybind('focused').of(this.state).to(focused => {
        return this.el.state('focus', focused);
      });
      simplybind('filled').of(this.state).to(filled => {
        return this.el.state('filled', filled);
      });
      simplybind('disabled').of(this.state).to(disabled => {
        return this.el.state('disabled', disabled);
      });
      simplybind('showLabel').of(this.state).to(showLabel => {
        return this.el.state('showLabel', showLabel);
      });
      simplybind('showError').of(this.state).to(showError => {
        return this.el.state('showError', showError);
      });
      simplybind('showHelp').of(this.state).to(showHelp => {
        return this.el.state('showHelp', showHelp);
      });
      simplybind('valid').of(this.state).to(valid => {
        this.el.state('valid', valid);
        return this.el.state('invalid', !valid);
      });
    }

    _attachBindings_display() {
      simplybind('placeholder').of(this.state).to('text').of(this.el.child.placeholder).transform(placeholder => {
        switch (false) {
          case !(placeholder === true && this.settings.label):
            return this.settings.label;

          case !IS$1$1.string(placeholder):
            return placeholder;

          default:
            return '';
        }
      });
      simplybind('disabled', {
        updateOnBind: this.state.disabled
      }).of(this.state).to((disabled, prev) => {
        if (this.settings.checkmark) {
          if (disabled || !disabled && prev != null) {
            return setTimeout(() => {
              this.el.child.checkmark_mask1.recalcStyle();
              this.el.child.checkmark_mask2.recalcStyle();
              return this.el.child.checkmark_patch.recalcStyle();
            });
          }
        }
      });
    } // @el.child.checkmark.recalcStyle(true)


    _attachBindings_display_autoWidth() {
      simplybind('width', {
        updateEvenIfSame: true
      }).of(this.state).to(width => {
        return (this.settings.autoWidth ? this.el.child.input : this.el).style('width', width);
      }).transform(this._formatWidth.bind(this)).updateOn('isMobile').of(this.state);

      if (this.settings.autoWidth) {
        simplybind('_value', {
          updateEvenIfSame: true,
          updateOnBind: false
        }).of(this).to('width').of(this.state).transform(() => {
          return `${this._getInputAutoWidth()}px`;
        }).updateOn('event:inserted').of(this.el).updateOn('visible').of(this.state);
      }
    }

    _attachBindings_value() {
      var input, resetInput;
      input = this.el.child.input.raw;

      resetInput = () => {
        var filled;
        filled = !this.mask.isEmpty();

        if (!filled) {
          this.selection(this.mask.cursor = 0);
          this._value = '';
          this.state.filled = false;
        }

        return filled;
      };

      simplybind('event:input').of(input).to(() => {
        this.value = input.value;

        if (this.mask) {
          this.selection(this.mask.cursor);
        }

        return this.emit('input', this.value);
      });
      simplybind('_value', {
        updateEvenIfSame: !!this.mask
      }).of(this).to('value').of(input).and.to(value => {
        var filled;
        filled = !!value;

        if (filled && this.mask && this.mask.guide && (!this.state.focused || this.mask.cursor === 0)) {
          filled = resetInput();
        }

        this.state.filled = filled;

        if (filled) {
          this.state.interacted = true;
        }

        this.state.valid = this.validate(void 0, true);

        if (!this.state.focused) {
          return this.emit('input', this.value);
        }
      });
      simplybind('event:keydown').of(this.el.child.input).to(event => {
        if (event.keyCode === KEYCODES.enter) {
          this.emit('submit');
        }

        return this.emit(`key-${event.keyCode}`);
      });

      if (this.mask && this.mask.guide) {
        simplybind('event:blur').of(this.el.child.input).to(resetInput);
      }
    }

    _attachBindings_autocomplete() {
      if (this.dropdown) {
        simplybind.defaultOptions.updateOnBind = false;
        simplybind('typing', {
          updateEvenIfSame: true
        }).of(this.state).to(isTyping => {
          if (isTyping) {
            if (!this._value) {
              return;
            }

            if (this.dropdown.isOpen) {
              return this.dropdown.list.calcDisplay();
            } else {
              this.dropdown.isOpen = true;
              return simplybind('event:click').of(document).once.to(() => {
                return this.dropdown.isOpen = false;
              }).condition(event => {
                return !quickdom(event.target).parentMatching(parent => {
                  return parent === this.el.child.innerwrap;
                });
              });
            }
          } else {
            return this.dropdown.isOpen = false;
          }
        });
        simplybind('_value').of(this).to(value => {
          var choice, i, len, ref, shouldBeVisible;
          ref = this.dropdown.choices;

          for (i = 0, len = ref.length; i < len; i++) {
            choice = ref[i];
            shouldBeVisible = !value ? true : fuzzyMatch(value, choice.label);

            if (choice.visible !== shouldBeVisible) {
              choice.visible = shouldBeVisible;
            }
          }

          if (this.dropdown.isOpen && !value) {
            this.dropdown.isOpen = false;
          }
        });
        this.dropdown.onSelected(selectedChoice => {
          this.selected = selectedChoice;
          this.value = selectedChoice.label;
          this.dropdown.isOpen = false;
          return this.selection(this.el.child.input.raw.value.length);
        });
        simplybind.defaultOptions.updateOnBind = true;
      }
    }

    _attachBindings_stateTriggers() {
      simplybind('event:mouseenter').of(this.el.child.input).to(() => {
        return this.state.hovered = true;
      });
      simplybind('event:mouseleave').of(this.el.child.input).to(() => {
        return this.state.hovered = false;
      });
      simplybind('event:focus').of(this.el.child.input).to(() => {
        this.state.focused = true;

        if (this.state.disabled) {
          return this.blur();
        }
      });
      simplybind('event:blur').of(this.el.child.input).to(() => {
        return this.state.typing = this.state.focused = false;
      });
      simplybind('event:input').of(this.el.child.input).to(() => {
        return this.state.typing = true;
      });
      simplybind('event:keydown').of(this.el.child.input).to(() => {
        return this.cursor.prev = this.selection().end;
      });
    }

    _scheduleCursorReset() {
      var currentCursor, diffIndex, newCursor;
      diffIndex = getIndexOfFirstDiff(this.mask.value, this.mask.prev.value);
      currentCursor = this.cursor.current;
      newCursor = this.mask.normalizeCursorPos(currentCursor, this.cursor.prev);

      if (newCursor !== currentCursor) {
        this.selection(newCursor);
      }
    }

    _setValueIfNotSet() {
      if (this.el.child.input.raw.value !== this._value) {
        this.el.child.input.raw.value = this._value;
      }
    }

    _getInputAutoWidth() {
      var inputWidth, labelWidth;

      if (this._value) {
        this._setValueIfNotSet();

        this.el.child.input.style('width', 0);
        this.el.child.input.raw.scrollLeft = 1e+10;
        inputWidth = Math.max(this.el.child.input.raw.scrollLeft + this.el.child.input.raw.offsetWidth, this.el.child.input.raw.scrollWidth) + 2;
        labelWidth = this.settings.label && this.el.child.label.styleSafe('position') === 'absolute' ? this.el.child.label.rect.width : 0;
      } else {
        inputWidth = this.el.child.placeholder.rect.width;
        labelWidth = 0;
      }

      return Math.min(this._getWidthSetting('max'), Math.max(this._getWidthSetting('min'), inputWidth, labelWidth));
    }

    _getWidthSetting(target) {
      var parent, parentWidth, result;

      if (target === 'min' || target === 'max') {
        target += 'Width';
      }

      if (typeof this.settings[target] === 'number') {
        result = this.settings[target];
      } else if (typeof this.settings[target] === 'string') {
        result = parseFloat(this.settings[target]);

        if (includes$2(this.settings[target], '%')) {
          if ((parent = this.el.parent) && parent.style('display') === 'block') {
            parentWidth = parent.styleParsed('width') - parent.styleParsed('paddingLeft') - parent.styleParsed('paddingRight') - 2;
            result = parentWidth * (result / 100);
          } else {
            result = 0;
          }
        }
      }

      return result || (target === 'minWidth' ? 0 : 2e308);
    }

    _validate(providedValue) {
      var matchingChoice, ref;

      if (this.settings.validWhenRegex && IS$1$1.regex(this.settings.validWhenRegex)) {
        if (!this.settings.validWhenRegex.test(providedValue)) {
          return false;
        }
      }

      if (this.settings.validWhenIsChoice && ((ref = this.settings.choices) != null ? ref.length : void 0)) {
        matchingChoice = this.settings.choices.filter(function (choice) {
          return choice.value === providedValue;
        });

        if (!matchingChoice.length) {
          return false;
        }
      }

      if (this.settings.minLength) {
        if (providedValue.length < this.settings.minLength) {
          return false;
        }
      }

      if (this.settings.maxLength) {
        if (providedValue.length >= this.settings.maxLength) {
          return false;
        }
      }

      if (this.mask) {
        if (!this.mask.validate(providedValue)) {
          return false;
        }
      }

      return true;
    }

    selection(arg) {
      var end, start;

      if (IS$1$1.object(arg)) {
        start = arg.start;
        end = arg.end;
      } else {
        start = arg;
        end = arguments[1];
      }

      if (start != null) {
        if (!end || end < start) {
          end = start;
        }

        this.el.child.input.raw.setSelectionRange(start, end);
      } else {
        return {
          'start': this.el.child.input.raw.selectionStart,
          'end': this.el.child.input.raw.selectionEnd
        };
      }
    }

    focus() {
      return this.el.child.input.raw.focus();
    }

    blur() {
      return this.el.child.input.raw.blur();
    }

  }

  TextField.prototype.template = textFieldTemplate;
  TextField.prototype.templates = templates;
  TextField.prototype.defaults = defaults$1;
  return TextField;
}.call(undefined);

var TextField$1 = TextField;var version$3 = "1.0.89";
var createBuilder, quickfield$1;

createBuilder = function (settingOverrides, templateOverrides) {
  var builder;

  builder = function (settings) {
    if (arguments.length > 1) {
      settings = primaryBuilder$1.clone(...arguments);
    }

    if (!IS$1$1.object(settings)) {
      settings = {};
    }

    if (settings.type == null) {
      settings.type = 'text';
    }

    if (!Field$1[settings.type]) {
      throw new Error(`QuickField: '${settings.type}' is not a valid/registered field type`);
    }

    registerAnimations();
    return new Field$1[settings.type](settings, builder, settingOverrides, templateOverrides);
  };

  builder.register = function (type, targetField) {
    var i, len, requiredMethod;

    if (!IS$1$1.string(type) || !IS$1$1.function(targetField)) {
      throw new Error("QuickField Registration: invalid arguments");
    }

    for (i = 0, len = REQUIRED_FIELD_METHODS.length; i < len; i++) {
      requiredMethod = REQUIRED_FIELD_METHODS[i];

      if (!targetField.prototype[requiredMethod]) {
        throw new Error(`QuickField Registration: '${requiredMethod}' method is required in order to register the field`);
      }
    }

    Field$1[type] = targetField;
    return this;
  };

  builder.config = function (newSettings, newTemplates) {
    var config, globalConfig, name$$1, originalTemplates, outputSettings, outputTemplates, ref, templates, type;

    if (!IS$1$1.object(newSettings)) {
      throw new Error(`QuickField Config: invalid config object provided ${String(newSettings)}`);
    }

    outputSettings = Object.create(null);

    for (type in newSettings) {
      config = newSettings[type];

      if (type === 'global') {
        outputSettings.globalDefaults = primaryBuilder$1.deep.notDeep(Field$1.shallowSettings).clone(Field$1.prototype.globalDefaults, config);
      } else if (Field$1[type]) {
        outputSettings[type] = primaryBuilder$1.clone.deep.notDeep(Field$1.shallowSettings)(Field$1[type].prototype.defaults, config);
      }
    }

    if (IS$1$1.object(newTemplates)) {
      outputTemplates = Object.create(null);
      globalConfig = newTemplates.global;

      if (globalConfig && globalConfig.field && !globalConfig.default) {
        globalConfig.default = globalConfig.field;
      }

      for (type in Field$1) {
        originalTemplates = (ref = Field$1[type].prototype) != null ? ref.templates : void 0;
        templates = newTemplates[type] || globalConfig;

        if (!originalTemplates) {
          continue;
        }

        if (!templates) {
          outputTemplates[type] = originalTemplates;
          continue;
        }

        if (templates.field && !templates.default) {
          templates.default = templates.field;
        }

        outputTemplates[type] = Object.create(null);

        for (name$$1 in templates) {
          config = templates[name$$1];

          if (name$$1 === 'field' || !originalTemplates[name$$1]) {
            continue;
          }

          if (globalConfig && globalConfig[name$$1]) {
            config = primaryBuilder$1.clone.deep.concat(globalConfig[name$$1], config);
          }

          outputTemplates[type][name$$1] = originalTemplates[name$$1].extend(config);
        }

        for (name$$1 in originalTemplates) {
          config = originalTemplates[name$$1];

          if (!outputTemplates[type][name$$1]) {
            outputTemplates[type][name$$1] = config;
          }
        }
      }
    }

    return createBuilder(outputSettings, outputTemplates);
  };

  Object.defineProperty(builder, 'fields', {
    get: function () {
      return primaryBuilder$1.clone.own.notKeys('instances')(Field$1);
    }
  });
  builder.settingOverrides = settingOverrides;
  builder.templateOverrides = templateOverrides;
  builder.version = version$3;
  builder.Field = Field$1;
  return builder;
}; // import NumberField from './fields/number'
// import SelectField from './fields/select'
// import ChoiceField from './fields/choice'
// import TruefalseField from './fields/truefalse'
// import ToggleField from './fields/toggle'
// import GroupField from './fields/group'
// import RepeaterField from './fields/repeater'
// import FileField from './fields/file'
// import CheckboxField from './fields/checkbox'


quickfield$1 = createBuilder();
quickfield$1.register('text', TextField$1); // quickfield.register 'textarea', TextareaField
// quickfield.register 'number', NumberField
// quickfield.register 'select', SelectField
// quickfield.register 'choice', ChoiceField
// quickfield.register 'truefalse', TruefalseField
// quickfield.register 'toggle', ToggleField
// quickfield.register 'group', GroupField
// quickfield.register 'repeater', RepeaterField
// quickfield.register 'checkbox', FileField
// quickfield.register 'file', CheckboxField

var quickfield$1$1 = quickfield$1;var defaults$2 = {
  placeholder: true,
  validWhenRegex: false,
  autoWidth: false,
  autoHeight: true,
  minHeight: 46,
  maxWidth: '100%',
  maxHeight: 2e308,
  minWidth: 2,
  minLength: null,
  maxLength: null,
  counter: false
}; // dropdown: {storeSelected:false, lockScroll:false}
var template$2 = textFieldTemplate.extend({
  children: {
    'innerwrap': {
      options: {
        style: {
          overflow: 'hidden',
          height: function (field) {
            return field.settings.minHeight || 46;
          },
          width: function (field) {
            if (!field.settings.autoWidth) {
              return '100%';
            }
          }
        }
      }
    },
    'label': {
      options: {
        style: {
          left: function (field) {
            return shorthandSideValue(field.settings.padding, 'left');
          },
          top: '7.6px'
        }
      }
    },
    'input': {
      type: 'textarea',
      options: {
        type: null,
        styleAfterInsert: true,
        style: {
          resize: 'none',
          whiteSpace: 'normal',
          width: '100%',
          height: function () {
            return `calc(100% - ${this.styleSafe('marginTop', true)} - ${this.styleSafe('marginBottom', true)})`;
          },
          margin: '0',
          marginTop: '15px',
          marginBottom: '12px',
          padding: '0 12px'
        }
      }
    },
    'placeholder': {
      options: {
        styleAfterInsert: true,
        style: {
          left: 0,
          padding: function (field) {
            var horiz, verti;
            horiz = field.el.child.input.styleSafe('paddingLeft', true) || field.el.child.input.styleSafe('paddingLeft');
            verti = field.el.child.input.styleSafe('marginTop', true) || field.el.child.input.styleSafe('marginTop');
            return `${verti} ${horiz}`;
          }
        }
      }
    }
  }
});
var counter = quickdom.template(['div', {
  ref: 'counter',
  style: {
    position: 'absolute',
    bottom: -10,
    right: 0,
    fontSize: 10,
    fontWeight: 500
  }
}]);
var templates$1 =
/*#__PURE__*/
Object.freeze({
  default: template$2,
  counter: counter
});var TextareaField;

TextareaField = function () {
  class TextareaField extends Field$1 {
    constructor() {
      super(...arguments);

      if (this._value == null) {
        this._value = '';
      }

      this.state.height = this.settings.autoHeight ? 'auto' : this.settings.height;
      this.state.typing = false;
      this.cursor = {
        prev: 0,
        current: 0
      };

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      return this._value;
    }

    _setValue(newValue) {
      if (IS$1$1.string(newValue) || IS$1$1.number(newValue)) {
        return this._value = String(newValue);
      }
    }

    _recalcDisplay() {
      if (this.settings.autoHeight || this.settings.autoWidth) {
        return this._value = this._value;
      }
    }

    _createElements() {
      var forceOpts;
      forceOpts = {
        relatedInstance: this
      };
      this.el = this.template.spawn(this.settings.templates.defaults, forceOpts);
      this.el.state('hasLabel', this.settings.label);
      this.el.child.innerwrap.raw._quickField = this.el.child.input.raw._quickField = this;
    }

    _attachBindings() {
      this._attachBindings_elState();

      this._attachBindings_display();

      this._attachBindings_display_autoWidth();

      this._attachBindings_display_autoHeight();

      this._attachBindings_value();

      this._attachBindings_autocomplete();

      this._attachBindings_stateTriggers();
    }

    _attachBindings_display_autoHeight() {
      simplybind('height', {
        updateEvenIfSame: true
      }).of(this.state).transformSelf(function (value) {
        if (isNaN(value) && isNaN(parseFloat(value))) {
          return 'auto';
        } else {
          return value;
        }
      }).to(height => {
        return this.el.child.innerwrap.style('height', height);
      }).updateOn('event:inserted').of(this);

      if (this.settings.autoHeight) {
        simplybind('_value', {
          updateEvenIfSame: true,
          updateOnBind: false
        }).of(this).to('height').of(this.state).transform(() => {
          return this._getInputAutoHeight();
        }).updateOn('event:inserted').of(this);
      }
    }

    _attachBindings_display_autoWidth() {
      simplybind('width', {
        updateEvenIfSame: true
      }).of(this.state).to(width => {
        return (this.settings.autoWidth ? this.el.child.innerwrap : this.el).style('width', width);
      }).transform(this._formatWidth.bind(this)).updateOn('isMobile').of(this.state);

      if (this.settings.autoWidth) {
        simplybind('_value', {
          updateEvenIfSame: true,
          updateOnBind: false
        }).of(this).to('width').of(this.state).transform(() => {
          return this._getInputAutoWidth();
        }).updateOn('event:inserted').of(this);
      }
    }

    _attachBindings_value() {
      var input;
      input = this.el.child.input.raw;
      simplybind('event:input').of(input).to(() => {
        return this.value = input.value;
      });
      simplybind('_value').of(this).to('value').of(input).and.to(value => {
        this.state.filled = !!value;

        if (value) {
          this.state.interacted = true;
        }

        this.state.valid = this.validate(void 0, true);
        return this.emit('input', value);
      });
    }

    _attachBindings_autocomplete() {}

    _getInputAutoHeight() {
      var inputHeight, prevHeight;
      prevHeight = this.el.child.input.raw.style.height;

      if (this._value) {
        this._setValueIfNotSet();

        this.el.child.input.style('height', 0);
        inputHeight = this.el.child.input.raw.scrollHeight + 2;
        inputHeight += this.el.child.input.styleParsed('marginTop') + this.el.child.input.styleParsed('marginBottom');
      } else {
        inputHeight = this.el.child.placeholder.height;
      }

      this.el.child.input.style('height', prevHeight);
      return Math.min(this.settings.maxHeight, Math.max(inputHeight, this.settings.minHeight));
    }

    _getInputAutoWidth() {
      var inputPadding, inputWidth, labelWidth;

      if (this._value) {
        this._setValueIfNotSet();

        this.el.child.input.style({
          width: 0,
          whiteSpace: 'nowrap'
        }).raw.scrollLeft = 1e+10;
        inputPadding = this.el.child.input.styleParsed('paddingLeft') || this.el.child.input.styleParsed('padding');
        inputWidth = Math.max(this.el.child.input.raw.scrollLeft + this.el.child.input.raw.offsetWidth, this.el.child.input.raw.scrollWidth) + 2 + inputPadding + 1;
        labelWidth = this.settings.label && this.el.child.label.styleSafe('position') === 'absolute' ? this.el.child.label.rect.width : 0;
      } else {
        inputWidth = this.el.child.placeholder.rect.width;
        labelWidth = 0;
      }

      this.el.child.input.style({
        width: '100%',
        whiteSpace: 'normal'
      });
      return Math.min(this._getWidthSetting('max'), Math.max(this._getWidthSetting('min'), inputWidth, labelWidth));
    }

  }

  TextareaField.prototype.template = template$2;
  TextareaField.prototype.templates = templates$1;
  TextareaField.prototype.defaults = defaults$2;
  inheritProto(TextareaField, TextField$1);
  return TextareaField;
}.call(undefined);

var TextareaField$1 = TextareaField;var defaults$3 = {
  placeholder: true,
  validWhenMin: false,
  validWhenMax: false,
  autoWidth: false,
  maxWidth: '100%',
  height: 46,
  buttons: true,
  minValue: -2e308,
  maxValue: 2e308,
  step: 1,
  enforce: false,
  inputSibling: 'buttons'
};var template$3 = textFieldTemplate.extend();
var stepButton = quickdom.template(['div', {
  stateTriggers: {
    'active': {
      on: 'mousedown',
      off: 'mouseup',
      bubbles: false
    }
  },
  attrs: {
    tabindex: -1
  },
  style: {
    display: 'inline-block',
    width: '100%',
    height: 17,
    boxSizing: 'border-box',
    verticalAlign: 'top',
    outline: 'none',
    cursor: 'pointer',
    fill: COLORS$1.grey,
    $active: {
      fill: COLORS$1.grey_dark
    }
  }
}]);
var buttons = quickdom.template(['div', {
  ref: 'buttons',
  style: {
    position: 'relative',
    zIndex: 3,
    top: '50%',
    transform: 'translateY(-50%)',
    display: 'inline-block',
    width: 17,
    paddingRight: function (field) {
      return field.settings.inputPadding;
    },
    outline: 'none'
  }
}, stepButton.extend({
  children: [caretUp],
  options: {
    ref: 'stepUp'
  }
}), stepButton.extend({
  children: [caretDown],
  options: {
    ref: 'stepDown'
  }
})]);
var templates$2 =
/*#__PURE__*/
Object.freeze({
  default: template$3,
  stepButton: stepButton,
  buttons: buttons
});var NumberField;

NumberField = function () {
  class NumberField extends Field$1 {
    constructor() {
      var ref;
      super(...arguments);

      if (this._value == null) {
        this._value = '';
      }

      if (this.settings.enforce && this.settings.minValue && this.settings.minValue !== -2e308) {
        this._value || (this._value = this.settings.minValue);
      }

      this.settings.step = Number(this.settings.step) || 1;
      this.state.typing = false;
      this.cursor = {
        prev: 0,
        current: 0
      };
      this.precision = ((ref = this.settings.step.toString().split('.')[1]) != null ? ref.length : void 0) || 0;

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      return Number(this._value) || 0;
    }

    _setValue(newValue) {
      return this._value = this._normalizeValue(newValue, this.settings.enforce);
    }

    _createElements() {
      var globalOpts;
      globalOpts = {
        relatedInstance: this
      };
      this.el = this.template.spawn(this.settings.templates.defaults, globalOpts);

      if (this.settings.buttons) {
        buttons.spawn(this.settings.templates.buttons, globalOpts).insertAfter(this.el.child.input);
      }

      this.el.state('hasLabel', this.settings.label);
      this.el.child.innerwrap.raw._quickField = this.el.childf.input.raw._quickField = this;
    }

    _attachBindings() {
      this._attachBindings_elState();

      this._attachBindings_display();

      this._attachBindings_display_autoWidth();

      this._attachBindings_value();

      this._attachBindings_stateTriggers();

      this._attachBindings_stepEvents();
    }

    _attachBindings_value() {
      var input;
      input = this.el.child.input.raw;
      simplybind('event:input').of(input).to(() => {
        var newValue, selectNumberPart;
        this.cursor.prev = this.cursor.current;
        this.cursor.current = this.selection().end;
        newValue = input.value;

        if (newValue[newValue.length - 1] === '-') {
          if (this.settings.minValue > -1) {
            newValue = this._value;
          } else {
            newValue = -1;
            selectNumberPart = true;
          }
        }

        this._setValue(newValue);

        if (this.state.focused) {
          if (selectNumberPart) {
            return this.selection(1, 2);
          } else {
            return this.selection(this.cursor.current, this.cursor.current + (String(this._value).length - newValue.length));
          }
        }
      });
      simplybind('_value').of(this).to('value').of(input).and.to(value => {
        this.state.filled = !!String(value);

        if (String(value)) {
          this.state.interacted = true;
        }

        this.state.valid = this.validate(void 0, true);
        return this.emit('input', value);
      });
      simplybind('event:blur').of(input).to(() => {
        var value;

        if (!this.settings.enforce) {
          value = Number(this._value) || 0;

          if (value === 0 || !this.state.interacted && value === this.settings.minValue) {
            return this._value = '';
          }
        }
      });
      simplybind('event:keydown').of(this.el.child.input).to(event => {
        if (event.keyCode === KEYCODES.enter) {
          this.emit('submit');
        }

        return this.emit(`key-${event.keyCode}`);
      });
    }

    _attachBindings_stepEvents() {
      var stopPropagation;
      simplybind('event:keydown').of(this.el.child.input).to(event => {
        switch (event.keyCode) {
          case KEYCODES.up:
            event.preventDefault();
            return this.stepUp();

          case KEYCODES.down:
            event.preventDefault();
            return this.stepDown();
        }
      });

      if (this.settings.buttons) {
        stopPropagation = function (event) {
          event.preventDefault();
          return event.stopPropagation();
        };

        simplybind('event:click').of(this.el.child.stepUp).to(this.stepUp.bind(this)).and.to(stopPropagation);
        simplybind('event:click').of(this.el.child.stepDown).to(this.stepDown.bind(this)).and.to(stopPropagation);
      }
    }

    _setValueIfNotSet() {
      if (Number(this.el.child.input.raw.value) !== this._value) {
        return this.el.child.input.raw.value = this._value;
      }
    }

    _normalizeValue(value, enforce) {
      value = value ? parseFloat(value) || 0 : 0;

      if (value % this.settings.step && enforce) {
        if (value < this.settings.step) {
          value = this.settings.step;
        } else {
          value = this._roundToNearest(value, this.settings.step);
        }
      }

      if (value < this.settings.minValue) {
        value = this.settings.minValue;
      }

      if (value > this.settings.maxValue) {
        value = this.settings.maxValue;
      }

      return value;
    }

    _roundToNearest(value, target) {
      var multiplier;
      value = (value || 0).toFixed(this.precision) * 1;
      multiplier = target < 1 ? 1 / target : 1;
      target *= multiplier;
      value *= multiplier;
      value = Math.ceil(value / target) * target / multiplier;
      return value;
    }

    stepUp() {
      var newValue, rounded;
      rounded = this._roundToNearest(this._value, this.settings.step);
      newValue = Math.min(rounded + this.settings.step, this._value + this.settings.step);
      return this._setValue(this._roundToNearest(newValue, this.settings.step));
    }

    stepDown() {
      var newValue, rounded;
      rounded = this._roundToNearest(this._value, this.settings.step);
      newValue = Math.max(rounded - this.settings.step, this._value - this.settings.step);
      return this._setValue(this._roundToNearest(newValue, this.settings.step));
    }

  }

  NumberField.prototype.template = template$3;
  NumberField.prototype.templates = templates$2;
  NumberField.prototype.defaults = defaults$3;
  inheritProto(NumberField, TextField$1);
  return NumberField;
}.call(undefined);

primaryBuilder$1.notKeys(NumberField.prototype)(NumberField.prototype, TextField$1.prototype);
var NumberField$1 = NumberField;var defaults$4 = {
  placeholder: true,
  validWhenIsChoice: false,
  validWhenRegex: false,
  validWhenChoseMin: 2e308,
  autoWidth: false,
  maxWidth: '100%',
  height: 46,
  labelFilter: null,
  choices: [],
  multiple: false,
  dropdown: {
    typeBuffer: true
  },
  inputSibling: 'caret'
};var template$4 = textFieldTemplate.extend({
  children: {
    innerwrap: {
      children: {
        'input': ['div', {
          props: {
            tabIndex: 0
          },
          style: {
            marginTop: 3,
            height: 'auto',
            cursor: 'default',
            userSelect: 'none',
            // overflow: 'scroll'
            overflow: 'hidden'
          }
        }],
        'caret': ['div', {
          ref: 'caret',
          styleAfterInsert: true,
          style: {
            position: 'relative',
            zIndex: 3,
            top: function (field) {
              return this.parent.styleParsed('height', true) / 2 - this.styleParsed('height') / 2;
            },
            display: 'inline-block',
            width: 17,
            height: 17,
            paddingRight: function (field) {
              return field.settings.inputPadding;
            },
            verticalAlign: 'top',
            outline: 'none',
            pointerEvents: 'none',
            fill: COLORS$1.grey
          }
        }, caretDown]
      }
    }
  }
});
var templates$3 =
/*#__PURE__*/
Object.freeze({
  default: template$4
});var SelectField;

SelectField = function () {
  class SelectField extends Field$1 {
    constructor() {
      var base;
      super(...arguments);
      this.settings.dropdown.multiple = this.settings.multiple;

      if (this.settings.multiple) {
        if ((base = this.settings.dropdown).help == null) {
          base.help = 'Tip: press ESC to close this menu';
        }
      }

      this._value = this.settings.multiple ? [] : null;
      this.dropdown = new Dropdown$1(this.settings.choices, this);

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      var ref;

      if (!this.settings.multiple) {
        return (ref = this._value) != null ? ref.value : void 0;
      } else {
        return this._value.map(function (choice) {
          return choice.value;
        });
      }
    }

    _setValue(newValue) {
      var i, len, value;

      if (!this.settings.multiple || !IS$1$1.array(newValue)) {
        this.setChoice(newValue);
      } else {
        for (i = 0, len = newValue.length; i < len; i++) {
          value = newValue[i];
          this.setChoice(value);
        }
      }
    }

    _recalcDisplay() {
      if (this.settings.autoWidth) {
        return this.valueLabel = this.valueLabel;
      }
    }

    _createElements() {
      var forceOpts;
      forceOpts = {
        relatedInstance: this
      };
      this.el = this.template.spawn(this.settings.templates.default, forceOpts);
      this.dropdown.appendTo(this.el.child.innerwrap);
      this.el.child.placeholder.insertBefore(this.el.child.input);

      if (this.settings.label) {
        this.el.child.label.text = this.settings.label;
        this.el.state('hasLabel', true);
      }

      this.el.child.innerwrap.raw._quickField = this.el.child.input.raw._quickField = this;
    }

    _attachBindings() {
      this._attachBindings_elState();

      this._attachBindings_value();

      this._attachBindings_display();

      this._attachBindings_display_autoWidth();

      this._attachBindings_dropdown();

      this._attachBindings_stateTriggers();
    }

    _attachBindings_display_autoWidth() {
      simplybind('width', {
        updateEvenIfSame: true
      }).of(this.state).to(width => {
        return (this.settings.autoWidth ? this.el.child.input : this.el).style({
          width
        });
      }).transform(this._formatWidth.bind(this)).updateOn('isMobile').of(this.state);

      if (this.settings.autoWidth) {
        simplybind('valueLabel', {
          updateEvenIfSame: true,
          updateOnBind: false
        }).of(this).to('width').of(this.state).transform(() => {
          return this._getInputAutoWidth();
        }).updateOn('event:inserted').of(this);
      }
    }

    _getInputAutoWidth() {
      var inputWidth, labelWidth;

      if (this.valueLabel) {
        this.el.child.input.style('width', 0);
        inputWidth = this.el.child.input.raw.scrollWidth + 2;
        labelWidth = this.el.child.label.styleSafe('position') === 'absolute' ? this.el.child.label.rect.width : 0;
      } else {
        inputWidth = this.el.child.placeholder.rect.width;
        labelWidth = 0;
      }

      return Math.max(inputWidth, labelWidth);
    }

    _attachBindings_value() {
      simplybind('array:_value').of(this).to(selected => {
        this.state.filled = this.settings.multiple ? !!(selected != null ? selected.length : void 0) : !!selected;

        if (this.state.filled) {
          this.state.interacted = true;
        }

        this.state.valid = this.validate(void 0, true);
        return this.emit('input', this.value);
      }).and.to('valueLabel').of(this).transform(selected => {
        if (!selected) {
          return '';
        } else {
          if (this.settings.multiple) {
            return selected.map(function (choice) {
              return choice.label;
            }).join(', ');
          } else {
            return selected.label;
          }
        }
      });
      simplybind('valueLabel').of(this).to('text').of(this.el.child.input).transform(label => {
        if (this.settings.labelFormat) {
          return this.settings.labelFormat(label);
        } else {
          return label;
        }
      });
    }

    _attachBindings_dropdown() {
      simplybind('event:click').of(this.el.child.input).to(event => {
        var escListener;

        if (!(this.state.disabled || this.dropdown.choices.length === 0)) {
          this.dropdown.isOpen = true;
          this.focus();
          quickdom(document).on('click.dropdown', event => {
            if (quickdom(event.target).parentMatching(parent => {
              return parent === this.el.child.innerwrap;
            })) {
              return;
            }

            return this.dropdown.isOpen = false;
          }, true);
          escListener = simplybind('event:keydown').of(document).once.to(() => {
            return this.dropdown.isOpen = false;
          }).condition(function (event) {
            return event.keyCode === 27;
          });
          return simplybind('isOpen', {
            updateOnBind: false
          }).of(this.dropdown).once.to(function () {
            escListener.unBind();
            return quickdom(document).off('click.dropdown');
          }).condition(function (isOpen) {
            return !isOpen;
          });
        }
      });
      simplybind('event:click').of(this.el.child.innerwrap).to(event => {
        event.stopPropagation();
        return this.el.child.input.emitPrivate('click');
      }).condition(event => {
        return event.target === this.el.child.innerwrap.raw;
      });
      simplybind('focused', {
        updateOnBind: false
      }).of(this.state).to(focused => {
        var triggeringKeycodes;

        if (!focused) {
          return this.el.child.input.off('keydown.dropdownTrigger');
        } else {
          triggeringKeycodes = [32, 37, 38, 39, 40];
          return this.el.child.input.on('keydown.dropdownTrigger', event => {
            var ref;

            if (includes$2(triggeringKeycodes, event.keyCode) && !this.dropdown.isOpen) {
              this.dropdown.isOpen = true;

              if ((ref = this.dropdown.lastSelected) != null ? ref.selected : void 0) {
                this.dropdown.currentHighlighted = this.dropdown.lastSelected;
              }

              return event.preventDefault();
            } else if (event.keyCode === 9 && this.dropdown.isOpen) {
              // Prevent tab key
              return event.preventDefault();
            }
          });
        }
      });
      this.dropdown.onSelected(choice => {
        if (!(choice.selected && !this.settings.multiple)) {
          this.value = choice;
        }

        if (!this.settings.multiple) {
          return this.dropdown.isOpen = false;
        }
      });
    }

    _attachBindings_stateTriggers() {
      //# ==========================================================================
      //# State event triggers
      //# ========================================================================== 
      simplybind('event:mouseenter').of(this.el.child.input).to(() => {
        return this.state.hovered = true;
      });
      simplybind('event:mouseleave').of(this.el.child.input).to(() => {
        return this.state.hovered = false;
      });
      simplybind('event:focus').of(this.el.child.input).to(() => {
        this.state.focused = true;

        if (this.state.disabled) {
          return this.blur();
        }
      });
      simplybind('event:blur').of(this.el.child.input).to(() => {
        return this.state.focused = false;
      });
    }

    _validate(providedValue) {
      var matchingChoice, ref, ref1;

      if (this.settings.validWhenRegex && IS$1$1.regex(this.settings.validWhenRegex)) {
        switch (false) {
          case !this.settings.multiple:
            if (!(() => {
              var validChoices;

              if (providedValue.length === 0) {
                return false;
              }

              validChoices = providedValue.filter(choice => {
                return this.settings.validWhenRegex.test(choice);
              });

              if (this.settings.validWhenChoseMin === 2e308 || !IS$1$1.number(this.settings.validWhenChoseMin)) {
                return validChoices.length === providedValue.length;
              } else {
                return validChoices.length >= this.settings.validWhenChoseMin;
              }
            })()) {
              return false;
            }

            break;

          default:
            if (!this.settings.validWhenRegex.test(providedValue)) {
              return false;
            }

        }
      }

      if (this.settings.validWhenIsChoice && ((ref = this.dropdown.choices) != null ? ref.length : void 0)) {
        matchingChoice = this.dropdown.choices.filter(function (option) {
          return option.value === providedValue;
        });

        if (!!!matchingChoice.length) {
          return false;
        }
      }

      if (this.settings.multiple && -1 > (ref1 = this.settings.validWhenChoseMin) && ref1 < 2e308) {
        if (!providedValue.length >= this.settings.validWhenChoseMin) {
          return false;
        }
      }

      if (this.settings.multiple && this.settings.required) {
        if (!providedValue.length) {
          return false;
        }
      }

      return true;
    }

    addChoice(choice) {
      return this.dropdown.addChoice(choice);
    }

    setChoice(choice) {
      var match, ref;

      if (IS$1$1.object(choice) && choice instanceof Dropdown$1.Choice) {
        return choice.toggle();
      } else if (match = this.dropdown.findChoiceAny(choice)) {
        return match.toggle(true);
      } else {
        return (ref = this.addChoice(choice)) != null ? ref.toggle(true) : void 0;
      }
    }

  }

  SelectField.prototype.template = template$4;
  SelectField.prototype.templates = templates$3;
  SelectField.prototype.defaults = defaults$4;
  SelectField.prototype.coreValueProp = 'value';
  return SelectField;
}.call(undefined);

inheritProto(SelectField, TextField$1, ['_getMaxWidth', '_attachBindings_elState', '_attachBindings_display', 'focus', 'blur']);
var SelectField$1 = SelectField;var defaults$5 = {
  validWhenSelected: false,
  validWhenIsChoice: false,
  showSelectAll: false,
  perGroup: 7,
  spacing: 8,
  choices: []
};var template$5 = quickdom.template(['div', {
  ref: 'field',
  style: {
    position: 'relative',
    display: 'none',
    width: function (field) {
      return field.state.width;
    },
    boxSizing: 'border-box',
    fontFamily: function (field) {
      return field.settings.fontFamily;
    },
    textAlign: 'left',
    $visible: {
      $hasVisibleChoices: {
        display: 'inline-block'
      }
    },
    $showError: {
      animation: '0.2s fieldErrorShake'
    }
  }
}, ['div', {
  ref: 'label',
  style: {
    display: 'none',
    marginBottom: '12px',
    fontFamily: 'inherit',
    fontSize: '13px',
    fontWeight: 600,
    color: COLORS$1.black,
    cursor: 'default',
    pointerEvents: 'none',
    userSelect: 'none',
    $showLabel: {
      display: 'block'
    },
    $showError: {
      color: COLORS$1.red
    }
  }
}], ['div', {
  ref: 'innerwrap',
  style: {
    position: 'relative',
    boxSizing: 'border-box',
    fontFamily: 'inherit'
  }
}], ['div', {
  ref: 'help',
  style: {
    marginTop: '10px',
    fontFamily: 'inherit',
    fontSize: '11px',
    color: COLORS$1.grey,
    display: 'none',
    $showError: {
      color: COLORS$1.red,
      display: 'block'
    },
    $showHelp: {
      display: 'block'
    }
  }
}]]);
var choiceGroup = quickdom.template(['div', {
  ref: 'choiceGroup',
  style: {
    marginBottom: function (field) {
      return field.settings.spacing;
    },
    userSelect: 'none',
    fontSize: '0',
    whiteSpace: 'nowrap'
  }
}]);
var choice$1 = quickdom.template(['div', {
  ref: 'choice',
  styleAfterInsert: true,
  style: {
    position: 'relative',
    display: 'inline-block',
    width: 'auto',
    marginLeft: function (field) {
      if (this.index) {
        return `calc(100% - (100% - ${field.settings.spacing}px))`;
      }
    },
    // minHeight: '46px'
    padding: '0 12px',
    borderRadius: '2px',
    backgroundColor: 'white',
    fontFamily: 'inherit',
    textAlign: 'center',
    color: COLORS$1.black,
    boxSizing: 'border-box',
    verticalAlign: 'top',
    cursor: 'pointer',
    $definedWidth: {
      width: function (field) {
        return `calc((100% - ${field.settings.spacing * (field.settings.perGroup - 1)}px) / ${field.settings.perGroup})`;
      }
    },
    $selected: {
      color: COLORS$1.orange
    },
    $unavailable: {
      display: 'none'
    },
    $disabled: {
      cursor: 'not-allowed',
      opacity: 0.7,
      color: COLORS$1.grey
    }
  }
}, ['div', {
  ref: 'border',
  style: {
    position: 'absolute',
    zIndex: 2,
    top: '0',
    left: '0',
    width: '100%',
    height: '100%',
    borderWidth: '1px',
    borderStyle: 'solid',
    borderColor: COLORS$1.grey_light,
    borderRadius: '2px',
    boxSizing: 'border-box',
    $selected: {
      borderColor: 'inherit',
      borderWidth: '2px'
    },
    $disabled: {
      borderColor: COLORS$1.grey_light
    }
  }
}], ['div', {
  ref: 'label',
  style: {
    position: 'relative',
    display: 'block',
    padding: '15px 0px',
    fontFamily: 'inherit',
    fontSize: function (field) {
      return field.settings.fontSize;
    },
    fontWeight: '500'
  }
}]]);
var choiceIcon = quickdom.template(['div', {
  ref: 'icon',
  style: {
    position: 'absolute',
    top: '50%',
    display: 'block',
    fontSize: '20px',
    opacity: 0.16,
    transform: 'translateY(-50%)'
  }
}]);
var templates$4 =
/*#__PURE__*/
Object.freeze({
  default: template$5,
  choiceGroup: choiceGroup,
  choice: choice$1,
  choiceIcon: choiceIcon
});var Choice$1, ChoiceField;

ChoiceField = function () {
  class ChoiceField extends Field$1 {
    constructor() {
      var ref;
      super(...arguments);

      if (!((ref = this.settings.choices) != null ? ref.length : void 0)) {
        throw new Error(`Choices were not provided for choice field '${this.settings.label || this.ID}'`);
      }

      this._value = this.settings.multiple ? [] : null;
      this.lastSelected = null;
      this.visibleChoicesCount = 0;
      this.choices = this.settings.choices;

      if (this.settings.validWhenSelected === true) {
        this.settings.validWhenSelected = 1;
      }

      this.settings.perGroup = Math.min(this.settings.perGroup, this.choices.length + (this.settings.multiple && this.settings.showSelectAll ? 1 : 0));

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      var ref;

      if (!this.settings.multiple) {
        return (ref = this._value) != null ? ref.value : void 0;
      } else {
        return this._value.map(function (choice) {
          return choice.value;
        });
      }
    }

    _setValue(newValue) {
      var i, len, value;

      if (!this.settings.multiple || !IS$1$1.array(newValue)) {
        this.setChoice(newValue);
      } else {
        for (i = 0, len = newValue.length; i < len; i++) {
          value = newValue[i];
          this.setChoice(value);
        }
      }
    }

    _createElements() {
      var choiceGroups, choices, globalOpts, perGroup;
      globalOpts = {
        relatedInstance: this
      };
      this.el = this.template.spawn(this.settings.templates.default, globalOpts);
      this.choices = [];
      choices = this.settings.choices;
      perGroup = this.settings.perGroup;
      choiceGroups = Array(Math.ceil(choices.length / perGroup)).fill().map(function (s, index) {
        return choices.slice(index * perGroup, index * perGroup + perGroup);
      });
      choiceGroups.forEach((choices, groupIndex) => {
        var groupEl;
        groupEl = this.templates.choiceGroup.spawn(this.settings.templates.choiceGroup, globalOpts).appendTo(this.el.child.innerwrap);
        return choices.forEach((choice, index) => {
          return this.choices.push(new Choice$1(this, choice, index, groupIndex, groupEl));
        });
      });
      this.el.child.innerwrap.raw._quickField = this;
    }

    _attachBindings() {
      var choice, i, len, ref;

      this._attachBindings_elState();

      this._attachBindings_stateTriggers();

      this._attachBindings_display();

      this._attachBindings_value();

      ref = this.choices;

      for (i = 0, len = ref.length; i < len; i++) {
        choice = ref[i];

        choice._attachBindings();
      }
    }

    _attachBindings_elState() {
      simplybind('visible').of(this.state).to(visible => {
        return this.el.state('visible', visible);
      });
      simplybind('hovered').of(this.state).to(hovered => {
        return this.el.state('hovered', hovered);
      });
      simplybind('filled').of(this.state).to(filled => {
        return this.el.state('filled', filled);
      });
      simplybind('disabled').of(this.state).to(disabled => {
        return this.el.state('disabled', disabled);
      });
      simplybind('showLabel').of(this.state).to(showLabel => {
        return this.el.state('showLabel', showLabel);
      });
      simplybind('showError').of(this.state).to(showError => {
        return this.el.state('showError', showError);
      });
      simplybind('showHelp').of(this.state).to(showHelp => {
        return this.el.state('showHelp', showHelp);
      });
      simplybind('valid').of(this.state).to(valid => {
        this.el.state('valid', valid);
        return this.el.state('invalid', !valid);
      });
    }

    _attachBindings_stateTriggers() {
      simplybind('event:mouseenter').of(this.el).to(() => {
        return this.state.hovered = true;
      });
      simplybind('event:mouseleave').of(this.el).to(() => {
        return this.state.hovered = false;
      });
    }

    _attachBindings_display() {
      simplybind('width').of(this.state).to(width => {
        return this.el.style('width', width).state('definedWidth', width !== 'auto');
      }).transform(this._formatWidth.bind(this)).updateOn('isMobile').of(this.state);
      simplybind('visibleChoicesCount').of(this).to(count => {
        return this.el.state('hasVisibleChoices', !!count);
      });
    }

    _attachBindings_value() {
      simplybind('_value').of(this).to(selected => {
        this.state.filled = !!(selected != null ? selected.length : void 0);

        if (this.state.filled) {
          this.state.interacted = true;
        }

        return this.state.valid = this.validate(void 0, true);
      });
      simplybind('array:_value', {
        updateOnBind: false
      }).of(this).to(() => {
        return this.emit('input', this.value);
      });
    }

    _validate(providedValue) {
      if (this.settings.multiple) {
        if (!IS$1$1.array(providedValue)) {
          providedValue = [providedValue];
        }

        if (providedValue.length && !IS$1$1.object(providedValue[0])) {
          providedValue = providedValue.map(function (choice) {
            return choice.value;
          });
        }
      } else {
        if (IS$1$1.object(providedValue)) {
          providedValue = providedValue.value;
        }
      }

      if (IS$1$1.number(this.settings.validWhenSelected)) {
        if (!((providedValue != null ? providedValue.length : void 0) >= this.settings.validWhenSelected)) {
          return false;
        }
      }

      if (this.settings.validWhenIsChoice) {
        if (this.settings.multiple) {
          if (!includes$2(providedValue, this.settings.validWhenIsChoice)) {
            return false;
          }
        } else {
          if (providedValue !== this.settings.validWhenIsChoice) {
            return false;
          }
        }
      }

      return true;
    }

    findChoice(providedValue, byLabel) {
      var matches;
      matches = this.choices.filter(function (choice) {
        switch (false) {
          case !IS$1$1.object(providedValue):
            return providedValue === choice;

          case !byLabel:
            return providedValue === choice.label;

          default:
            return providedValue === choice.value;
        }
      });
      return matches[0];
    }

    findChoiceAny(providedValue) {
      return this.findChoice(providedValue) || this.findChoice(providedValue, true);
    }

    setChoice(choice) {
      if (IS$1$1.object(choice) && choice instanceof Choice$1) {
        return choice.toggle();
      } else if (choice = this.findChoiceAny(choice)) {
        return choice.toggle(true);
      }
    }

  }

  ChoiceField.prototype.template = template$5;
  ChoiceField.prototype.templates = templates$4;
  ChoiceField.prototype.defaults = defaults$5;
  return ChoiceField;
}.call(undefined);

Choice$1 = class Choice {
  constructor(field, settings, index1, groupIndex, groupEl) {
    var globalOpts, iconEl, ref;
    this.field = field;
    this.settings = settings;
    this.index = index1;
    globalOpts = {
      relatedInstance: this.field
    };
    ({
      label: this.label,
      value: this.value,
      conditions: this.conditions
    } = this.settings);

    if (this.label == null) {
      this.label = this.value;
    }

    if (this.value == null) {
      this.value = this.label;
    }

    this.el = this.field.templates.choice.spawn(this.field.settings.templates.choice, globalOpts).appendTo(groupEl);

    if (this.icon) {
      iconEl = this.templates.choiceIcon.spawn(this.field.settings.templates.choiceIcon, globalOpts).insertBefore(this.el.child.label);
      iconEl.text = this.icon;
    }

    if (this.el.index == null) {
      this.el.index = this.index;
    }

    this.el.totalIndex = this.index * groupIndex;
    this.el.prop('title', this.label);
    this.el.child.label.text = this.label;
    this.visible = true;
    this.selected = false;
    this.disabled = this.settings.disabled || false;
    this.unavailable = false;

    if ((ref = this.conditions) != null ? ref.length : void 0) {
      this.unavailable = true;
      this.allFields = this.field.allFields;
      Condition$1.init(this, this.conditions, () => {
        return this.unavailable = !Condition$1.validate(this.conditions);
      });
    }
  }

  _attachBindings() {
    return (() => {
      simplybind('visible').of(this).to(visible => {
        return this.el.state('visible', visible);
      }).and.to(visible => {
        return this.field.visibleChoicesCount += visible ? 1 : -1;
      });
      simplybind('selected', {
        updateOnBind: false
      }).of(this).to(selected => {
        return this.el.state('selected', selected);
      });
      simplybind('disabled', {
        updateOnBind: false
      }).of(this).to(disabled => {
        return this.el.state('disabled', disabled);
      });
      simplybind('unavailable', {
        updateOnBind: false
      }).of(this).to(unavailable => {
        return this.el.state('unavailable', unavailable);
      }).and.to(unavailable => {
        if (unavailable) {
          return this.toggle(false, true);
        }
      });
      return simplybind('event:click').of(this.el).to(() => {
        return this.field.value = this;
      }).condition(() => {
        return !this.disabled;
      });
    })();
  }

  toggle(newValue, unavailable) {
    var newState, prevState, ref;
    prevState = this.selected;
    newState = IS$1$1.defined(newValue) ? newValue : !this.selected;

    if (!newState) {
      if (this.field.settings.multiple && prevState) {
        this.selected = newState;
        return removeItem$1(this.field._value, this);
      } else {
        if (IS$1$1.defined(newValue)) {
          this.selected = newState;
        }

        if (unavailable) {
          return this.field._value = null;
        }
      }
    } else {
      this.selected = newState;

      if (this.field.settings.multiple) {
        this.field._value.push(this);
      } else {
        if (this.field._value !== this) {
          if ((ref = this.field._value) != null) {
            ref.toggle(false);
          }
        }

        this.field._value = this;
      }

      return this.field.lastSelected = this;
    }
  }

};
var ChoiceField$1 = ChoiceField;var template$1$2 = template$5.extend();
var choice$1$1 = choice$1.extend();
var choiceIcon$1 = choiceIcon.extend();
var choiceGroup$1 = choiceGroup.extend();
var templates$5 =
/*#__PURE__*/
Object.freeze({
  default: template$1$2,
  choice: choice$1$1,
  choiceIcon: choiceIcon$1,
  choiceGroup: choiceGroup$1
});var defaults$6 = {
  validWhenSelected: false,
  validWhenIsChoice: false,
  validWhenTrue: true,
  choiceLabels: ['True', 'False'],
  choices: [{
    value: true
  }, {
    value: false
  }],
  spacing: 8
};var TrueFalseField;

TrueFalseField = function () {
  class TrueFalseField extends Field$1 {
    constructor() {
      super(...arguments);
      this.lastSelected = null;
      this.visibleChoicesCount = 2;
      this.choices = this.settings.choices;
      this.choices[0].label = this.settings.choiceLabels[0];
      this.choices[1].label = this.settings.choiceLabels[1];
      this.settings.perGroup = 2;

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      if (this._value === null) {
        return null;
      } else {
        if (this._value.index === 0) {
          return true;
        } else {
          return false;
        }
      }
    }

    _setValue(newValue) {
      var ref;

      if (newValue === this.choices[0]) {
        newValue = this.choices[0].value;
      }

      if (newValue === this.choices[1]) {
        newValue = this.choices[1].value;
      }

      if (newValue === null) {
        this._value = null;

        if ((ref = this.lastSelected) != null) {
          ref.toggle(false);
        }

        return;
      }

      if (typeof newValue === 'string') {
        newValue = newValue.toLowerCase();

        if (newValue === 'false') {
          newValue = false;
        }
      }

      return (newValue ? this.choices[0] : this.choices[1]).toggle();
    }

    _validate(providedValue) {
      if (typeof providedValue === 'string') {
        providedValue = this.findChoice(providedValue);
      }

      if (this.settings.validWhenIsChoice) {
        if (providedValue) {
          if (this.settings.validWhenIsChoice !== providedValue.value) {
            return false;
          }
        } else {
          return false;
        }
      }

      if (this.settings.validWhenSelected) {
        if (!providedValue) {
          return false;
        }
      }

      if (this.settings.validWhenTrue) {
        if ((providedValue != null ? providedValue.index : void 0) !== 0) {
          return false;
        }
      }

      return true;
    }

  }

  TrueFalseField.prototype.template = template$1$2;
  TrueFalseField.prototype.templates = templates$5;
  TrueFalseField.prototype.defaults = defaults$6;
  return TrueFalseField;
}.call(undefined);

inheritProto(TrueFalseField, ChoiceField$1, ['_createElements', '_attachBindings', '_attachBindings_elState', '_attachBindings_stateTriggers', '_attachBindings_display', '_attachBindings_value']);
var TrueFalseField$1 = TrueFalseField;var defaults$7 = {
  validWhenTrue: true,
  size: 50,
  style: 'centered',
  color: COLORS$1.green,
  background: COLORS$1.grey_light,
  triggerEvent: 'mouseup'
};var template$6 = quickdom.template(['div', {
  ref: 'field',
  style: {
    position: 'relative',
    display: 'none',
    width: function (field) {
      return field.state.width;
    },
    boxSizing: 'border-box',
    fontFamily: function (field) {
      return field.settings.fontFamily;
    },
    textAlign: 'left',
    $visible: {
      display: 'inline-block'
    },
    $showError: {
      animation: '0.2s fieldErrorShake'
    },
    $alignedStyle: {
      paddingRight: function (field) {
        return field.settings.size + 20;
      }
    }
  }
}, ['div', {
  ref: 'label',
  style: {
    display: 'none',
    marginBottom: '12px',
    fontFamily: 'inherit',
    fontSize: '13px',
    fontWeight: 600,
    textAlign: 'center',
    color: COLORS$1.black,
    cursor: 'default',
    pointerEvents: 'none',
    userSelect: 'none',
    $showLabel: {
      display: 'block'
    },
    $showError: {
      color: COLORS$1.red
    },
    $alignedStyle: {
      marginBottom: '0',
      textAlign: 'left'
    }
  }
}], ['div', {
  ref: 'innerwrap',
  style: {
    position: 'relative',
    boxSizing: 'border-box',
    fontFamily: 'inherit',
    $alignedStyle: {
      position: 'absolute',
      right: 0,
      top: '50%',
      transform: 'translateY(-50%)'
    }
  }
}, ['div', {
  ref: 'input',
  style: {
    position: 'relative',
    zIndex: 2,
    width: function (field) {
      return field.settings.size;
    },
    height: function (field) {
      return field.settings.size / 2;
    },
    margin: '0 auto',
    backgroundColor: function (field) {
      return field.settings.background;
    },
    border: `1px solid ${COLORS$1.grey_semi_light}`,
    borderRadius: function (field) {
      return field.settings.size;
    },
    cursor: 'pointer'
  }
}, ['div', {
  ref: 'background',
  style: {
    position: 'absolute',
    zIndex: 1,
    left: 0,
    right: 0,
    width: function (field) {
      return field.settings.size / 2;
    },
    height: '100%',
    borderRadius: function (field) {
      var size;
      size = field.settings.size;
      return `${size}px 0 0 ${size}px`;
    },
    backgroundColor: function (field) {
      return field.settings.color;
    },
    opacity: 0,
    transition: 'opacity 0.2s, width 0.2s',
    $toggled: {
      opacity: 1,
      width: function (field) {
        return field.settings.size * 0.7;
      }
    }
  }
}], ['div', {
  ref: 'ball',
  style: {
    position: 'absolute',
    zIndex: 2,
    left: 0,
    right: 0,
    width: function (field) {
      return field.settings.size / 2;
    },
    height: function (field) {
      return field.settings.size / 2;
    },
    margin: '0 auto',
    backgroundColor: 'white',
    borderRadius: '50%',
    border: `1px solid ${COLORS$1.grey_light}`,
    boxSizing: 'border-box',
    transform: 'translateX(-55%)',
    transition: 'transform 0.2s',
    userSelect: 'none',
    $toggled: {
      transform: 'translateX(50%)',
      border: function (field) {
        return `1px solid ${field.settings.color}`;
      }
    }
  }
}]]], ['div', {
  ref: 'help',
  style: {
    marginTop: '10px',
    fontFamily: 'inherit',
    fontSize: '11px',
    color: COLORS$1.grey,
    display: 'none',
    $showError: {
      color: COLORS$1.red,
      display: 'block'
    },
    $showHelp: {
      display: 'block'
    }
  }
}]]);
var templates$6 =
/*#__PURE__*/
Object.freeze({
  default: template$6
});var ToggleField;

ToggleField = function () {
  class ToggleField extends Field$1 {
    constructor() {
      super(...arguments);
      this._value = !!this._value;
      this.settings.size = parseFloat(this.settings.size) || defaults$7.size;

      if (this.settings.style !== 'centered' && this.settings.style !== 'aligned') {
        this.settings.style = defaults$7.style;
      }

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      return this._value;
    }

    _setValue(newValue) {
      return this._value = !!newValue;
    }

    _createElements() {
      var forceOpts;
      forceOpts = {
        relatedInstance: this
      };
      this.el = this.template.spawn(this.settings.templates.default, forceOpts);
      this.el.state('alignedStyle', this.settings.style === 'aligned').child.innerwrap.raw._quickField = this;
    }

    _attachBindings() {
      this._attachBindings_elState();

      this._attachBindings_stateTriggers();

      this._attachBindings_display();

      this._attachBindings_value();
    }

    _attachBindings_value() {
      simplybind('_value').of(this).to(value => {
        return this.el.state('toggled', value);
      });
      simplybind('_value', {
        updateOnBind: false
      }).of(this).to(value => {
        return this.emit('input', value);
      });
      simplybind(`event:${this.settings.triggerEvent}`).of(this.el.child.input).to(() => {
        return this.value = !this._value;
      });
    }

    _validate(providedValue) {
      if (this.settings.validWhenTrue) {
        if (!providedValue) {
          return false;
        }
      }

      return true;
    }

  }

  ToggleField.prototype.template = template$6;
  ToggleField.prototype.templates = templates$6;
  ToggleField.prototype.defaults = defaults$7;
  return ToggleField;
}.call(undefined);

inheritProto(ToggleField, TrueFalseField$1, ['_attachBindings_elState', '_attachBindings_stateTriggers', '_attachBindings_display']);
var ToggleField$1 = ToggleField;var defaults$8 = {
  fields: {},
  collapsable: true,
  startCollapsed: false,
  padding: 20,
  fieldMargin: 0,
  fieldAlign: 'top',
  labelSize: 16,
  color: COLORS$1.grey_light4
};var action = quickdom.template(['div', {
  events: {
    inserted: function () {
      if (this.index) {
        return this.style('marginLeft', 5);
      }
    }
  },
  style: {
    display: 'inline-block',
    boxSizing: 'border-box'
  }
}, [// verticalAlign: 'middle'
'div', {
  ref: 'icon',
  style: {
    width: 17,
    height: 17,
    color: COLORS$1.grey,
    fill: COLORS$1.grey,
    $hover: {
      color: COLORS$1.grey_dark,
      fill: COLORS$1.grey_dark
    }
  }
}]]);
var collapseIcons = [caretUp.extend({
  options: {
    style: {
      position: 'relative',
      top: -2,
      display: 'none',
      $collapsed: {
        display: 'block'
      }
    }
  }
}), caretDown.extend({
  options: {
    style: {
      display: 'block',
      $collapsed: {
        display: 'none'
      }
    }
  }
})];
var template$7 = quickdom.template(['div', {
  ref: 'field',
  style: {
    position: 'relative',
    boxSizing: 'border-box',
    verticalAlign: 'top',
    display: 'none',
    width: function (field) {
      return field.state.width;
    },
    fontFamily: function (field) {
      return field.settings.fontFamily;
    },
    // backgroundColor: (field)-> field.settings.color
    border: `1px solid ${COLORS$1.grey_light}`,
    borderRadius: 3,
    textAlign: 'left',
    // lineHeight: '1em'
    $visible: {
      display: 'inline-block'
    },
    $showError: {
      $collapsed: {
        animation: '0.2s fieldErrorShake'
      }
    }
  }
}, ['div', {
  ref: 'label',
  style: {
    display: 'none',
    fontFamily: 'inherit',
    fontSize: function (field) {
      return field.settings.labelSize;
    },
    fontWeight: 600,
    textAlign: 'left',
    color: COLORS$1.black,
    cursor: 'default',
    userSelect: 'none',
    $showLabel: {
      display: 'block'
    },
    $showError: {
      color: COLORS$1.red
    }
  }
}], ['div', {
  ref: 'actions',
  style: {
    position: 'absolute',
    top: function (field) {
      return field.settings.padding * (12 / 20);
    },
    right: function (field) {
      return field.settings.padding * (12 / 20);
    },
    lineHeight: 0,
    fontSize: 0,
    textAlign: 'center',
    $showLabel: {
      top: function (field) {
        return field.settings.padding * (21 / 20);
      }
    }
  }
}], ['div', {
  ref: 'help',
  style: {
    marginTop: '10px',
    fontFamily: 'inherit',
    fontSize: '11px',
    color: COLORS$1.grey,
    display: 'none',
    whiteSpace: 'pre-line',
    $showError: {
      color: COLORS$1.red,
      display: 'block'
    },
    $showHelp: {
      display: 'block'
    }
  }
}], ['div', {
  ref: 'innerwrap',
  unpassableStates: ['visible', 'hover', 'focus', 'disabled', 'showLabel', 'showError', 'showHelp', 'collapsed', 'valid', 'invalid'],
  style: {
    position: 'relative',
    boxSizing: 'border-box',
    marginTop: 15,
    fontFamily: 'inherit',
    textAlign: 'justify',
    textJustify: 'distribute-all-lines',
    fontSize: 0,
    $collapsed: {
      display: 'none'
    }
  }
}]]);
var templates$7 =
/*#__PURE__*/
Object.freeze({
  action: action,
  collapseIcons: collapseIcons,
  default: template$7
});var GroupField;

GroupField = function () {
  class GroupField extends Field$1 {
    constructor() {
      super(...arguments);
      this._calcFocusState = this._calcFocusState.bind(this);
      this._calcBlurState = this._calcBlurState.bind(this);
      this._emitSubmit = this.emit.bind(this, 'submit');
      this.state.collapsed = this.settings.startCollapsed && this.settings.collapsable;

      if (this._value == null) {
        this._value = Object.create(null);
      }

      this.fields = Object.create(null);
      this.fieldsArray = [];

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      var field, name, ref, values;
      values = Object.create(null);
      ref = this.fields;

      for (name in ref) {
        field = ref[name];
        values[name] = field.value;
      }

      return values;
    }

    _setValue(newValue) {
      var name, value;

      if (IS$1$1.object(newValue)) {
        for (name in newValue) {
          value = newValue[name];

          if (this.fields[name]) {
            this.fields[name].value = value;
          }
        }

        return newValue;
      }
    }

    _recalcDisplay() {
      var field, i, len, ref;
      ref = this.fieldsArray;

      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];

        if (field._recalcDisplay) {
          field._recalcDisplay();
        }
      }
    }

    _createElements() {
      var config, field, fields, forceOpts, i, len, margin, name, ref, ref1;
      forceOpts = {
        relatedInstance: this
      };
      margin = `0 0 ${this.settings.fieldMargin}px 0`;
      this.el = this.template.spawn(this.settings.templates.default, forceOpts);

      if (this.settings.collapsable) {
        this.addAction('collapse', this.templates.collapseIcons);
      }

      if (IS$1$1.array(this.settings.fields)) {
        fields = Object.create(null);
        ref = this.settings.fields;

        for (i = 0, len = ref.length; i < len; i++) {
          field = ref[i];

          if (!field.name) {
            throw new Error(`field ${this.name || this.ID}:group fields provided in array format must have a name`);
          }

          fields[field.name] = field;
        }

        this.settings.fields = fields;
      }

      ref1 = this.settings.fields;

      for (name in ref1) {
        field = ref1[name];
        config = primaryBuilder$1({
          margin,
          fieldInstances: this.fields
        }, field, {
          ID: name
        });
        this.fieldsArray.push(this.fields[name] = this.builder(config).appendTo(this.el.child.innerwrap));
        this.fields[name].on('focus', this._calcFocusState).on('blur', this._calcBlurState).on('submit', this._emitSubmit).el.style('verticalAlign', this.settings.fieldAlign).after(' ');
      }

      this.el.child.innerwrap.append(quickdom.div({
        style: {
          display: 'inline-block',
          width: '100%'
        }
      }));
      this.el.state('collapsable', this.settings.collapsable);
      this.el.raw._quickField = this.el.childf.innerwrap.raw._quickField = this;
    }

    _attachBindings() {
      this._attachBindings_elState();

      this._attachBindings_display();

      this._attachBindings_stateTriggers();

      this._attachBindings_value();
    }

    _attachBindings_elState() {
      simplybind('visible').of(this.state).to(visible => {
        return this.el.state('visible', visible);
      });
      simplybind('hovered').of(this.state).to(hovered => {
        return this.el.state('hover', hovered);
      });
      simplybind('focused').of(this.state).to(focused => {
        return this.el.state('focus', focused);
      });
      simplybind('disabled').of(this.state).to(disabled => {
        return this.el.state('disabled', disabled);
      });
      simplybind('showLabel').of(this.state).to(showLabel => {
        return this.el.state('showLabel', showLabel);
      });
      simplybind('showError').of(this.state).to(showError => {
        return this.el.state('showError', showError);
      });
      simplybind('showHelp').of(this.state).to(showHelp => {
        return this.el.state('showHelp', showHelp);
      });
      simplybind('collapsed').of(this.state).to(collapsed => {
        return this.el.state('collapsed', collapsed);
      });
      return simplybind('valid').of(this.state).to(valid => {
        this.el.state('valid', valid);
        return this.el.state('invalid', !valid);
      });
    }

    _attachBindings_display() {
      var field, i, len, ref;
      simplybind('width').of(this.state).to(width => {
        return this.el.style('width', width).state('definedWidth', width !== 'auto');
      }).transform(this._formatWidth.bind(this)).updateOn('isMobile').of(this.state);
      ref = this.fieldsArray;

      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];
        simplybind('disabled').of(this.state).to('disabled').of(field.state);
      }
    }

    _attachBindings_stateTriggers() {
      var toggleCollapse;

      if (this.settings.collapsable) {
        toggleCollapse = () => {
          this.state.collapsed = !this.state.collapsed;
          return this.emit('collapsed', this.state.collapsed);
        };

        simplybind('event:click').of(this.el.child.collapse).to(toggleCollapse);
        simplybind('event:click').of(this.el.child.label).to(toggleCollapse);
        simplybind('collapsed').of(this.state).once.to(() => {
          return this._recalcDisplay();
        }).condition(function (collapsed) {
          return !collapsed;
        });
      }
    }

    _attachBindings_value() {
      var field, fieldName, ref;
      ref = this.fields;

      for (fieldName in ref) {
        field = ref[fieldName];
        simplybind('_value').of(field).to(fieldName).of(this._value);
        simplybind('_value', {
          updateOnBind: false
        }).of(field).to(value => {
          if (value) {
            this.state.interacted = true;
          }

          this.state.valid = this.validate(void 0, true);
          return this.emit('input', this._value);
        });
      }
    }

    _validate(providedValue, testUnrequired, report) {
      var field, i, isValid, len, ref, someInvalid;
      someInvalid = false;
      ref = this.fieldsArray;

      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];

        if (!field.state.visible) {
          continue;
        }

        if (report) {
          isValid = field.validateAndReport(providedValue[field.name], testUnrequired);
        } else {
          isValid = field.validate(providedValue[field.name], testUnrequired);
        }

        if (!isValid) {
          someInvalid = true;
        }
      }

      return !someInvalid;
    }

    _calcFocusState() {
      return this.state.focused = this.fieldsArray.some(function (field) {
        return field.state.focused;
      });
    }

    _calcBlurState() {
      return setTimeout(this._calcFocusState);
    }

    focus() {
      var field, i, len, ref;
      this.state.collapsed = false;
      ref = this.fieldsArray;

      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];

        if (field.focus) {
          return field.focus();
        }
      }
    }

    blur() {
      var field, i, len, ref;
      ref = this.fieldsArray;

      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];

        if (field.blur) {
          return field.blur();
        }
      }
    }

    addAction(name, icons, callback, prepend) {
      var action$$1, i, icon, len;

      if (icons && !IS$1$1.array(icons)) {
        icons = [icons];
      }

      action$$1 = this.templates.action.spawn(this.settings.templates.action, {
        relatedInstance: this
      });
      action$$1.ref = action$$1.options.ref = name;

      for (i = 0, len = icons.length; i < len; i++) {
        icon = icons[i];
        action$$1.child.icon.append(icon);
      }

      this.el.child.actions[prepend ? 'prepend' : 'append'](action$$1);

      if (callback) {
        simplybind('event:click').of(action$$1).to(callback);
      }

      return action$$1;
    }

  }

  GroupField.prototype.template = template$7;
  GroupField.prototype.templates = templates$7;
  GroupField.prototype.defaults = defaults$8;
  GroupField.prototype.shallowSettings = ['fields'];
  return GroupField;
}.call(undefined);

var GroupField$1 = GroupField;var template$8 = quickdom.template(['div', {
  ref: 'field',
  style: {
    position: 'relative',
    boxSizing: 'border-box',
    verticalAlign: 'top',
    display: 'none',
    width: function (field) {
      return field.state.width;
    },
    fontFamily: function (field) {
      return field.settings.fontFamily;
    },
    borderRadius: 3,
    textAlign: 'left',
    $visible: {
      display: 'inline-block'
    },
    $showError: {
      animation: '0.2s fieldErrorShake'
    }
  }
}, ['div', {
  ref: 'label',
  style: {
    display: 'none',
    fontFamily: 'inherit',
    fontSize: '16px',
    fontWeight: 600,
    textAlign: 'left',
    color: COLORS$1.black,
    cursor: 'default',
    userSelect: 'none',
    $showLabel: {
      display: 'block'
    },
    $showError: {
      color: COLORS$1.red
    }
  }
}], ['div', {
  ref: 'collapse',
  style: {
    position: 'absolute',
    top: 5,
    right: 0,
    lineHeight: 0,
    fontSize: 0,
    display: 'none',
    $showLabel: {
      $collapsable: {
        display: 'block'
      }
    }
  }
}, ['div', {
  ref: 'icon',
  style: {
    width: 17,
    height: 17,
    color: COLORS$1.grey,
    fill: COLORS$1.grey,
    $hover: {
      color: COLORS$1.grey_dark,
      fill: COLORS$1.grey_dark
    }
  }
}, ...collapseIcons]], ['div', {
  ref: 'help',
  style: {
    marginTop: '10px',
    fontFamily: 'inherit',
    fontSize: '11px',
    color: COLORS$1.grey,
    display: 'none',
    $showError: {
      color: COLORS$1.red,
      display: 'block'
    },
    $showHelp: {
      display: 'block'
    }
  }
}], ['div', {
  ref: 'innerwrap',
  unpassableStates: ['visible', 'hover', 'focus', 'disabled', 'showLabel', 'showError', 'showHelp', 'collapsed', 'valid', 'invalid'],
  style: {
    position: 'relative',
    boxSizing: 'border-box',
    marginTop: 15,
    fontFamily: 'inherit',
    textAlign: 'justify',
    textJustify: 'distribute-all-lines',
    fontSize: 0,
    $collapsed: {
      display: 'none'
    }
  }
}, ['div', {
  ref: 'addButton',
  style: {
    position: 'relative',
    verticalAlign: 'middle',
    boxSizing: 'border-box',
    padding: 12,
    backgroundColor: COLORS$1.grey_semi_light,
    borderRadius: 3,
    cursor: 'pointer',
    userSelect: 'none',
    lineHeight: '1em',
    textAlign: 'center',
    $disabled: {
      display: 'none'
    },
    $inlineStyle: {
      display: 'inline-block',
      top: function (field) {
        return field.settings.groupMargin / 2 * -1;
      }
    }
  }
}, ['div', {
  style: {
    display: 'inline-block',
    width: 15,
    height: 15,
    color: COLORS$1.black,
    fill: COLORS$1.black
  }
}, plus]]]]);
var cloneIcon = clone$1.extend({
  options: {
    style: {
      width: 11
    }
  }
});
var removeIcon = remove$1.extend({
  options: {
    style: {
      width: 11
    }
  }
});
var blockGroup = {};
var inlineGroup = {
  default: {
    // options: style:
    // 	verticalAlign: 'middle'
    children: {
      innerwrap: {
        options: {
          style: {
            display: 'inline-block',
            verticalAlign: 'middle',
            marginTop: 0
          }
        }
      },
      actions: {
        options: {
          events: {
            inserted: function () {
              return this.insertAfter(this.parent.child.innerwrap);
            }
          },
          style: {
            position: 'static',
            verticalAlign: 'middle',
            display: 'inline-table'
          }
        }
      }
    }
  },
  action: ['div', {
    events: {
      inserted: function () {
        if (this.index) {
          return this.style('borderTop', `1px solid ${COLORS$1.grey}`);
        }
      }
    },
    style: {
      boxSizing: 'border-box',
      display: 'table-row',
      padding: 4
    }
  }, ['div', {
    ref: 'icon',
    style: {
      verticalAlign: 'middle',
      display: 'table-cell',
      color: COLORS$1.black,
      fill: COLORS$1.black,
      opacity: 0.6,
      $hover: {
        opacity: 1
      }
    }
  }]]
};
var templates$8 =
/*#__PURE__*/
Object.freeze({
  default: template$8,
  cloneIcon: cloneIcon,
  removeIcon: removeIcon,
  blockGroup: blockGroup,
  inlineGroup: inlineGroup
});var defaults$9 = {
  fields: null,
  style: 'block',
  collapsable: true,
  startCollapsed: false,
  groupMargin: 10,
  groupWidth: '100%',
  autoWidth: true,
  autoRemoveEmpty: false,
  dynamicLabel: false,
  minItems: null,
  maxItems: null,
  draggable: false,
  cloneable: false,
  removeable: true,
  singleMode: false,
  numbering: false,
  multiple: true,
  groupSettings: {
    labelSize: 14,
    inline: {
      padding: 0,
      fieldMargin: 0,
      width: 'auto',
      collapsable: false,
      startCollapsed: false,
      templates: inlineGroup
    },
    block: {
      startCollapsed: false,
      templates: blockGroup
    }
  }
};var RepeaterField;

RepeaterField = function () {
  class RepeaterField extends Field$1 {
    constructor() {
      var base, diff$$1;
      super(...arguments);
      this._calcFocusState = this._calcFocusState.bind(this);
      this._calcBlurState = this._calcBlurState.bind(this);
      this._emitSubmit = this.emit.bind(this, 'submit');
      this.groupLabel = IS$1$1.string(this.settings.numbering) ? this.settings.numbering : 'Item';
      this.labelRegex = new RegExp(`^${this.groupLabel} \\d+(?:\: )?`);
      this.state.collapsed = this.settings.startCollapsed && this.settings.collapsable;

      if (this._value == null) {
        this._value = [];
      }

      this.settings._groupSettings = primaryBuilder$1.notKeys(['inline', 'block']).clone(this.settings.groupSettings);
      this.settings.groupSettings = primaryBuilder$1.keys(['inline', 'block']).clone(this.settings.groupSettings);

      if (this.settings.style === 'block') {
        this.settings.autoWidth = true;
      }

      if (this.settings.field) {
        this.settings.singleMode = true;
      }

      if (this.settings.singleMode) {
        this.settings.fields = [this.settings.field || this.settings.fields];
      }

      if ((base = this.settings).value == null) {
        base.value = [];
      }

      if (this.settings.minItems && this.settings.value.length < this.settings.minItems) {
        diff$$1 = this.settings.minItems - this.settings.value.length;

        while (--diff$$1) {
          this.settings.value.push(null);
        }
      }

      this._createElements();

      this._attachBindings();

      this._constructorEnd();
    }

    _getValue() {
      var group, i, index, len, ref, values;
      values = [];
      ref = this._value;

      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        group = ref[index];
        values[index] = group.value;
      }

      return values;
    }

    _setValue(newValue) {
      var i, index, len, value;

      if (!IS$1$1.array(newValue)) {
        this.addItem(newValue, false, true);
      } else {
        for (index = i = 0, len = newValue.length; i < len; index = ++i) {
          value = newValue[index];

          if (this._value[index] != null) {
            this._value[index].value = value;
          } else {
            this.addItem(value, false, true);
          }
        }
      }

      return newValue;
    }

    _createElements() {
      var forceOpts;
      forceOpts = {
        relatedInstance: this
      };
      this.el = this.template.spawn(this.settings.templates.default, forceOpts);
      this.el.state('collapsable', this.settings.collapsable);
      this.el.state(`${this.settings.style}Style`, true);
      this.el.raw._quickField = this.el.childf.innerwrap.raw._quickField = this;
    }

    _attachBindings() {
      this._attachBindings_elState();

      this._attachBindings_display();

      this._attachBindings_stateTriggers();

      this._attachBindings_value();
    }

    _attachBindings_elState() {
      simplybind('visible').of(this.state).to(visible => {
        return this.el.state('visible', visible);
      });
      simplybind('disabled').of(this.state).to(disabled => {
        return this.el.state('disabled', disabled);
      });
      simplybind('showLabel').of(this.state).to(showLabel => {
        return this.el.state('showLabel', showLabel);
      });
      simplybind('showError').of(this.state).to(showError => {
        return this.el.state('showError', showError);
      });
      simplybind('showHelp').of(this.state).to(showHelp => {
        return this.el.state('showHelp', showHelp);
      });
      simplybind('collapsed').of(this.state).to(collapsed => {
        return this.el.state('collapsed', collapsed);
      });
      return simplybind('valid').of(this.state).to(valid => {
        this.el.state('valid', valid);
        return this.el.state('invalid', !valid);
      });
    }

    _attachBindings_display() {
      var group, i, len, ref;
      simplybind('width').of(this.state).to(width => {
        return this.el.style('width', width).state('definedWidth', width !== 'auto');
      }).transform(this._formatWidth.bind(this)).updateOn('isMobile').of(this.state);
      simplybind('showError', {
        updateOnBind: false
      }).of(this.state).to(showError => {
        var group, i, len, ref, results;
        ref = this._value;
        results = [];

        for (i = 0, len = ref.length; i < len; i++) {
          group = ref[i];
          results.push(group.state.showError = showError);
        }

        return results;
      });
      ref = this._value;

      for (i = 0, len = ref.length; i < len; i++) {
        group = ref[i];
        simplybind('disabled').of(this.state).to('disabled').of(field.state);
      }
    }

    _attachBindings_stateTriggers() {
      var toggleCollapse;

      if (this.settings.collapsable) {
        toggleCollapse = () => {
          this.state.collapsed = !this.state.collapsed;
          return this.emit('collapsed', this.state.collapsed);
        };

        simplybind('event:click').of(this.el.child.collapse).to(toggleCollapse);
        simplybind('event:click').of(this.el.child.label).to(toggleCollapse);
        simplybind('collapsed').of(this.state).once.to(() => {
          return this._recalcDisplay();
        }).condition(function (collapsed) {
          return !collapsed;
        });
      }
    }

    _attachBindings_value() {
      simplybind('array:_value', {
        updateOnBind: true
      }).of(this).to((value, prevValue) => {
        if (value.length) {
          this._recalcLabels();
        }

        if (prevValue) {
          this.state.interacted = true;
          return this.state.valid = this.validate(void 0, true);
        }
      });
      simplybind('event:click').of(this.el.child.addButton).to(() => {
        return this.addItem().focus();
      });
    }

    _validate(providedValue, testUnrequired) {
      var group, i, isValid, len, ref;
      ref = this._value;

      for (i = 0, len = ref.length; i < len; i++) {
        group = ref[i];
        isValid = group.validate(providedValue[group.name], testUnrequired);

        if (!isValid) {
          return false;
        }
      }

      return true;
    }

    _calcFocusState() {
      return this.state.focused = this._value.some(function (field) {
        return field.state.focused;
      });
    }

    _calcBlurState() {
      return setTimeout(this._calcFocusState);
    }

    focus() {
      var ref;
      return (ref = this._value[0]) != null ? ref.focus() : void 0;
    }

    blur() {
      var field, i, len, ref;
      ref = this._value;

      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];

        if (field.blur) {
          field.blur();
        }
      }
    }

    _recalcLabels() {
      var group, i, index, len, ref;

      if (this.settings.style === 'block') {
        if (!this.settings.numbering && !this.settings.dynamicLabel) {
          return;
        }

        ref = this._value;

        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          group = ref[index];

          this._recalcLabel(group, index);
        }
      }
    }

    _recalcLabel(group, index) {
      var existingLabel, newLabel;

      if (this.settings.dynamicLabel && group.fields[this.settings.dynamicLabel]) {
        newLabel = group.fields[this.settings.dynamicLabel].value;
      } else {
        existingLabel = group.state.label || '';
        existingLabel = existingLabel.replace(this.labelRegex, '');
        newLabel = `${this.groupLabel} ${index + 1}`;

        if (existingLabel) {
          newLabel += `: ${existingLabel}`;
        }
      }

      return group.state.label = newLabel;
    }

    _recalcDisplay() {
      var group, i, len, ref;
      ref = this._value;

      for (i = 0, len = ref.length; i < len; i++) {
        group = ref[i];

        if (group._recalcDisplay) {
          group._recalcDisplay();
        }
      }
    }

    addItem(value, skipInsert, skipEmit) {
      var firstField, group, margin, refreshChildren, settings;

      if (this.settings.maxItems && this._value.length === this.settings.maxItems || this.state.disabled) {
        return;
      }

      margin = this.settings.style === 'inline' ? `0 ${this.settings.groupMargin}px ${this.settings.groupMargin}px 0` : `0 0 ${this.settings.groupMargin}px 0`;
      settings = primaryBuilder$1({
        type: 'group',
        fields: this.settings.fields,
        margin,
        value
      }, this.settings._groupSettings, this.settings.groupSettings[this.settings.style]);

      if (this.settings.singleMode) {
        firstField = this.settings.fields[0].name;

        settings.getter = function (fields) {
          return fields[firstField];
        };

        settings.setter = function (value) {
          return {
            [`${firstField}`]: value
          };
        };
      }

      group = this.builder(settings);
      group.el.child.actions.append(this.settings.groupSettings[this.settings.style]);

      if (this.settings.cloneable) {
        group.addAction('clone', this.templates.cloneIcon, this.cloneItem.bind(this, group), this.settings.style === 'block');
      }

      if (this.settings.removeable) {
        group.addAction('remove', this.templates.removeIcon, this.removeItem.bind(this, group), this.settings.style === 'block');
      }

      group.on('focus', this._calcFocusState);
      group.on('blur', this._calcBlurState);
      group.on('submit', this._emitSubmit);
      simplybind('event:input').of(group).to(() => {
        return this.emit('input', this._value, group);
      });
      simplybind('disabled').of(this.state).to('disabled').of(group.state);
      refreshChildren = group.el.childf;

      if (this.settings.dynamicLabel) {
        group.on('input', () => {
          return this._recalcLabel(group);
        });
      }

      if (this.settings.autoRemoveEmpty) {
        group.once('blur', () => {
          if (!group.state.interacted) {
            return this.removeItem(group);
          }
        });
      }

      if (!this.settings.autoWidth) {
        group.state.width = this.settings.groupWidth;
        group.el.child.innerwrap.once('inserted', function () {
          return this.style('width', `calc(100% - ${this.parent.child.actions.width || 17}px)`);
        });
      }

      if (!skipInsert) {
        group.insertBefore(this.el.child.addButton);

        if (!skipEmit) {
          this.emit('itemAdd', group);
        }

        this._value.push(group);
      }

      return group;
    }

    cloneItem(group) {
      var clone;

      if (this.settings.maxItems && this._value.length === this.settings.maxItems || this.state.disabled) {
        return;
      }

      if (!includes$2(this._value, group)) {
        return;
      }

      clone = this.addItem(group.value, true);
      clone.insertAfter(group.el);
      insertAfter$1(this._value, group, clone);
      this.emit('itemAdd', clone);
      this.emit('itemClone', clone);
      return clone;
    }

    removeItem(group) {
      var ref, removed, targetIndex;

      if (this.settings.minItems && this._value.length === this.settings.minItems || this.state.disabled) {
        return;
      }

      targetIndex = Math.max(1, this._value.indexOf(group));

      if (removed = removeItem$1(this._value, group)) {
        group.destroy();
        this.emit('itemRemove', group);

        if ((ref = this._value[targetIndex - 1]) != null) {
          ref.focus();
        }
      }

      return !!removed;
    }

  }

  RepeaterField.prototype.template = template$8;
  RepeaterField.prototype.templates = templates$8;
  RepeaterField.prototype.defaults = defaults$9;
  RepeaterField.prototype.shallowSettings = ['fields'];
  return RepeaterField;
}.call(undefined);

var RepeaterField$1 = RepeaterField;var assert$1, emitEvent, expect$1;
chai$2.use(chaiDom);
chai$2.use(sources);
chai$2.use(chaiAlmost_1);
chai$2.use(asserttype);
chai$2.use(chaiEvents);
chai$2.config.truncateThreshold = 1e3;
mocha.setup('tdd');
mocha.slow(400);
mocha.timeout(12000);

if (!window.__karma__) {
  mocha.bail();
}

assert$1 = chai$2.assert;
expect$1 = chai$2.expect;
window.sandbox = null;
quickfield$1$1.register('textarea', TextareaField$1);
quickfield$1$1.register('number', NumberField$1);
quickfield$1$1.register('select', SelectField$1);
quickfield$1$1.register('choice', ChoiceField$1);
quickfield$1$1.register('truefalse', TrueFalseField$1);
quickfield$1$1.register('toggle', ToggleField$1);
quickfield$1$1.register('group', GroupField$1);
quickfield$1$1.register('repeater', RepeaterField$1); // quickfield.register('file', FileField)

window.quickfield = quickfield$1$1;

emitEvent = function (target, event, trigger) {
  var promise;
  promise = pEvent(target, event);
  trigger();
  return promise;
};

suite("QuickField", function () {
  teardown(function () {
    var lastChild;
    lastChild = sandbox.children[sandbox.children.length - 1];

    if ((lastChild != null ? lastChild.ref : void 0) === 'testTitle') {
      return lastChild.remove();
    }
  });
  suiteSetup(function () {
    return restartSandbox$1();
  });
  suite("creation", function () {
    teardown(restartSandbox$1);
    test("text field", function () {
      var field;
      field = quickfield$1$1({
        type: 'text'
      }).appendTo(sandbox);
      assert$1.equal(field.el.parent, sandbox);
      return assert$1.equal(field.el.child.input.attr('type'), 'text');
    });
    test("textarea field", function () {
      var field;
      field = quickfield$1$1({
        type: 'textarea'
      }).appendTo(sandbox);
      return assert$1.equal(field.el.parent, sandbox);
    });
    test("number field", function () {
      var field;
      field = quickfield$1$1({
        type: 'number'
      }).appendTo(sandbox);
      return assert$1.equal(field.el.parent, sandbox);
    });
    test("select field", function () {
      var field;
      field = quickfield$1$1({
        type: 'select'
      }).appendTo(sandbox);
      return assert$1.equal(field.el.parent, sandbox);
    });
    test("choice field", function () {
      var field;
      field = quickfield$1$1({
        type: 'choice',
        choices: ['a', 'b']
      }).appendTo(sandbox);
      return assert$1.equal(field.el.parent, sandbox);
    });
    test("truefalse field", function () {
      var field;
      field = quickfield$1$1({
        type: 'truefalse'
      }).appendTo(sandbox);
      return assert$1.equal(field.el.parent, sandbox);
    });
    test("toggle field", function () {
      var field;
      field = quickfield$1$1({
        type: 'toggle'
      }).appendTo(sandbox);
      return assert$1.equal(field.el.parent, sandbox);
    });
    return suite("misc", function () {
      return test("with multiple options object", function () {
        var config, field1, field2;
        config = {
          type: 'text',
          label: 'abc',
          value: '123'
        };
        field1 = quickfield$1$1(config);
        field2 = quickfield$1$1(config, {
          label: 'def'
        }, {
          height: 50,
          value: '456'
        });
        expect$1(config).to.eql({
          type: 'text',
          label: 'abc',
          value: '123'
        });
        expect$1(field1.settings.label).to.equal('abc');
        expect$1(field2.settings.label).to.equal('def');
        expect$1(field1.settings.height).to.equal(46);
        expect$1(field2.settings.height).to.equal(50);
        expect$1(field1.value).to.equal('123');
        return expect$1(field2.value).to.equal('456');
      });
    });
  });
  suite("text field", function () {
    suiteSetup(function () {
      addTitle("text field");
      return this.control = quickfield$1$1({
        type: 'text',
        label: 'Regular'
      }).appendTo(sandbox);
    });
    teardown(function () {
      return this.control.value = '';
    });
    test("getter/setter", function () {
      var fieldA, fieldB, fieldC, getter, setter;

      getter = function (value) {
        return `example.com/${value}`;
      };

      setter = function (value) {
        return value.toLowerCase();
      };

      fieldA = quickfield$1$1({
        type: 'text',
        label: 'path',
        getter
      });
      fieldB = quickfield$1$1({
        type: 'text',
        label: 'path',
        setter
      });
      fieldC = quickfield$1$1({
        type: 'text',
        label: 'path',
        getter,
        setter
      });
      expect$1(fieldA.value).to.equal('example.com/');
      expect$1(fieldA.el.child.input.raw.value).to.equal('');
      expect$1(fieldB.value).to.equal('');
      expect$1(fieldB.el.child.input.raw.value).to.equal('');
      expect$1(fieldC.value).to.equal('example.com/');
      expect$1(fieldC.el.child.input.raw.value).to.equal('');
      simulateKeys(fieldA.el.child.input.raw, 'AbC');
      simulateKeys(fieldB.el.child.input.raw, 'AbC');
      simulateKeys(fieldC.el.child.input.raw, 'AbC');
      expect$1(fieldA.value).to.equal('example.com/AbC');
      expect$1(fieldA.el.child.input.raw.value).to.equal('AbC');
      expect$1(fieldB.value).to.equal('abc');
      expect$1(fieldB.el.child.input.raw.value).to.equal('abc');
      expect$1(fieldC.value).to.equal('example.com/abc');
      expect$1(fieldC.el.child.input.raw.value).to.equal('abc');
      fieldA.value = 'DeF';
      fieldB.value = 'DeF';
      fieldC.value = 'DeF';
      expect$1(fieldA.value).to.equal('example.com/DeF');
      expect$1(fieldA.el.child.input.raw.value).to.equal('DeF');
      expect$1(fieldB.value).to.equal('def');
      expect$1(fieldB.el.child.input.raw.value).to.equal('def');
      expect$1(fieldC.value).to.equal('example.com/def');
      return expect$1(fieldC.el.child.input.raw.value).to.equal('def');
    });
    test("with help message", function () {
      var field;
      field = quickfield$1$1({
        type: 'text',
        label: 'With Help Message',
        help: 'help <b>message</b> here'
      }).appendTo(sandbox);
      expect$1(field.el.text).to.include('help message here');
      expect$1(field.els.help.html).to.equal('help <b>message</b> here');
      expect$1(this.control.els.help.html).to.equal('');
      expect$1(this.control.el.raw).to.have.style('marginBottom', '0px');
      expect$1(field.el.raw).to.have.style('marginBottom', '25px');
      field.state.help = '';
      expect$1(field.el.raw).to.have.style('marginBottom', '0px');
      expect$1(field.els.help.html).to.equal('');
      field.state.error = 'abc123';
      expect$1(field.el.raw).to.have.style('marginBottom', '0px');
      expect$1(field.els.help.html).to.equal('');
      field.state.showError = true;
      expect$1(field.el.raw).to.have.style('marginBottom', '25px');
      expect$1(field.els.help.html).to.equal('abc123');
      field.state.help = 'def456';
      expect$1(field.el.raw).to.have.style('marginBottom', '25px');
      expect$1(field.els.help.html).to.equal('def456');
      field.state.help = '';
      field.state.showError = false;
      expect$1(field.el.raw).to.have.style('marginBottom', '25px');
      return expect$1(field.els.help.html).to.equal('help <b>message</b> here');
    });
    test("without label", function () {
      var initialTop, withLabel, withoutLabel;
      withLabel = quickfield$1$1({
        type: 'text',
        label: 'With Label'
      }).appendTo(sandbox);
      withoutLabel = quickfield$1$1({
        type: 'text',
        placeholder: 'Without Label'
      }).appendTo(sandbox);
      quickdom.batch([withLabel.els.label, withLabel.els.innerwrap, withLabel.els.input, withoutLabel.els.label, withoutLabel.els.innerwrap, withoutLabel.els.input]).style('transition', null);
      assert$1.equal(withLabel.el.child.placeholder.html, 'With Label');
      assert$1.equal(withLabel.el.child.label.html, 'With Label');
      assert$1.equal(withLabel.el.child.label.style('opacity'), '0');
      assert$1.equal(withoutLabel.el.child.placeholder.html, 'Without Label');
      assert$1.notEqual(withoutLabel.el.child.label.html, 'Without Label');
      assert$1.equal(withoutLabel.el.child.label.style('opacity'), '0');
      initialTop = {
        withLabel: withLabel.el.child.input.rect.top,
        withoutLabel: withoutLabel.el.child.input.rect.top
      };
      withLabel.value = 'abc123';
      withoutLabel.value = 'abc123';
      assert$1.notEqual(withLabel.el.child.input.rect.top, initialTop.withLabel);
      assert$1.equal(withoutLabel.el.child.input.rect.top, initialTop.withoutLabel);
      assert$1.equal(withLabel.el.child.label.style('opacity'), '1');
      return assert$1.equal(withoutLabel.el.child.label.style('opacity'), '0');
    });
    test("with icon", function () {
      var iconField;
      return iconField = quickfield$1$1({
        type: 'text',
        label: 'With Icon',
        icon: 'B'
      }).appendTo(sandbox);
    });
    test("custom height/fontsize", function () {
      var fieldA, fieldB;
      fieldA = quickfield$1$1({
        type: 'text',
        label: 'Custom Height',
        height: 40,
        fontSize: 13,
        autoWidth: true
      }).appendTo(sandbox);
      fieldB = quickfield$1$1({
        type: 'text',
        label: 'Custom Height',
        height: 60,
        fontSize: 16,
        autoWidth: true
      }).appendTo(sandbox);
      assert$1.isAtLeast(this.control.el.height, this.control.settings.height);
      assert$1.isAtMost(this.control.el.height, this.control.settings.height + 5);
      assert$1.isAtLeast(fieldA.el.height, 40);
      assert$1.isAtMost(fieldA.el.height, 45);
      assert$1.isAtLeast(fieldB.el.height, 60);
      return assert$1.isAtMost(fieldB.el.height, 65);
    });
    test("custom border", function () {
      var custom;
      custom = quickfield$1$1({
        type: 'text',
        label: 'Custom Border',
        border: '0 0 2px 0'
      }).appendTo(sandbox);
      assert$1.deepEqual(getBorderSides(this.control.el.child.innerwrap), {
        top: '1px',
        left: '1px',
        right: '1px',
        bottom: '1px'
      });
      return assert$1.deepEqual(getBorderSides(custom.el.child.innerwrap), {
        top: '0px',
        left: '0px',
        right: '0px',
        bottom: '2px'
      });
    });
    test("default value", function () {
      var fieldA, fieldB, fieldC;
      fieldA = quickfield$1$1({
        type: 'text'
      });
      fieldB = quickfield$1$1({
        type: 'text',
        defaultValue: 'valueB'
      });
      fieldC = quickfield$1$1({
        type: 'text',
        value: 'valueC'
      });
      assert$1.equal(fieldA.value, '');
      assert$1.equal(fieldA.el.child.input.raw.value, '');
      assert$1.equal(fieldB.value, 'valueB');
      assert$1.equal(fieldB.el.child.input.raw.value, 'valueB');
      assert$1.equal(fieldC.value, 'valueC');
      return assert$1.equal(fieldC.el.child.input.raw.value, 'valueC');
    });
    test("disabled", function () {
      var fieldA, fieldB;
      fieldA = quickfield$1$1({
        type: 'text',
        label: 'Disabled',
        autoWidth: true,
        disabled: true
      }).appendTo(sandbox);
      fieldB = quickfield$1$1({
        type: 'text',
        label: 'Disabled w/ value',
        autoWidth: true,
        disabled: true,
        value: 'abc123'
      }).appendTo(sandbox);
      window.assert = assert$1;
      expect$1(this.control.value).to.equal('');
      expect$1(this.control.el.child.input.raw.value).to.equal('');
      expect$1(this.control.el.child.innerwrap.raw).to.have.style('backgroundColor', 'white');
      expect$1(fieldA.value).to.equal('');
      expect$1(fieldA.el.child.input.raw.value).to.equal('');
      expect$1(fieldA.el.child.innerwrap.raw).to.have.style('backgroundColor', COLORS.grey_light);
      expect$1(fieldB.value).to.equal('abc123');
      expect$1(fieldB.el.child.input.raw.value).to.equal('abc123');
      return expect$1(fieldB.el.child.innerwrap.raw).to.have.style('backgroundColor', COLORS.grey_light);
    }); // expect(@control.state.focused).to.equal false
    // @control.focus()
    // expect(@control.state.focused).to.equal true
    // expect(fieldA.state.focused).to.equal false
    // fieldA.focus()
    // Promise.delay(5).then ()->
    // 	expect(fieldA.state.focused).to.equal false

    test("conditions", function () {
      var master, slave;
      master = quickfield$1$1({
        type: 'text',
        label: 'Master Field',
        ID: 'masterField',
        mask: 'aaa-111',
        required: true,
        autoWidth: true
      }).appendTo(sandbox);
      return slave = quickfield$1$1({
        type: 'text',
        label: 'Slave Field',
        conditions: [{
          target: 'masterField'
        }],
        autoWidth: true
      }).appendTo(sandbox);
    });
    test("autowidth", function () {
      var field;
      return field = quickfield$1$1({
        type: 'text',
        label: 'Autowidth',
        autoWidth: true,
        checkmark: false
      }).appendTo(sandbox);
    });
    test("input event", function () {
      var count, field, input;
      count = 0;
      field = this.control;
      input = field.els.input.raw;
      field.on('input', function () {
        return count++;
      });
      return Promise.resolve().then(function () {
        return expect$1(count).to.equal(0);
      }).then(function () {
        return emitEvent(field, 'input', () => {
          return field.value = 'change';
        });
      }).then(function () {
        return expect$1(count).to.equal(1);
      }).then(function () {
        return emitEvent(field, 'input', () => {
          return field.value = 'change2';
        });
      }).then(function () {
        return expect$1(count).to.equal(2);
      }).then(function () {
        return emitEvent(field, 'input', () => {
          return simulateKeys(input, 'a');
        });
      }).then(function () {
        return expect$1(count).to.equal(3);
      }).then(function () {
        return emitEvent(field, 'input', () => {
          return simulateKeys(input, 'abc');
        });
      }).then(function () {
        return expect$1(count).to.equal(6);
      });
    });
    suite("options/autocomplete", function () {
      suiteSetup(function () {
        this.field = quickfield$1$1({
          type: 'text',
          label: 'My options field',
          choices: ['apple', 'banana', 'orange', 'banana republic', {
            label: 'orange split',
            value: 'split'
          }]
        }).appendTo(sandbox);
        this.choices = this.field.dropdown.choices;
        this.dropdownEl = this.field.dropdown.els.container.raw;
        return this.inputEl = this.field.el.child.input.raw;
      });
      teardown(function () {
        this.field.blur();
        return this.field.value = '';
      });
      test("triggering", function () {
        return Promise.bind(this).then(function () {
          var promise;
          expect$1(this.dropdownEl).not.to.be.displayed;
          promise = pEvent(this.field.el.child.input, 'focus');
          this.field.focus();
          return promise;
        }).then(function () {
          var promise;
          expect$1(this.dropdownEl).not.to.be.displayed;
          simulateKeys(this.inputEl, 'a');
          expect$1(this.dropdownEl).to.be.displayed;
          promise = pEvent(this.field.el.child.input, 'blur');
          this.field.blur();
          return promise;
        }).then(function () {
          expect$1(this.dropdownEl).not.to.be.displayed;
          this.field.focus();
          simulateAction(this.inputEl, 'down');
          return expect$1(this.dropdownEl).not.to.be.displayed;
        }).then(function () {
          simulateKeys(this.inputEl, 'a');
          return expect$1(this.dropdownEl).to.be.displayed;
        }).then(function () {
          var promise;
          promise = pEvent(this.field.el.child.input, 'blur');
          this.field.blur();
          return promise;
        }).then(function () {
          this.field.dropdown.isOpen = true;
          expect$1(this.dropdownEl).to.be.displayed;
          this.field.dropdown.isOpen = false;
          return expect$1(this.dropdownEl).not.to.be.displayed;
        });
      });
      test("highlighting", function () {
        this.field.focus();
        simulateKeys(this.inputEl, 'a');
        expect$1(this.field.dropdown.currentHighlighted).to.equal(null);
        simulateAction(this.inputEl, 'down');
        expect$1(this.field.dropdown.currentHighlighted).to.equal(this.choices[0]);
        simulateAction(this.inputEl, 'down');
        simulateAction(this.inputEl, 'down');
        expect$1(this.field.dropdown.currentHighlighted).to.equal(this.choices[2]);
        simulateAction(this.inputEl, 'down');
        simulateAction(this.inputEl, 'down');
        expect$1(this.field.dropdown.currentHighlighted).to.equal(this.choices[4]);
        simulateAction(this.inputEl, 'down');
        expect$1(this.field.dropdown.currentHighlighted).to.equal(this.choices[0]);
        simulateAction(this.inputEl, 'up');
        expect$1(this.field.dropdown.currentHighlighted).to.equal(this.choices[4]);
        simulateAction(this.inputEl, 'up');
        expect$1(this.field.dropdown.currentHighlighted).to.equal(this.choices[3]);
        this.field.blur();
        return expect$1(this.field.dropdown.currentHighlighted).to.equal(null);
      });
      test("filtering", function () {
        var getVisible;

        getVisible = () => {
          return this.choices.filter(function (choice) {
            return choice.visible;
          }).map(function (choice) {
            return choice.value;
          });
        };

        this.field.focus();
        expect$1(getVisible()).to.eql(['apple', 'banana', 'orange', 'banana republic', 'split']);
        simulateKeys(this.inputEl, 'ban');
        expect$1(getVisible()).to.eql(['banana', 'banana republic']);
        simulateKeys(this.inputEl, 'ana');
        expect$1(getVisible()).to.eql(['banana', 'banana republic']);
        simulateKeys(this.inputEl, ' ');
        expect$1(getVisible()).to.eql(['banana republic']);
        this.field.value = 'ora';
        return expect$1(getVisible()).to.eql(['orange', 'split']);
      });
      return test("selecting", function () {
        this.field.focus();
        expect$1(this.field.value).to.equal('');
        this.choices[1].el.emit('click');
        expect$1(this.field.value).to.equal('banana');
        expect$1(this.inputEl.value).to.equal('banana');
        this.field.focus();
        this.field.state.typing = true;
        this.field.value = 'ora';
        simulateAction(this.inputEl, 'down');
        simulateAction(this.inputEl, 'down');
        expect$1(this.field.dropdown.currentHighlighted).to.equal(this.choices[4]);
        expect$1(this.field.value).to.equal('ora');
        expect$1(this.inputEl.value).to.equal('ora');
        simulateAction(this.inputEl, 'enter');
        expect$1(this.field.value).to.equal('split');
        expect$1(this.inputEl.value).to.equal('orange split');
        this.field.value = 'orange';
        expect$1(this.field.value).to.equal('orange');
        expect$1(this.inputEl.value).to.equal('orange');
        this.field.value = 'orange split';
        expect$1(this.field.value).to.equal('split');
        return expect$1(this.inputEl.value).to.equal('orange split');
      });
    });
    suite("keyboard/custom-type", function () {
      test("password", function () {
        var field;
        return field = quickfield$1$1({
          type: 'text',
          label: 'Password',
          keyboard: 'password'
        }).appendTo(sandbox);
      });
      test("email", function () {
        var field;
        field = quickfield$1$1({
          type: 'text',
          label: 'Email',
          ID: 'email',
          keyboard: 'email',
          required: true
        }).appendTo(sandbox);
        return field = quickfield$1$1({
          type: 'text',
          label: 'Email',
          keyboard: 'email',
          mask: {
            guide: false
          },
          required: true
        }).appendTo(sandbox);
      });
      return test("number (simluated)", function () {
        var field;
        return field = quickfield$1$1({
          type: 'text',
          label: 'Number (simluated)',
          keyboard: 'number',
          validWhenRegex: /[^0]/,
          autoWidth: true
        }).appendTo(sandbox);
      });
    });
    return suite("mask", function () {
      suiteSetup(function () {
        return addTitle('mask');
      });
      test("alpha", function () {
        var field;
        field = quickfield$1$1({
          type: 'text',
          label: 'Name',
          mask: 'NAME',
          width: '50%'
        }).appendTo(sandbox);
        return field = quickfield$1$1({
          type: 'text',
          label: 'Full Name',
          mask: 'FULLNAME',
          width: '50%'
        }).appendTo(sandbox);
      });
      test("numeric", function () {
        var field;
        field = quickfield$1$1({
          type: 'text',
          label: 'Phone',
          distance: 10,
          width: '50%',
          mobileWidth: '100%',
          mask: '(111) 111-1111'
        }).appendTo(sandbox);
        return field = quickfield$1$1({
          type: 'text',
          label: 'Phone',
          distance: 10,
          width: '50%',
          mobileWidth: '100%',
          keyboard: 'phone'
        }).appendTo(sandbox);
      });
      test("alphanumeric", function () {
        var field;
        return field = quickfield$1$1({
          type: 'text',
          label: 'Licence Plate',
          mask: {
            pattern: 'aaa-111',
            transform: function (v) {
              return v.toUpperCase();
            }
          }
        }).appendTo(sandbox);
      });
      test("prefix", function () {
        var field;
        return field = quickfield$1$1({
          type: 'text',
          label: 'Dollar',
          mask: {
            pattern: 'NUMBER',
            prefix: '$',
            decimal: true,
            sep: true
          }
        }).appendTo(sandbox);
      });
      test("date", function () {
        var field;
        field = quickfield$1$1({
          type: 'text',
          label: 'Date',
          keyboard: 'date',
          autoWidth: true
        }).appendTo(sandbox);
        return field = quickfield$1$1({
          type: 'text',
          label: 'Date',
          mask: {
            pattern: ['DATE', 'mm / yy']
          },
          autoWidth: true
        }).appendTo(sandbox);
      });
      test("literal", function () {
        var field;
        return field = quickfield$1$1({
          type: 'text',
          label: 'Literal',
          mask: 'My N\\ame is a+ K\\alen'
        }).appendTo(sandbox);
      });
      test("optionals", function () {
        var field;
        return field = quickfield$1$1({
          type: 'text',
          label: 'Optionals',
          mask: 'aaa[AAA]111'
        }).appendTo(sandbox);
      });
      return test("custom patterns", function () {
        var field;
        return field = quickfield$1$1({
          type: 'text',
          label: 'Only specific chars',
          mask: {
            pattern: '&&+-aa-111-[ aa+]',
            customPatterns: {
              '&': /[ab12]/,
              'a': /[0-4]/
            }
          }
        }).appendTo(sandbox);
      });
    });
  });
  suite("number field", function () {
    suiteSetup(function () {
      return addTitle('number field');
    });
    test("basic", function () {
      var field;
      return field = quickfield$1$1({
        type: 'number',
        label: 'Number',
        autoWidth: false
      }).appendTo(sandbox);
    });
    test.skip("getter/setter", function () {
      var fieldA, fieldB, fieldC, getter, setter;

      getter = function (value) {
        return (value || 0) * 10;
      };

      setter = function (value) {
        return (value || 0) * 2;
      };

      fieldA = quickfield$1$1({
        type: 'number',
        label: 'Number',
        autoWidth: true,
        getter
      });
      fieldB = quickfield$1$1({
        type: 'number',
        label: 'Number',
        autoWidth: true,
        setter
      });
      fieldC = quickfield$1$1({
        type: 'number',
        label: 'Number',
        autoWidth: true,
        getter,
        setter
      });
      expect$1(fieldA.value).to.equal(0);
      expect$1(fieldA.el.child.input.raw.value).to.equal('');
      expect$1(fieldB.value).to.equal(0);
      expect$1(fieldB.el.child.input.raw.value).to.equal('');
      expect$1(fieldC.value).to.equal(0);
      expect$1(fieldC.el.child.input.raw.value).to.equal('');
      simulateKeys(fieldA.el.child.input.raw, '3');
      simulateKeys(fieldB.el.child.input.raw, '3');
      simulateKeys(fieldC.el.child.input.raw, '3');
      expect$1(fieldA.value).to.equal(30);
      expect$1(fieldA.el.child.input.raw.value).to.equal('3');
      expect$1(fieldB.value).to.equal(6);
      expect$1(fieldB.el.child.input.raw.value).to.equal('6');
      expect$1(fieldC.value).to.equal(60);
      expect$1(fieldC.el.child.input.raw.value).to.equal('6');
      fieldA.value = 12;
      fieldB.value = 12;
      fieldC.value = 12;
      expect$1(fieldA.value).to.equal(120);
      expect$1(fieldA.el.child.input.raw.value).to.equal('12');
      expect$1(fieldB.value).to.equal(24);
      expect$1(fieldB.el.child.input.raw.value).to.equal('24');
      expect$1(fieldC.value).to.equal(240);
      return expect$1(fieldC.el.child.input.raw.value).to.equal('24');
    });
    test("min/max", function () {
      var field;
      return field = quickfield$1$1({
        type: 'number',
        label: 'Number (min/max)',
        minValue: 10,
        maxValue: 1000,
        autoWidth: true
      }).appendTo(sandbox);
    });
    test("min/max/step", function () {
      var field;
      return field = quickfield$1$1({
        type: 'number',
        label: 'Number (min/max/step)',
        minValue: 10,
        maxValue: 100,
        step: 3,
        autoWidth: true
      }).appendTo(sandbox);
    });
    test("min/max/step (enforced)", function () {
      var field;
      return field = quickfield$1$1({
        type: 'number',
        label: 'Number (enforced)',
        minValue: 10,
        maxValue: 100,
        step: 12,
        enforce: true,
        autoWidth: true
      }).appendTo(sandbox);
    });
    return test("decimal step", function () {
      var field;
      return field = quickfield$1$1({
        type: 'number',
        label: 'Number (decimal step)',
        minValue: 0.1,
        maxValue: 100,
        step: 0.1,
        autoWidth: true
      }).appendTo(sandbox);
    });
  });
  suite("textarea field", function () {
    suiteSetup(function () {
      return addTitle('textarea field');
    });
    test("basic", function () {
      var field;
      return field = quickfield$1$1({
        type: 'textarea',
        label: 'Textarea',
        width: '300px',
        height: '250px',
        autoHeight: false
      }).appendTo(sandbox);
    });
    test("getter/setter", function () {
      var fieldA, fieldB, fieldC, getter, setter;

      getter = function (value) {
        return `example.com/${value}`;
      };

      setter = function (value) {
        return value.toLowerCase();
      };

      fieldA = quickfield$1$1({
        type: 'textarea',
        label: 'path',
        getter
      });
      fieldB = quickfield$1$1({
        type: 'textarea',
        label: 'path',
        setter
      });
      fieldC = quickfield$1$1({
        type: 'textarea',
        label: 'path',
        getter,
        setter
      });
      expect$1(fieldA.value).to.equal('example.com/');
      expect$1(fieldA.el.child.input.raw.value).to.equal('');
      expect$1(fieldB.value).to.equal('');
      expect$1(fieldB.el.child.input.raw.value).to.equal('');
      expect$1(fieldC.value).to.equal('example.com/');
      expect$1(fieldC.el.child.input.raw.value).to.equal('');
      simulateKeys(fieldA.el.child.input.raw, 'AbC');
      simulateKeys(fieldB.el.child.input.raw, 'AbC');
      simulateKeys(fieldC.el.child.input.raw, 'AbC');
      expect$1(fieldA.value).to.equal('example.com/AbC');
      expect$1(fieldA.el.child.input.raw.value).to.equal('AbC');
      expect$1(fieldB.value).to.equal('abc');
      expect$1(fieldB.el.child.input.raw.value).to.equal('abc');
      expect$1(fieldC.value).to.equal('example.com/abc');
      expect$1(fieldC.el.child.input.raw.value).to.equal('abc');
      fieldA.value = 'DeF';
      fieldB.value = 'DeF';
      fieldC.value = 'DeF';
      expect$1(fieldA.value).to.equal('example.com/DeF');
      expect$1(fieldA.el.child.input.raw.value).to.equal('DeF');
      expect$1(fieldB.value).to.equal('def');
      expect$1(fieldB.el.child.input.raw.value).to.equal('def');
      expect$1(fieldC.value).to.equal('example.com/def');
      return expect$1(fieldC.el.child.input.raw.value).to.equal('def');
    });
    test("autoheight", function () {
      var field;
      return field = quickfield$1$1({
        type: 'textarea',
        label: 'Textarea (autoHeight)',
        width: '300px',
        maxHeight: 500
      }).appendTo(sandbox);
    });
    return test("autowidth", function () {
      var field;
      return field = quickfield$1$1({
        type: 'textarea',
        label: 'Textarea (autowidth)',
        autoWidth: true,
        maxWidth: 300
      }).appendTo(sandbox);
    });
  });
  suite("select field", function () {
    suiteSetup(function () {
      return addTitle('select field');
    });
    test("single selectable", function () {
      var field;
      return field = quickfield$1$1({
        type: 'select',
        label: 'My Choices (single)',
        choices: ['Apple', 'Apple Juice', 'Banana', 'Orange', {
          label: 'Lemon',
          value: 'lime',
          conditions: {
            'email': 'valid'
          }
        }]
      }).appendTo(sandbox);
    });
    test("multi selectable", function () {
      var field;
      field = quickfield$1$1({
        type: 'select',
        label: 'My Choices (multi)',
        choices: ['Apple', 'Banana', 'Orange', 'Lime', 'Kiwi'],
        multiple: true,
        defaultValue: 'Apple'
      }).appendTo(sandbox);
      return assert$1.equal(field.value, 'Apple');
    });
    test("default value", function () {
      var field;
      field = quickfield$1$1({
        type: 'select',
        label: 'My Choices (default)',
        choices: ['Apple', 'Banana', 'Orange', {
          label: 'Lemon',
          value: 'lime',
          conditions: {
            'email': 'valid'
          }
        }],
        value: 'Banana'
      }).appendTo(sandbox);
      assert$1.equal(field.value, 'Banana');
      field = quickfield$1$1({
        type: 'select',
        label: 'My Choices (default)',
        value: 'Banana'
      }).appendTo(sandbox);
      return assert$1.equal(field.value, 'Banana');
    });
    test("cusotm border", function () {
      var field;
      return field = quickfield$1$1({
        type: 'select',
        label: 'Custom Border',
        choices: ['Apple', 'Banana', 'Orange'],
        border: '0 0 2px 0',
        margin: '0 0 30px'
      }).appendTo(sandbox);
    });
    test("no choices", function () {
      var field;
      return field = quickfield$1$1({
        type: 'select',
        label: 'No choices',
        autoWidth: true
      }).appendTo(sandbox);
    });
    return test("many choices", function () {
      var field;
      return field = quickfield$1$1({
        type: 'select',
        label: 'Many Choices',
        choices: companyNames,
        autoWidth: true
      }).appendTo(sandbox);
    });
  });
  suite("choice field", function () {
    suiteSetup(function () {
      addTitle('choice field');
      this.control = quickfield$1$1({
        type: 'choice',
        choices: ['Apple', 'Banana', 'Orange'],
        required: true
      });
      return this.controlMulti = quickfield$1$1({
        type: 'choice',
        choices: ['Apple', 'Banana', 'Orange'],
        required: true,
        multiple: true
      });
    });
    test("single selectable", function () {
      var field;
      return field = quickfield$1$1({
        type: 'choice',
        label: 'My Choices (single)',
        choices: ['Apple', 'Banana', 'Orange']
      }).appendTo(sandbox);
    });
    test("multi selectable", function () {
      var field;
      return field = quickfield$1$1({
        type: 'choice',
        label: 'My Choices (multi)',
        choices: ['Apple', 'Banana', 'Orange', 'Lime', 'Kiwi'],
        perGroup: 3,
        multiple: true
      }).appendTo(sandbox);
    });
    test("default value", function () {
      var field;
      field = quickfield$1$1({
        type: 'choice',
        label: 'My Choices (single)',
        choices: ['Apple', 'Banana', 'Orange'],
        value: 'Orange'
      }).appendTo(sandbox);
      assert$1.equal(field.value, 'Orange');
      assert$1.equal(field.findChoice('Orange').selected, true);
      field = quickfield$1$1({
        type: 'choice',
        label: 'My Choices (multi)',
        choices: ['Apple', 'Banana', 'Orange', 'Lime', 'Kiwi'],
        multiple: true,
        value: ['Banana', 'Lime']
      }).appendTo(sandbox);
      assert$1.deepEqual(field.value, ['Banana', 'Lime']);
      assert$1.equal(field.findChoice('Banana').selected, true);
      return assert$1.equal(field.findChoice('Lime').selected, true);
    });
    test("conditions", function () {
      var field, master;
      master = quickfield$1$1({
        type: 'text',
        ID: 'master',
        required: true
      }).appendTo(sandbox);
      return field = quickfield$1$1({
        type: 'choice',
        label: 'My Choices (single)',
        choices: ['Apple', {
          label: 'Banana',
          value: 'banana',
          conditions: {
            'master': /^bana/
          }
        }, 'Orange', {
          label: 'Lemon',
          value: 'lime',
          conditions: {
            'master': 'valid'
          }
        }]
      }).appendTo(sandbox);
    });
    test("getter/setter", function () {
      var fieldA, fieldB, fieldC, getter, ref, ref1, ref2, ref3, ref4, ref5, setter;

      getter = function (value) {
        return (value != null ? value.toUpperCase() : void 0) || value;
      };

      setter = function (value) {
        if ((value != null ? value.value : void 0) === 'Banana') {
          return 'Apple';
        } else {
          return value;
        }
      };

      fieldA = quickfield$1$1({
        type: 'choice',
        choices: ['Apple', 'Banana', 'Orange'],
        getter
      }).appendTo(sandbox);
      fieldB = quickfield$1$1({
        type: 'choice',
        choices: ['Apple', 'Banana', 'Orange'],
        setter
      }).appendTo(sandbox);
      fieldC = quickfield$1$1({
        type: 'choice',
        choices: ['Apple', 'Banana', 'Orange'],
        getter,
        setter
      }).appendTo(sandbox);
      expect$1(fieldA.value).to.equal(void 0);
      expect$1(fieldA.valueRaw).to.equal(null);
      expect$1(fieldB.value).to.equal(void 0);
      expect$1(fieldB.valueRaw).to.equal(null);
      expect$1(fieldC.value).to.equal(void 0);
      expect$1(fieldC.valueRaw).to.equal(null);
      fieldA.choices[1].el.emit('click');
      fieldB.choices[1].el.emit('click');
      fieldC.choices[1].el.emit('click');
      expect$1(fieldA.value).to.equal('BANANA');
      expect$1((ref = fieldA.valueRaw) != null ? ref.value : void 0).to.equal('Banana');
      expect$1(fieldB.value).to.equal('Apple');
      expect$1((ref1 = fieldB.valueRaw) != null ? ref1.value : void 0).to.equal('Apple');
      expect$1(fieldC.value).to.equal('APPLE');
      expect$1((ref2 = fieldC.valueRaw) != null ? ref2.value : void 0).to.equal('Apple');
      fieldA.value = 'Orange';
      fieldB.value = 'Orange';
      fieldC.value = 'Orange';
      expect$1(fieldA.value).to.equal('ORANGE');
      expect$1((ref3 = fieldA.valueRaw) != null ? ref3.value : void 0).to.equal('Orange');
      expect$1(fieldB.value).to.equal('Orange');
      expect$1((ref4 = fieldB.valueRaw) != null ? ref4.value : void 0).to.equal('Orange');
      expect$1(fieldC.value).to.equal('ORANGE');
      return expect$1((ref5 = fieldC.valueRaw) != null ? ref5.value : void 0).to.equal('Orange');
    });
    return test("valid when selected", function () {
      var multiple, single;
      single = quickfield$1$1({
        type: 'choice',
        choices: ['Apple', 'Banana', 'Orange'],
        required: true,
        validWhenSelected: true
      });
      multiple = quickfield$1$1({
        type: 'choice',
        choices: ['Apple', 'Banana', 'Orange'],
        required: true,
        validWhenSelected: 2,
        multiple: true
      });
      expect$1(single.validate()).to.equal(false);
      expect$1(multiple.validate()).to.equal(false);
      expect$1(this.control.validate()).to.equal(false);
      expect$1(this.controlMulti.validate()).to.equal(false);
      single.value = multiple.value = this.control.value = this.controlMulti.value = 'Banana';
      expect$1(single.validate()).to.equal(true);
      expect$1(multiple.validate()).to.equal(false);
      expect$1(this.control.validate()).to.equal(true);
      expect$1(this.controlMulti.validate()).to.equal(true);
      multiple.value = ['Apple', 'Banana'];
      return expect$1(multiple.validate()).to.equal(true);
    });
  });
  suite("truefalse field", function () {
    suiteSetup(function () {
      return addTitle('truefalse field');
    });
    test("basic", function () {
      var field;
      field = quickfield$1$1({
        type: 'truefalse',
        label: 'Is it true or false?',
        width: 'auto'
      }).appendTo(sandbox).el.style('marginRight', 20);
      return assert$1.equal(field.value, null);
    });
    return test("default value", function () {
      var field;
      field = quickfield$1$1({
        type: 'truefalse',
        label: 'It\'s false by default',
        width: 'auto',
        choiceLabels: ['Yes', 'No'],
        value: false
      }).appendTo(sandbox);
      field.el.style('marginRight', 20);
      assert$1.equal(field.value, false);
      field = quickfield$1$1({
        type: 'truefalse',
        label: 'It\'s true by default',
        width: 'auto',
        choiceLabels: ['Yes', 'No'],
        value: true
      }).appendTo(sandbox);
      field.el.style('marginRight', 20);
      return assert$1.equal(field.value, true);
    });
  });
  suite("toggle field", function () {
    suiteSetup(function () {
      return addTitle('toggle field');
    });
    test("basic", function () {
      var field;
      return field = quickfield$1$1({
        type: 'toggle',
        label: 'The toggle field',
        width: 'auto'
      }).appendTo(sandbox).el.style('marginRight', 20);
    });
    test("default value", function () {
      var field;
      return field = quickfield$1$1({
        type: 'toggle',
        label: 'Toggled by default',
        width: '130px',
        defaultValue: 1
      }).appendTo(sandbox).el.style('marginRight', 20);
    });
    test("custom size", function () {
      var field;
      return field = quickfield$1$1({
        type: 'toggle',
        label: 'Custom size toggle',
        width: 'auto',
        size: 40
      }).appendTo(sandbox).el.style('marginRight', 20);
    });
    test("aligned style", function () {
      var field;
      return field = quickfield$1$1({
        type: 'toggle',
        label: 'Aligned style',
        style: 'aligned',
        width: 'auto'
      }).appendTo(sandbox);
    });
    return test("aligned style + defined width", function () {
      var field;
      field = quickfield$1$1({
        type: 'toggle',
        label: 'Aligned style with defined width',
        style: 'aligned',
        width: '400px'
      }).appendTo(sandbox);
      return field = quickfield$1$1({
        type: 'toggle',
        label: 'Aligned style with defined width',
        style: 'aligned',
        width: '200px'
      }).appendTo(sandbox);
    });
  });
  suite("group field", function () {
    setup(addDivider);
    suiteSetup(function () {
      addTitle('group field');
      this.fields = {
        first: {
          type: 'text',
          label: 'First',
          width: '49%'
        },
        second: {
          type: 'text',
          label: 'Second',
          width: '49%'
        },
        third: {
          type: 'select',
          label: 'Third',
          width: '74%',
          choices: ['Apple', 'Banana', 'Kiwi'],
          value: 'Kiwi'
        },
        fourth: {
          type: 'toggle',
          label: 'Fourth',
          style: 'aligned',
          width: '24%',
          conditions: {
            third: 'Kiwi'
          }
        }
      };
      return this.control = quickfield$1$1({
        type: 'group',
        label: 'Basic Group',
        width: '70%',
        fieldMargin: 10,
        fieldAlign: 'middle',
        fields: this.fields
      }).appendTo(sandbox);
    });
    test("basic", function () {
      expect$1(this.control.value).to.eql({
        first: '',
        second: '',
        third: 'Kiwi',
        fourth: false
      });
      expect$1(this.control.state.interacted).to.equal(false);
      this.control.value = {
        first: 'valueA',
        third: 'Kawa',
        fourth: true,
        fifth: '5'
      };
      expect$1(this.control.value).to.eql({
        first: 'valueA',
        second: '',
        third: 'Kawa',
        fourth: true
      });
      expect$1(this.control.state.interacted).to.equal(true);
      this.control.value = {
        second: 'valueB',
        third: 'Apple'
      };
      expect$1(this.control.value).to.eql({
        first: 'valueA',
        second: 'valueB',
        third: 'Apple',
        fourth: true
      });
      this.control.value = null;
      return expect$1(this.control.value).to.eql({
        first: 'valueA',
        second: 'valueB',
        third: 'Apple',
        fourth: true
      });
    });
    test("collapsed by default", function () {
      var field;
      field = quickfield$1$1({
        type: 'group',
        width: '70%',
        fieldMargin: 10,
        startCollapsed: true,
        fields: this.fields
      }).appendTo(sandbox);
      expect$1(this.control.els.innerwrap.raw).to.be.displayed;
      expect$1(field.els.innerwrap.raw).not.to.be.displayed;
      this.control.state.collapsed = true;
      field.state.collapsed = false;
      expect$1(this.control.els.innerwrap.raw).not.to.be.displayed;
      expect$1(field.els.innerwrap.raw).to.be.displayed;
      this.control.els.collapse.emit('click');
      field.els.collapse.emit('click');
      expect$1(this.control.els.innerwrap.raw).to.be.displayed;
      return expect$1(field.els.innerwrap.raw).not.to.be.displayed;
    });
    return test("default value", function () {
      var field;
      field = quickfield$1$1({
        type: 'group',
        width: '70%',
        fieldMargin: 10,
        fields: this.fields,
        value: {
          first: 'firstValue',
          third: 'Banana'
        }
      });
      return expect$1(field.value).to.eql({
        first: 'firstValue',
        second: '',
        third: 'Banana',
        fourth: false
      });
    });
  }); // test "inline mode", ()->
  // 	field = quickfield({type:'group', width:'70%', fieldMargin:10, @fields, value:{first:'firstValue', third:'Banana'}})
  // 	expect(field.value).to.eql {first:'firstValue', second:'', third:'Banana', fourth:false}

  suite("repeater field", function () {
    setup(addDivider);
    suiteSetup(function () {
      addDivider(40);
      this.fields = {
        first: {
          type: 'text',
          name: 'first',
          label: 'First',
          width: '49%'
        },
        second: {
          type: 'text',
          name: 'second',
          label: 'Second',
          width: '49%'
        }
      };
      return this.control = quickfield$1$1({
        type: 'repeater',
        label: 'Basic Repeater',
        width: '70%',
        fieldMargin: 10,
        numbering: true,
        cloneable: true,
        fields: this.fields
      }).appendTo(sandbox);
    });
    test("block", function () {
      expect$1(this.control.value).to.eql([]);
      expect$1(this.control.state.interacted).to.equal(false);
      this.control.els.addButton.emit('click');
      expect$1(this.control.value).to.eql([{
        first: '',
        second: ''
      }]);
      expect$1(this.control.state.interacted).to.equal(true);
      this.control.value = {
        first: 'abc',
        second: 'def'
      };
      expect$1(this.control.value).to.eql([{
        first: '',
        second: ''
      }, {
        first: 'abc',
        second: 'def'
      }]);
      expect$1(this.control._value[0].els.label.text).to.equal('Item 1');
      expect$1(this.control._value[1].els.label.text).to.equal('Item 2');

      this.control._value[0].els.remove.emit('click');

      expect$1(this.control.value).to.eql([{
        first: 'abc',
        second: 'def'
      }]);
      expect$1(this.control._value[0].els.label.text).to.equal('Item 1');
      this.control.value = [{
        first: 'ABC'
      }, {
        second: 'DEF'
      }];
      return expect$1(this.control.value).to.eql([{
        first: 'ABC',
        second: 'def'
      }, {
        first: '',
        second: 'DEF'
      }]);
    });
    test("inline", function () {
      var field;
      field = quickfield$1$1({
        type: 'repeater',
        label: 'Inline Repeater',
        width: '70%',
        fieldMargin: 10,
        numbering: true,
        autoRemoveEmpty: true,
        style: 'inline',
        value: [{
          first: 'abc',
          second: '123'
        }, {
          second: '456'
        }],
        fields: {
          first: primaryBuilder$1({
            autoWidth: true
          }, this.fields.first),
          second: primaryBuilder$1({
            autoWidth: true
          }, this.fields.second)
        }
      }).appendTo(sandbox);
      return expect$1(field.value).to.eql([{
        first: 'abc',
        second: '123'
      }, {
        first: '',
        second: '456'
      }]);
    });
    test("inline singleMode", function () {
      var field;
      field = quickfield$1$1({
        type: 'repeater',
        label: 'Inline Repeater',
        width: '70%',
        fieldMargin: 10,
        autoWidth: false,
        autoRemoveEmpty: true,
        numbering: true,
        style: 'inline',
        singleMode: true,
        groupSettings: {
          inline: {
            width: '100%'
          }
        },
        fields: primaryBuilder$1.clone(this.fields.first, {
          width: '100%'
        })
      }).appendTo(sandbox);
      expect$1(field.value).to.eql([]);
      field.value = ['abc', '123'];
      expect$1(field.value).to.eql(['abc', '123']);
      field.value = 'def';
      return expect$1(field.value).to.eql(['abc', '123', 'def']);
    });
    return test("dynamicLabel", function () {
      var field;
      field = quickfield$1$1({
        type: 'repeater',
        label: 'Inline Repeater',
        width: '70%',
        dynamicLabel: 'first',
        fieldMargin: 10,
        autoRemoveEmpty: true,
        value: [{
          first: 'abc',
          second: '123'
        }, {
          second: '456'
        }],
        fields: {
          first: primaryBuilder$1({
            autoWidth: true
          }, this.fields.first),
          second: primaryBuilder$1({
            autoWidth: true
          }, this.fields.second)
        }
      }).appendTo(sandbox);
      expect$1(field._value[0].el.child.label.text).to.equal('abc');
      expect$1(field._value[1].el.child.label.text).to.equal('');
      field.value = [{
        first: 'def'
      }, {
        first: '123'
      }];
      expect$1(field._value[0].el.child.label.text).to.equal('def');
      return expect$1(field._value[1].el.child.label.text).to.equal('123');
    });
  }); // expect(field.value).to.eql [
  // 	{first:'abc', second:'123'}
  // 	{first:'', second:'456'}
  // ]

  return suite(".config()", function () {
    return test("creates a new copy of QuickField with setting overrides and template overrides", function () {
      var choice, quickfield2, textA, textB, textC, textD;
      quickfield2 = quickfield$1$1.config({
        global: {
          fontFamily: 'helvetica',
          width: '50%',
          required: true,
          border: '0 0 2px 0',
          margin: '0 10px 10px 0',
          fontSize: 13,
          inputPadding: 8
        },
        text: {
          height: 40,
          autoWidth: true,
          inputPadding: 0,
          checkmark: false,
          minLength: 2,
          mask: {
            placeholder: '*',
            decimal: true
          }
        }
      }, {
        global: {
          field: {
            options: {
              style: {
                verticalAlign: 'middle'
              }
            },
            children: {
              label: {
                options: {
                  style: {
                    $focus: {
                      color: COLORS.green
                    }
                  }
                }
              },
              innerwrap: {
                options: {
                  style: {
                    $focus: {
                      borderColor: COLORS.green
                    }
                  }
                }
              }
            }
          }
        },
        text: {
          default: {
            children: {
              label: {
                options: {
                  style: {
                    fontWeight: 700
                  }
                }
              }
            }
          }
        },
        choice: {
          choice: {
            options: {
              style: {
                $selected: {
                  color: COLORS.green
                }
              }
            }
          }
        }
      });
      expect$1(quickfield2).not.to.equal(quickfield$1$1);
      textA = quickfield$1$1({
        type: 'text',
        label: 'textA'
      }).appendTo(sandbox);
      textB = quickfield2({
        type: 'text',
        label: 'textB',
        autoWidth: false
      }).appendTo(sandbox);
      addDivider();
      textC = quickfield2({
        type: 'text',
        label: 'textC',
        mask: {
          pattern: 'NUMBER',
          suffix: '%'
        }
      }).appendTo(sandbox);
      textD = quickfield2({
        type: 'text',
        label: 'textD',
        mask: {
          pattern: 'DATE',
          suffix: '%'
        }
      }).appendTo(sandbox);
      choice = quickfield2({
        type: 'choice',
        choices: ['Apple', 'Banana', 'Orange']
      }).appendTo(sandbox);
      expect$1(textA.el.style('fontFamily')).to.equal(quickfield$1$1.Field.prototype.globalDefaults.fontFamily);
      expect$1(textB.el.style('fontFamily')).to.equal('helvetica');
      expect$1(textA.el.style('verticalAlign')).to.equal('top');
      expect$1(textB.el.style('verticalAlign')).to.equal('middle');
      expect$1(textA.el.styleParsed('marginBottom')).to.equal(0);
      expect$1(textB.el.styleParsed('marginBottom')).to.equal(10);
      expect$1(textA.el.styleSafe('width', true)).to.equal('100%');
      expect$1(textB.el.styleSafe('width', true)).to.equal('50%');
      expect$1(textA.el.child.label.styleParsed('fontWeight', true)).to.equal(600);
      expect$1(textB.el.child.label.styleParsed('fontWeight', true)).to.equal(700);
      expect$1(textA.el.height).to.equal(quickfield$1$1.Field.text.prototype.defaults.height);
      expect$1(textB.el.height).to.equal(40);
      expect$1(textA.el.child.checkmark).to.be.object();
      expect$1(textB.el.child.checkmark).not.to.be.object();
      expect$1(getBorderSides(textA.els.innerwrap)).to.eql({
        top: '1px',
        left: '1px',
        right: '1px',
        bottom: '1px'
      });
      expect$1(getBorderSides(textB.els.innerwrap)).to.eql({
        top: '0px',
        left: '0px',
        right: '0px',
        bottom: '2px'
      });
      expect$1(textA.validate()).to.equal(true);
      expect$1(textB.validate()).to.equal(false);
      simulateKeys(textA.el.child.input.raw, 'abc');
      simulateKeys(textB.el.child.input.raw, 'abc');
      expect$1(textA.validate()).to.equal(true);
      expect$1(textB.validate()).to.equal(true);
      simulateKeys(textD.el.child.input.raw, '1');
      expect$1(textD.value).to.equal('1*/**/****');
      quickdom.batch([textA.els.label, textB.els.label, textA.els.innerwrap, textB.els.innerwrap]).style('transition', null);
      textA.state.focused = textB.state.focused = true;
      expect$1(textA.el.child.label.raw).to.have.style('color', COLORS.orange);
      expect$1(textB.el.child.label.raw).to.have.style('color', COLORS.green);
      expect$1(textA.el.child.innerwrap.raw).to.have.style('borderColor', COLORS.orange);
      expect$1(textB.el.child.innerwrap.raw).to.have.style('borderColor', COLORS.green);
      textA.blur();
      textB.blur();
      choice.value = 'Banana';
      expect$1(choice.valueRaw.label).to.equal('Banana');
      return expect$1(choice.valueRaw.el.raw).to.have.style('color', COLORS.green);
    });
  });
});}));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5qcyIsInNvdXJjZXMiOlsiaGVscGVycy9jb21wYW55TmFtZXMuY29mZmVlIiwiLi4vbm9kZV9tb2R1bGVzL2tleXNpbS9kaXN0L2tleXNpbS5tanMiLCJoZWxwZXJzL3NpbXVsYXRlS2V5cy5jb2ZmZWUiLCJoZWxwZXJzL3NpbXVsYXRlQWN0aW9uLmNvZmZlZSIsIi4uL25vZGVfbW9kdWxlcy9xdWlja2Nzcy9kaXN0L3F1aWNrY3NzLmVzbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9zbWFydC1leHRlbmQvZGlzdC9zbWFydC1leHRlbmQuZXNtLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BkYW5pZWxrYWxlbi9pcy9kaXN0L2lzLmVzbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9xdWlja2RvbS9kaXN0L3F1aWNrZG9tLmVzbS5qcyIsImhlbHBlcnMvcmVzdGFydFNhbmRib3guY29mZmVlIiwiaGVscGVycy9hZGRUaXRsZS5jb2ZmZWUiLCJoZWxwZXJzL2FkZERpdmlkZXIuY29mZmVlIiwiaGVscGVycy9nZXRCb3JkZXJTaWRlcy5jb2ZmZWUiLCIuLi9ub2RlX21vZHVsZXMvcC1maW5hbGx5L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3AtdGltZW91dC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wLWV2ZW50L2luZGV4LmpzIiwiLi4vc3JjL2NvbnN0YW50cy9jb2xvcnMuY29mZmVlIiwiLi4vbm9kZV9tb2R1bGVzL2Fzc2VydGlvbi1lcnJvci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wYXRodmFsL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZmxhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL3Rlc3QuanMiLCIuLi9ub2RlX21vZHVsZXMvdHlwZS1kZXRlY3QvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9leHBlY3RUeXBlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldEFjdHVhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9nZXQtZnVuYy1uYW1lL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0UHJvcGVydGllcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldEVudW1lcmFibGVQcm9wZXJ0aWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29uZmlnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvaW5zcGVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL29iakRpc3BsYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRNZXNzYWdlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvdHJhbnNmZXJGbGFncy5qcyIsIi4uL25vZGVfbW9kdWxlcy9kZWVwLWVxbC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2lzUHJveHlFbmFibGVkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkUHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9hZGRMZW5ndGhHdWFyZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL3Byb3hpZnkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9hZGRNZXRob2QuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9vdmVyd3JpdGVQcm9wZXJ0eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZU1ldGhvZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2FkZENoYWluYWJsZU1ldGhvZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2NvbXBhcmVCeUluc3BlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hlY2stZXJyb3IvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9pc05hTi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvYXNzZXJ0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29yZS9hc3NlcnRpb25zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvaW50ZXJmYWNlL2V4cGVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9zaG91bGQuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS9pbnRlcmZhY2UvYXNzZXJ0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpLWRvbS9jaGFpLWRvbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpLXN0eWxlL3NvdXJjZXMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS1hbG1vc3Qvbm9kZV9tb2R1bGVzL2RlZXAtZXFsL25vZGVfbW9kdWxlcy90eXBlLWRldGVjdC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpLWFsbW9zdC9ub2RlX21vZHVsZXMvZGVlcC1lcWwvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS1hbG1vc3QvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hlY2stdHlwZXMvc3JjL2NoZWNrLXR5cGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWktYXNzZXJ0dHlwZS9hc3NlcnR0eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWktZXZlbnRzL2NoYWktZXZlbnRzLmpzIiwiLi4vYnVpbGQvYW5pbWF0aW9ucy5qcyIsIi4uL2J1aWxkL2NoZWNrcy5qcyIsIi4uL2J1aWxkL2NvbnNvbGVQYXRjaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AZGFuaWVsa2FsZW4vc2ltcGx5YmluZC9kaXN0L3NpbXBseWJpbmQuanMiLCIuLi9idWlsZC9jb25zdGFudHMvcmVnZXguanMiLCIuLi9idWlsZC9oZWxwZXJzLmpzIiwiLi4vYnVpbGQvY29uc3RhbnRzL3JlcUZpZWxkTWV0aG9kcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9mYXN0ZG9tL2Zhc3Rkb20uanMiLCIuLi9idWlsZC9jb21wb25lbnRzL2NvbmRpdGlvbi5qcyIsIi4uL2J1aWxkL2ZpZWxkL3RyYW5zZm9ybVNldHRpbmdzLmpzIiwiLi4vYnVpbGQvZmllbGQvZ2xvYmFsRGVmYXVsdHMuanMiLCIuLi9idWlsZC9maWVsZC9pbmRleC5qcyIsIi4uL2J1aWxkL2NvbnN0YW50cy9rZXlDb2Rlcy5qcyIsIi4uL2J1aWxkL3N2Zy9jaGVja21hcmsuanMiLCIuLi9idWlsZC9zdmcvYW5nbGVEb3duLmpzIiwiLi4vYnVpbGQvc3ZnL2NhcmV0VXAuanMiLCIuLi9idWlsZC9zdmcvY2FyZXREb3duLmpzIiwiLi4vYnVpbGQvc3ZnL3BsdXMuanMiLCIuLi9idWlsZC9zdmcvY2xvbmUuanMiLCIuLi9idWlsZC9zdmcvcmVtb3ZlLmpzIiwiLi4vYnVpbGQvY29tcG9uZW50cy9kcm9wZG93bi90ZW1wbGF0ZS1iOTYxZjgxZi5qcyIsIi4uL2J1aWxkL2NvbXBvbmVudHMvZHJvcGRvd24vZGVmYXVsdHMuanMiLCIuLi9idWlsZC9jb21wb25lbnRzL2Ryb3Bkb3duL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3RleHQtbWFzay1jb3JlL2Rpc3QvdGV4dE1hc2tDb3JlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3RleHQtbWFzay1hZGRvbnMvZGlzdC90ZXh0TWFza0FkZG9ucy5qcyIsIi4uL2J1aWxkL2NvbXBvbmVudHMvbWFzay5qcyIsIi4uL2J1aWxkL2NvbnN0YW50cy9jb2xvcnMuanMiLCIuLi9idWlsZC9maWVsZHMvdGV4dC90ZW1wbGF0ZS0yMzNlOTQxMy5qcyIsIi4uL2J1aWxkL2ZpZWxkcy90ZXh0L2RlZmF1bHRzLmpzIiwiLi4vYnVpbGQvZmllbGRzL3RleHQvaW5kZXguanMiLCIuLi9idWlsZC9xdWlja2ZpZWxkLmpzIiwiLi4vYnVpbGQvZmllbGRzL3RleHRhcmVhL2RlZmF1bHRzLmpzIiwiLi4vYnVpbGQvZmllbGRzL3RleHRhcmVhL3RlbXBsYXRlLTY1ZmVkYTA1LmpzIiwiLi4vYnVpbGQvZmllbGRzL3RleHRhcmVhL2luZGV4LmpzIiwiLi4vYnVpbGQvZmllbGRzL251bWJlci9kZWZhdWx0cy5qcyIsIi4uL2J1aWxkL2ZpZWxkcy9udW1iZXIvdGVtcGxhdGUtYzkyMmUxNjMuanMiLCIuLi9idWlsZC9maWVsZHMvbnVtYmVyL2luZGV4LmpzIiwiLi4vYnVpbGQvZmllbGRzL3NlbGVjdC9kZWZhdWx0cy5qcyIsIi4uL2J1aWxkL2ZpZWxkcy9zZWxlY3QvdGVtcGxhdGUtNmJiY2RkZDAuanMiLCIuLi9idWlsZC9maWVsZHMvc2VsZWN0L2luZGV4LmpzIiwiLi4vYnVpbGQvZmllbGRzL2Nob2ljZS9kZWZhdWx0cy5qcyIsIi4uL2J1aWxkL2ZpZWxkcy9jaG9pY2UvdGVtcGxhdGUtYzg4ZmE5NWIuanMiLCIuLi9idWlsZC9maWVsZHMvY2hvaWNlL2luZGV4LmpzIiwiLi4vYnVpbGQvZmllbGRzL3RydWVmYWxzZS90ZW1wbGF0ZS0zZDZjNTRhMC5qcyIsIi4uL2J1aWxkL2ZpZWxkcy90cnVlZmFsc2UvZGVmYXVsdHMuanMiLCIuLi9idWlsZC9maWVsZHMvdHJ1ZWZhbHNlL2luZGV4LmpzIiwiLi4vYnVpbGQvZmllbGRzL3RvZ2dsZS9kZWZhdWx0cy5qcyIsIi4uL2J1aWxkL2ZpZWxkcy90b2dnbGUvdGVtcGxhdGUtYmY3Yjk5YzEuanMiLCIuLi9idWlsZC9maWVsZHMvdG9nZ2xlL2luZGV4LmpzIiwiLi4vYnVpbGQvZmllbGRzL2dyb3VwL2RlZmF1bHRzLmpzIiwiLi4vYnVpbGQvZmllbGRzL2dyb3VwL3RlbXBsYXRlLTA4NmE4MmUyLmpzIiwiLi4vYnVpbGQvZmllbGRzL2dyb3VwL2luZGV4LmpzIiwiLi4vYnVpbGQvZmllbGRzL3JlcGVhdGVyL3RlbXBsYXRlLTdjMjg0ZTYxLmpzIiwiLi4vYnVpbGQvZmllbGRzL3JlcGVhdGVyL2RlZmF1bHRzLmpzIiwiLi4vYnVpbGQvZmllbGRzL3JlcGVhdGVyL2luZGV4LmpzIiwidGVzdC5jb2ZmZWUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgW1xuICBcIktpZWhuIEluY1wiXG4gIFwiTWFya3MgYW5kIFNvbnNcIlxuICBcIldhZWxjaGkgU2NoaWxsZXIgYW5kIERlbmVzaWtcIlxuICBcIk9sc29uIFplbWxhayBhbmQgTWFnZ2lvXCJcbiAgXCJKYWNvYnMgLSBWb25cIlxuICBcIkF1ZXIgTG93ZSBhbmQgR3V0bWFublwiXG4gIFwiRmVlbmV5IFJlbXBlbCBhbmQgQ2Fzc2luXCJcbiAgXCJTYXdheW4gLSBNYXJrc1wiXG4gIFwiSm9obnMgYW5kIFNvbnNcIlxuICBcIlJvZHJpZ3VleiBDaGFtcGxpbiBhbmQgRGFyZVwiXG4gIFwiTG93ZSAtIFJpdGNoaWVcIlxuICBcIkdsZWljaG5lciBHb2xkbmVyIGFuZCBCZWNrZXJcIlxuICBcIkplcmRlIC0gT3NpbnNraVwiXG4gIFwiQmF1bWJhY2ggR3JvdXBcIlxuICBcIlNjaHJvZWRlciBadWxhdWYgYW5kIFJlbXBlbFwiXG4gIFwiTydSZWlsbHkgTWlsbHMgYW5kIERlbmVzaWtcIlxuICBcIktvaGxlciAtIFZldW1cIlxuICBcIk8nSGFyYSBJbmNcIlxuICBcIk9iZXJicnVubmVyIGFuZCBTb25zXCJcbiAgXCJFbW1lcmljaCBHcm91cFwiXG4gIFwiTXVycmF5IFppZW1lIGFuZCBGcmFuZWNraVwiXG4gIFwiTW9lbiAtIEx1ZXR0Z2VuXCJcbiAgXCJHb3JjemFueSBIYXJ2ZXkgYW5kIEd1bGdvd3NraVwiXG4gIFwiUmVpbGx5IC0gUnVlY2tlclwiXG4gIFwiTWNEZXJtb3R0IC0gSHlhdHRcIlxuICBcIlNwaW5rYSAtIE1hcmtzXCJcbiAgXCJIYXllcyBhbmQgU29uc1wiXG4gIFwiS2lsYmFjayBLaWVobiBhbmQgTW9uYWhhblwiXG4gIFwiRGF2aXMgYW5kIFNvbnNcIlxuICBcIkh1ZHNvbiAtIFl1bmR0XCJcbiAgXCJHb29kd2luIC0gWmVtbGFrXCJcbiAgXCJCZWVyIEt1aGxtYW4gYW5kIFdhbGtlclwiXG4gIFwiSm9uZXMgQ2Fycm9sbCBhbmQgQW5kZXJzb25cIlxuICBcIlJ1dGhlcmZvcmQgSW5jXCJcbiAgXCJQcmVkb3ZpYyBXaGl0ZSBhbmQgQ29sbGluc1wiXG4gIFwiU3BvcmVyIEJhdW1iYWNoIGFuZCBDcmlzdFwiXG4gIFwiR3JpbWVzIGFuZCBTb25zXCJcbiAgXCJLdW5kZSBhbmQgU29uc1wiXG4gIFwiVGlsbG1hbiAtIEJvZGVcIlxuICBcIkNyb25pbiAtIEtvZXBwXCJcbiAgXCJTbWl0aGFtIFppZW1lIGFuZCBEYW5pZWxcIlxuICBcIkt1bnplIFdlbGNoIGFuZCBSdXNzZWxcIlxuICBcIkpvaG5zIExhYmFkaWUgYW5kIEhhcmJlclwiXG4gIFwiTGVzY2ggLSBXYXRlcnNcIlxuICBcIkJyYWt1cyAtIFNtaXRoYW1cIlxuICBcIkJpbnMgYW5kIFNvbnNcIlxuICBcIk5pdHpzY2hlIEluY1wiXG4gIFwiV3Vuc2NoIEluY1wiXG4gIFwiU2Nob3dhbHRlciBGcmFuZWNraSBhbmQgS3VwaGFsXCJcbiAgXCJSZXlub2xkcyAtIFN3YW5pYXdza2lcIlxuXSIsInZhciBpc0VkaXRhYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQub3duZXJEb2N1bWVudC5kZXNpZ25Nb2RlICYmIGVsZW1lbnQub3duZXJEb2N1bWVudC5kZXNpZ25Nb2RlLnRvTG93ZXJDYXNlKCkgPT09ICdvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN3aXRjaCAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICByZXR1cm4gaXNFZGl0YWJsZUlucHV0KGVsZW1lbnQpO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGlzQ29udGVudEVkaXRhYmxlKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBpc0NvbnRlbnRFZGl0YWJsZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSAmJiBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZWxlbWVudC5jb250ZW50RWRpdGFibGUgJiYgZWxlbWVudC5jb250ZW50RWRpdGFibGUudG9Mb3dlckNhc2UoKSA9PT0gJ2luaGVyaXQnICYmIGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgIHJldHVybiBpc0NvbnRlbnRFZGl0YWJsZShlbGVtZW50LnBhcmVudE5vZGUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFZGl0YWJsZUlucHV0KGlucHV0KSB7XG4gIHN3aXRjaCAoaW5wdXQudHlwZSkge1xuICAgIGNhc2UgJ3RleHQnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnZW1haWwnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAncGFzc3dvcmQnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnc2VhcmNoJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ3RlbCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICd1cmwnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG52YXIgQ1RSTCA9IDEgPDwgMDtcbnZhciBNRVRBID0gMSA8PCAxO1xudmFyIEFMVCA9IDEgPDwgMjtcbnZhciBTSElGVCA9IDEgPDwgMztcblxuLy8gS2V5IEV2ZW50c1xudmFyIEtleUV2ZW50cyA9IHtcbiAgRE9XTjogMSA8PCAwLFxuICBQUkVTUzogMSA8PCAxLFxuICBVUDogMSA8PCAyLFxuICBJTlBVVDogMSA8PCAzXG59O1xuS2V5RXZlbnRzLkFMTCA9IEtleUV2ZW50cy5ET1dOIHwgS2V5RXZlbnRzLlBSRVNTIHwgS2V5RXZlbnRzLlVQIHwgS2V5RXZlbnRzLklOUFVUO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBrZXlzdHJva2UsIG9yIGEgc2luZ2xlIGtleSBjb2RlIHdpdGggYSBzZXQgb2YgYWN0aXZlIG1vZGlmaWVycy5cbiAqXG4gKiBAY2xhc3MgS2V5c3Ryb2tlXG4gKi9cbnZhciBLZXlzdHJva2UgPVxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbW9kaWZpZXJzIEEgYml0bWFzayBmb3JtZWQgYnkgQ1RSTCwgTUVUQSwgQUxULCBhbmQgU0hJRlQuXG4gKiBAcGFyYW0ge251bWJlcn0ga2V5Q29kZVxuICovXG5mdW5jdGlvbiBLZXlzdHJva2UobW9kaWZpZXJzLCBrZXlDb2RlKSB7XG4gIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEtleXN0cm9rZSk7XG5cbiAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gIHRoaXMuY3RybEtleSA9ICEhKG1vZGlmaWVycyAmIENUUkwpO1xuICB0aGlzLm1ldGFLZXkgPSAhIShtb2RpZmllcnMgJiBNRVRBKTtcbiAgdGhpcy5hbHRLZXkgPSAhIShtb2RpZmllcnMgJiBBTFQpO1xuICB0aGlzLnNoaWZ0S2V5ID0gISEobW9kaWZpZXJzICYgU0hJRlQpO1xuICB0aGlzLmtleUNvZGUgPSBrZXlDb2RlO1xufTtcblxuLyoqXG4gKiBTaW11bGF0ZXMgYSBrZXlib2FyZCB3aXRoIGEgcGFydGljdWxhciBrZXktdG8tY2hhcmFjdGVyIGFuZCBrZXktdG8tYWN0aW9uXG4gKiBtYXBwaW5nLiBVc2UgYFVTX0VOR0xJU0hgIHRvIGdldCBhIHByZS1jb25maWd1cmVkIGtleWJvYXJkLlxuICovXG5LZXlzdHJva2UuQ1RSTCA9IENUUkw7XG5LZXlzdHJva2UuTUVUQSA9IE1FVEE7XG5LZXlzdHJva2UuQUxUID0gQUxUO1xuS2V5c3Ryb2tlLlNISUZUID0gU0hJRlQ7XG52YXIgS2V5Ym9hcmQgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdC48bnVtYmVyLCBLZXlzdHJva2U+fSBjaGFyQ29kZUtleUNvZGVNYXBcbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gYWN0aW9uS2V5Q29kZU1hcFxuICAgKi9cbiAgZnVuY3Rpb24gS2V5Ym9hcmQoY2hhckNvZGVLZXlDb2RlTWFwLCBhY3Rpb25LZXlDb2RlTWFwKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgS2V5Ym9hcmQpO1xuXG4gICAgdGhpcy5fY2hhckNvZGVLZXlDb2RlTWFwID0gY2hhckNvZGVLZXlDb2RlTWFwO1xuICAgIHRoaXMuX2FjdGlvbktleUNvZGVNYXAgPSBhY3Rpb25LZXlDb2RlTWFwO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIGNoYXJhY3RlciBjb2RlIGdlbmVyYXRlZCBieSBwcmVzc2luZyB0aGUgZ2l2ZW4ga2V5c3Ryb2tlLlxuICAgKlxuICAgKiBAcGFyYW0ge0tleXN0cm9rZX0ga2V5c3Ryb2tlXG4gICAqIEByZXR1cm4gez9udW1iZXJ9XG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoS2V5Ym9hcmQsIFt7XG4gICAga2V5OiAnY2hhckNvZGVGb3JLZXlzdHJva2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFyQ29kZUZvcktleXN0cm9rZShrZXlzdHJva2UpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9jaGFyQ29kZUtleUNvZGVNYXA7XG4gICAgICBmb3IgKHZhciBjaGFyQ29kZSBpbiBtYXApIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGNoYXJDb2RlKSkge1xuICAgICAgICAgIHZhciBrZXlzdHJva2VGb3JDaGFyQ29kZSA9IG1hcFtjaGFyQ29kZV07XG4gICAgICAgICAgaWYgKGtleXN0cm9rZS5rZXlDb2RlID09PSBrZXlzdHJva2VGb3JDaGFyQ29kZS5rZXlDb2RlICYmIGtleXN0cm9rZS5tb2RpZmllcnMgPT09IGtleXN0cm9rZUZvckNoYXJDb2RlLm1vZGlmaWVycykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGNoYXJDb2RlLCAxMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGV2ZW50IHJlYWR5IGZvciBkaXNwYXRjaGluZyBvbnRvIHRoZSBnaXZlbiB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBPbmUgb2YgXCJrZXlkb3duXCIsIFwia2V5cHJlc3NcIiwgXCJrZXl1cFwiLCBcInRleHRJbnB1dFwiIG9yIFwiaW5wdXRcIi5cbiAgICAgKiBAcGFyYW0ge0tleXN0cm9rZX0ga2V5c3Ryb2tlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XG4gICAgICogQHJldHVybiB7RXZlbnR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZUV2ZW50RnJvbUtleXN0cm9rZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50RnJvbUtleXN0cm9rZSh0eXBlLCBrZXlzdHJva2UsIHRhcmdldCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICB2YXIgd2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICB2YXIgRXZlbnQgPSB3aW5kb3cuRXZlbnQ7XG5cbiAgICAgIHZhciBldmVudCA9IHZvaWQgMDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZXZlbnQgPSBuZXcgRXZlbnQodHlwZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ1VJRXZlbnRzJyk7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3RleHRJbnB1dCc6XG4gICAgICAgICAgZXZlbnQuZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5jaGFyQ29kZUZvcktleXN0cm9rZShrZXlzdHJva2UpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdrZXlkb3duJzpjYXNlICdrZXlwcmVzcyc6Y2FzZSAna2V5dXAnOlxuICAgICAgICAgIGV2ZW50LnNoaWZ0S2V5ID0ga2V5c3Ryb2tlLnNoaWZ0S2V5O1xuICAgICAgICAgIGV2ZW50LmFsdEtleSA9IGtleXN0cm9rZS5hbHRLZXk7XG4gICAgICAgICAgZXZlbnQubWV0YUtleSA9IGtleXN0cm9rZS5tZXRhS2V5O1xuICAgICAgICAgIGV2ZW50LmN0cmxLZXkgPSBrZXlzdHJva2UuY3RybEtleTtcbiAgICAgICAgICBldmVudC5rZXlDb2RlID0gdHlwZSA9PT0gJ2tleXByZXNzJyA/IHRoaXMuY2hhckNvZGVGb3JLZXlzdHJva2Uoa2V5c3Ryb2tlKSA6IGtleXN0cm9rZS5rZXlDb2RlO1xuICAgICAgICAgIGV2ZW50LmNoYXJDb2RlID0gdHlwZSA9PT0gJ2tleXByZXNzJyA/IGV2ZW50LmtleUNvZGUgOiAwO1xuICAgICAgICAgIGV2ZW50LndoaWNoID0gZXZlbnQua2V5Q29kZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHRoZSBjb3JyZWN0IHNlcXVlbmNlIG9mIGV2ZW50cyBvbiB0aGUgZ2l2ZW4gdGFyZ2V0IGFzIGlmIHRoZSBnaXZlblxuICAgICAqIGFjdGlvbiB3YXMgdW5kZXJ0YWtlbiBieSBhIGh1bWFuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvbiBlLmcuIFwiYWx0K3NoaWZ0K2xlZnRcIiBvciBcImJhY2tzcGFjZVwiXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3BhdGNoRXZlbnRzRm9yQWN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcGF0Y2hFdmVudHNGb3JBY3Rpb24oYWN0aW9uLCB0YXJnZXQpIHtcbiAgICAgIHZhciBrZXlzdHJva2UgPSB0aGlzLmtleXN0cm9rZUZvckFjdGlvbihhY3Rpb24pO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50c0ZvcktleXN0cm9rZShrZXlzdHJva2UsIHRhcmdldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgdGhlIGNvcnJlY3Qgc2VxdWVuY2Ugb2YgZXZlbnRzIG9uIHRoZSBnaXZlbiB0YXJnZXQgYXMgaWYgdGhlIGdpdmVuXG4gICAgICogaW5wdXQgaGFkIGJlZW4gdHlwZWQgYnkgYSBodW1hbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXNwYXRjaEV2ZW50c0ZvcklucHV0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcGF0Y2hFdmVudHNGb3JJbnB1dChpbnB1dCwgdGFyZ2V0KSB7XG4gICAgICB2YXIgY3VycmVudE1vZGlmaWVyU3RhdGUgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXlzdHJva2UgPSB0aGlzLmtleXN0cm9rZUZvckNoYXJDb2RlKGlucHV0LmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTW9kaWZpZXJTdGF0ZVRyYW5zaXRpb24odGFyZ2V0LCBjdXJyZW50TW9kaWZpZXJTdGF0ZSwga2V5c3Ryb2tlLm1vZGlmaWVycyk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudHNGb3JLZXlzdHJva2Uoa2V5c3Ryb2tlLCB0YXJnZXQsIGZhbHNlKTtcbiAgICAgICAgY3VycmVudE1vZGlmaWVyU3RhdGUgPSBrZXlzdHJva2UubW9kaWZpZXJzO1xuICAgICAgfVxuICAgICAgdGhpcy5kaXNwYXRjaE1vZGlmaWVyU3RhdGVUcmFuc2l0aW9uKHRhcmdldCwgY3VycmVudE1vZGlmaWVyU3RhdGUsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHRoZSBjb3JyZWN0IHNlcXVlbmNlIG9mIGV2ZW50cyBvbiB0aGUgZ2l2ZW4gdGFyZ2V0IGFzIGlmIHRoZSBnaXZlblxuICAgICAqIGtleXN0cm9rZSB3YXMgcGVyZm9ybWVkIGJ5IGEgaHVtYW4uIFdoZW4gc2ltdWxhdGluZywgZm9yIGV4YW1wbGUsIHR5cGluZ1xuICAgICAqIHRoZSBsZXR0ZXIgXCJBXCIgKGFzc3VtaW5nIGEgVS5TLiBFbmdsaXNoIGtleWJvYXJkKSB0aGVuIHRoZSBzZXF1ZW5jZSB3aWxsXG4gICAgICogbG9vayBsaWtlIHRoaXM6XG4gICAgICpcbiAgICAgKiAgIGtleWRvd24gICBrZXlDb2RlPTE2IChTSElGVCkgY2hhckNvZGU9MCAgICAgIHNoaWZ0S2V5PXRydWVcbiAgICAgKiAgIGtleWRvd24gICBrZXlDb2RlPTY1IChBKSAgICAgY2hhckNvZGU9MCAgICAgIHNoaWZ0S2V5PXRydWVcbiAgICAgKiAgIGtleXByZXNzICBrZXlDb2RlPTY1IChBKSAgICAgY2hhckNvZGU9NjUgKEEpIHNoaWZ0S2V5PXRydWVcbiAgICAgKiAgIHRleHRJbnB1dCBkYXRhPUFcbiAgICAgKiAgIGlucHV0XG4gICAgICogICBrZXl1cCAgICAga2V5Q29kZT02NSAoQSkgICAgIGNoYXJDb2RlPTAgICAgICBzaGlmdEtleT10cnVlXG4gICAgICogICBrZXl1cCAgICAga2V5Q29kZT0xNiAoU0hJRlQpIGNoYXJDb2RlPTAgICAgICBzaGlmdEtleT1mYWxzZVxuICAgICAqXG4gICAgICogSWYgdGhlIGtleXN0cm9rZSB3b3VsZCBub3QgY2F1c2UgYSBjaGFyYWN0ZXIgdG8gYmUgaW5wdXQsIHN1Y2ggYXMgd2hlblxuICAgICAqIHByZXNzaW5nIGFsdCtzaGlmdCtsZWZ0LCB0aGUgc2VxdWVuY2UgbG9va3MgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogICBrZXlkb3duICAga2V5Q29kZT0xNiAoU0hJRlQpIGNoYXJDb2RlPTAgYWx0S2V5PWZhbHNlIHNoaWZ0S2V5PXRydWVcbiAgICAgKiAgIGtleWRvd24gICBrZXlDb2RlPTE4IChBTFQpICAgY2hhckNvZGU9MCBhbHRLZXk9dHJ1ZSAgc2hpZnRLZXk9dHJ1ZVxuICAgICAqICAga2V5ZG93biAgIGtleUNvZGU9MzcgKExFRlQpICBjaGFyQ29kZT0wIGFsdEtleT10cnVlICBzaGlmdEtleT10cnVlXG4gICAgICogICBrZXl1cCAgICAga2V5Q29kZT0zNyAoTEVGVCkgIGNoYXJDb2RlPTAgYWx0S2V5PXRydWUgIHNoaWZ0S2V5PXRydWVcbiAgICAgKiAgIGtleXVwICAgICBrZXlDb2RlPTE4IChBTFQpICAgY2hhckNvZGU9MCBhbHRLZXk9ZmFsc2Ugc2hpZnRLZXk9dHJ1ZVxuICAgICAqICAga2V5dXAgICAgIGtleUNvZGU9MTYgKFNISUZUKSBjaGFyQ29kZT0wIGFsdEtleT1mYWxzZSBzaGlmdEtleT1mYWxzZVxuICAgICAqXG4gICAgICogVG8gZGlzYWJsZSBoYW5kbGluZyBvZiBtb2RpZmllciBrZXlzLCBjYWxsIHdpdGggYHRyYW5zaXRpb25Nb2RpZmVyc2Agc2V0XG4gICAgICogdG8gZmFsc2UuIERvaW5nIHNvIHdpbGwgb21pdCB0aGUga2V5ZG93biBhbmQga2V5dXAgZXZlbnRzIGFzc29jaWF0ZWQgd2l0aFxuICAgICAqIHNoaWZ0LCBjdHJsLCBhbHQsIGFuZCBtZXRhIGtleXMgc3Vycm91bmRpbmcgdGhlIGFjdHVhbCBrZXlzdHJva2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0tleXN0cm9rZX0ga2V5c3Ryb2tlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdHJhbnNpdGlvbk1vZGlmaWVyc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGlzcGF0Y2hFdmVudHNGb3JLZXlzdHJva2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50c0ZvcktleXN0cm9rZShrZXlzdHJva2UsIHRhcmdldCkge1xuICAgICAgdmFyIHRyYW5zaXRpb25Nb2RpZmllcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICB2YXIgZXZlbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBLZXlFdmVudHMuQUxMO1xuXG4gICAgICBpZiAodHJhbnNpdGlvbk1vZGlmaWVycykge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTW9kaWZpZXJTdGF0ZVRyYW5zaXRpb24odGFyZ2V0LCAwLCBrZXlzdHJva2UubW9kaWZpZXJzLCBldmVudHMpO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5ZG93bkV2ZW50ID0gdm9pZCAwO1xuICAgICAgaWYgKGV2ZW50cyAmIEtleUV2ZW50cy5ET1dOKSB7XG4gICAgICAgIGtleWRvd25FdmVudCA9IHRoaXMuY3JlYXRlRXZlbnRGcm9tS2V5c3Ryb2tlKCdrZXlkb3duJywga2V5c3Ryb2tlLCB0YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ZG93bkV2ZW50ICYmIHRhcmdldC5kaXNwYXRjaEV2ZW50KGtleWRvd25FdmVudCkgJiYgdGhpcy50YXJnZXRDYW5SZWNlaXZlVGV4dElucHV0KHRhcmdldCkpIHtcbiAgICAgICAgdmFyIGtleXByZXNzRXZlbnQgPSB2b2lkIDA7XG4gICAgICAgIGlmIChldmVudHMgJiBLZXlFdmVudHMuUFJFU1MpIHtcbiAgICAgICAgICBrZXlwcmVzc0V2ZW50ID0gdGhpcy5jcmVhdGVFdmVudEZyb21LZXlzdHJva2UoJ2tleXByZXNzJywga2V5c3Ryb2tlLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlwcmVzc0V2ZW50ICYmIGtleXByZXNzRXZlbnQuY2hhckNvZGUgJiYgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoa2V5cHJlc3NFdmVudCkpIHtcbiAgICAgICAgICBpZiAoZXZlbnRzICYgS2V5RXZlbnRzLklOUFVUKSB7XG4gICAgICAgICAgICB2YXIgdGV4dGlucHV0RXZlbnQgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbUtleXN0cm9rZSgndGV4dElucHV0Jywga2V5c3Ryb2tlLCB0YXJnZXQpO1xuICAgICAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQodGV4dGlucHV0RXZlbnQpO1xuXG4gICAgICAgICAgICB2YXIgaW5wdXRFdmVudCA9IHRoaXMuY3JlYXRlRXZlbnRGcm9tS2V5c3Ryb2tlKCdpbnB1dCcsIGtleXN0cm9rZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGlucHV0RXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnRzICYgS2V5RXZlbnRzLlVQKSB7XG4gICAgICAgIHZhciBrZXl1cEV2ZW50ID0gdGhpcy5jcmVhdGVFdmVudEZyb21LZXlzdHJva2UoJ2tleXVwJywga2V5c3Ryb2tlLCB0YXJnZXQpO1xuICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChrZXl1cEV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zaXRpb25Nb2RpZmllcnMpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE1vZGlmaWVyU3RhdGVUcmFuc2l0aW9uKHRhcmdldCwga2V5c3Ryb2tlLm1vZGlmaWVycywgMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNpdGlvbnMgZnJvbSBvbmUgbW9kaWZpZXIgc3RhdGUgdG8gYW5vdGhlciBieSBkaXNwYXRjaGluZyBrZXkgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21Nb2RpZmllclN0YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvTW9kaWZpZXJTdGF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkaXNwYXRjaE1vZGlmaWVyU3RhdGVUcmFuc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcGF0Y2hNb2RpZmllclN0YXRlVHJhbnNpdGlvbih0YXJnZXQsIGZyb21Nb2RpZmllclN0YXRlLCB0b01vZGlmaWVyU3RhdGUpIHtcbiAgICAgIHZhciBldmVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IEtleUV2ZW50cy5BTEw7XG5cbiAgICAgIHZhciBjdXJyZW50TW9kaWZpZXJTdGF0ZSA9IGZyb21Nb2RpZmllclN0YXRlO1xuICAgICAgdmFyIGRpZEhhdmVNZXRhID0gKGZyb21Nb2RpZmllclN0YXRlICYgTUVUQSkgPT09IE1FVEE7XG4gICAgICB2YXIgd2lsbEhhdmVNZXRhID0gKHRvTW9kaWZpZXJTdGF0ZSAmIE1FVEEpID09PSBNRVRBO1xuICAgICAgdmFyIGRpZEhhdmVDdHJsID0gKGZyb21Nb2RpZmllclN0YXRlICYgQ1RSTCkgPT09IENUUkw7XG4gICAgICB2YXIgd2lsbEhhdmVDdHJsID0gKHRvTW9kaWZpZXJTdGF0ZSAmIENUUkwpID09PSBDVFJMO1xuICAgICAgdmFyIGRpZEhhdmVTaGlmdCA9IChmcm9tTW9kaWZpZXJTdGF0ZSAmIFNISUZUKSA9PT0gU0hJRlQ7XG4gICAgICB2YXIgd2lsbEhhdmVTaGlmdCA9ICh0b01vZGlmaWVyU3RhdGUgJiBTSElGVCkgPT09IFNISUZUO1xuICAgICAgdmFyIGRpZEhhdmVBbHQgPSAoZnJvbU1vZGlmaWVyU3RhdGUgJiBBTFQpID09PSBBTFQ7XG4gICAgICB2YXIgd2lsbEhhdmVBbHQgPSAodG9Nb2RpZmllclN0YXRlICYgQUxUKSA9PT0gQUxUO1xuXG4gICAgICB2YXIgaW5jbHVkZUtleVVwID0gZXZlbnRzICYgS2V5RXZlbnRzLlVQO1xuICAgICAgdmFyIGluY2x1ZGVLZXlEb3duID0gZXZlbnRzICYgS2V5RXZlbnRzLkRPV047XG5cbiAgICAgIGlmIChpbmNsdWRlS2V5VXAgJiYgZGlkSGF2ZU1ldGEgPT09IHRydWUgJiYgd2lsbEhhdmVNZXRhID09PSBmYWxzZSkge1xuICAgICAgICAvLyBSZWxlYXNlIHRoZSBtZXRhIGtleS5cbiAgICAgICAgY3VycmVudE1vZGlmaWVyU3RhdGUgJj0gfk1FVEE7XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KHRoaXMuY3JlYXRlRXZlbnRGcm9tS2V5c3Ryb2tlKCdrZXl1cCcsIG5ldyBLZXlzdHJva2UoY3VycmVudE1vZGlmaWVyU3RhdGUsIHRoaXMuX2FjdGlvbktleUNvZGVNYXAuTUVUQSksIHRhcmdldCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZUtleVVwICYmIGRpZEhhdmVDdHJsID09PSB0cnVlICYmIHdpbGxIYXZlQ3RybCA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gUmVsZWFzZSB0aGUgY3RybCBrZXkuXG4gICAgICAgIGN1cnJlbnRNb2RpZmllclN0YXRlICY9IH5DVFJMO1xuICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudCh0aGlzLmNyZWF0ZUV2ZW50RnJvbUtleXN0cm9rZSgna2V5dXAnLCBuZXcgS2V5c3Ryb2tlKGN1cnJlbnRNb2RpZmllclN0YXRlLCB0aGlzLl9hY3Rpb25LZXlDb2RlTWFwLkNUUkwpLCB0YXJnZXQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluY2x1ZGVLZXlVcCAmJiBkaWRIYXZlU2hpZnQgPT09IHRydWUgJiYgd2lsbEhhdmVTaGlmdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gUmVsZWFzZSB0aGUgc2hpZnQga2V5LlxuICAgICAgICBjdXJyZW50TW9kaWZpZXJTdGF0ZSAmPSB+U0hJRlQ7XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KHRoaXMuY3JlYXRlRXZlbnRGcm9tS2V5c3Ryb2tlKCdrZXl1cCcsIG5ldyBLZXlzdHJva2UoY3VycmVudE1vZGlmaWVyU3RhdGUsIHRoaXMuX2FjdGlvbktleUNvZGVNYXAuU0hJRlQpLCB0YXJnZXQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluY2x1ZGVLZXlVcCAmJiBkaWRIYXZlQWx0ID09PSB0cnVlICYmIHdpbGxIYXZlQWx0ID09PSBmYWxzZSkge1xuICAgICAgICAvLyBSZWxlYXNlIHRoZSBhbHQga2V5LlxuICAgICAgICBjdXJyZW50TW9kaWZpZXJTdGF0ZSAmPSB+QUxUO1xuICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudCh0aGlzLmNyZWF0ZUV2ZW50RnJvbUtleXN0cm9rZSgna2V5dXAnLCBuZXcgS2V5c3Ryb2tlKGN1cnJlbnRNb2RpZmllclN0YXRlLCB0aGlzLl9hY3Rpb25LZXlDb2RlTWFwLkFMVCksIHRhcmdldCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZUtleURvd24gJiYgZGlkSGF2ZU1ldGEgPT09IGZhbHNlICYmIHdpbGxIYXZlTWV0YSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBQcmVzcyB0aGUgbWV0YSBrZXkuXG4gICAgICAgIGN1cnJlbnRNb2RpZmllclN0YXRlIHw9IE1FVEE7XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KHRoaXMuY3JlYXRlRXZlbnRGcm9tS2V5c3Ryb2tlKCdrZXlkb3duJywgbmV3IEtleXN0cm9rZShjdXJyZW50TW9kaWZpZXJTdGF0ZSwgdGhpcy5fYWN0aW9uS2V5Q29kZU1hcC5NRVRBKSwgdGFyZ2V0KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmNsdWRlS2V5RG93biAmJiBkaWRIYXZlQ3RybCA9PT0gZmFsc2UgJiYgd2lsbEhhdmVDdHJsID09PSB0cnVlKSB7XG4gICAgICAgIC8vIFByZXNzIHRoZSBjdHJsIGtleS5cbiAgICAgICAgY3VycmVudE1vZGlmaWVyU3RhdGUgfD0gQ1RSTDtcbiAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQodGhpcy5jcmVhdGVFdmVudEZyb21LZXlzdHJva2UoJ2tleWRvd24nLCBuZXcgS2V5c3Ryb2tlKGN1cnJlbnRNb2RpZmllclN0YXRlLCB0aGlzLl9hY3Rpb25LZXlDb2RlTWFwLkNUUkwpLCB0YXJnZXQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluY2x1ZGVLZXlEb3duICYmIGRpZEhhdmVTaGlmdCA9PT0gZmFsc2UgJiYgd2lsbEhhdmVTaGlmdCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBQcmVzcyB0aGUgc2hpZnQga2V5LlxuICAgICAgICBjdXJyZW50TW9kaWZpZXJTdGF0ZSB8PSBTSElGVDtcbiAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQodGhpcy5jcmVhdGVFdmVudEZyb21LZXlzdHJva2UoJ2tleWRvd24nLCBuZXcgS2V5c3Ryb2tlKGN1cnJlbnRNb2RpZmllclN0YXRlLCB0aGlzLl9hY3Rpb25LZXlDb2RlTWFwLlNISUZUKSwgdGFyZ2V0KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmNsdWRlS2V5RG93biAmJiBkaWRIYXZlQWx0ID09PSBmYWxzZSAmJiB3aWxsSGF2ZUFsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBQcmVzcyB0aGUgYWx0IGtleS5cbiAgICAgICAgY3VycmVudE1vZGlmaWVyU3RhdGUgfD0gQUxUO1xuICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudCh0aGlzLmNyZWF0ZUV2ZW50RnJvbUtleXN0cm9rZSgna2V5ZG93bicsIG5ldyBLZXlzdHJva2UoY3VycmVudE1vZGlmaWVyU3RhdGUsIHRoaXMuX2FjdGlvbktleUNvZGVNYXAuQUxUKSwgdGFyZ2V0KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50TW9kaWZpZXJTdGF0ZSAhPT0gdG9Nb2RpZmllclN0YXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW50ZXJuYWwgZXJyb3IsIGV4cGVjdGVkIG1vZGlmaWVyIHN0YXRlOiAnICsgdG9Nb2RpZmllclN0YXRlICsgKCcsIGdvdDogJyArIGN1cnJlbnRNb2RpZmllclN0YXRlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUga2V5c3Ryb2tlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gYWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvblxuICAgICAqIEByZXR1cm4gez9LZXlzdHJva2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2tleXN0cm9rZUZvckFjdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtleXN0cm9rZUZvckFjdGlvbihhY3Rpb24pIHtcbiAgICAgIHZhciBrZXlDb2RlID0gbnVsbDtcbiAgICAgIHZhciBtb2RpZmllcnMgPSAwO1xuXG4gICAgICB2YXIgcGFydHMgPSBhY3Rpb24uc3BsaXQoJysnKTtcbiAgICAgIHZhciBsYXN0UGFydCA9IHBhcnRzLnBvcCgpO1xuXG4gICAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgIHN3aXRjaCAocGFydC50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSAnQ1RSTCc6XG4gICAgICAgICAgICBtb2RpZmllcnMgfD0gQ1RSTDticmVhaztcbiAgICAgICAgICBjYXNlICdNRVRBJzpcbiAgICAgICAgICAgIG1vZGlmaWVycyB8PSBNRVRBO2JyZWFrO1xuICAgICAgICAgIGNhc2UgJ0FMVCc6XG4gICAgICAgICAgICBtb2RpZmllcnMgfD0gQUxUO2JyZWFrO1xuICAgICAgICAgIGNhc2UgJ1NISUZUJzpcbiAgICAgICAgICAgIG1vZGlmaWVycyB8PSBTSElGVDticmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbiBcIicgKyBhY3Rpb24gKyAnXCIsIGludmFsaWQgbW9kaWZpZXI6ICcgKyBwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChsYXN0UGFydC50b1VwcGVyQ2FzZSgpIGluIHRoaXMuX2FjdGlvbktleUNvZGVNYXApIHtcbiAgICAgICAga2V5Q29kZSA9IHRoaXMuX2FjdGlvbktleUNvZGVNYXBbbGFzdFBhcnQudG9VcHBlckNhc2UoKV07XG4gICAgICB9IGVsc2UgaWYgKGxhc3RQYXJ0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgbGFzdFBhcnRLZXlzdHJva2UgPSB0aGlzLmtleXN0cm9rZUZvckNoYXJDb2RlKGxhc3RQYXJ0LmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICBtb2RpZmllcnMgfD0gbGFzdFBhcnRLZXlzdHJva2UubW9kaWZpZXJzO1xuICAgICAgICBrZXlDb2RlID0gbGFzdFBhcnRLZXlzdHJva2Uua2V5Q29kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW4gXCInICsgYWN0aW9uICsgJ1wiLCBpbnZhbGlkIGFjdGlvbjogJyArIGxhc3RQYXJ0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBLZXlzdHJva2UobW9kaWZpZXJzLCBrZXlDb2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBrZXlzdHJva2UgdXNlZCB0byBnZW5lcmF0ZSB0aGUgZ2l2ZW4gY2hhcmFjdGVyIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhckNvZGVcbiAgICAgKiBAcmV0dXJuIHs/S2V5c3Ryb2tlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdrZXlzdHJva2VGb3JDaGFyQ29kZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtleXN0cm9rZUZvckNoYXJDb2RlKGNoYXJDb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hhckNvZGVLZXlDb2RlTWFwW2NoYXJDb2RlXSB8fCBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RhcmdldENhblJlY2VpdmVUZXh0SW5wdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0YXJnZXRDYW5SZWNlaXZlVGV4dElucHV0KHRhcmdldCkge1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNFZGl0YWJsZSh0YXJnZXQpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2V5Ym9hcmQ7XG59KCk7XG5cbnZhciBVU19FTkdMSVNIX0NIQVJDT0RFX0tFWUNPREVfTUFQID0ge1xuICAzMjogbmV3IEtleXN0cm9rZSgwLCAzMiksIC8vIDxzcGFjZT5cbiAgMzM6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDQ5KSwgLy8gIVxuICAzNDogbmV3IEtleXN0cm9rZShTSElGVCwgMjIyKSwgLy8gXCJcbiAgMzU6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDUxKSwgLy8gI1xuICAzNjogbmV3IEtleXN0cm9rZShTSElGVCwgNTIpLCAvLyAkXG4gIDM3OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA1MyksIC8vICVcbiAgMzg6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDU1KSwgLy8gJlxuICAzOTogbmV3IEtleXN0cm9rZSgwLCAyMjIpLCAvLyAnXG4gIDQwOiBuZXcgS2V5c3Ryb2tlKFNISUZULCA1NyksIC8vIChcbiAgNDE6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDQ4KSwgLy8gKVxuICA0MjogbmV3IEtleXN0cm9rZShTSElGVCwgNTYpLCAvLyAqXG4gIDQzOiBuZXcgS2V5c3Ryb2tlKFNISUZULCAxODcpLCAvLyArXG4gIDQ0OiBuZXcgS2V5c3Ryb2tlKDAsIDE4OCksIC8vICxcbiAgNDU6IG5ldyBLZXlzdHJva2UoMCwgMTg5KSwgLy8gLVxuICA0NjogbmV3IEtleXN0cm9rZSgwLCAxOTApLCAvLyAuXG4gIDQ3OiBuZXcgS2V5c3Ryb2tlKDAsIDE5MSksIC8vIC9cbiAgNDg6IG5ldyBLZXlzdHJva2UoMCwgNDgpLCAvLyAwXG4gIDQ5OiBuZXcgS2V5c3Ryb2tlKDAsIDQ5KSwgLy8gMVxuICA1MDogbmV3IEtleXN0cm9rZSgwLCA1MCksIC8vIDJcbiAgNTE6IG5ldyBLZXlzdHJva2UoMCwgNTEpLCAvLyAzXG4gIDUyOiBuZXcgS2V5c3Ryb2tlKDAsIDUyKSwgLy8gNFxuICA1MzogbmV3IEtleXN0cm9rZSgwLCA1MyksIC8vIDVcbiAgNTQ6IG5ldyBLZXlzdHJva2UoMCwgNTQpLCAvLyA2XG4gIDU1OiBuZXcgS2V5c3Ryb2tlKDAsIDU1KSwgLy8gN1xuICA1NjogbmV3IEtleXN0cm9rZSgwLCA1NiksIC8vIDhcbiAgNTc6IG5ldyBLZXlzdHJva2UoMCwgNTcpLCAvLyA5XG4gIDU4OiBuZXcgS2V5c3Ryb2tlKFNISUZULCAxODYpLCAvLyA6XG4gIDU5OiBuZXcgS2V5c3Ryb2tlKDAsIDE4NiksIC8vIDtcbiAgNjA6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDE4OCksIC8vIDxcbiAgNjE6IG5ldyBLZXlzdHJva2UoMCwgMTg3KSwgLy8gPVxuICA2MjogbmV3IEtleXN0cm9rZShTSElGVCwgMTkwKSwgLy8gPlxuICA2MzogbmV3IEtleXN0cm9rZShTSElGVCwgMTkxKSwgLy8gP1xuICA2NDogbmV3IEtleXN0cm9rZShTSElGVCwgNTApLCAvLyBAXG4gIDY1OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA2NSksIC8vIEFcbiAgNjY6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDY2KSwgLy8gQlxuICA2NzogbmV3IEtleXN0cm9rZShTSElGVCwgNjcpLCAvLyBDXG4gIDY4OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA2OCksIC8vIERcbiAgNjk6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDY5KSwgLy8gRVxuICA3MDogbmV3IEtleXN0cm9rZShTSElGVCwgNzApLCAvLyBGXG4gIDcxOiBuZXcgS2V5c3Ryb2tlKFNISUZULCA3MSksIC8vIEdcbiAgNzI6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDcyKSwgLy8gSFxuICA3MzogbmV3IEtleXN0cm9rZShTSElGVCwgNzMpLCAvLyBJXG4gIDc0OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA3NCksIC8vIEpcbiAgNzU6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDc1KSwgLy8gS1xuICA3NjogbmV3IEtleXN0cm9rZShTSElGVCwgNzYpLCAvLyBMXG4gIDc3OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA3NyksIC8vIE1cbiAgNzg6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDc4KSwgLy8gTlxuICA3OTogbmV3IEtleXN0cm9rZShTSElGVCwgNzkpLCAvLyBPXG4gIDgwOiBuZXcgS2V5c3Ryb2tlKFNISUZULCA4MCksIC8vIFBcbiAgODE6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDgxKSwgLy8gUVxuICA4MjogbmV3IEtleXN0cm9rZShTSElGVCwgODIpLCAvLyBSXG4gIDgzOiBuZXcgS2V5c3Ryb2tlKFNISUZULCA4MyksIC8vIFNcbiAgODQ6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDg0KSwgLy8gVFxuICA4NTogbmV3IEtleXN0cm9rZShTSElGVCwgODUpLCAvLyBVXG4gIDg2OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA4NiksIC8vIFZcbiAgODc6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDg3KSwgLy8gV1xuICA4ODogbmV3IEtleXN0cm9rZShTSElGVCwgODgpLCAvLyBYXG4gIDg5OiBuZXcgS2V5c3Ryb2tlKFNISUZULCA4OSksIC8vIFlcbiAgOTA6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDkwKSwgLy8gWlxuICA5MTogbmV3IEtleXN0cm9rZSgwLCAyMTkpLCAvLyBbXG4gIDkyOiBuZXcgS2V5c3Ryb2tlKDAsIDIyMCksIC8vIFxcXG4gIDkzOiBuZXcgS2V5c3Ryb2tlKDAsIDIyMSksIC8vIF1cbiAgOTY6IG5ldyBLZXlzdHJva2UoMCwgMTkyKSwgLy8gYFxuICA5NzogbmV3IEtleXN0cm9rZSgwLCA2NSksIC8vIGFcbiAgOTg6IG5ldyBLZXlzdHJva2UoMCwgNjYpLCAvLyBiXG4gIDk5OiBuZXcgS2V5c3Ryb2tlKDAsIDY3KSwgLy8gY1xuICAxMDA6IG5ldyBLZXlzdHJva2UoMCwgNjgpLCAvLyBkXG4gIDEwMTogbmV3IEtleXN0cm9rZSgwLCA2OSksIC8vIGVcbiAgMTAyOiBuZXcgS2V5c3Ryb2tlKDAsIDcwKSwgLy8gZlxuICAxMDM6IG5ldyBLZXlzdHJva2UoMCwgNzEpLCAvLyBnXG4gIDEwNDogbmV3IEtleXN0cm9rZSgwLCA3MiksIC8vIGhcbiAgMTA1OiBuZXcgS2V5c3Ryb2tlKDAsIDczKSwgLy8gaVxuICAxMDY6IG5ldyBLZXlzdHJva2UoMCwgNzQpLCAvLyBqXG4gIDEwNzogbmV3IEtleXN0cm9rZSgwLCA3NSksIC8vIGtcbiAgMTA4OiBuZXcgS2V5c3Ryb2tlKDAsIDc2KSwgLy8gbFxuICAxMDk6IG5ldyBLZXlzdHJva2UoMCwgNzcpLCAvLyBtXG4gIDExMDogbmV3IEtleXN0cm9rZSgwLCA3OCksIC8vIG5cbiAgMTExOiBuZXcgS2V5c3Ryb2tlKDAsIDc5KSwgLy8gb1xuICAxMTI6IG5ldyBLZXlzdHJva2UoMCwgODApLCAvLyBwXG4gIDExMzogbmV3IEtleXN0cm9rZSgwLCA4MSksIC8vIHFcbiAgMTE0OiBuZXcgS2V5c3Ryb2tlKDAsIDgyKSwgLy8gclxuICAxMTU6IG5ldyBLZXlzdHJva2UoMCwgODMpLCAvLyBzXG4gIDExNjogbmV3IEtleXN0cm9rZSgwLCA4NCksIC8vIHRcbiAgMTE3OiBuZXcgS2V5c3Ryb2tlKDAsIDg1KSwgLy8gdVxuICAxMTg6IG5ldyBLZXlzdHJva2UoMCwgODYpLCAvLyB2XG4gIDExOTogbmV3IEtleXN0cm9rZSgwLCA4NyksIC8vIHdcbiAgMTIwOiBuZXcgS2V5c3Ryb2tlKDAsIDg4KSwgLy8geFxuICAxMjE6IG5ldyBLZXlzdHJva2UoMCwgODkpLCAvLyB5XG4gIDEyMjogbmV3IEtleXN0cm9rZSgwLCA5MCksIC8vIHpcbiAgMTIzOiBuZXcgS2V5c3Ryb2tlKFNISUZULCAyMTkpLCAvLyB7XG4gIDEyNDogbmV3IEtleXN0cm9rZShTSElGVCwgMjIwKSwgLy8gfFxuICAxMjU6IG5ldyBLZXlzdHJva2UoU0hJRlQsIDIyMSksIC8vIH1cbiAgMTI2OiBuZXcgS2V5c3Ryb2tlKFNISUZULCAxOTIpIC8vIH5cbn07XG5cbnZhciBVU19FTkdMSVNIX0FDVElPTl9LRVlDT0RFX01BUCA9IHtcbiAgQkFDS1NQQUNFOiA4LFxuICBUQUI6IDksXG4gIEVOVEVSOiAxMyxcbiAgU0hJRlQ6IDE2LFxuICBDVFJMOiAxNyxcbiAgQUxUOiAxOCxcbiAgUEFVU0U6IDE5LFxuICBDQVBTTE9DSzogMjAsXG4gIEVTQ0FQRTogMjcsXG4gIFBBR0VVUDogMzMsXG4gIFBBR0VET1dOOiAzNCxcbiAgRU5EOiAzNSxcbiAgSE9NRTogMzYsXG4gIExFRlQ6IDM3LFxuICBVUDogMzgsXG4gIFJJR0hUOiAzOSxcbiAgRE9XTjogNDAsXG4gIElOU0VSVDogNDUsXG4gIERFTEVURTogNDYsXG4gIE1FVEE6IDkxLFxuICBGMTogMTEyLFxuICBGMjogMTEzLFxuICBGMzogMTE0LFxuICBGNDogMTE1LFxuICBGNTogMTE2LFxuICBGNjogMTE3LFxuICBGNzogMTE4LFxuICBGODogMTE5LFxuICBGOTogMTIwLFxuICBGMTA6IDEyMSxcbiAgRjExOiAxMjIsXG4gIEYxMjogMTIzXG59O1xuXG4vKipcbiAqIEdldHMgYSBrZXlib2FyZCBpbnN0YW5jZSBjb25maWd1cmVkIGFzIGEgVS5TLiBFbmdsaXNoIGtleWJvYXJkIHdvdWxkIGJlLlxuICpcbiAqIEByZXR1cm4ge0tleWJvYXJkfVxuICovXG5LZXlib2FyZC5VU19FTkdMSVNIID0gbmV3IEtleWJvYXJkKFVTX0VOR0xJU0hfQ0hBUkNPREVfS0VZQ09ERV9NQVAsIFVTX0VOR0xJU0hfQUNUSU9OX0tFWUNPREVfTUFQKTtcblxuZXhwb3J0IHsgS2V5RXZlbnRzLCBLZXlzdHJva2UsIEtleWJvYXJkIH07XG4iLCJpbXBvcnQge0tleWJvYXJkfSBmcm9tICdrZXlzaW0nXG5rZXlib2FyZCA9IEtleWJvYXJkLlVTX0VOR0xJU0hcblxuXG5leHBvcnQgZGVmYXVsdCAodGFyZ2V0LCBrZXlzLCB2YWx1ZSktPlxuXHR0YXJnZXQuZm9jdXMoKSBpZiB0YXJnZXQuZm9jdXNcblx0dGFyZ2V0LnZhbHVlICs9IGlmIHZhbHVlPyB0aGVuICh2YWx1ZSBvciAnJykgZWxzZSBrZXlzXG5cdGtleWJvYXJkLmRpc3BhdGNoRXZlbnRzRm9ySW5wdXQoa2V5cywgdGFyZ2V0KVxuXG5cblxuXG4iLCJpbXBvcnQge0tleWJvYXJkfSBmcm9tICdrZXlzaW0nXG5rZXlib2FyZCA9IEtleWJvYXJkLlVTX0VOR0xJU0hcblxuXG5leHBvcnQgZGVmYXVsdCAodGFyZ2V0LCBrZXlzKS0+XG5cdGtleWJvYXJkLmRpc3BhdGNoRXZlbnRzRm9yQWN0aW9uKGtleXMsIHRhcmdldClcblxuXG5cblxuIiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufXZhciBSRUdFWF9MRU5fVkFMID0gL15cXGQrKD86W2Etel18XFwlKSskL2k7XG52YXIgUkVHRVhfRElHSVRTID0gL1xcZCskLztcbnZhciBSRUdFWF9TUEFDRSA9IC9cXHMvO1xudmFyIFJFR0VYX0tFQkFCID0gLyhbQS1aXSkrL2c7XG52YXIgSU1QT1JUQU5UID0gJ2ltcG9ydGFudCc7XG52YXIgUE9TU0lCTEVfUFJFRklYRVMgPSBbJ3dlYmtpdCcsICdtb3onLCAnbXMnLCAnbyddO1xudmFyIFJFUVVJUkVTX1VOSVRfVkFMVUUgPSBbJ2JhY2tncm91bmQtcG9zaXRpb24teCcsICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLCAnYmxvY2stc2l6ZScsICdib3JkZXItd2lkdGgnLCAnY29sdW1uUnVsZS13aWR0aCcsICdjeCcsICdjeScsICdmb250LXNpemUnLCAnZ3JpZC1jb2x1bW4tZ2FwJywgJ2dyaWQtcm93LWdhcCcsICdoZWlnaHQnLCAnaW5saW5lLXNpemUnLCAnbGluZS1oZWlnaHQnLCAnbWluQmxvY2stc2l6ZScsICdtaW4taGVpZ2h0JywgJ21pbi1pbmxpbmUtc2l6ZScsICdtaW4td2lkdGgnLCAnbWF4LWhlaWdodCcsICdtYXgtd2lkdGgnLCAnb3V0bGluZS1vZmZzZXQnLCAnb3V0bGluZS13aWR0aCcsICdwZXJzcGVjdGl2ZScsICdzaGFwZS1tYXJnaW4nLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLXdpZHRoJywgJ3RleHQtaW5kZW50JywgJ3dpZHRoJywgJ3dvcmQtc3BhY2luZycsICd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnLCAneCcsICd5J107XG52YXIgUVVBRF9TSE9SVEhBTkRTID0gWydtYXJnaW4nLCAncGFkZGluZycsICdib3JkZXInLCAnYm9yZGVyLXJhZGl1cyddO1xudmFyIERJUkVDVElPTlMgPSBbJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCddO1xuUVVBRF9TSE9SVEhBTkRTLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gIHZhciBkaXJlY3Rpb24sIGksIGxlbjtcbiAgUkVRVUlSRVNfVU5JVF9WQUxVRS5wdXNoKHByb3BlcnR5KTtcblxuICBmb3IgKGkgPSAwLCBsZW4gPSBESVJFQ1RJT05TLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgZGlyZWN0aW9uID0gRElSRUNUSU9OU1tpXTtcbiAgICBSRVFVSVJFU19VTklUX1ZBTFVFLnB1c2gocHJvcGVydHkgKyAnLScgKyBkaXJlY3Rpb24pO1xuICB9XG59KTt2YXIgU0FNUExFX1NUWUxFLCBzdHlsZUNvbmZpZztcblNBTVBMRV9TVFlMRSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xudmFyIGluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXModGFyZ2V0LCBpdGVtKSB7XG4gIHJldHVybiB0YXJnZXQgJiYgdGFyZ2V0LmluZGV4T2YoaXRlbSkgIT09IC0xO1xufTtcbnZhciBpc0l0ZXJhYmxlID0gZnVuY3Rpb24gaXNJdGVyYWJsZSh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldCAmJiBfdHlwZW9mKHRhcmdldCkgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0YXJnZXQubGVuZ3RoID09PSAnbnVtYmVyJyAmJiAhdGFyZ2V0Lm5vZGVUeXBlO1xufTtcbnZhciB0b0tlYmFiQ2FzZSA9IGZ1bmN0aW9uIHRvS2ViYWJDYXNlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoUkVHRVhfS0VCQUIsIGZ1bmN0aW9uIChlLCBsZXR0ZXIpIHtcbiAgICByZXR1cm4gXCItXCIuY29uY2F0KGxldHRlci50b0xvd2VyQ2FzZSgpKTtcbiAgfSk7XG59O1xudmFyIGlzUHJvcFN1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzUHJvcFN1cHBvcnRlZChwcm9wZXJ0eSkge1xuICByZXR1cm4gdHlwZW9mIFNBTVBMRV9TVFlMRVtwcm9wZXJ0eV0gIT09ICd1bmRlZmluZWQnO1xufTtcbnZhciBpc1ZhbHVlU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNWYWx1ZVN1cHBvcnRlZChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgaWYgKHdpbmRvdy5DU1MgJiYgd2luZG93LkNTUy5zdXBwb3J0cykge1xuICAgIHJldHVybiB3aW5kb3cuQ1NTLnN1cHBvcnRzKHByb3BlcnR5LCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgU0FNUExFX1NUWUxFW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIHJldHVybiBTQU1QTEVfU1RZTEVbcHJvcGVydHldID09PSAnJyArIHZhbHVlO1xuICB9XG59O1xudmFyIGdldFByZWZpeCA9IGZ1bmN0aW9uIGdldFByZWZpeChwcm9wZXJ0eSwgc2tpcEluaXRpYWxDaGVjaykge1xuICB2YXIgaiwgbGVuMSwgcHJlZml4O1xuXG4gIGlmIChza2lwSW5pdGlhbENoZWNrIHx8ICFpc1Byb3BTdXBwb3J0ZWQocHJvcGVydHkpKSB7XG4gICAgZm9yIChqID0gMCwgbGVuMSA9IFBPU1NJQkxFX1BSRUZJWEVTLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgcHJlZml4ID0gUE9TU0lCTEVfUFJFRklYRVNbal07XG5cbiAgICAgIGlmIChpc1Byb3BTdXBwb3J0ZWQoXCItXCIuY29uY2F0KHByZWZpeCwgXCItXCIpLmNvbmNhdChwcm9wZXJ0eSkpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBcIi1cIi5jb25jYXQocHJlZml4LCBcIi1cIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufTtcbnZhciBub3JtYWxpemVQcm9wZXJ0eSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BlcnR5KHByb3BlcnR5KSB7XG4gIHByb3BlcnR5ID0gdG9LZWJhYkNhc2UocHJvcGVydHkpO1xuXG4gIGlmIChpc1Byb3BTdXBwb3J0ZWQocHJvcGVydHkpKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChnZXRQcmVmaXgocHJvcGVydHksIHRydWUpKS5jb25jYXQocHJvcGVydHkpO1xuICB9XG59O1xudmFyIG5vcm1hbGl6ZVZhbHVlID0gZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUocHJvcGVydHksIHZhbHVlKSB7XG4gIGlmIChpbmNsdWRlcyhSRVFVSVJFU19VTklUX1ZBTFVFLCBwcm9wZXJ0eSkgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICB2YWx1ZSA9ICcnICsgdmFsdWU7XG5cbiAgICBpZiAoUkVHRVhfRElHSVRTLnRlc3QodmFsdWUpICYmICFSRUdFWF9MRU5fVkFMLnRlc3QodmFsdWUpICYmICFSRUdFWF9TUEFDRS50ZXN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgKz0gcHJvcGVydHkgPT09ICdsaW5lLWhlaWdodCcgPyAnZW0nIDogJ3B4JztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIHNvcnQgPSBmdW5jdGlvbiBzb3J0KGFycmF5KSB7XG4gIHZhciBncmVhdCwgaSwgbGVuLCBsZXNzLCBwaXZvdDtcblxuICBpZiAoYXJyYXkubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBhcnJheTtcbiAgfSBlbHNlIHtcbiAgICBwaXZvdCA9IGFycmF5WzBdO1xuICAgIGxlc3MgPSBbXTtcbiAgICBncmVhdCA9IFtdO1xuICAgIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICBpID0gMDtcblxuICAgIHdoaWxlICgrK2kgIT09IGxlbikge1xuICAgICAgaWYgKGFycmF5W2ldIDw9IHBpdm90KSB7XG4gICAgICAgIGxlc3MucHVzaChhcnJheVtpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncmVhdC5wdXNoKGFycmF5W2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc29ydChsZXNzKS5jb25jYXQocGl2b3QsIHNvcnQoZ3JlYXQpKTtcbiAgfVxufTtcbnZhciBoYXNoID0gZnVuY3Rpb24gaGFzaChzdHJpbmcpIHtcbiAgdmFyIGhzaCwgaSwgbGVuZ3RoO1xuICBoc2ggPSA1MzgxO1xuICBpID0gLTE7XG4gIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraSAhPT0gc3RyaW5nLmxlbmd0aCkge1xuICAgIGhzaCA9IChoc2ggPDwgNSkgLSBoc2ggKyBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICBoc2ggfD0gMDtcbiAgfVxuXG4gIHJldHVybiAnXycgKyAoaHNoIDwgMCA/IGhzaCAqIC0yIDogaHNoKTtcbn07XG52YXIgcnVsZVRvU3RyaW5nID0gZnVuY3Rpb24gcnVsZVRvU3RyaW5nKHJ1bGUsIGltcG9ydGFudCkge1xuICB2YXIgaiwgbGVuMSwgb3V0cHV0LCBwcm9wLCBwcm9wZXJ0eSwgcHJvcHMsIHZhbHVlO1xuICBvdXRwdXQgPSAnJztcbiAgcHJvcHMgPSBzb3J0KE9iamVjdC5rZXlzKHJ1bGUpKTtcblxuICBmb3IgKGogPSAwLCBsZW4xID0gcHJvcHMubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgcHJvcCA9IHByb3BzW2pdO1xuXG4gICAgaWYgKHR5cGVvZiBydWxlW3Byb3BdID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcnVsZVtwcm9wXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHByb3BlcnR5ID0gbm9ybWFsaXplUHJvcGVydHkocHJvcCk7XG4gICAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHByb3BlcnR5LCBydWxlW3Byb3BdKTtcblxuICAgICAgaWYgKGltcG9ydGFudCkge1xuICAgICAgICB2YWx1ZSArPSBcIiAhaW1wb3J0YW50XCI7XG4gICAgICB9XG5cbiAgICAgIG91dHB1dCArPSBcIlwiLmNvbmNhdChwcm9wZXJ0eSwgXCI6XCIpLmNvbmNhdCh2YWx1ZSwgXCI7XCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xudmFyIGlubGluZVN0eWxlQ29uZmlnID0gc3R5bGVDb25maWcgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xudmFyIGlubGluZVN0eWxlID0gZnVuY3Rpb24gaW5saW5lU3R5bGUocnVsZSwgdmFsdWVUb1N0b3JlLCBsZXZlbCkge1xuICB2YXIgY29uZmlnLCBzdHlsZUVsO1xuXG4gIGlmICghKGNvbmZpZyA9IHN0eWxlQ29uZmlnW2xldmVsXSkpIHtcbiAgICBzdHlsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZUVsLmlkID0gXCJxdWlja2Nzc1wiLmNvbmNhdChsZXZlbCB8fCAnJyk7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsKTtcbiAgICBzdHlsZUNvbmZpZ1tsZXZlbF0gPSBjb25maWcgPSB7XG4gICAgICBlbDogc3R5bGVFbCxcbiAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgY2FjaGU6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFjb25maWcuY2FjaGVbcnVsZV0pIHtcbiAgICBjb25maWcuY2FjaGVbcnVsZV0gPSB2YWx1ZVRvU3RvcmUgfHwgdHJ1ZTtcbiAgICBjb25maWcuZWwudGV4dENvbnRlbnQgPSBjb25maWcuY29udGVudCArPSBydWxlO1xuICB9XG59O1xudmFyIGNsZWFySW5saW5lU3R5bGUgPSBmdW5jdGlvbiBjbGVhcklubGluZVN0eWxlKGxldmVsKSB7XG4gIHZhciBjb25maWcsIGosIGtleSwga2V5cywgbGVuMTtcblxuICBpZiAoY29uZmlnID0gc3R5bGVDb25maWdbbGV2ZWxdKSB7XG4gICAgaWYgKCFjb25maWcuY29udGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbmZpZy5lbC50ZXh0Q29udGVudCA9IGNvbmZpZy5jb250ZW50ID0gJyc7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZy5jYWNoZSk7XG5cbiAgICBmb3IgKGogPSAwLCBsZW4xID0ga2V5cy5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICAgIGtleSA9IGtleXNbal07XG4gICAgICBjb25maWcuY2FjaGVba2V5XSA9IG51bGw7XG4gICAgfVxuICB9XG59O3ZhciB2ZXJzaW9uID0gXCIxLjQuM1wiO3ZhciBfcXVpY2tjc3M7XG52YXIgaW5kZXggPSBfcXVpY2tjc3MgPSBmdW5jdGlvbiBxdWlja2Nzcyh0YXJnZXRFbCwgcHJvcGVydHksIHZhbHVlLCBpbXBvcnRhbnQpIHtcbiAgdmFyIGNvbXB1dGVkU3R5bGUsIGksIGxlbiwgc3ViRWwsIHN1YlByb3BlcnR5LCBzdWJWYWx1ZTtcblxuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhaXNJdGVyYWJsZSh0YXJnZXRFbCk6XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0YXJnZXRFbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdWJFbCA9IHRhcmdldEVsW2ldO1xuXG4gICAgICAgIF9xdWlja2NzcyhzdWJFbCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIF90eXBlb2YocHJvcGVydHkpICE9PSAnb2JqZWN0JzpcbiAgICAgIC8vIFBhc3NlZCBhIHN0eWxlIG1hcFxuICAgICAgZm9yIChzdWJQcm9wZXJ0eSBpbiBwcm9wZXJ0eSkge1xuICAgICAgICBzdWJWYWx1ZSA9IHByb3BlcnR5W3N1YlByb3BlcnR5XTtcblxuICAgICAgICBfcXVpY2tjc3ModGFyZ2V0RWwsIHN1YlByb3BlcnR5LCBzdWJWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHByb3BlcnR5ID0gbm9ybWFsaXplUHJvcGVydHkocHJvcGVydHkpO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb21wdXRlZFN0eWxlID0gdGFyZ2V0RWwuX2NvbXB1dGVkU3R5bGUgfHwgKHRhcmdldEVsLl9jb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXRFbCkpO1xuICAgICAgICByZXR1cm4gY29tcHV0ZWRTdHlsZVtwcm9wZXJ0eV07XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5KSB7XG4gICAgICAgIHRhcmdldEVsLnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5LCBub3JtYWxpemVWYWx1ZShwcm9wZXJ0eSwgdmFsdWUpLCBpbXBvcnRhbnQgPyBJTVBPUlRBTlQgOiB2b2lkIDApO1xuICAgICAgfVxuXG4gIH1cbn07XG5cbl9xdWlja2Nzcy5hbmltYXRpb24gPSBmdW5jdGlvbiAobmFtZSQkMSwgZnJhbWVzKSB7XG4gIHZhciBmcmFtZSwgZ2VuZXJhdGVkLCBwcmVmaXgsIHJ1bGVzO1xuXG4gIGlmIChuYW1lJCQxICYmIHR5cGVvZiBuYW1lJCQxID09PSAnc3RyaW5nJyAmJiBmcmFtZXMgJiYgX3R5cGVvZihmcmFtZXMpID09PSAnb2JqZWN0Jykge1xuICAgIHByZWZpeCA9IGdldFByZWZpeCgnYW5pbWF0aW9uJyk7XG4gICAgZ2VuZXJhdGVkID0gJyc7XG5cbiAgICBmb3IgKGZyYW1lIGluIGZyYW1lcykge1xuICAgICAgcnVsZXMgPSBmcmFtZXNbZnJhbWVdO1xuICAgICAgZ2VuZXJhdGVkICs9IFwiXCIuY29uY2F0KGZyYW1lLCBcIiB7XCIpLmNvbmNhdChydWxlVG9TdHJpbmcocnVsZXMpLCBcIn1cIik7XG4gICAgfVxuXG4gICAgZ2VuZXJhdGVkID0gXCJAXCIuY29uY2F0KHByZWZpeCwgXCJrZXlmcmFtZXMgXCIpLmNvbmNhdChuYW1lJCQxLCBcIiB7XCIpLmNvbmNhdChnZW5lcmF0ZWQsIFwifVwiKTtcbiAgICByZXR1cm4gaW5saW5lU3R5bGUoZ2VuZXJhdGVkLCB0cnVlLCAwKTtcbiAgfVxufTtcblxuX3F1aWNrY3NzLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHJ1bGUsIGxldmVsLCBpbXBvcnRhbnQpIHtcbiAgdmFyIGNsYXNzTmFtZSwgcmVmLCBzdHlsZTtcblxuICBpZiAocnVsZSAmJiBfdHlwZW9mKHJ1bGUpID09PSAnb2JqZWN0Jykge1xuICAgIGxldmVsIHx8IChsZXZlbCA9IDApO1xuICAgIHJ1bGUgPSBydWxlVG9TdHJpbmcocnVsZSwgaW1wb3J0YW50KTtcblxuICAgIGlmICghKGNsYXNzTmFtZSA9IChyZWYgPSBpbmxpbmVTdHlsZUNvbmZpZ1tsZXZlbF0pICE9IG51bGwgPyByZWZbcnVsZV0gOiB2b2lkIDApKSB7XG4gICAgICBjbGFzc05hbWUgPSBoYXNoKHJ1bGUpO1xuICAgICAgc3R5bGUgPSBcIi5cIi5jb25jYXQoY2xhc3NOYW1lLCBcIiB7XCIpLmNvbmNhdChydWxlLCBcIn1cIik7XG4gICAgICBpbmxpbmVTdHlsZShzdHlsZSwgY2xhc3NOYW1lLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxufTtcblxuX3F1aWNrY3NzLmNsZWFyUmVnaXN0ZXJlZCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICByZXR1cm4gY2xlYXJJbmxpbmVTdHlsZShsZXZlbCB8fCAwKTtcbn07XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5cbl9xdWlja2Nzcy5VTlNFVCA9IGZ1bmN0aW9uICgpIHtcbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIWlzVmFsdWVTdXBwb3J0ZWQoJ2Rpc3BsYXknLCAndW5zZXQnKTpcbiAgICAgIHJldHVybiAndW5zZXQnO1xuXG4gICAgY2FzZSAhaXNWYWx1ZVN1cHBvcnRlZCgnZGlzcGxheScsICdpbml0aWFsJyk6XG4gICAgICByZXR1cm4gJ2luaXRpYWwnO1xuXG4gICAgY2FzZSAhaXNWYWx1ZVN1cHBvcnRlZCgnZGlzcGxheScsICdpbmhlcml0Jyk6XG4gICAgICByZXR1cm4gJ2luaGVyaXQnO1xuICB9XG59KCk7XG5cbl9xdWlja2Nzcy5zdXBwb3J0cyA9IGlzVmFsdWVTdXBwb3J0ZWQ7XG5fcXVpY2tjc3Muc3VwcG9ydHNQcm9wZXJ0eSA9IGlzUHJvcFN1cHBvcnRlZDtcbl9xdWlja2Nzcy5ub3JtYWxpemVQcm9wZXJ0eSA9IG5vcm1hbGl6ZVByb3BlcnR5O1xuX3F1aWNrY3NzLm5vcm1hbGl6ZVZhbHVlID0gbm9ybWFsaXplVmFsdWU7XG5fcXVpY2tjc3MudmVyc2lvbiA9IHZlcnNpb247ZXhwb3J0IGRlZmF1bHQgaW5kZXg7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufXZhciBfZXh0ZW5kLCBpc0FycmF5LCBpc09iamVjdCwgX3Nob3VsZERlZXBFeHRlbmQ7XG5cbmlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KHRhcmdldCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0YXJnZXQpO1xufTtcblxuaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGFyZ2V0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgfHwgaXNBcnJheSh0YXJnZXQpO1xufTtcblxuX3Nob3VsZERlZXBFeHRlbmQgPSBmdW5jdGlvbiBzaG91bGREZWVwRXh0ZW5kKG9wdGlvbnMsIHRhcmdldCwgcGFyZW50S2V5KSB7XG4gIGlmIChvcHRpb25zLmRlZXApIHtcbiAgICBpZiAob3B0aW9ucy5ub3REZWVwKSB7XG4gICAgICByZXR1cm4gIW9wdGlvbnMubm90RGVlcFt0YXJnZXRdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5kZWVwT25seSkge1xuICAgIHJldHVybiBvcHRpb25zLmRlZXBPbmx5W3RhcmdldF0gfHwgcGFyZW50S2V5ICYmIF9zaG91bGREZWVwRXh0ZW5kKG9wdGlvbnMsIHBhcmVudEtleSk7XG4gIH1cbn07IC8vIGVsc2UgZmFsc2VcblxuXG52YXIgZXh0ZW5kID0gX2V4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZChvcHRpb25zLCB0YXJnZXQsIHNvdXJjZXMsIHBhcmVudEtleSkge1xuICB2YXIgaSwga2V5LCBsZW4sIHNvdXJjZSwgc291cmNlVmFsdWUsIHN1YlRhcmdldCwgdGFyZ2V0VmFsdWU7XG5cbiAgaWYgKCF0YXJnZXQgfHwgX3R5cGVvZih0YXJnZXQpICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGFyZ2V0ID0ge307XG4gIH1cblxuICBmb3IgKGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc291cmNlID0gc291cmNlc1tpXTtcblxuICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIHNvdXJjZVZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgIHRhcmdldFZhbHVlID0gdGFyZ2V0W2tleV07XG5cbiAgICAgICAgaWYgKHNvdXJjZVZhbHVlID09PSB0YXJnZXQgfHwgc291cmNlVmFsdWUgPT09IHZvaWQgMCB8fCBzb3VyY2VWYWx1ZSA9PT0gbnVsbCAmJiAhb3B0aW9ucy5hbGxvd051bGwgJiYgIW9wdGlvbnMubnVsbERlbGV0ZXMgfHwgb3B0aW9ucy5rZXlzICYmICFvcHRpb25zLmtleXNba2V5XSB8fCBvcHRpb25zLm5vdEtleXMgJiYgb3B0aW9ucy5ub3RLZXlzW2tleV0gfHwgb3B0aW9ucy5vd24gJiYgIXNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpIHx8IG9wdGlvbnMuZ2xvYmFsRmlsdGVyICYmICFvcHRpb25zLmdsb2JhbEZpbHRlcihzb3VyY2VWYWx1ZSwga2V5LCBzb3VyY2UpIHx8IG9wdGlvbnMuZmlsdGVycyAmJiBvcHRpb25zLmZpbHRlcnNba2V5XSAmJiAhb3B0aW9ucy5maWx0ZXJzW2tleV0oc291cmNlVmFsdWUsIGtleSwgc291cmNlKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvdXJjZVZhbHVlID09PSBudWxsICYmIG9wdGlvbnMubnVsbERlbGV0ZXMpIHtcbiAgICAgICAgICBkZWxldGUgdGFyZ2V0W2tleV07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5nbG9iYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBzb3VyY2VWYWx1ZSA9IG9wdGlvbnMuZ2xvYmFsVHJhbnNmb3JtKHNvdXJjZVZhbHVlLCBrZXksIHNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy50cmFuc2Zvcm1zICYmIG9wdGlvbnMudHJhbnNmb3Jtc1trZXldKSB7XG4gICAgICAgICAgc291cmNlVmFsdWUgPSBvcHRpb25zLnRyYW5zZm9ybXNba2V5XShzb3VyY2VWYWx1ZSwga2V5LCBzb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgIGNhc2UgIShvcHRpb25zLmNvbmNhdCAmJiBpc0FycmF5KHNvdXJjZVZhbHVlKSAmJiBpc0FycmF5KHRhcmdldFZhbHVlKSk6XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHRhcmdldFZhbHVlLmNvbmNhdChzb3VyY2VWYWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgIShfc2hvdWxkRGVlcEV4dGVuZChvcHRpb25zLCBrZXksIHBhcmVudEtleSkgJiYgaXNPYmplY3Qoc291cmNlVmFsdWUpKTpcbiAgICAgICAgICAgIHN1YlRhcmdldCA9IGlzT2JqZWN0KHRhcmdldFZhbHVlKSA/IHRhcmdldFZhbHVlIDogaXNBcnJheShzb3VyY2VWYWx1ZSkgPyBbXSA6IHt9O1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBfZXh0ZW5kKG9wdGlvbnMsIHN1YlRhcmdldCwgW3NvdXJjZVZhbHVlXSwga2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTt2YXIgdmVyc2lvbiA9IFwiMS43LjRcIjt2YXIgbW9kaWZpZXJzLCBuZXdCdWlsZGVyLCBub3JtYWxpemVLZXlzLCBwcmltYXJ5QnVpbGRlcjtcblxubm9ybWFsaXplS2V5cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUtleXMoa2V5cykge1xuICB2YXIgaSwga2V5LCBsZW4sIG91dHB1dDtcblxuICBpZiAoa2V5cykge1xuICAgIG91dHB1dCA9IHt9O1xuXG4gICAgaWYgKF90eXBlb2Yoa2V5cykgIT09ICdvYmplY3QnKSB7XG4gICAgICBvdXRwdXRba2V5c10gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGtleXMpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIG91dHB1dFtrZXldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG59O1xuXG5uZXdCdWlsZGVyID0gZnVuY3Rpb24gbmV3QnVpbGRlcihpc0Jhc2UpIHtcbiAgdmFyIF9idWlsZGVyO1xuXG4gIF9idWlsZGVyID0gZnVuY3Rpb24gYnVpbGRlcih0YXJnZXQpIHtcbiAgICB2YXIgdGhlVGFyZ2V0O1xuICAgIHZhciAkX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsICRfaSA9IC0xLCBzb3VyY2VzID0gbmV3IEFycmF5KCRfbGVuKTsgd2hpbGUgKCsrJF9pIDwgJF9sZW4pIHNvdXJjZXNbJF9pXSA9IGFyZ3VtZW50c1skX2ldO1xuXG4gICAgaWYgKF9idWlsZGVyLm9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICB0aGVUYXJnZXQgPSBfYnVpbGRlci5vcHRpb25zLnRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhlVGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgc291cmNlcy5zaGlmdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBleHRlbmQoX2J1aWxkZXIub3B0aW9ucywgdGhlVGFyZ2V0LCBzb3VyY2VzKTtcbiAgfTtcblxuICBpZiAoaXNCYXNlKSB7XG4gICAgX2J1aWxkZXIuaXNCYXNlID0gdHJ1ZTtcbiAgfVxuXG4gIF9idWlsZGVyLm9wdGlvbnMgPSB7fTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX2J1aWxkZXIsIG1vZGlmaWVycyk7XG4gIHJldHVybiBfYnVpbGRlcjtcbn07XG5cbm1vZGlmaWVycyA9IHtcbiAgJ2RlZXAnOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgXztcblxuICAgICAgXyA9IHRoaXMuaXNCYXNlID8gbmV3QnVpbGRlcigpIDogdGhpcztcbiAgICAgIF8ub3B0aW9ucy5kZWVwID0gdHJ1ZTtcbiAgICAgIHJldHVybiBfO1xuICAgIH1cbiAgfSxcbiAgJ293bic6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgXy5vcHRpb25zLm93biA9IHRydWU7XG4gICAgICByZXR1cm4gXztcbiAgICB9XG4gIH0sXG4gICdhbGxvd051bGwnOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgXztcblxuICAgICAgXyA9IHRoaXMuaXNCYXNlID8gbmV3QnVpbGRlcigpIDogdGhpcztcbiAgICAgIF8ub3B0aW9ucy5hbGxvd051bGwgPSB0cnVlO1xuICAgICAgcmV0dXJuIF87XG4gICAgfVxuICB9LFxuICAnbnVsbERlbGV0ZXMnOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgXztcblxuICAgICAgXyA9IHRoaXMuaXNCYXNlID8gbmV3QnVpbGRlcigpIDogdGhpcztcbiAgICAgIF8ub3B0aW9ucy5udWxsRGVsZXRlcyA9IHRydWU7XG4gICAgICByZXR1cm4gXztcbiAgICB9XG4gIH0sXG4gICdjb25jYXQnOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgXztcblxuICAgICAgXyA9IHRoaXMuaXNCYXNlID8gbmV3QnVpbGRlcigpIDogdGhpcztcbiAgICAgIF8ub3B0aW9ucy5jb25jYXQgPSB0cnVlO1xuICAgICAgcmV0dXJuIF87XG4gICAgfVxuICB9LFxuICAnY2xvbmUnOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgXztcblxuICAgICAgXyA9IHRoaXMuaXNCYXNlID8gbmV3QnVpbGRlcigpIDogdGhpcztcbiAgICAgIF8ub3B0aW9ucy50YXJnZXQgPSB7fTtcbiAgICAgIHJldHVybiBfO1xuICAgIH1cbiAgfSxcbiAgJ25vdERlZXAnOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgXztcblxuICAgICAgXyA9IHRoaXMuaXNCYXNlID8gbmV3QnVpbGRlcigpIDogdGhpcztcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICBfLm9wdGlvbnMubm90RGVlcCA9IG5vcm1hbGl6ZUtleXMoa2V5cyk7XG4gICAgICAgIHJldHVybiBfO1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gICdkZWVwT25seSc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIF8ub3B0aW9ucy5kZWVwT25seSA9IG5vcm1hbGl6ZUtleXMoa2V5cyk7XG4gICAgICAgIHJldHVybiBfO1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gICdrZXlzJzoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF87XG5cbiAgICAgIF8gPSB0aGlzLmlzQmFzZSA/IG5ld0J1aWxkZXIoKSA6IHRoaXM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgXy5vcHRpb25zLmtleXMgPSBub3JtYWxpemVLZXlzKGtleXMpO1xuICAgICAgICByZXR1cm4gXztcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAnbm90S2V5cyc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIF8ub3B0aW9ucy5ub3RLZXlzID0gbm9ybWFsaXplS2V5cyhrZXlzKTtcbiAgICAgICAgcmV0dXJuIF87XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgJ3RyYW5zZm9ybSc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBfLm9wdGlvbnMuZ2xvYmFsVHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybSAmJiBfdHlwZW9mKHRyYW5zZm9ybSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgXy5vcHRpb25zLnRyYW5zZm9ybXMgPSB0cmFuc2Zvcm07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXztcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAnZmlsdGVyJzoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF87XG5cbiAgICAgIF8gPSB0aGlzLmlzQmFzZSA/IG5ld0J1aWxkZXIoKSA6IHRoaXM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIF8ub3B0aW9ucy5nbG9iYWxGaWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsdGVyICYmIF90eXBlb2YoZmlsdGVyKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBfLm9wdGlvbnMuZmlsdGVycyA9IGZpbHRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5wcmltYXJ5QnVpbGRlciA9IG5ld0J1aWxkZXIodHJ1ZSk7XG5wcmltYXJ5QnVpbGRlci52ZXJzaW9uID0gdmVyc2lvbjtcbnZhciBwcmltYXJ5QnVpbGRlciQxID0gcHJpbWFyeUJ1aWxkZXI7ZXhwb3J0IGRlZmF1bHQgcHJpbWFyeUJ1aWxkZXIkMTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn12YXIgZGVmaW5lZCA9IGZ1bmN0aW9uIGRlZmluZWQoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdCAhPT0gdm9pZCAwO1xufTtcbnZhciBhcnJheSA9IGZ1bmN0aW9uIGFycmF5KHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QgaW5zdGFuY2VvZiBBcnJheTtcbn07XG52YXIgb2JqZWN0ID0gZnVuY3Rpb24gb2JqZWN0KHN1YmplY3QpIHtcbiAgcmV0dXJuIF90eXBlb2Yoc3ViamVjdCkgPT09ICdvYmplY3QnICYmIHN1YmplY3Q7IC8vIDJuZCBjaGVjayBpcyB0byB0ZXN0IGFnYWluc3QgJ251bGwnIHZhbHVlc1xufTtcbnZhciBvYmplY3RQbGFpbiA9IGZ1bmN0aW9uIG9iamVjdFBsYWluKHN1YmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdChzdWJqZWN0KSAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViamVjdCkgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmIHN1YmplY3QuY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn07XG52YXIgc3RyaW5nID0gZnVuY3Rpb24gc3RyaW5nKHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAnc3RyaW5nJztcbn07XG52YXIgbnVtYmVyID0gZnVuY3Rpb24gbnVtYmVyKHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oc3ViamVjdCk7XG59O1xudmFyIG51bWJlckxvb3NlID0gZnVuY3Rpb24gbnVtYmVyTG9vc2Uoc3ViamVjdCkge1xuICByZXR1cm4gbnVtYmVyKHN1YmplY3QpIHx8IHN0cmluZyhzdWJqZWN0KSAmJiBudW1iZXIoTnVtYmVyKHN1YmplY3QpKTtcbn07XG52YXIgaXRlcmFibGUgPSBmdW5jdGlvbiBpdGVyYWJsZShzdWJqZWN0KSB7XG4gIHJldHVybiBvYmplY3Qoc3ViamVjdCkgJiYgbnVtYmVyKHN1YmplY3QubGVuZ3RoKTtcbn07XG52YXIgZnVuY3Rpb25fID0gZnVuY3Rpb24gZnVuY3Rpb25fKHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAnZnVuY3Rpb24nO1xufTt2YXIgbmF0aXZlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtkZWZpbmVkOiBkZWZpbmVkLGFycmF5OiBhcnJheSxvYmplY3Q6IG9iamVjdCxvYmplY3RQbGFpbjogb2JqZWN0UGxhaW4sc3RyaW5nOiBzdHJpbmcsbnVtYmVyOiBudW1iZXIsbnVtYmVyTG9vc2U6IG51bWJlckxvb3NlLGl0ZXJhYmxlOiBpdGVyYWJsZSxmdW5jdGlvbl86IGZ1bmN0aW9uX30pO3ZhciBkb21Eb2MgPSBmdW5jdGlvbiBkb21Eb2Moc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdCAmJiBzdWJqZWN0Lm5vZGVUeXBlID09PSA5O1xufTtcbnZhciBkb21FbCA9IGZ1bmN0aW9uIGRvbUVsKHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QgJiYgc3ViamVjdC5ub2RlVHlwZSA9PT0gMTtcbn07XG52YXIgZG9tVGV4dCA9IGZ1bmN0aW9uIGRvbVRleHQoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdCAmJiBzdWJqZWN0Lm5vZGVUeXBlID09PSAzO1xufTtcbnZhciBkb21Ob2RlID0gZnVuY3Rpb24gZG9tTm9kZShzdWJqZWN0KSB7XG4gIHJldHVybiBkb21FbChzdWJqZWN0KSB8fCBkb21UZXh0KHN1YmplY3QpO1xufTtcbnZhciBkb21UZXh0YXJlYSA9IGZ1bmN0aW9uIGRvbVRleHRhcmVhKHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QgJiYgc3ViamVjdC5ub2RlTmFtZSA9PT0gJ1RFWFRBUkVBJztcbn07XG52YXIgZG9tSW5wdXQgPSBmdW5jdGlvbiBkb21JbnB1dChzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0ICYmIHN1YmplY3Qubm9kZU5hbWUgPT09ICdJTlBVVCc7XG59O1xudmFyIGRvbVNlbGVjdCA9IGZ1bmN0aW9uIGRvbVNlbGVjdChzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0ICYmIHN1YmplY3Qubm9kZU5hbWUgPT09ICdTRUxFQ1QnO1xufTtcbnZhciBkb21GaWVsZCA9IGZ1bmN0aW9uIGRvbUZpZWxkKHN1YmplY3QpIHtcbiAgcmV0dXJuIGRvbUlucHV0KHN1YmplY3QpIHx8IGRvbVRleHRhcmVhKHN1YmplY3QpIHx8IGRvbVNlbGVjdChzdWJqZWN0KTtcbn07dmFyIGRvbSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtkb21Eb2M6IGRvbURvYyxkb21FbDogZG9tRWwsZG9tVGV4dDogZG9tVGV4dCxkb21Ob2RlOiBkb21Ob2RlLGRvbVRleHRhcmVhOiBkb21UZXh0YXJlYSxkb21JbnB1dDogZG9tSW5wdXQsZG9tU2VsZWN0OiBkb21TZWxlY3QsZG9tRmllbGQ6IGRvbUZpZWxkfSk7dmFyIEFWQUlMX1NFVFMsIENoZWNrcztcbkFWQUlMX1NFVFMgPSB7XG4gIG5hdGl2ZXM6IG5hdGl2ZXMsXG4gIGRvbTogZG9tXG59O1xuXG5DaGVja3MgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBfY3JlYXRlQ2xhc3MoQ2hlY2tzLCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgdmFyIGFyZ3M7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IENoZWNrcyhhcmdzKTtcbiAgICB9XG4gIH1dKTtcblxuICBmdW5jdGlvbiBDaGVja3Moc2V0cykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaGVja3MpO1xuXG4gICAgdmFyIGksIGxlbiwgc2V0O1xuXG4gICAgaWYgKHNldHMgPT0gbnVsbCkge1xuICAgICAgc2V0cyA9IFsnbmF0aXZlcyddO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHNldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNldCA9IHNldHNbaV07XG5cbiAgICAgIGlmIChBVkFJTF9TRVRTW3NldF0pIHtcbiAgICAgICAgdGhpcy5sb2FkKEFWQUlMX1NFVFNbc2V0XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENoZWNrcywgW3tcbiAgICBrZXk6IFwibG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKHNldCkge1xuICAgICAgdmFyIGtleSwgdmFsdWU7XG5cbiAgICAgIGlmIChBVkFJTF9TRVRTLm5hdGl2ZXMuc3RyaW5nKHNldCkpIHtcbiAgICAgICAgc2V0ID0gQVZBSUxfU0VUU1tzZXRdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIUFWQUlMX1NFVFMubmF0aXZlcy5vYmplY3RQbGFpbihzZXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yIChrZXkgaW4gc2V0KSB7XG4gICAgICAgIHZhbHVlID0gc2V0W2tleV07XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2Z1bmN0aW9uXycpIHtcbiAgICAgICAgICBrZXkgPSAnZnVuY3Rpb24nO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENoZWNrcztcbn0oKTtcblxudmFyIGluZGV4ID0gQ2hlY2tzLnByb3RvdHlwZS5jcmVhdGUoKTtleHBvcnQgZGVmYXVsdCBpbmRleDsiLCJpbXBvcnQgQ1NTIGZyb20ncXVpY2tjc3MnO2ltcG9ydCBleHRlbmQgZnJvbSdzbWFydC1leHRlbmQnO2ltcG9ydCBJU18gZnJvbSdAZGFuaWVsa2FsZW4vaXMnO2Z1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufXZhciB0ZW1wbGF0ZSA9IFsnaWQnLCAnbmFtZScsICd0eXBlJywgJ2hyZWYnLCAnc2VsZWN0ZWQnLCAnY2hlY2tlZCcsICdjbGFzc05hbWUnXTsgLy8gVG8gY29weSBmcm9tIERPTSBFbGVtZW50c1xuXG52YXIgZWxlbWVudCA9IFsnaWQnLCAncmVmJywgJ3R5cGUnLCAnbmFtZScsICd0ZXh0JywgJ3N0eWxlJywgJ2NsYXNzJywgJ2NsYXNzTmFtZScsICd1cmwnLCAnaHJlZicsICdzZWxlY3RlZCcsICdjaGVja2VkJywgJ3Byb3BzJywgJ2F0dHJzJywgJ3Bhc3NTdGF0ZVRvQ2hpbGRyZW4nLCAnc3RhdGVUcmlnZ2VycycsICd1bnBhc3NhYmxlU3RhdGVzJ107IC8vIFVzZWQgaW4gUXVpY2tFbGVtZW50Ojp0b0pTT05cbi8vICdyZWxhdGVkSW5zdGFuY2UnXG52YXIgSVM7XG5JUyA9IElTXy5jcmVhdGUoJ25hdGl2ZXMnLCAnZG9tJyk7XG5JUy5sb2FkKHtcbiAgcXVpY2tEb21FbDogZnVuY3Rpb24gcXVpY2tEb21FbChzdWJqZWN0KSB7XG4gICAgcmV0dXJuIHN1YmplY3QgJiYgc3ViamVjdC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnUXVpY2tFbGVtZW50JztcbiAgfSxcbiAgdGVtcGxhdGU6IGZ1bmN0aW9uIHRlbXBsYXRlKHN1YmplY3QpIHtcbiAgICByZXR1cm4gc3ViamVjdCAmJiBzdWJqZWN0LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdRdWlja1RlbXBsYXRlJztcbiAgfVxufSk7IC8vIGJhdGNoOiAoc3ViamVjdCktPiBzdWJqZWN0IGFuZCBzdWJqZWN0LmNvbnN0cnVjdG9yLm5hbWUgaXMgJ1F1aWNrQmF0Y2gnXG5cbnZhciBJUyQxID0gSVM7dmFyIFF1aWNrRWxlbWVudCwgUXVpY2tXaW5kb3csIF9xdWlja2RvbTtcblF1aWNrRWxlbWVudCA9IG51bGw7XG5RdWlja1dpbmRvdyA9IG51bGw7XG5cbl9xdWlja2RvbSA9IGZ1bmN0aW9uIHF1aWNrZG9tKCkge1xuICB2YXIgYXJnLCBhcmdzLCBlbGVtZW50LCBpLCBqLCBsZW4sIHByZXZDb3VudDtcbiAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcblxuICBmb3IgKGkgPSBqID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaiA8IGxlbjsgaSA9ICsraikge1xuICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICBhcmdzW2ldID0gYXJnO1xuICB9XG5cbiAgcHJldkNvdW50ID0gUXVpY2tFbGVtZW50LmNvdW50O1xuICBlbGVtZW50ID0gX3F1aWNrZG9tLmNyZWF0ZShhcmdzKTtcblxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9wb3N0Q3JlYXRpb24gJiYgUXVpY2tFbGVtZW50LmNvdW50ICE9PSBwcmV2Q291bnQpIHtcbiAgICBlbGVtZW50Ll9wb3N0Q3JlYXRpb24oKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuX3F1aWNrZG9tLmNyZWF0ZSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gIHZhciBhcmdzTGVuZ3RoLCBjaGlsZCwgY2hpbGRyZW4sIGVsZW1lbnQsIGksIGosIGxlbiwgb3B0aW9ucywgdHlwZTtcblxuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhSVMkMS5hcnJheShhcmdzWzBdKTpcbiAgICAgIHJldHVybiBfcXVpY2tkb20uYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJnc1swXSkpO1xuXG4gICAgY2FzZSAhSVMkMS50ZW1wbGF0ZShhcmdzWzBdKTpcbiAgICAgIHJldHVybiBhcmdzWzBdLnNwYXduKCk7XG5cbiAgICBjYXNlICFJUyQxLnF1aWNrRG9tRWwoYXJnc1swXSk6XG4gICAgICBpZiAoYXJnc1sxXSkge1xuICAgICAgICByZXR1cm4gYXJnc1swXS51cGRhdGVPcHRpb25zKGFyZ3NbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICB9XG5cbiAgICBjYXNlICEoSVMkMS5kb21Ob2RlKGFyZ3NbMF0pIHx8IElTJDEuZG9tRG9jKGFyZ3NbMF0pKTpcbiAgICAgIGlmIChhcmdzWzBdLl9xdWlja0VsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbMF0uX3F1aWNrRWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgdHlwZSA9IGFyZ3NbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCcjJywgJycpO1xuICAgICAgb3B0aW9ucyA9IGFyZ3NbMV0gfHwge307XG4gICAgICBvcHRpb25zLmV4aXN0aW5nID0gYXJnc1swXTtcbiAgICAgIHJldHVybiBuZXcgUXVpY2tFbGVtZW50KHR5cGUsIG9wdGlvbnMpO1xuXG4gICAgY2FzZSBhcmdzWzBdICE9PSB3aW5kb3c6XG4gICAgICByZXR1cm4gUXVpY2tXaW5kb3c7XG5cbiAgICBjYXNlICFJUyQxLnN0cmluZyhhcmdzWzBdKTpcbiAgICAgIHR5cGUgPSBhcmdzWzBdLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgb3B0aW9ucyA9IElTJDEub2JqZWN0KGFyZ3NbMV0pID8gYXJnc1sxXSA6IHtcbiAgICAgICAgICB0ZXh0OiBhcmdzWzFdIHx8ICcnXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0gSVMkMS5vYmplY3QoYXJnc1sxXSkgPyBhcmdzWzFdIDoge307XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQgPSBuZXcgUXVpY2tFbGVtZW50KHR5cGUsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAyKSB7XG4gICAgICAgIGNoaWxkcmVuID0gbmV3IEFycmF5KGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCk7XG4gICAgICAgIGkgPSAxO1xuXG4gICAgICAgIHdoaWxlICgrK2kgPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gYXJnc1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltqXTtcblxuICAgICAgICAgIGlmIChJUyQxLnN0cmluZyhjaGlsZCkpIHtcbiAgICAgICAgICAgIGNoaWxkID0gX3F1aWNrZG9tLnRleHQoY2hpbGQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChJUyQxLmFycmF5KGNoaWxkKSkge1xuICAgICAgICAgICAgY2hpbGQgPSBfcXVpY2tkb20uYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoY2hpbGQpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSVMkMS5xdWlja0RvbUVsKGNoaWxkKSkge1xuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmQoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlbWVudDtcblxuICAgIGNhc2UgIShhcmdzWzBdICYmIChJUyQxLmRvbU5vZGUoYXJnc1swXVswXSkgfHwgSVMkMS5kb21Eb2MoYXJnc1swXVswXSkpKTpcbiAgICAgIHJldHVybiBfcXVpY2tkb20oYXJnc1swXVswXSk7XG4gIH1cbn07XG5cbl9xdWlja2RvbS5odG1sID0gZnVuY3Rpb24gKGlubmVySFRNTCkge1xuICB2YXIgY2hpbGRyZW4sIGNvbnRhaW5lcjtcbiAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnRhaW5lci5pbm5lckhUTUwgPSBpbm5lckhUTUw7XG4gIGNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGFpbmVyLmNoaWxkTm9kZXMpO1xuICByZXR1cm4gX3F1aWNrZG9tLmJhdGNoKGNoaWxkcmVuKTtcbn07XG5cbl9xdWlja2RvbS5pc1F1aWNrRWwgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHJldHVybiBJUyQxLnF1aWNrRG9tRWwodGFyZ2V0KTtcbn07XG5cbl9xdWlja2RvbS5pc0VsID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICByZXR1cm4gSVMkMS5kb21FbCh0YXJnZXQpO1xufTtcbnZhciBpbml0ID0gZnVuY3Rpb24gaW5pdChRdWlja0VsZW1lbnRfLCBRdWlja1dpbmRvd18pIHtcbiAgUXVpY2tFbGVtZW50ID0gUXVpY2tFbGVtZW50XztcbiAgUXVpY2tXaW5kb3cgPSBRdWlja1dpbmRvd187XG4gIHJldHVybiBfcXVpY2tkb207XG59O3ZhciBpbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzKHRhcmdldCwgaXRlbSkge1xuICByZXR1cm4gdGFyZ2V0ICYmIHRhcmdldC5pbmRleE9mKGl0ZW0pICE9PSAtMTtcbn07XG52YXIgcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIHJlbW92ZUl0ZW0odGFyZ2V0LCBpdGVtKSB7XG4gIHZhciBpdGVtSW5kZXg7XG4gIGl0ZW1JbmRleCA9IHRhcmdldC5pbmRleE9mKGl0ZW0pO1xuXG4gIGlmIChpdGVtSW5kZXggIT09IC0xKSB7XG4gICAgdGFyZ2V0LnNwbGljZShpdGVtSW5kZXgsIDEpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgbm9ybWFsaXplRWxlbWVudEFyZyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUVsZW1lbnRBcmcodGFyZ2V0RWwpIHtcbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIUlTJDEuc3RyaW5nKHRhcmdldEVsKTpcbiAgICAgIHJldHVybiBxdWlja2RvbS50ZXh0KHRhcmdldEVsKTtcblxuICAgIGNhc2UgIUlTJDEuZG9tTm9kZSh0YXJnZXRFbCk6XG4gICAgICByZXR1cm4gcXVpY2tkb20odGFyZ2V0RWwpO1xuXG4gICAgY2FzZSAhSVMkMS50ZW1wbGF0ZSh0YXJnZXRFbCk6XG4gICAgICByZXR1cm4gdGFyZ2V0RWwuc3Bhd24oKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdGFyZ2V0RWw7XG4gIH1cbn07XG52YXIgaXNTdGF0ZVN0eWxlID0gZnVuY3Rpb24gaXNTdGF0ZVN0eWxlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nWzBdID09PSAnJCcgfHwgc3RyaW5nWzBdID09PSAnQCc7XG59O1xudmFyIHJlZ2lzdGVyU3R5bGUgPSBmdW5jdGlvbiByZWdpc3RlclN0eWxlKHJ1bGUsIGxldmVsLCBpbXBvcnRhbnQpIHtcbiAgdmFyIGNhY2hlZCwgaSwgbGVuLCBvdXRwdXQsIHByb3AsIHByb3BzO1xuICBsZXZlbCB8fCAobGV2ZWwgPSAwKTtcbiAgY2FjaGVkID0gc3R5bGVDYWNoZS5nZXQocnVsZSwgbGV2ZWwpO1xuXG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG5cbiAgb3V0cHV0ID0ge1xuICAgIGNsYXNzTmFtZTogW0NTUy5yZWdpc3RlcihydWxlLCBsZXZlbCwgaW1wb3J0YW50KV0sXG4gICAgZm5zOiBbXSxcbiAgICBydWxlOiBydWxlXG4gIH07XG4gIHByb3BzID0gT2JqZWN0LmtleXMocnVsZSk7XG5cbiAgZm9yIChpID0gMCwgbGVuID0gcHJvcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBwcm9wID0gcHJvcHNbaV07XG5cbiAgICBpZiAodHlwZW9mIHJ1bGVbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG91dHB1dC5mbnMucHVzaChbcHJvcCwgcnVsZVtwcm9wXV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHlsZUNhY2hlLnNldChydWxlLCBvdXRwdXQsIGxldmVsKTtcbn07XG52YXIgc3R5bGVDYWNoZSA9IG5ldyAoXG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIF9jbGFzcygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2NsYXNzKTtcblxuICAgIHRoaXMua2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy52YWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9jbGFzcywgW3tcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChrZXksIGxldmVsKSB7XG4gICAgICB2YXIgaW5kZXg7XG5cbiAgICAgIGlmICh0aGlzLmtleXNbbGV2ZWxdKSB7XG4gICAgICAgIGluZGV4ID0gdGhpcy5rZXlzW2xldmVsXS5pbmRleE9mKGtleSk7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1tsZXZlbF1baW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSwgbGV2ZWwpIHtcbiAgICAgIGlmICghdGhpcy5rZXlzW2xldmVsXSkge1xuICAgICAgICB0aGlzLmtleXNbbGV2ZWxdID0gW107XG4gICAgICAgIHRoaXMudmFsdWVzW2xldmVsXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmtleXNbbGV2ZWxdLnB1c2goa2V5KTtcbiAgICAgIHRoaXMudmFsdWVzW2xldmVsXS5wdXNoKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2NsYXNzO1xufSgpKSgpO3ZhciBSRUdFWF9XSElURVNQQUNFO1xuUkVHRVhfV0hJVEVTUEFDRSA9IC9cXHMrLztcbnZhciBvbl8gPSBmdW5jdGlvbiBvbl8oZXZlbnROYW1lcywgY2FsbGJhY2ssIHVzZUNhcHR1cmUsIGlzUHJpdmF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBjYWxsYmFja1JlZiwgc3BsaXQ7XG5cbiAgaWYgKHRoaXMuX2V2ZW50Q2FsbGJhY2tzID09IG51bGwpIHtcbiAgICB0aGlzLl9ldmVudENhbGxiYWNrcyA9IHtcbiAgICAgIF9fcmVmczoge31cbiAgICB9O1xuICB9XG5cbiAgaWYgKElTJDEuc3RyaW5nKGV2ZW50TmFtZXMpICYmIElTJDEuZnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgc3BsaXQgPSBldmVudE5hbWVzLnNwbGl0KCcuJyk7XG4gICAgY2FsbGJhY2tSZWYgPSBzcGxpdFsxXTtcbiAgICBldmVudE5hbWVzID0gc3BsaXRbMF07XG5cbiAgICBpZiAoZXZlbnROYW1lcyA9PT0gJ2luc2VydGVkJyAmJiB0aGlzLl9pbnNlcnRlZCkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLl9wYXJlbnQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZXZlbnROYW1lcy5zcGxpdChSRUdFWF9XSElURVNQQUNFKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgIHZhciBiYXNlO1xuXG4gICAgICBpZiAoIV90aGlzLl9ldmVudENhbGxiYWNrc1tldmVudE5hbWVdKSB7XG4gICAgICAgIF90aGlzLl9ldmVudENhbGxiYWNrc1tldmVudE5hbWVdID0gW107XG5cbiAgICAgICAgaWYgKCFpc1ByaXZhdGUpIHtcbiAgICAgICAgICBfdGhpcy5fbGlzdGVuVG8oZXZlbnROYW1lLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5faW52b2tlSGFuZGxlcnMoZXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgICAgfSwgdXNlQ2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNhbGxiYWNrUmVmKSB7XG4gICAgICAgIGlmICgoYmFzZSA9IF90aGlzLl9ldmVudENhbGxiYWNrcy5fX3JlZnMpW2V2ZW50TmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgIGJhc2VbZXZlbnROYW1lXSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuX2V2ZW50Q2FsbGJhY2tzLl9fcmVmc1tldmVudE5hbWVdW2NhbGxiYWNrUmVmXSA9IGNhbGxiYWNrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMuX2V2ZW50Q2FsbGJhY2tzW2V2ZW50TmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgb25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnROYW1lcywgY2FsbGJhY2spIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgdmFyIF9vbmNlQ2FsbGJhY2s7XG5cbiAgaWYgKElTJDEuc3RyaW5nKGV2ZW50TmFtZXMpICYmIElTJDEuZnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgdGhpcy5vbihldmVudE5hbWVzLCBfb25jZUNhbGxiYWNrID0gZnVuY3Rpb24gb25jZUNhbGxiYWNrKGV2ZW50KSB7XG4gICAgICBfdGhpczIub2ZmKGV2ZW50TmFtZXMsIF9vbmNlQ2FsbGJhY2spO1xuXG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChfdGhpczIsIGV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBvZmZfID0gZnVuY3Rpb24gb2ZmXyhldmVudE5hbWVzLCBjYWxsYmFjaykge1xuICB2YXIgX3RoaXMzID0gdGhpcztcblxuICB2YXIgY2FsbGJhY2tSZWYsIGV2ZW50TmFtZSwgc3BsaXQ7XG5cbiAgaWYgKHRoaXMuX2V2ZW50Q2FsbGJhY2tzID09IG51bGwpIHtcbiAgICB0aGlzLl9ldmVudENhbGxiYWNrcyA9IHtcbiAgICAgIF9fcmVmczoge31cbiAgICB9O1xuICB9XG5cbiAgaWYgKCFJUyQxLnN0cmluZyhldmVudE5hbWVzKSkge1xuICAgIGZvciAoZXZlbnROYW1lIGluIHRoaXMuX2V2ZW50Q2FsbGJhY2tzKSB7XG4gICAgICB0aGlzLm9mZihldmVudE5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzcGxpdCA9IGV2ZW50TmFtZXMuc3BsaXQoJy4nKTtcbiAgICBjYWxsYmFja1JlZiA9IHNwbGl0WzFdO1xuICAgIGV2ZW50TmFtZXMgPSBzcGxpdFswXTtcbiAgICBldmVudE5hbWVzLnNwbGl0KFJFR0VYX1dISVRFU1BBQ0UpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgdmFyIHJlZjtcblxuICAgICAgaWYgKF90aGlzMy5fZXZlbnRDYWxsYmFja3NbZXZlbnROYW1lXSkge1xuICAgICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCkge1xuICAgICAgICAgIGNhbGxiYWNrID0gKHJlZiA9IF90aGlzMy5fZXZlbnRDYWxsYmFja3MuX19yZWZzW2V2ZW50TmFtZV0pICE9IG51bGwgPyByZWZbY2FsbGJhY2tSZWZdIDogdm9pZCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKElTJDEuZnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgcmV0dXJuIHJlbW92ZUl0ZW0oX3RoaXMzLl9ldmVudENhbGxiYWNrc1tldmVudE5hbWVdLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNhbGxiYWNrUmVmKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5fZXZlbnRDYWxsYmFja3NbZXZlbnROYW1lXS5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnROYW1lKSB7XG4gIHZhciBidWJibGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICB2YXIgY2FuY2VsYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgdmFyIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGV2ZW50O1xuXG4gIGlmIChldmVudE5hbWUgJiYgSVMkMS5zdHJpbmcoZXZlbnROYW1lKSkge1xuICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KGV2ZW50TmFtZSwgYnViYmxlcywgY2FuY2VsYWJsZSk7XG5cbiAgICBpZiAoZGF0YSAmJiBfdHlwZW9mKGRhdGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgZXh0ZW5kKGV2ZW50LCBkYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLmVsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGVtaXRQcml2YXRlID0gZnVuY3Rpb24gZW1pdFByaXZhdGUoZXZlbnROYW1lLCBhcmcpIHtcbiAgdmFyIHJlZjtcblxuICBpZiAoZXZlbnROYW1lICYmIElTJDEuc3RyaW5nKGV2ZW50TmFtZSkgJiYgKChyZWYgPSB0aGlzLl9ldmVudENhbGxiYWNrcykgIT0gbnVsbCA/IHJlZltldmVudE5hbWVdIDogdm9pZCAwKSkge1xuICAgIHRoaXMuX2ludm9rZUhhbmRsZXJzKGV2ZW50TmFtZSwgYXJnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBfaW52b2tlSGFuZGxlcnMgPSBmdW5jdGlvbiBfaW52b2tlSGFuZGxlcnMoZXZlbnROYW1lLCBhcmcpIHtcbiAgdmFyIGNhbGxiYWNrcywgY2IsIGksIGxlbjtcbiAgY2FsbGJhY2tzID0gdGhpcy5fZXZlbnRDYWxsYmFja3NbZXZlbnROYW1lXS5zbGljZSgpO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGNiLmNhbGwodGhpcywgYXJnKTtcbiAgfVxufTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbnZhciBfbGlzdGVuVG8gPSBmdW5jdGlvbiBfbGlzdGVuVG8oZXZlbnROYW1lLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSkge1xuICB2YXIgZXZlbnROYW1lVG9MaXN0ZW5Gb3IsIGxpc3Rlbk1ldGhvZDtcbiAgbGlzdGVuTWV0aG9kID0gdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ2F0dGFjaEV2ZW50JztcbiAgZXZlbnROYW1lVG9MaXN0ZW5Gb3IgPSB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIgPyBldmVudE5hbWUgOiBcIm9uXCIuY29uY2F0KGV2ZW50TmFtZSk7XG4gIHRoaXMuZWxbbGlzdGVuTWV0aG9kXShldmVudE5hbWVUb0xpc3RlbkZvciwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpO1xuICByZXR1cm4gdGhpcztcbn07XG5mdW5jdGlvbiBldmVudHMgKFF1aWNrRWxlbWVudCkge1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLm9uID0gb25fO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLm9uY2UgPSBvbmNlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLm9mZiA9IG9mZl87XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuZW1pdCA9IGVtaXQ7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuZW1pdFByaXZhdGUgPSBlbWl0UHJpdmF0ZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5faW52b2tlSGFuZGxlcnMgPSBfaW52b2tlSGFuZGxlcnM7XG4gIHJldHVybiBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9saXN0ZW5UbyA9IF9saXN0ZW5Ubztcbn0vKipcbiAqIFNldHMvZ2V0cyB0aGUgdmFsdWUgb2YgYSBzdHlsZSBwcm9wZXJ0eS4gSW4gZ2V0dGVyIG1vZGUgdGhlIGNvbXB1dGVkIHByb3BlcnR5IG9mXG4gKiB0aGUgc3R5bGUgd2lsbCBiZSByZXR1cm5lZCB1bmxlc3MgdGhlIGVsZW1lbnQgaXMgbm90IGluc2VydGVkIGludG8gdGhlIERPTS4gSW5cbiAqIHdlYmtpdCBicm93c2VycyBhbGwgY29tcHV0ZWQgcHJvcGVydGllcyBvZiBhIGRldGFjaGVkIG5vZGUgYXJlIGFsd2F5cyBhbiBlbXB0eVxuICogc3RyaW5nIGJ1dCBpbiBnZWNrbyB0aGV5IHJlZmxlY3Qgb24gdGhlIGFjdHVhbCBjb21wdXRlZCB2YWx1ZSwgaGVuY2Ugd2UgbmVlZFxuICogdG8gXCJub3JtYWxpemVcIiB0aGlzIGJlaGF2aW9yIGFuZCBtYWtlIHN1cmUgdGhhdCBldmVuIG9uIGdlY2tvIGFuIGVtcHR5IHN0cmluZ1xuICogaXMgcmV0dXJuZWRcbiAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICovXG5cbnZhciBzdHlsZSA9IGZ1bmN0aW9uIHN0eWxlKHByb3BlcnR5KSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIGFyZ3MsIGksIGtleSwga2V5cywgcmVzdWx0LCB2YWx1ZTtcblxuICBpZiAodGhpcy50eXBlID09PSAndGV4dCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBhcmdzID0gYXJndW1lbnRzO1xuXG4gIGlmIChJUyQxLnN0cmluZyhwcm9wZXJ0eSkpIHtcbiAgICB2YWx1ZSA9IHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nID8gYXJnc1sxXS5jYWxsKHRoaXMsIHRoaXMucmVsYXRlZCkgOiBhcmdzWzFdO1xuXG4gICAgaWYgKGFyZ3NbMV0gPT09IG51bGwgJiYgSVMkMS5kZWZpbmVkKHRoaXMuY3VycmVudFN0YXRlU3R5bGUocHJvcGVydHkpKSAmJiAhSVMkMS5mdW5jdGlvbih0aGlzLmN1cnJlbnRTdGF0ZVN0eWxlKHByb3BlcnR5KSkpIHtcbiAgICAgIHZhbHVlID0gQ1NTLlVOU0VUO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIENTUyhfdGhpcy5lbCwgcHJvcGVydHksIHZhbHVlLCBfdGhpcy5vcHRpb25zLmZvcmNlU3R5bGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IENTUyh0aGlzLmVsLCBwcm9wZXJ0eSwgdmFsdWUsIHRoaXMub3B0aW9ucy5mb3JjZVN0eWxlKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBpZiAodGhpcy5faW5zZXJ0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChJUyQxLm9iamVjdChwcm9wZXJ0eSkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydHkpO1xuICAgIGkgPSAtMTtcblxuICAgIHdoaWxlIChrZXkgPSBrZXlzWysraV0pIHtcbiAgICAgIHRoaXMuc3R5bGUoa2V5LCBwcm9wZXJ0eVtrZXldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiogQXR0ZW1wdHMgdG8gcmVzb2x2ZSB0aGUgdmFsdWUgZm9yIGEgZ2l2ZW4gcHJvcGVydHkgaW4gdGhlIGZvbGxvd2luZyBvcmRlciBpZiBlYWNoIG9uZSBpc24ndCBhIHZhbGlkIHZhbHVlOlxuKiAxLiBmcm9tIGNvbXB1dGVkIHN0eWxlIChmb3IgZG9tLWluc2VydGVkIGVscylcbiogMi4gZnJvbSBET01FbGVtZW50LnN0eWxlIG9iamVjdCAoZm9yIG5vbi1pbnNlcnRlZCBlbHM7IGlmIG9wdGlvbnMuc3R5bGVBZnRlckluc2VydCwgd2lsbCBvbmx5IGhhdmUgc3RhdGUgc3R5bGVzKVxuKiAzLiBmcm9tIHByb3ZpZGVkIHN0eWxlIG9wdGlvbnNcbiogKGZvciBub24taW5zZXJ0ZWQgZWxzOyBjaGVja2luZyBvbmx5ICRiYXNlIHNpbmNlIHN0YXRlIHN0eWxlcyB3aWxsIGFsd2F5cyBiZSBhcHBsaWVkIHRvIHRoZSBzdHlsZSBvYmplY3QgZXZlbiBmb3Igbm9uLWluc2VydGVkKVxuICovXG5cbnZhciBzdHlsZVNhZmUgPSBmdW5jdGlvbiBzdHlsZVNhZmUocHJvcGVydHksIHNraXBDb21wdXRlZCkge1xuICB2YXIgY29tcHV0ZWQsIHJlc3VsdCwgc2FtcGxlO1xuXG4gIGlmICh0aGlzLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHNhbXBsZSA9IHRoaXMuZWwuc3R5bGVbcHJvcGVydHldO1xuXG4gIGlmIChJUyQxLnN0cmluZyhzYW1wbGUpIHx8IElTJDEubnVtYmVyKHNhbXBsZSkpIHtcbiAgICBjb21wdXRlZCA9IHNraXBDb21wdXRlZCA/IDAgOiB0aGlzLnN0eWxlKHByb3BlcnR5KTtcbiAgICByZXN1bHQgPSBjb21wdXRlZCB8fCB0aGlzLmVsLnN0eWxlW3Byb3BlcnR5XSB8fCB0aGlzLmN1cnJlbnRTdGF0ZVN0eWxlKHByb3BlcnR5KSB8fCAnJztcblxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LmNhbGwodGhpcywgdGhpcy5yZWxhdGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgc3R5bGVQYXJzZWQgPSBmdW5jdGlvbiBzdHlsZVBhcnNlZChwcm9wZXJ0eSwgc2tpcENvbXB1dGVkKSB7XG4gIHJldHVybiBwYXJzZUZsb2F0KHRoaXMuc3R5bGVTYWZlKHByb3BlcnR5LCBza2lwQ29tcHV0ZWQpKTtcbn07XG52YXIgcmVjYWxjU3R5bGUgPSBmdW5jdGlvbiByZWNhbGNTdHlsZShyZWNhbGNDaGlsZHJlbikge1xuICB2YXIgY2hpbGQsIGosIGxlbiwgcmVmLCB0YXJnZXRTdHlsZXM7XG4gIHRhcmdldFN0eWxlcyA9IHRoaXMuX3Jlc29sdmVGblN0eWxlcyh0aGlzLl9nZXRBY3RpdmVTdGF0ZXMoKSwgdHJ1ZSk7XG4gIHRoaXMuc3R5bGUodGFyZ2V0U3R5bGVzKTtcblxuICBpZiAocmVjYWxjQ2hpbGRyZW4pIHtcbiAgICByZWYgPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgY2hpbGQgPSByZWZbal07XG4gICAgICBjaGlsZC5yZWNhbGNTdHlsZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBjdXJyZW50U3RhdGVTdHlsZSA9IGZ1bmN0aW9uIGN1cnJlbnRTdGF0ZVN0eWxlKHByb3BlcnR5KSB7XG4gIHZhciBpLCBzdGF0ZSwgc3RhdGVzO1xuXG4gIGlmIChwcm9wZXJ0eSkge1xuICAgIGlmICh0aGlzLl9zdGF0ZS5sZW5ndGgpIHtcbiAgICAgIHN0YXRlcyA9IHRoaXMuX3N0YXRlLnNsaWNlKCk7XG5cbiAgICAgIGlmICh0aGlzLl9zdGF0ZVNoYXJlZCAmJiB0aGlzLl9zdGF0ZVNoYXJlZC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIF9zdGF0ZXM7XG5cbiAgICAgICAgKF9zdGF0ZXMgPSBzdGF0ZXMpLnB1c2guYXBwbHkoX3N0YXRlcywgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX3N0YXRlU2hhcmVkKSk7XG4gICAgICB9XG5cbiAgICAgIGkgPSBzdGF0ZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoc3RhdGUgPSBzdGF0ZXNbLS1pXSkge1xuICAgICAgICBpZiAodGhpcy5fc3R5bGVzW3N0YXRlXSAmJiBJUyQxLmRlZmluZWQodGhpcy5fc3R5bGVzW3N0YXRlXS5ydWxlW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGVzW3N0YXRlXS5ydWxlW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdHlsZXMuYmFzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlcy5iYXNlLnJ1bGVbcHJvcGVydHldO1xuICAgIH1cbiAgfVxufTtcbnZhciBoaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcbiAgcmV0dXJuIHRoaXMuc3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpO1xufTtcbnZhciBzaG93ID0gZnVuY3Rpb24gc2hvdyhkaXNwbGF5KSB7XG4gIHZhciByZWY7XG5cbiAgaWYgKCFkaXNwbGF5KSB7XG4gICAgZGlzcGxheSA9IHRoaXMuY3VycmVudFN0YXRlU3R5bGUoJ2Rpc3BsYXknKTtcblxuICAgIGlmIChkaXNwbGF5ID09PSAnbm9uZScgfHwgIWRpc3BsYXkpIHtcbiAgICAgIGRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXNwbGF5ID09IG51bGwpIHtcbiAgICBkaXNwbGF5ID0gKChyZWYgPSB0aGlzLl9zdHlsZXMuYmFzZSkgIT0gbnVsbCA/IHJlZi5kaXNwbGF5IDogdm9pZCAwKSB8fCAnYmxvY2snO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuc3R5bGUoJ2Rpc3BsYXknLCBkaXNwbGF5KTtcbn07XG52YXIgb3JpZW50YXRpb25HZXR0ZXIgPSB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLndpZHRoID4gdGhpcy5oZWlnaHQpIHtcbiAgICAgIHJldHVybiAnbGFuZHNjYXBlJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdwb3J0cmFpdCc7XG4gICAgfVxuICB9XG59O1xudmFyIGFzcGVjdFJhdGlvR2V0dGVyID0ge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0O1xuICB9XG59O1xuZnVuY3Rpb24gc3R5bGUkMSAoUXVpY2tFbGVtZW50KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFF1aWNrRWxlbWVudC5wcm90b3R5cGUsIHtcbiAgICAnb3JpZW50YXRpb24nOiBvcmllbnRhdGlvbkdldHRlcixcbiAgICAnYXNwZWN0UmF0aW8nOiBhc3BlY3RSYXRpb0dldHRlcixcbiAgICAncmVjdCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICd3aWR0aCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLnN0eWxlKCd3aWR0aCcpKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSgnd2lkdGgnLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnaGVpZ2h0Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMuc3R5bGUoJ2hlaWdodCcpKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSgnaGVpZ2h0JywgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuc3R5bGUgPSBzdHlsZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5zdHlsZVNhZmUgPSBzdHlsZVNhZmU7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuc3R5bGVQYXJzZWQgPSBzdHlsZVBhcnNlZDtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5yZWNhbGNTdHlsZSA9IHJlY2FsY1N0eWxlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmN1cnJlbnRTdGF0ZVN0eWxlID0gY3VycmVudFN0YXRlU3R5bGU7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuaGlkZSA9IGhpZGU7XG4gIHJldHVybiBRdWlja0VsZW1lbnQucHJvdG90eXBlLnNob3cgPSBzaG93O1xufXZhciBRdWlja1dpbmRvdyQxO1xudmFyIFF1aWNrV2luZG93JDIgPSBRdWlja1dpbmRvdyQxID0ge1xuICB0eXBlOiAnd2luZG93JyxcbiAgZWw6IHdpbmRvdyxcbiAgcmF3OiB3aW5kb3csXG4gIF9ldmVudENhbGxiYWNrczoge1xuICAgIF9fcmVmczoge31cbiAgfVxufTtcblF1aWNrV2luZG93JDEub24gPSBvbl87XG5RdWlja1dpbmRvdyQxLm9mZiA9IG9mZl87XG5RdWlja1dpbmRvdyQxLmVtaXQgPSBlbWl0O1xuUXVpY2tXaW5kb3ckMS5lbWl0UHJpdmF0ZSA9IGVtaXRQcml2YXRlO1xuUXVpY2tXaW5kb3ckMS5fbGlzdGVuVG8gPSBfbGlzdGVuVG87XG5RdWlja1dpbmRvdyQxLl9pbnZva2VIYW5kbGVycyA9IF9pbnZva2VIYW5kbGVycztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFF1aWNrV2luZG93JDEsIHtcbiAgJ3dpZHRoJzoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIH1cbiAgfSxcbiAgJ2hlaWdodCc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfVxuICB9LFxuICAnb3JpZW50YXRpb24nOiBvcmllbnRhdGlvbkdldHRlcixcbiAgJ2FzcGVjdFJhdGlvJzogYXNwZWN0UmF0aW9HZXR0ZXJcbn0pO3ZhciBNZWRpYVF1ZXJ5LCBSVUxFX0RFSUxJTUlURVI7XG5SVUxFX0RFSUxJTUlURVIgPSAvLFxccyovO1xudmFyIE1lZGlhUXVlcnkkMSA9IE1lZGlhUXVlcnkgPSBuZXcgZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGJhY2tzLCB0ZXN0UnVsZTtcbiAgY2FsbGJhY2tzID0gW107XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhbGxiYWNrLCBpLCBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2tzW2ldO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMucGFyc2VRdWVyeSA9IGZ1bmN0aW9uICh0YXJnZXQsIHF1ZXJ5U3RyaW5nKSB7XG4gICAgdmFyIHF1ZXJ5U3BsaXQsIHJ1bGVzLCBzb3VyY2U7XG4gICAgcXVlcnlTcGxpdCA9IHF1ZXJ5U3RyaW5nLnNwbGl0KCcoJyk7XG4gICAgc291cmNlID0gcXVlcnlTcGxpdFswXTtcblxuICAgIHNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN3aXRjaCAoc291cmNlKSB7XG4gICAgICAgIGNhc2UgJ3dpbmRvdyc6XG4gICAgICAgICAgcmV0dXJuIFF1aWNrV2luZG93JDI7XG5cbiAgICAgICAgY2FzZSAncGFyZW50JzpcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0LnBhcmVudDtcblxuICAgICAgICBjYXNlICdzZWxmJzpcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRhcmdldC5wYXJlbnRNYXRjaGluZyhmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LnJlZiA9PT0gc291cmNlLnNsaWNlKDEpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0oKTtcblxuICAgIHJ1bGVzID0gcXVlcnlTcGxpdFsxXS5zbGljZSgwLCAtMSkuc3BsaXQoUlVMRV9ERUlMSU1JVEVSKS5tYXAoZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgIHZhciBnZXR0ZXIsIGtleSwga2V5UHJlZml4LCBtYXgsIG1pbiwgc3BsaXQsIHZhbHVlO1xuICAgICAgc3BsaXQgPSBydWxlLnNwbGl0KCc6Jyk7XG4gICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQoc3BsaXRbMV0pO1xuXG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gc3BsaXRbMV07XG4gICAgICB9XG5cbiAgICAgIGtleSA9IHNwbGl0WzBdO1xuICAgICAga2V5UHJlZml4ID0ga2V5LnNsaWNlKDAsIDQpO1xuICAgICAgbWF4ID0ga2V5UHJlZml4ID09PSAnbWF4LSc7XG4gICAgICBtaW4gPSAhbWF4ICYmIGtleVByZWZpeCA9PT0gJ21pbi0nO1xuXG4gICAgICBpZiAobWF4IHx8IG1pbikge1xuICAgICAgICBrZXkgPSBrZXkuc2xpY2UoNCk7XG4gICAgICB9XG5cbiAgICAgIGdldHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlICdvcmllbnRhdGlvbic6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gc291cmNlLm9yaWVudGF0aW9uO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIGNhc2UgJ2FzcGVjdC1yYXRpbyc6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gc291cmNlLmFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgICBjYXNlICdoZWlnaHQnOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgcGFyc2VkVmFsdWUsIHN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgICBzdHJpbmdWYWx1ZSA9IHNvdXJjZS5zdHlsZShrZXkpO1xuICAgICAgICAgICAgICBwYXJzZWRWYWx1ZSA9IHBhcnNlRmxvYXQoc3RyaW5nVmFsdWUpO1xuXG4gICAgICAgICAgICAgIGlmIChpc05hTihwYXJzZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIG1pbjogbWluLFxuICAgICAgICBtYXg6IG1heCxcbiAgICAgICAgZ2V0dGVyOiBnZXR0ZXJcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgcnVsZXM6IHJ1bGVzXG4gICAgfTtcbiAgfTtcblxuICB0aGlzLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHRhcmdldCwgcXVlcnlTdHJpbmcpIHtcbiAgICB2YXIgY2FsbGJhY2ssIHF1ZXJ5O1xuICAgIHF1ZXJ5ID0gdGhpcy5wYXJzZVF1ZXJ5KHRhcmdldCwgcXVlcnlTdHJpbmcpO1xuXG4gICAgaWYgKHF1ZXJ5LnNvdXJjZSkge1xuICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRlc3RSdWxlKHRhcmdldCwgcXVlcnksIHF1ZXJ5U3RyaW5nKTtcbiAgICAgIH0pO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVlcnk7XG4gIH07XG5cbiAgdGVzdFJ1bGUgPSBmdW5jdGlvbiB0ZXN0UnVsZSh0YXJnZXQsIHF1ZXJ5LCBxdWVyeVN0cmluZykge1xuICAgIHZhciBjdXJyZW50VmFsdWUsIGksIGxlbiwgcGFzc2VkLCByZWYsIHJ1bGU7XG4gICAgcGFzc2VkID0gdHJ1ZTtcbiAgICByZWYgPSBxdWVyeS5ydWxlcztcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcnVsZSA9IHJlZltpXTtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IHJ1bGUuZ2V0dGVyKCk7XG5cbiAgICAgIHBhc3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgIGNhc2UgIXJ1bGUubWluOlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSA+PSBydWxlLnZhbHVlO1xuXG4gICAgICAgICAgY2FzZSAhcnVsZS5tYXg6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFZhbHVlIDw9IHJ1bGUudmFsdWU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSA9PT0gcnVsZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuXG4gICAgICBpZiAoIXBhc3NlZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0LnN0YXRlKHF1ZXJ5U3RyaW5nLCBwYXNzZWQpO1xuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufSgpO3ZhciBTdGF0ZUNoYWluO1xudmFyIFN0YXRlQ2hhaW4kMSA9IFN0YXRlQ2hhaW4gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdGF0ZUNoYWluKHN0YXRlcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGF0ZUNoYWluKTtcblxuICAgIHRoaXMuc3RyaW5nID0gc3RhdGVzLmpvaW4oJysnKTtcbiAgICB0aGlzLmFycmF5ID0gc3RhdGVzLnNsaWNlKCk7XG4gICAgdGhpcy5sZW5ndGggPSBzdGF0ZXMubGVuZ3RoO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0YXRlQ2hhaW4sIFt7XG4gICAga2V5OiBcImluY2x1ZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluY2x1ZGVzKHRhcmdldCkge1xuICAgICAgdmFyIGksIGxlbiwgcmVmLCBzdGF0ZTtcbiAgICAgIHJlZiA9IHRoaXMuYXJyYXk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdGF0ZSA9IHJlZltpXTtcblxuICAgICAgICBpZiAoc3RhdGUgPT09IHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aG91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRob3V0KHRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXkuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICByZXR1cm4gc3RhdGUgIT09IHRhcmdldDtcbiAgICAgIH0pLmpvaW4oJysnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNBcHBsaWNhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQXBwbGljYWJsZSh0YXJnZXQsIG90aGVyQWN0aXZlKSB7XG4gICAgICB2YXIgYWN0aXZlO1xuICAgICAgYWN0aXZlID0gdGhpcy5hcnJheS5maWx0ZXIoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSA9PT0gdGFyZ2V0IHx8IG90aGVyQWN0aXZlLmluZGV4T2Yoc3RhdGUpICE9PSAtMTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjdGl2ZS5sZW5ndGggPT09IHRoaXMuYXJyYXkubGVuZ3RoO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdGF0ZUNoYWluO1xufSgpO3ZhciBCQVNFX1NUQVRFX1RSSUdHRVJTLCBDQUNIRURfRk5fSU5TRVJURUQ7XG5CQVNFX1NUQVRFX1RSSUdHRVJTID0ge1xuICAnaG92ZXInOiB7XG4gICAgb246ICdtb3VzZWVudGVyJyxcbiAgICBvZmY6ICdtb3VzZWxlYXZlJyxcbiAgICBidWJibGVzOiB0cnVlXG4gIH0sXG4gICdmb2N1cyc6IHtcbiAgICBvbjogJ2ZvY3VzJyxcbiAgICBvZmY6ICdibHVyJyxcbiAgICBidWJibGVzOiB0cnVlXG4gIH1cbn07XG52YXIgX25vcm1hbGl6ZU9wdGlvbnMgPSBmdW5jdGlvbiBfbm9ybWFsaXplT3B0aW9ucygpIHtcbiAgdmFyIGJhc2UxLCBiYXNlMiwgYmFzZTMsIGJhc2U0LCBiYXNlNTtcblxuICBpZiAodGhpcy5vcHRpb25zLnJlbGF0ZWRJbnN0YW5jZSkge1xuICAgIChiYXNlMSA9IHRoaXMub3B0aW9ucykucmVsYXRlZCB8fCAoYmFzZTEucmVsYXRlZCA9IHRoaXMub3B0aW9ucy5yZWxhdGVkSW5zdGFuY2UpO1xuICAgIHRoaXMub3B0aW9ucy5yZWxhdGVkSW5zdGFuY2UgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5yZWxhdGVkID0gKGJhc2UyID0gdGhpcy5vcHRpb25zKS5yZWxhdGVkICE9IG51bGwgPyBiYXNlMi5yZWxhdGVkIDogYmFzZTIucmVsYXRlZCA9IHRoaXM7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5jbGFzcykge1xuICAgIHRoaXMub3B0aW9ucy5jbGFzc05hbWUgPSB0aGlzLm9wdGlvbnMuY2xhc3M7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnVybCkge1xuICAgIHRoaXMub3B0aW9ucy5ocmVmID0gdGhpcy5vcHRpb25zLnVybDtcbiAgfVxuXG4gIGlmICgoYmFzZTMgPSB0aGlzLm9wdGlvbnMpLnVucGFzc2FibGVTdGF0ZXMgPT0gbnVsbCkge1xuICAgIGJhc2UzLnVucGFzc2FibGVTdGF0ZXMgPSBbXTtcbiAgfVxuXG4gIGlmICgoYmFzZTQgPSB0aGlzLm9wdGlvbnMpLnBhc3NTdGF0ZVRvQ2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIGJhc2U0LnBhc3NTdGF0ZVRvQ2hpbGRyZW4gPSB0cnVlO1xuICB9XG5cbiAgaWYgKChiYXNlNSA9IHRoaXMub3B0aW9ucykucGFzc0RhdGFUb0NoaWxkcmVuID09IG51bGwpIHtcbiAgICBiYXNlNS5wYXNzRGF0YVRvQ2hpbGRyZW4gPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5vcHRpb25zLnN0YXRlVHJpZ2dlcnMgPSB0aGlzLm9wdGlvbnMuc3RhdGVUcmlnZ2VycyA/IGV4dGVuZC5jbG9uZS5kZWVwKEJBU0VfU1RBVEVfVFJJR0dFUlMsIHRoaXMub3B0aW9ucy5zdGF0ZVRyaWdnZXJzKSA6IEJBU0VfU1RBVEVfVFJJR0dFUlM7XG5cbiAgaWYgKHRoaXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgZXh0ZW5kKHRoaXMsIHRoaXMuX3BhcnNlVGV4dHModGhpcy5vcHRpb25zLnRleHQsIHRoaXMuX3RleHRzKSk7XG4gIH0gZWxzZSB7XG4gICAgZXh0ZW5kKHRoaXMsIHRoaXMuX3BhcnNlU3R5bGVzKHRoaXMub3B0aW9ucy5zdHlsZSwgdGhpcy5fc3R5bGVzKSk7XG4gIH1cbn07XG52YXIgX3BhcnNlU3R5bGVzID0gZnVuY3Rpb24gX3BhcnNlU3R5bGVzKHN0eWxlcywgc3RvcmUpIHtcbiAgdmFyIF9tZWRpYVN0YXRlcywgX3Byb3ZpZGVkU3RhdGVzLCBfcHJvdmlkZWRTdGF0ZXNTaGFyZWQsIF9zdGF0ZVNoYXJlZCwgX3N0eWxlcywgYmFzZSwgX2ZsYXR0ZW5OZXN0ZWRTdGF0ZXMsIGZvcmNlU3R5bGUsIGksIGtleXMsIGxlbiwgc3BlY2lhbFN0YXRlcywgc3RhdGUsIHN0YXRlU3R5bGVzLCBzdGF0ZV8sIHN0YXRlcztcblxuICBpZiAoIUlTJDEub2JqZWN0UGxhaW4oc3R5bGVzKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGtleXMgPSBPYmplY3Qua2V5cyhzdHlsZXMpO1xuICBzdGF0ZXMgPSBrZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGlzU3RhdGVTdHlsZShrZXkpO1xuICB9KTtcbiAgc3BlY2lhbFN0YXRlcyA9IHJlbW92ZUl0ZW0oc3RhdGVzLnNsaWNlKCksICckYmFzZScpO1xuICBfbWVkaWFTdGF0ZXMgPSBzdGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5WzBdID09PSAnQCc7XG4gIH0pLm1hcChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuc2xpY2UoMSk7XG4gIH0pO1xuICBfcHJvdmlkZWRTdGF0ZXMgPSBzdGF0ZXMubWFwKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5zbGljZSgxKTsgLy8gUmVtb3ZlICckJyBwcmVmaXhcbiAgfSk7XG4gIF9zdHlsZXMgPSBzdG9yZSB8fCB7fTtcbiAgX3N0YXRlU2hhcmVkID0gX3Byb3ZpZGVkU3RhdGVzU2hhcmVkID0gdm9pZCAwO1xuICBiYXNlID0gIWluY2x1ZGVzKHN0YXRlcywgJyRiYXNlJykgPyBzdHlsZXMgOiBzdHlsZXMuJGJhc2U7XG4gIF9zdHlsZXMuYmFzZSA9IHJlZ2lzdGVyU3R5bGUoYmFzZSwgMCwgZm9yY2VTdHlsZSA9IHRoaXMub3B0aW9ucy5mb3JjZVN0eWxlKTtcblxuICBpZiAoc3BlY2lhbFN0YXRlcy5sZW5ndGgpIHtcbiAgICBfZmxhdHRlbk5lc3RlZFN0YXRlcyA9IGZ1bmN0aW9uIGZsYXR0ZW5OZXN0ZWRTdGF0ZXMoc3R5bGVPYmplY3QsIGNoYWluLCBsZXZlbCkge1xuICAgICAgdmFyIGhhc05vblN0YXRlUHJvcHMsIGksIGxlbiwgb3V0cHV0LCBzdGF0ZSwgc3RhdGVDaGFpbiwgc3RhdGVfLCBzdHlsZUtleXM7XG4gICAgICBzdHlsZUtleXMgPSBPYmplY3Qua2V5cyhzdHlsZU9iamVjdCk7XG4gICAgICBvdXRwdXQgPSB7fTtcbiAgICAgIGhhc05vblN0YXRlUHJvcHMgPSBmYWxzZTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gc3R5bGVLZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN0YXRlID0gc3R5bGVLZXlzW2ldO1xuXG4gICAgICAgIGlmICghaXNTdGF0ZVN0eWxlKHN0YXRlKSkge1xuICAgICAgICAgIGhhc05vblN0YXRlUHJvcHMgPSB0cnVlO1xuICAgICAgICAgIG91dHB1dFtzdGF0ZV0gPSBzdHlsZU9iamVjdFtzdGF0ZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhaW4ucHVzaChzdGF0ZV8gPSBzdGF0ZS5zbGljZSgxKSk7XG4gICAgICAgICAgc3RhdGVDaGFpbiA9IG5ldyBTdGF0ZUNoYWluJDEoY2hhaW4pO1xuXG4gICAgICAgICAgaWYgKF9zdGF0ZVNoYXJlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBfc3RhdGVTaGFyZWQgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX3Byb3ZpZGVkU3RhdGVzU2hhcmVkID09IG51bGwpIHtcbiAgICAgICAgICAgIF9wcm92aWRlZFN0YXRlc1NoYXJlZCA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9wcm92aWRlZFN0YXRlc1NoYXJlZC5wdXNoKHN0YXRlQ2hhaW4pO1xuXG4gICAgICAgICAgaWYgKHN0YXRlWzBdID09PSAnQCcpIHtcbiAgICAgICAgICAgIF9tZWRpYVN0YXRlcy5wdXNoKHN0YXRlXyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3N0eWxlc1tzdGF0ZUNoYWluLnN0cmluZ10gPSByZWdpc3RlclN0eWxlKF9mbGF0dGVuTmVzdGVkU3RhdGVzKHN0eWxlT2JqZWN0W3N0YXRlXSwgY2hhaW4sIGxldmVsICsgMSksIGxldmVsICsgMSwgZm9yY2VTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc05vblN0YXRlUHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gc3BlY2lhbFN0YXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc3RhdGUgPSBzcGVjaWFsU3RhdGVzW2ldO1xuICAgICAgc3RhdGVfID0gc3RhdGUuc2xpY2UoMSk7XG4gICAgICBzdGF0ZVN0eWxlcyA9IF9mbGF0dGVuTmVzdGVkU3RhdGVzKHN0eWxlc1tzdGF0ZV0sIFtzdGF0ZV9dLCAxKTtcblxuICAgICAgaWYgKHN0YXRlU3R5bGVzKSB7XG4gICAgICAgIF9zdHlsZXNbc3RhdGVfXSA9IHJlZ2lzdGVyU3R5bGUoc3RhdGVTdHlsZXMsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgX3N0eWxlczogX3N0eWxlcyxcbiAgICBfbWVkaWFTdGF0ZXM6IF9tZWRpYVN0YXRlcyxcbiAgICBfc3RhdGVTaGFyZWQ6IF9zdGF0ZVNoYXJlZCxcbiAgICBfcHJvdmlkZWRTdGF0ZXM6IF9wcm92aWRlZFN0YXRlcyxcbiAgICBfcHJvdmlkZWRTdGF0ZXNTaGFyZWQ6IF9wcm92aWRlZFN0YXRlc1NoYXJlZFxuICB9O1xufTtcbnZhciBfcGFyc2VUZXh0cyA9IGZ1bmN0aW9uIF9wYXJzZVRleHRzKHRleHRzLCBzdG9yZSkge1xuICB2YXIgX3Byb3ZpZGVkU3RhdGVzLCBfdGV4dHMsIGksIGxlbiwgc3RhdGUsIHN0YXRlcztcblxuICBpZiAoIUlTJDEub2JqZWN0UGxhaW4odGV4dHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGVzID0gT2JqZWN0LmtleXModGV4dHMpLm1hcChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuc2xpY2UoMSk7XG4gIH0pO1xuICBfcHJvdmlkZWRTdGF0ZXMgPSBzdGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZSAhPT0gJ2Jhc2UnO1xuICB9KTtcbiAgX3RleHRzID0gc3RvcmUgfHwge307XG4gIF90ZXh0cyA9IHtcbiAgICBiYXNlOiAnJ1xuICB9O1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHN0YXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHN0YXRlID0gc3RhdGVzW2ldO1xuICAgIF90ZXh0c1tzdGF0ZV0gPSB0ZXh0c1snJCcgKyBzdGF0ZV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIF90ZXh0czogX3RleHRzLFxuICAgIF9wcm92aWRlZFN0YXRlczogX3Byb3ZpZGVkU3RhdGVzXG4gIH07XG59O1xudmFyIF9hcHBseU9wdGlvbnMgPSBmdW5jdGlvbiBfYXBwbHlPcHRpb25zKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBldmVudCwgaGFuZGxlciwgbWV0aG9kLCByZWYsIHJlZjEsIHJlZjIsIHZhbHVlO1xuXG4gIGlmIChyZWYgPSB0aGlzLm9wdGlvbnMuaWQgfHwgdGhpcy5vcHRpb25zLnJlZikge1xuICAgIHRoaXMuYXR0cignZGF0YS1yZWYnLCB0aGlzLnJlZiA9IHJlZik7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLmlkKSB7XG4gICAgdGhpcy5lbC5pZCA9IHRoaXMub3B0aW9ucy5pZDtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7XG4gICAgdGhpcy5lbC5jbGFzc05hbWUgPSB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5zcmMpIHtcbiAgICB0aGlzLmVsLnNyYyA9IHRoaXMub3B0aW9ucy5zcmM7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLmhyZWYpIHtcbiAgICB0aGlzLmVsLmhyZWYgPSB0aGlzLm9wdGlvbnMuaHJlZjtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMudHlwZSkge1xuICAgIHRoaXMuZWwudHlwZSA9IHRoaXMub3B0aW9ucy50eXBlO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5uYW1lKSB7XG4gICAgdGhpcy5lbC5uYW1lID0gdGhpcy5vcHRpb25zLm5hbWU7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnZhbHVlKSB7XG4gICAgdGhpcy5lbC52YWx1ZSA9IHRoaXMub3B0aW9ucy52YWx1ZTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuc2VsZWN0ZWQpIHtcbiAgICB0aGlzLmVsLnNlbGVjdGVkID0gdGhpcy5vcHRpb25zLnNlbGVjdGVkO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5jaGVja2VkKSB7XG4gICAgdGhpcy5lbC5jaGVja2VkID0gdGhpcy5vcHRpb25zLmNoZWNrZWQ7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnByb3BzKSB7XG4gICAgdGhpcy5wcm9wKHRoaXMub3B0aW9ucy5wcm9wcyk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLmF0dHJzKSB7XG4gICAgdGhpcy5hdHRyKHRoaXMub3B0aW9ucy5hdHRycyk7XG4gIH1cblxuICB0aGlzLl9hcHBseVJlZ2lzdGVyZWRTdHlsZSh0aGlzLl9zdHlsZXMuYmFzZSwgbnVsbCwgbnVsbCwgdGhpcy5vcHRpb25zLnN0eWxlQWZ0ZXJJbnNlcnQpO1xuXG4gIGlmICh0aGlzLl90ZXh0cykge1xuICAgIHRoaXMudGV4dCA9IHRoaXMuX3RleHRzLmJhc2U7XG4gIH1cblxuICB0aGlzLm9uKCdpbnNlcnRlZCcsIENBQ0hFRF9GTl9JTlNFUlRFRCwgZmFsc2UsIHRydWUpO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMuaW52b2tlQ29tcHV0ZXJzT25jZSkge1xuICAgIHRoaXMuX2ludm9rZWRDb21wdXRlcnMgPSB7fTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMucmVjYWxjT25SZXNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnJlY2FsY1N0eWxlKCk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLmV2ZW50cykge1xuICAgIHJlZjEgPSB0aGlzLm9wdGlvbnMuZXZlbnRzO1xuXG4gICAgZm9yIChldmVudCBpbiByZWYxKSB7XG4gICAgICBoYW5kbGVyID0gcmVmMVtldmVudF07XG4gICAgICB0aGlzLm9uKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLm1ldGhvZHMpIHtcbiAgICByZWYyID0gdGhpcy5vcHRpb25zLm1ldGhvZHM7XG5cbiAgICBmb3IgKG1ldGhvZCBpbiByZWYyKSB7XG4gICAgICB2YWx1ZSA9IHJlZjJbbWV0aG9kXTtcblxuICAgICAgaWYgKCF0aGlzW21ldGhvZF0pIHtcbiAgICAgICAgaWYgKElTJDEuZnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgdGhpc1ttZXRob2RdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoSVMkMS5vYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG1ldGhvZCwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiB2YWx1ZS5nZXQsXG4gICAgICAgICAgICBzZXQ6IHZhbHVlLnNldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMudHlwZSAhPT0gJ3RleHQnICYmIElTJDEub2JqZWN0KHRoaXMub3B0aW9ucy50ZXh0KSkge1xuICAgIHRoaXMuYXBwZW5kKF9xdWlja2RvbSgndGV4dCcsIHtcbiAgICAgIHRleHQ6IHRoaXMub3B0aW9ucy50ZXh0XG4gICAgfSkpO1xuICB9XG59O1xudmFyIF9wb3N0Q3JlYXRpb24gPSBmdW5jdGlvbiBfcG9zdENyZWF0aW9uKGRhdGEpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5jb21wdXRlcnMpIHtcbiAgICBpZiAoZGF0YSAmJiB0aGlzLm9wdGlvbnMuZGF0YSkge1xuICAgICAgZGF0YSA9IGV4dGVuZC5jbG9uZSh0aGlzLm9wdGlvbnMuZGF0YSwgZGF0YSk7XG4gICAgfVxuXG4gICAgZGF0YSB8fCAoZGF0YSA9IHRoaXMub3B0aW9ucy5kYXRhKTtcbiAgICB0aGlzLmFwcGx5RGF0YShkYXRhLCBmYWxzZSk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbXB1dGVycy5faW5pdCkge1xuICAgICAgdGhpcy5fcnVuQ29tcHV0ZXIoJ19pbml0JywgZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5zdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUodGhpcy5vcHRpb25zLnN0YXRlKTtcbiAgfVxufTtcbnZhciBfYXR0YWNoU3RhdGVFdmVudHMgPSBmdW5jdGlvbiBfYXR0YWNoU3RhdGVFdmVudHMoZm9yY2UpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlcztcbiAgc3RhdGVzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLnN0YXRlVHJpZ2dlcnMpO1xuICBzdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgZGlzYWJsZXIsIGVuYWJsZXIsIHRyaWdnZXI7XG4gICAgdHJpZ2dlciA9IF90aGlzMi5vcHRpb25zLnN0YXRlVHJpZ2dlcnNbc3RhdGVdO1xuXG4gICAgaWYgKCFpbmNsdWRlcyhfdGhpczIuX3Byb3ZpZGVkU3RhdGVzLCBzdGF0ZSkgJiYgIWZvcmNlICYmICF0cmlnZ2VyLmZvcmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZW5hYmxlciA9IElTJDEuc3RyaW5nKHRyaWdnZXIpID8gdHJpZ2dlciA6IHRyaWdnZXIub247XG5cbiAgICBpZiAoSVMkMS5vYmplY3QodHJpZ2dlcikpIHtcbiAgICAgIGRpc2FibGVyID0gdHJpZ2dlci5vZmY7XG4gICAgfVxuXG4gICAgX3RoaXMyLl9saXN0ZW5UbyhlbmFibGVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLnN0YXRlKHN0YXRlLCB0cnVlLCB0cmlnZ2VyLmJ1YmJsZXMpO1xuICAgIH0pO1xuXG4gICAgaWYgKGRpc2FibGVyKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLl9saXN0ZW5UbyhkaXNhYmxlciwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnN0YXRlKHN0YXRlLCBmYWxzZSwgdHJpZ2dlci5idWJibGVzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyIF9wcm94eVBhcmVudCA9IGZ1bmN0aW9uIF9wcm94eVBhcmVudCgpIHtcbiAgdmFyIHBhcmVudDtcbiAgcGFyZW50ID0gdm9pZCAwO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfcGFyZW50Jywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1BhcmVudCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBsYXN0UGFyZW50O1xuXG4gICAgICBpZiAocGFyZW50ID0gbmV3UGFyZW50KSB7XG4gICAgICAgIGxhc3RQYXJlbnQgPSB0aGlzLnBhcmVudHMuc2xpY2UoLTEpWzBdO1xuXG4gICAgICAgIGlmIChsYXN0UGFyZW50LnJhdyA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5fdW5wcm94eVBhcmVudChuZXdQYXJlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudC5vbignaW5zZXJ0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50ID09PSBuZXdQYXJlbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fdW5wcm94eVBhcmVudChuZXdQYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG52YXIgX3VucHJveHlQYXJlbnQgPSBmdW5jdGlvbiBfdW5wcm94eVBhcmVudChuZXdQYXJlbnQpIHtcbiAgZGVsZXRlIHRoaXMuX3BhcmVudDtcbiAgdGhpcy5fcGFyZW50ID0gbmV3UGFyZW50O1xuICB0aGlzLmVtaXRQcml2YXRlKCdpbnNlcnRlZCcsIG5ld1BhcmVudCk7XG59O1xuXG5DQUNIRURfRk5fSU5TRVJURUQgPSBmdW5jdGlvbiBDQUNIRURfRk5fSU5TRVJURUQoKSB7XG4gIHZhciBpLCBsZW4sIG1lZGlhU3RhdGVzLCBxdWVyeVN0cmluZywgcmVzdWx0cztcbiAgdGhpcy5faW5zZXJ0ZWQgPSB0aGlzO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMuc3R5bGVBZnRlckluc2VydCkge1xuICAgIHRoaXMucmVjYWxjU3R5bGUoKTtcbiAgfVxuXG4gIGlmICgobWVkaWFTdGF0ZXMgPSB0aGlzLl9tZWRpYVN0YXRlcykgJiYgdGhpcy5fbWVkaWFTdGF0ZXMubGVuZ3RoKSB7XG4gICAgdGhpcy5fbWVkaWFTdGF0ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJlc3VsdHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IG1lZGlhU3RhdGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBxdWVyeVN0cmluZyA9IG1lZGlhU3RhdGVzW2ldO1xuICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuX21lZGlhU3RhdGVzW3F1ZXJ5U3RyaW5nXSA9IE1lZGlhUXVlcnkkMS5yZWdpc3Rlcih0aGlzLCBxdWVyeVN0cmluZykpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG59O1xuXG5mdW5jdGlvbiBpbml0JDEgKFF1aWNrRWxlbWVudCkge1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9ub3JtYWxpemVPcHRpb25zID0gX25vcm1hbGl6ZU9wdGlvbnM7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3BhcnNlU3R5bGVzID0gX3BhcnNlU3R5bGVzO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9wYXJzZVRleHRzID0gX3BhcnNlVGV4dHM7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX2FwcGx5T3B0aW9ucyA9IF9hcHBseU9wdGlvbnM7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3Bvc3RDcmVhdGlvbiA9IF9wb3N0Q3JlYXRpb247XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX2F0dGFjaFN0YXRlRXZlbnRzID0gX2F0dGFjaFN0YXRlRXZlbnRzO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9wcm94eVBhcmVudCA9IF9wcm94eVBhcmVudDtcbiAgcmV0dXJuIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3VucHJveHlQYXJlbnQgPSBfdW5wcm94eVBhcmVudDtcbn1mdW5jdGlvbiBhbGlhc2VzIChRdWlja0VsZW1lbnQpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFF1aWNrRWxlbWVudC5wcm90b3R5cGUsIHtcbiAgICAncmF3Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsO1xuICAgICAgfVxuICAgIH0sXG4gICAgJzAnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWw7XG4gICAgICB9XG4gICAgfSxcbiAgICAnY3NzJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3JlcGxhY2VXaXRoJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2U7XG4gICAgICB9XG4gICAgfSxcbiAgICAncmVtb3ZlTGlzdGVuZXInOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59dmFyIHBhcmVudHNVbnRpbCA9IGZ1bmN0aW9uIHBhcmVudHNVbnRpbChmaWx0ZXIpIHtcbiAgcmV0dXJuIF9nZXRQYXJlbnRzKHRoaXMsIGZpbHRlcik7XG59O1xudmFyIHBhcmVudE1hdGNoaW5nID0gZnVuY3Rpb24gcGFyZW50TWF0Y2hpbmcoZmlsdGVyKSB7XG4gIHZhciBpc1JlZiwgbmV4dFBhcmVudDtcblxuICBpZiAoSVMkMS5mdW5jdGlvbihmaWx0ZXIpIHx8IChpc1JlZiA9IElTJDEuc3RyaW5nKGZpbHRlcikpKSB7XG4gICAgbmV4dFBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgd2hpbGUgKG5leHRQYXJlbnQpIHtcbiAgICAgIGlmIChpc1JlZikge1xuICAgICAgICBpZiAobmV4dFBhcmVudC5yZWYgPT09IGZpbHRlcikge1xuICAgICAgICAgIHJldHVybiBuZXh0UGFyZW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZmlsdGVyKG5leHRQYXJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dFBhcmVudCA9IG5leHRQYXJlbnQucGFyZW50O1xuICAgIH1cbiAgfVxufTtcbnZhciBxdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KHNlbGVjdG9yKSB7XG4gIHJldHVybiBfcXVpY2tkb20odGhpcy5yYXcucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpO1xufTtcbnZhciBxdWVyeUFsbCA9IGZ1bmN0aW9uIHF1ZXJ5QWxsKHNlbGVjdG9yKSB7XG4gIHZhciBpLCBpdGVtLCBsZW4sIG91dHB1dCwgcmVzdWx0O1xuICByZXN1bHQgPSB0aGlzLnJhdy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgb3V0cHV0ID0gW107XG5cbiAgZm9yIChpID0gMCwgbGVuID0gcmVzdWx0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaXRlbSA9IHJlc3VsdFtpXTtcbiAgICBvdXRwdXQucHVzaChpdGVtKTtcbiAgfVxuXG4gIHJldHVybiBfcXVpY2tkb20uYmF0Y2gob3V0cHV0KTtcbn07XG52YXIgX2dldFBhcmVudHMgPSBmdW5jdGlvbiBfZ2V0UGFyZW50cyh0YXJnZXRFbCwgZmlsdGVyKSB7XG4gIHZhciBpc1JlZiwgbmV4dFBhcmVudCwgcGFyZW50cztcblxuICBpZiAoIUlTJDEuZnVuY3Rpb24oZmlsdGVyKSAmJiAhKGlzUmVmID0gSVMkMS5zdHJpbmcoZmlsdGVyKSkpIHtcbiAgICBmaWx0ZXIgPSB2b2lkIDA7XG4gIH1cblxuICBwYXJlbnRzID0gW107XG4gIG5leHRQYXJlbnQgPSB0YXJnZXRFbC5wYXJlbnQ7XG5cbiAgd2hpbGUgKG5leHRQYXJlbnQpIHtcbiAgICBwYXJlbnRzLnB1c2gobmV4dFBhcmVudCk7XG4gICAgbmV4dFBhcmVudCA9IG5leHRQYXJlbnQucGFyZW50O1xuXG4gICAgaWYgKGlzUmVmKSB7XG4gICAgICBpZiAobmV4dFBhcmVudCAmJiBuZXh0UGFyZW50LnJlZiA9PT0gZmlsdGVyKSB7XG4gICAgICAgIG5leHRQYXJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZmlsdGVyKSB7XG4gICAgICBpZiAoZmlsdGVyKG5leHRQYXJlbnQpKSB7XG4gICAgICAgIG5leHRQYXJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJlbnRzO1xufTtcbnZhciBfZ2V0Q2hpbGRSZWZzID0gZnVuY3Rpb24gX2dldENoaWxkUmVmcyh0YXJnZXQsIGZyZXNoQ29weSkge1xuICB2YXIgY2hpbGQsIGNoaWxkUmVmcywgY2hpbGRyZW4sIGVsLCBpLCBsZW4sIHJlZiwgcmVmcztcblxuICBpZiAoZnJlc2hDb3B5IHx8ICF0YXJnZXQuX2NoaWxkUmVmcykge1xuICAgIHRhcmdldC5fY2hpbGRSZWZzID0ge307XG4gIH1cblxuICByZWZzID0gdGFyZ2V0Ll9jaGlsZFJlZnM7XG5cbiAgaWYgKHRhcmdldC5yZWYpIHtcbiAgICByZWZzW3RhcmdldC5yZWZdID0gdGFyZ2V0O1xuICB9XG5cbiAgY2hpbGRyZW4gPSB0YXJnZXQuY2hpbGRyZW47XG5cbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgY2hpbGRSZWZzID0gX2dldENoaWxkUmVmcyhjaGlsZCwgZnJlc2hDb3B5KTtcblxuICAgICAgZm9yIChyZWYgaW4gY2hpbGRSZWZzKSB7XG4gICAgICAgIGVsID0gY2hpbGRSZWZzW3JlZl07XG4gICAgICAgIHJlZnNbcmVmXSB8fCAocmVmc1tyZWZdID0gZWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWZzO1xufTtcbnZhciBfZ2V0SW5kZXhCeVByb3AgPSBmdW5jdGlvbiBfZ2V0SW5kZXhCeVByb3AobWFpbiwgcHJvcCkge1xuICB2YXIgcGFyZW50O1xuXG4gIGlmICghKHBhcmVudCA9IG1haW4ucGFyZW50KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJlbnQuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkW3Byb3BdID09PSBtYWluW3Byb3BdO1xuICAgIH0pLmluZGV4T2YobWFpbik7XG4gIH1cbn07XG52YXIgX2ZpbHRlckVsZW1lbnRzID0gZnVuY3Rpb24gX2ZpbHRlckVsZW1lbnRzKGFycmF5KSB7XG4gIHZhciBpLCBpdGVtLCBsZW4sIG91dHB1dDtcblxuICBpZiAoIWFycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiBhcnJheTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBbXTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpdGVtID0gYXJyYXlbaV07XG5cbiAgICAgIGlmIChpdGVtLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgICBvdXRwdXQucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG59O1xuZnVuY3Rpb24gdHJhdmVyc2luZyAoUXVpY2tFbGVtZW50KSB7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucGFyZW50c1VudGlsID0gcGFyZW50c1VudGlsO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnBhcmVudE1hdGNoaW5nID0gcGFyZW50TWF0Y2hpbmc7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucXVlcnkgPSBxdWVyeTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5xdWVyeUFsbCA9IHF1ZXJ5QWxsO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUXVpY2tFbGVtZW50LnByb3RvdHlwZSwge1xuICAgICdjaGlsZHJlbic6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgY2hpbGQsIGksIGxlbiwgcmVmMTtcblxuICAgICAgICBpZiAodGhpcy5lbC5jaGlsZE5vZGVzLmxlbmd0aCAhPT0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gUmUtY29sbGVjdCBjaGlsZHJlblx0XG4gICAgICAgICAgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID0gMDsgLy8gRW1wdHkgb3V0IGNoaWxkcmVuIGFycmF5XG5cbiAgICAgICAgICByZWYxID0gdGhpcy5lbC5jaGlsZE5vZGVzO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSByZWYxW2ldO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPCA0KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goX3F1aWNrZG9tKGNoaWxkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2VsZW1lbnRDaGlsZHJlbic6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2ZpbHRlckVsZW1lbnRzKHRoaXMuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3BhcmVudCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAoKCF0aGlzLl9wYXJlbnQgfHwgdGhpcy5fcGFyZW50LmVsICE9PSB0aGlzLmVsLnBhcmVudE5vZGUpICYmICFJUyQxLmRvbURvYyh0aGlzLmVsLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgdGhpcy5fcGFyZW50ID0gX3F1aWNrZG9tKHRoaXMuZWwucGFyZW50Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3BhcmVudHMnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRQYXJlbnRzKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ25leHQnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9xdWlja2RvbSh0aGlzLmVsLm5leHRTaWJsaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICduZXh0RWwnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9xdWlja2RvbSh0aGlzLmVsLm5leHRFbGVtZW50U2libGluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnbmV4dEVsQWxsJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZmlsdGVyRWxlbWVudHModGhpcy5uZXh0QWxsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICduZXh0QWxsJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBuZXh0U2libGluZywgc2libGluZ3M7XG4gICAgICAgIHNpYmxpbmdzID0gW107XG4gICAgICAgIG5leHRTaWJsaW5nID0gX3F1aWNrZG9tKHRoaXMuZWwubmV4dFNpYmxpbmcpO1xuXG4gICAgICAgIHdoaWxlIChuZXh0U2libGluZykge1xuICAgICAgICAgIHNpYmxpbmdzLnB1c2gobmV4dFNpYmxpbmcpO1xuICAgICAgICAgIG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaWJsaW5ncztcbiAgICAgIH1cbiAgICB9LFxuICAgICdwcmV2Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfcXVpY2tkb20odGhpcy5lbC5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3ByZXZFbCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3F1aWNrZG9tKHRoaXMuZWwucHJldmlvdXNFbGVtZW50U2libGluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAncHJldkVsQWxsJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZmlsdGVyRWxlbWVudHModGhpcy5wcmV2QWxsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdwcmV2QWxsJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBwcmV2U2libGluZywgc2libGluZ3M7XG4gICAgICAgIHNpYmxpbmdzID0gW107XG4gICAgICAgIHByZXZTaWJsaW5nID0gX3F1aWNrZG9tKHRoaXMuZWwucHJldmlvdXNTaWJsaW5nKTtcblxuICAgICAgICB3aGlsZSAocHJldlNpYmxpbmcpIHtcbiAgICAgICAgICBzaWJsaW5ncy5wdXNoKHByZXZTaWJsaW5nKTtcbiAgICAgICAgICBwcmV2U2libGluZyA9IHByZXZTaWJsaW5nLnByZXY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2libGluZ3M7XG4gICAgICB9XG4gICAgfSxcbiAgICAnc2libGluZ3MnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldkFsbC5yZXZlcnNlKCkuY29uY2F0KHRoaXMubmV4dEFsbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnZWxlbWVudFNpYmxpbmdzJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZmlsdGVyRWxlbWVudHModGhpcy5zaWJsaW5ncyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnY2hpbGQnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkUmVmcyB8fCBfZ2V0Q2hpbGRSZWZzKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2NoaWxkZic6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2dldENoaWxkUmVmcyh0aGlzLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdmaXJzdENoaWxkJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzBdO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2xhc3RDaGlsZCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgY2hpbGRyZW47XG4gICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2luZGV4Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBwYXJlbnQ7XG5cbiAgICAgICAgaWYgKCEocGFyZW50ID0gdGhpcy5wYXJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnaW5kZXhUeXBlJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZ2V0SW5kZXhCeVByb3AodGhpcywgJ3R5cGUnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdpbmRleFJlZic6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2dldEluZGV4QnlQcm9wKHRoaXMsICdyZWYnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5fcXVpY2tkb20ucXVlcnkgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHJldHVybiBfcXVpY2tkb20oZG9jdW1lbnQpLnF1ZXJ5KHRhcmdldCk7XG59O1xuXG5fcXVpY2tkb20ucXVlcnlBbGwgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHJldHVybiBfcXVpY2tkb20oZG9jdW1lbnQpLnF1ZXJ5QWxsKHRhcmdldCk7XG59O3ZhciBEVU1NWV9BUlJBWTtcbkRVTU1ZX0FSUkFZID0gW107XG52YXIgc3RhdGUgPSBmdW5jdGlvbiBzdGF0ZSh0YXJnZXRTdGF0ZSwgdmFsdWUsIGJ1YmJsZXMsIHNvdXJjZSkge1xuICB2YXIgYWN0aXZlU3RhdGVzLCBjaGlsZCwgZGVzaXJlZFZhbHVlLCBpLCBqLCBrZXksIGtleXMsIGxlbiwgcHJvcCwgcmVmLCB0b2dnbGU7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuc2xpY2UoKTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKElTJDEuc3RyaW5nKHRhcmdldFN0YXRlKSkge1xuICAgICAgcmV0dXJuIGluY2x1ZGVzKHRoaXMuX3N0YXRlLCB0YXJnZXRTdGF0ZSk7XG4gICAgfSBlbHNlIGlmIChJUyQxLm9iamVjdCh0YXJnZXRTdGF0ZSkpIHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh0YXJnZXRTdGF0ZSk7XG4gICAgICBpID0gLTE7XG5cbiAgICAgIHdoaWxlIChrZXkgPSBrZXlzWysraV0pIHtcbiAgICAgICAgdGhpcy5zdGF0ZShrZXksIHRhcmdldFN0YXRlW2tleV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5fc3RhdGVQaXBlVGFyZ2V0ICYmIHNvdXJjZSAhPT0gdGhpcykge1xuICAgIHRoaXMuX3N0YXRlUGlwZVRhcmdldC5zdGF0ZSh0YXJnZXRTdGF0ZSwgdmFsdWUsIGJ1YmJsZXMsIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSBpZiAoSVMkMS5zdHJpbmcodGFyZ2V0U3RhdGUpKSB7XG4gICAgaWYgKHRhcmdldFN0YXRlWzBdID09PSAnJCcpIHtcbiAgICAgIHRhcmdldFN0YXRlID0gdGFyZ2V0U3RhdGUuc2xpY2UoMSk7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldFN0YXRlID09PSAnYmFzZScpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGRlc2lyZWRWYWx1ZSA9ICEhdmFsdWU7IC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIGEgYm9vbGVhblxuXG4gICAgYWN0aXZlU3RhdGVzID0gdGhpcy5fZ2V0QWN0aXZlU3RhdGVzKHRhcmdldFN0YXRlLCBmYWxzZSk7IC8vID09PT0gVG9nZ2xlIHN0eWxlcyBmb3IgdGhpcyBzdGF0ZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIGlmICh0aGlzLnN0YXRlKHRhcmdldFN0YXRlKSAhPT0gZGVzaXJlZFZhbHVlKSB7XG4gICAgICBwcm9wID0gdGhpcy50eXBlID09PSAndGV4dCcgPyAnVGV4dCcgOiAnU3R5bGUnO1xuXG4gICAgICBpZiAoZGVzaXJlZFZhbHVlKSB7XG4gICAgICAgIC8vaXMgb25cbiAgICAgICAgdGhpcy5fc3RhdGUucHVzaCh0YXJnZXRTdGF0ZSk7XG5cbiAgICAgICAgdG9nZ2xlID0gJ09OJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUl0ZW0odGhpcy5fc3RhdGUsIHRhcmdldFN0YXRlKTtcbiAgICAgICAgdG9nZ2xlID0gJ09GRic7XG4gICAgICB9XG5cbiAgICAgIHRoaXNbJ190dXJuJyArIHByb3AgKyB0b2dnbGVdKHRhcmdldFN0YXRlLCBhY3RpdmVTdGF0ZXMpO1xuICAgICAgdGhpcy5lbWl0UHJpdmF0ZShcInN0YXRlQ2hhbmdlOlwiLmNvbmNhdCh0YXJnZXRTdGF0ZSksIGRlc2lyZWRWYWx1ZSk7XG4gICAgfSAvLyA9PT09IFBhc3Mgc3RhdGUgdG8gcGFyZW50L2NoaWxkcmVuID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgICBpZiAoIWluY2x1ZGVzKHRoaXMub3B0aW9ucy51bnBhc3NhYmxlU3RhdGVzLCB0YXJnZXRTdGF0ZSkpIHtcbiAgICAgIGlmIChidWJibGVzKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgIHRoaXMuX3BhcmVudC5zdGF0ZSh0YXJnZXRTdGF0ZSwgdmFsdWUsIHRydWUsIHNvdXJjZSB8fCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMucGFzc1N0YXRlVG9DaGlsZHJlbikge1xuICAgICAgICByZWYgPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICBjaGlsZCA9IHJlZltqXTtcbiAgICAgICAgICBjaGlsZC5zdGF0ZSh0YXJnZXRTdGF0ZSwgdmFsdWUsIGZhbHNlLCBzb3VyY2UgfHwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciB0b2dnbGVTdGF0ZSA9IGZ1bmN0aW9uIHRvZ2dsZVN0YXRlKHRhcmdldFN0YXRlKSB7XG4gIHJldHVybiB0aGlzLnN0YXRlKHRhcmdldFN0YXRlLCAhdGhpcy5zdGF0ZSh0YXJnZXRTdGF0ZSkpO1xufTtcbnZhciByZXNldFN0YXRlID0gZnVuY3Rpb24gcmVzZXRTdGF0ZSgpIHtcbiAgdmFyIGFjdGl2ZVN0YXRlLCBqLCBsZW4sIHJlZjtcbiAgcmVmID0gdGhpcy5fc3RhdGUuc2xpY2UoKTtcblxuICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICBhY3RpdmVTdGF0ZSA9IHJlZltqXTtcbiAgICB0aGlzLnN0YXRlKGFjdGl2ZVN0YXRlLCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgcGlwZVN0YXRlID0gZnVuY3Rpb24gcGlwZVN0YXRlKHRhcmdldEVsKSB7XG4gIHZhciBhY3RpdmVTdGF0ZSwgaiwgbGVuLCByZWY7XG5cbiAgaWYgKHRhcmdldEVsKSB7XG4gICAgdGFyZ2V0RWwgPSBub3JtYWxpemVFbGVtZW50QXJnKHRhcmdldEVsKTtcblxuICAgIGlmIChJUyQxLnF1aWNrRG9tRWwodGFyZ2V0RWwpICYmIHRhcmdldEVsICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLl9zdGF0ZVBpcGVUYXJnZXQgPSB0YXJnZXRFbDtcbiAgICAgIHJlZiA9IHRoaXMuX3N0YXRlO1xuXG4gICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgYWN0aXZlU3RhdGUgPSByZWZbal07XG4gICAgICAgIHRhcmdldEVsLnN0YXRlKGFjdGl2ZVN0YXRlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodGFyZ2V0RWwgPT09IGZhbHNlKSB7XG4gICAgZGVsZXRlIHRoaXMuX3N0YXRlUGlwZVRhcmdldDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBfYXBwbHlSZWdpc3RlcmVkU3R5bGUgPSBmdW5jdGlvbiBfYXBwbHlSZWdpc3RlcmVkU3R5bGUodGFyZ2V0U3R5bGUsIHN1cGVyaW9yU3RhdGVzLCBpbmNsdWRlQmFzZSwgc2tpcEZucykge1xuICB2YXIgY2xhc3NOYW1lLCBlbnRyeSwgaiwgaywgbGVuLCBsZW4xLCByZWYsIHJlZjEsIHN1cGVyaW9yU3R5bGVzO1xuXG4gIGlmICh0YXJnZXRTdHlsZSkge1xuICAgIHJlZiA9IHRhcmdldFN0eWxlLmNsYXNzTmFtZTtcblxuICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgY2xhc3NOYW1lID0gcmVmW2pdO1xuICAgICAgdGhpcy5hZGRDbGFzcyhjbGFzc05hbWUpO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXRTdHlsZS5mbnMubGVuZ3RoICYmICFza2lwRm5zKSB7XG4gICAgICBpZiAoc3VwZXJpb3JTdGF0ZXMpIHtcbiAgICAgICAgc3VwZXJpb3JTdHlsZXMgPSB0aGlzLl9yZXNvbHZlRm5TdHlsZXMoc3VwZXJpb3JTdGF0ZXMsIGluY2x1ZGVCYXNlKTtcbiAgICAgIH1cblxuICAgICAgcmVmMSA9IHRhcmdldFN0eWxlLmZucztcblxuICAgICAgZm9yIChrID0gMCwgbGVuMSA9IHJlZjEubGVuZ3RoOyBrIDwgbGVuMTsgaysrKSB7XG4gICAgICAgIGVudHJ5ID0gcmVmMVtrXTtcblxuICAgICAgICBpZiAoIShzdXBlcmlvclN0eWxlcyAmJiBzdXBlcmlvclN0eWxlc1tlbnRyeVswXV0pKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZShlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIF9yZW1vdmVSZWdpc3RlcmVkU3R5bGUgPSBmdW5jdGlvbiBfcmVtb3ZlUmVnaXN0ZXJlZFN0eWxlKHRhcmdldFN0eWxlLCBzdXBlcmlvclN0YXRlcywgaW5jbHVkZUJhc2UpIHtcbiAgdmFyIGNsYXNzTmFtZSwgZW50cnksIGosIGssIGxlbiwgbGVuMSwgcmVmLCByZWYxLCByZXNldFZhbHVlLCBzdXBlcmlvclN0eWxlcztcbiAgcmVmID0gdGFyZ2V0U3R5bGUuY2xhc3NOYW1lO1xuXG4gIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgIGNsYXNzTmFtZSA9IHJlZltqXTtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XG4gIH1cblxuICBpZiAodGFyZ2V0U3R5bGUuZm5zLmxlbmd0aCkge1xuICAgIGlmIChzdXBlcmlvclN0YXRlcykge1xuICAgICAgc3VwZXJpb3JTdHlsZXMgPSB0aGlzLl9yZXNvbHZlRm5TdHlsZXMoc3VwZXJpb3JTdGF0ZXMsIGluY2x1ZGVCYXNlKTtcbiAgICB9XG5cbiAgICByZWYxID0gdGFyZ2V0U3R5bGUuZm5zO1xuXG4gICAgZm9yIChrID0gMCwgbGVuMSA9IHJlZjEubGVuZ3RoOyBrIDwgbGVuMTsgaysrKSB7XG4gICAgICBlbnRyeSA9IHJlZjFba107XG4gICAgICByZXNldFZhbHVlID0gc3VwZXJpb3JTdHlsZXMgJiYgc3VwZXJpb3JTdHlsZXNbZW50cnlbMF1dIHx8IG51bGw7XG4gICAgICB0aGlzLnN0eWxlKGVudHJ5WzBdLCByZXNldFZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG52YXIgX3R1cm5TdHlsZU9OID0gZnVuY3Rpb24gX3R1cm5TdHlsZU9OKHRhcmdldFN0YXRlLCBhY3RpdmVTdGF0ZXMpIHtcbiAgdmFyIGosIGxlbiwgc2hhcmVkU3RhdGVzLCBza2lwRm5zLCBzdGF0ZUNoYWluO1xuICBza2lwRm5zID0gdGhpcy5vcHRpb25zLnN0eWxlQWZ0ZXJJbnNlcnQgJiYgIXRoaXMuX2luc2VydGVkO1xuXG4gIGlmICh0aGlzLl9zdHlsZXNbdGFyZ2V0U3RhdGVdKSB7XG4gICAgdGhpcy5fYXBwbHlSZWdpc3RlcmVkU3R5bGUodGhpcy5fc3R5bGVzW3RhcmdldFN0YXRlXSwgdGhpcy5fZ2V0U3VwZXJpb3JTdGF0ZXModGFyZ2V0U3RhdGUsIGFjdGl2ZVN0YXRlcyksIGZhbHNlLCBza2lwRm5zKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9wcm92aWRlZFN0YXRlc1NoYXJlZCkge1xuICAgIHNoYXJlZFN0YXRlcyA9IHRoaXMuX2dldFNoYXJlZFN0YXRlcyh0YXJnZXRTdGF0ZSk7XG5cbiAgICBmb3IgKGogPSAwLCBsZW4gPSBzaGFyZWRTdGF0ZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHN0YXRlQ2hhaW4gPSBzaGFyZWRTdGF0ZXNbal07XG5cbiAgICAgIGlmICghaW5jbHVkZXModGhpcy5fc3RhdGVTaGFyZWQsIHN0YXRlQ2hhaW4uc3RyaW5nKSkge1xuICAgICAgICB0aGlzLl9zdGF0ZVNoYXJlZC5wdXNoKHN0YXRlQ2hhaW4uc3RyaW5nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYXBwbHlSZWdpc3RlcmVkU3R5bGUodGhpcy5fc3R5bGVzW3N0YXRlQ2hhaW4uc3RyaW5nXSwgbnVsbCwgbnVsbCwgc2tpcEZucyk7XG4gICAgfVxuICB9XG59O1xudmFyIF90dXJuU3R5bGVPRkYgPSBmdW5jdGlvbiBfdHVyblN0eWxlT0ZGKHRhcmdldFN0YXRlLCBhY3RpdmVTdGF0ZXMpIHtcbiAgdmFyIGFjdGl2ZVNoYXJlZFN0YXRlcywgaiwgbGVuLCBzaGFyZWRTdGF0ZXMsIHN0YXRlQ2hhaW4sIHRhcmdldFN0eWxlO1xuXG4gIGlmICh0aGlzLl9zdHlsZXNbdGFyZ2V0U3RhdGVdKSB7XG4gICAgdGhpcy5fcmVtb3ZlUmVnaXN0ZXJlZFN0eWxlKHRoaXMuX3N0eWxlc1t0YXJnZXRTdGF0ZV0sIGFjdGl2ZVN0YXRlcywgdHJ1ZSk7XG4gIH1cblxuICBpZiAodGhpcy5fcHJvdmlkZWRTdGF0ZXNTaGFyZWQpIHtcbiAgICBzaGFyZWRTdGF0ZXMgPSB0aGlzLl9nZXRTaGFyZWRTdGF0ZXModGFyZ2V0U3RhdGUpO1xuXG4gICAgaWYgKHNoYXJlZFN0YXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGogPSAwLCBsZW4gPSBzaGFyZWRTdGF0ZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHN0YXRlQ2hhaW4gPSBzaGFyZWRTdGF0ZXNbal07XG4gICAgICByZW1vdmVJdGVtKHRoaXMuX3N0YXRlU2hhcmVkLCBzdGF0ZUNoYWluLnN0cmluZyk7XG4gICAgICB0YXJnZXRTdHlsZSA9IHRoaXMuX3N0eWxlc1tzdGF0ZUNoYWluLnN0cmluZ107XG5cbiAgICAgIGlmICh0YXJnZXRTdHlsZS5mbnMubGVuZ3RoICYmIHRoaXMuX3N0YXRlU2hhcmVkLmxlbmd0aCAmJiAhYWN0aXZlU2hhcmVkU3RhdGVzKSB7XG4gICAgICAgIGFjdGl2ZVNoYXJlZFN0YXRlcyA9IHRoaXMuX3N0YXRlU2hhcmVkLmZpbHRlcihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gIWluY2x1ZGVzKHN0YXRlLCB0YXJnZXRTdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhY3RpdmVTdGF0ZXMgPSBhY3RpdmVTdGF0ZXMuY29uY2F0KGFjdGl2ZVNoYXJlZFN0YXRlcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlbW92ZVJlZ2lzdGVyZWRTdHlsZSh0YXJnZXRTdHlsZSwgYWN0aXZlU3RhdGVzLCB0cnVlKTtcbiAgICB9XG4gIH1cbn07XG52YXIgX3R1cm5UZXh0T04gPSBmdW5jdGlvbiBfdHVyblRleHRPTih0YXJnZXRTdGF0ZSwgYWN0aXZlU3RhdGVzKSB7XG4gIHZhciBzdXBlcmlvclN0YXRlcywgdGFyZ2V0VGV4dDtcblxuICBpZiAodGhpcy5fdGV4dHMgJiYgSVMkMS5zdHJpbmcodGFyZ2V0VGV4dCA9IHRoaXMuX3RleHRzW3RhcmdldFN0YXRlXSkpIHtcbiAgICBzdXBlcmlvclN0YXRlcyA9IHRoaXMuX2dldFN1cGVyaW9yU3RhdGVzKHRhcmdldFN0YXRlLCBhY3RpdmVTdGF0ZXMpO1xuXG4gICAgaWYgKCFzdXBlcmlvclN0YXRlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMudGV4dCA9IHRhcmdldFRleHQ7XG4gICAgfVxuICB9XG59O1xudmFyIF90dXJuVGV4dE9GRiA9IGZ1bmN0aW9uIF90dXJuVGV4dE9GRih0YXJnZXRTdGF0ZSwgYWN0aXZlU3RhdGVzKSB7XG4gIHZhciB0YXJnZXRUZXh0O1xuXG4gIGlmICh0aGlzLl90ZXh0cyAmJiBJUyQxLnN0cmluZyh0YXJnZXRUZXh0ID0gdGhpcy5fdGV4dHNbdGFyZ2V0U3RhdGVdKSkge1xuICAgIGFjdGl2ZVN0YXRlcyA9IGFjdGl2ZVN0YXRlcy5maWx0ZXIoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGUgIT09IHRhcmdldFN0YXRlO1xuICAgIH0pO1xuICAgIHRhcmdldFRleHQgPSB0aGlzLl90ZXh0c1thY3RpdmVTdGF0ZXNbYWN0aXZlU3RhdGVzLmxlbmd0aCAtIDFdXTtcblxuICAgIGlmICh0YXJnZXRUZXh0ID09IG51bGwpIHtcbiAgICAgIHRhcmdldFRleHQgPSB0aGlzLl90ZXh0cy5iYXNlO1xuICAgIH1cblxuICAgIHRoaXMudGV4dCA9IHRhcmdldFRleHQ7XG4gIH1cbn07XG52YXIgX2dldEFjdGl2ZVN0YXRlcyA9IGZ1bmN0aW9uIF9nZXRBY3RpdmVTdGF0ZXMoc3RhdGVUb0V4Y2x1ZGUpIHtcbiAgdmFyIGluY2x1ZGVTaGFyZWRTdGF0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHZhciBhY3RpdmVTdGF0ZXMsIGosIGxlbiwgcGxhaW5TdGF0ZXM7XG5cbiAgaWYgKCF0aGlzLl9wcm92aWRlZFN0YXRlcykge1xuICAgIHJldHVybiBEVU1NWV9BUlJBWTtcbiAgfVxuXG4gIGFjdGl2ZVN0YXRlcyA9IHBsYWluU3RhdGVzID0gdGhpcy5fc3RhdGU7XG5cbiAgaWYgKHN0YXRlVG9FeGNsdWRlKSB7XG4gICAgcGxhaW5TdGF0ZXMgPSBbXTtcblxuICAgIGZvciAoaiA9IDAsIGxlbiA9IGFjdGl2ZVN0YXRlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgc3RhdGUgPSBhY3RpdmVTdGF0ZXNbal07XG5cbiAgICAgIGlmIChzdGF0ZSAhPT0gc3RhdGVUb0V4Y2x1ZGUpIHtcbiAgICAgICAgcGxhaW5TdGF0ZXMucHVzaChzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpbmNsdWRlU2hhcmVkU3RhdGVzIHx8ICF0aGlzLl9wcm92aWRlZFN0YXRlc1NoYXJlZCkge1xuICAgIHJldHVybiBwbGFpblN0YXRlcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGxhaW5TdGF0ZXMuY29uY2F0KHRoaXMuX3N0YXRlU2hhcmVkKTtcbiAgfVxufTtcbnZhciBfZ2V0U3VwZXJpb3JTdGF0ZXMgPSBmdW5jdGlvbiBfZ2V0U3VwZXJpb3JTdGF0ZXModGFyZ2V0U3RhdGUsIGFjdGl2ZVN0YXRlcykge1xuICB2YXIgY2FuZGlkYXRlLCBqLCBsZW4sIHN1cGVyaW9yLCB0YXJnZXRTdGF0ZUluZGV4O1xuICB0YXJnZXRTdGF0ZUluZGV4ID0gdGhpcy5fcHJvdmlkZWRTdGF0ZXMuaW5kZXhPZih0YXJnZXRTdGF0ZSk7XG5cbiAgaWYgKHRhcmdldFN0YXRlSW5kZXggPT09IHRoaXMuX3Byb3ZpZGVkU3RhdGVzLmxlbmd0aCAtIDEpIHtcbiAgICByZXR1cm4gRFVNTVlfQVJSQVk7XG4gIH1cblxuICBzdXBlcmlvciA9IFtdO1xuXG4gIGZvciAoaiA9IDAsIGxlbiA9IGFjdGl2ZVN0YXRlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgIGNhbmRpZGF0ZSA9IGFjdGl2ZVN0YXRlc1tqXTtcblxuICAgIGlmICh0aGlzLl9wcm92aWRlZFN0YXRlcy5pbmRleE9mKGNhbmRpZGF0ZSkgPiB0YXJnZXRTdGF0ZUluZGV4KSB7XG4gICAgICBzdXBlcmlvci5wdXNoKGNhbmRpZGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1cGVyaW9yO1xufTtcbnZhciBfZ2V0U2hhcmVkU3RhdGVzID0gZnVuY3Rpb24gX2dldFNoYXJlZFN0YXRlcyh0YXJnZXRTdGF0ZSkge1xuICB2YXIgYWN0aXZlU3RhdGVzLCBqLCBsZW4sIHJlZiwgc2hhcmVkU3RhdGVzLCBzdGF0ZUNoYWluO1xuICBhY3RpdmVTdGF0ZXMgPSB0aGlzLl9zdGF0ZTtcbiAgc2hhcmVkU3RhdGVzID0gW107XG4gIHJlZiA9IHRoaXMuX3Byb3ZpZGVkU3RhdGVzU2hhcmVkO1xuXG4gIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgIHN0YXRlQ2hhaW4gPSByZWZbal07XG5cbiAgICBpZiAoc3RhdGVDaGFpbi5pbmNsdWRlcyh0YXJnZXRTdGF0ZSkgJiYgc3RhdGVDaGFpbi5pc0FwcGxpY2FibGUodGFyZ2V0U3RhdGUsIGFjdGl2ZVN0YXRlcykpIHtcbiAgICAgIHNoYXJlZFN0YXRlcy5wdXNoKHN0YXRlQ2hhaW4pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzaGFyZWRTdGF0ZXM7XG59O1xudmFyIF9yZXNvbHZlRm5TdHlsZXMgPSBmdW5jdGlvbiBfcmVzb2x2ZUZuU3R5bGVzKHN0YXRlcywgaW5jbHVkZUJhc2UpIHtcbiAgdmFyIGVudHJ5LCBqLCBrLCBsZW4sIGxlbjEsIG91dHB1dCwgcmVmO1xuXG4gIGlmIChpbmNsdWRlQmFzZSkge1xuICAgIHN0YXRlcyA9IFsnYmFzZSddLmNvbmNhdChzdGF0ZXMpO1xuICB9XG5cbiAgb3V0cHV0ID0ge307XG5cbiAgZm9yIChqID0gMCwgbGVuID0gc3RhdGVzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgc3RhdGUgPSBzdGF0ZXNbal07XG5cbiAgICBpZiAodGhpcy5fc3R5bGVzW3N0YXRlXSAmJiB0aGlzLl9zdHlsZXNbc3RhdGVdLmZucy5sZW5ndGgpIHtcbiAgICAgIHJlZiA9IHRoaXMuX3N0eWxlc1tzdGF0ZV0uZm5zO1xuXG4gICAgICBmb3IgKGsgPSAwLCBsZW4xID0gcmVmLmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgICBlbnRyeSA9IHJlZltrXTtcbiAgICAgICAgb3V0cHV0W2VudHJ5WzBdXSA9IGVudHJ5WzFdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuZnVuY3Rpb24gc3RhdGUkMSAoUXVpY2tFbGVtZW50KSB7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuc3RhdGUgPSBzdGF0ZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS50b2dnbGVTdGF0ZSA9IHRvZ2dsZVN0YXRlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnJlc2V0U3RhdGUgPSByZXNldFN0YXRlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnBpcGVTdGF0ZSA9IHBpcGVTdGF0ZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fYXBwbHlSZWdpc3RlcmVkU3R5bGUgPSBfYXBwbHlSZWdpc3RlcmVkU3R5bGU7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3JlbW92ZVJlZ2lzdGVyZWRTdHlsZSA9IF9yZW1vdmVSZWdpc3RlcmVkU3R5bGU7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3R1cm5TdHlsZU9OID0gX3R1cm5TdHlsZU9OO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl90dXJuU3R5bGVPRkYgPSBfdHVyblN0eWxlT0ZGO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl90dXJuVGV4dE9OID0gX3R1cm5UZXh0T047XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3R1cm5UZXh0T0ZGID0gX3R1cm5UZXh0T0ZGO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9nZXRBY3RpdmVTdGF0ZXMgPSBfZ2V0QWN0aXZlU3RhdGVzO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9nZXRTdXBlcmlvclN0YXRlcyA9IF9nZXRTdXBlcmlvclN0YXRlcztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fZ2V0U2hhcmVkU3RhdGVzID0gX2dldFNoYXJlZFN0YXRlcztcbiAgcmV0dXJuIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3Jlc29sdmVGblN0eWxlcyA9IF9yZXNvbHZlRm5TdHlsZXM7XG59dmFyIHRvVGVtcGxhdGUgPSBmdW5jdGlvbiB0b1RlbXBsYXRlKCkge1xuICByZXR1cm4gX3F1aWNrZG9tLnRlbXBsYXRlKHRoaXMpO1xufTtcbnZhciBjbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICB2YXIgYWN0aXZlU3RhdGUsIGNhbGxiYWNrLCBjYWxsYmFja3MsIGNoaWxkLCBlbENsb25lLCBldmVudE5hbWUsIGksIGosIGssIGxlbiwgbGVuMSwgbGVuMiwgbmV3RWwsIG9wdGlvbnMsIHJlZiwgcmVmMSwgcmVmMjtcbiAgZWxDbG9uZSA9IHRoaXMuZWwuY2xvbmVOb2RlKGZhbHNlKTtcbiAgb3B0aW9ucyA9IGV4dGVuZC5jbG9uZSh0aGlzLm9wdGlvbnMsIHtcbiAgICBleGlzdGluZzogZWxDbG9uZVxuICB9KTtcbiAgbmV3RWwgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnR5cGUsIG9wdGlvbnMpO1xuICByZWYgPSB0aGlzLl9zdGF0ZTtcblxuICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhY3RpdmVTdGF0ZSA9IHJlZltpXTtcbiAgICBuZXdFbC5zdGF0ZShhY3RpdmVTdGF0ZSwgdHJ1ZSk7XG4gIH1cblxuICByZWYxID0gdGhpcy5jaGlsZHJlbjtcblxuICBmb3IgKGogPSAwLCBsZW4xID0gcmVmMS5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICBjaGlsZCA9IHJlZjFbal07XG4gICAgbmV3RWwuYXBwZW5kKGNoaWxkLmNsb25lKCkpO1xuICB9XG5cbiAgcmVmMiA9IHRoaXMuX2V2ZW50Q2FsbGJhY2tzO1xuXG4gIGZvciAoZXZlbnROYW1lIGluIHJlZjIpIHtcbiAgICBjYWxsYmFja3MgPSByZWYyW2V2ZW50TmFtZV07XG5cbiAgICBmb3IgKGsgPSAwLCBsZW4yID0gY2FsbGJhY2tzLmxlbmd0aDsgayA8IGxlbjI7IGsrKykge1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFja3Nba107XG4gICAgICBuZXdFbC5vbihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3RWw7XG59O1xudmFyIGFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCh0YXJnZXRFbCkge1xuICB2YXIgcHJldlBhcmVudDtcblxuICBpZiAodGFyZ2V0RWwpIHtcbiAgICB0YXJnZXRFbCA9IG5vcm1hbGl6ZUVsZW1lbnRBcmcodGFyZ2V0RWwpO1xuXG4gICAgaWYgKElTJDEucXVpY2tEb21FbCh0YXJnZXRFbCkpIHtcbiAgICAgIHByZXZQYXJlbnQgPSB0YXJnZXRFbC5wYXJlbnQ7XG5cbiAgICAgIGlmIChwcmV2UGFyZW50KSB7XG4gICAgICAgIHByZXZQYXJlbnQuX3JlbW92ZUNoaWxkKHRhcmdldEVsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaCh0YXJnZXRFbCk7XG5cbiAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGFyZ2V0RWwuZWwpO1xuXG4gICAgICB0YXJnZXRFbC5fcmVmcmVzaFBhcmVudCgpOyAvLyBGb3JjZSByZS1mcmVzaCB0YXJnZXRFbC5fcGFyZW50IHZhbHVlIHRvIHRyaWdnZXIgaW5zZXJ0ZWQgY2FsbGJhY2tcblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBhcHBlbmRUbyA9IGZ1bmN0aW9uIGFwcGVuZFRvKHRhcmdldEVsKSB7XG4gIGlmICh0YXJnZXRFbCkge1xuICAgIHRhcmdldEVsID0gbm9ybWFsaXplRWxlbWVudEFyZyh0YXJnZXRFbCk7XG5cbiAgICBpZiAoSVMkMS5xdWlja0RvbUVsKHRhcmdldEVsKSkge1xuICAgICAgdGFyZ2V0RWwuYXBwZW5kKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBwcmVwZW5kID0gZnVuY3Rpb24gcHJlcGVuZCh0YXJnZXRFbCkge1xuICB2YXIgcHJldlBhcmVudDtcblxuICBpZiAodGFyZ2V0RWwpIHtcbiAgICB0YXJnZXRFbCA9IG5vcm1hbGl6ZUVsZW1lbnRBcmcodGFyZ2V0RWwpO1xuXG4gICAgaWYgKElTJDEucXVpY2tEb21FbCh0YXJnZXRFbCkpIHtcbiAgICAgIHByZXZQYXJlbnQgPSB0YXJnZXRFbC5wYXJlbnQ7XG5cbiAgICAgIGlmIChwcmV2UGFyZW50KSB7XG4gICAgICAgIHByZXZQYXJlbnQuX3JlbW92ZUNoaWxkKHRhcmdldEVsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2hpbGRyZW4udW5zaGlmdCh0YXJnZXRFbCk7XG5cbiAgICAgIHRoaXMuZWwuaW5zZXJ0QmVmb3JlKHRhcmdldEVsLmVsLCB0aGlzLmVsLmZpcnN0Q2hpbGQpO1xuXG4gICAgICB0YXJnZXRFbC5fcmVmcmVzaFBhcmVudCgpOyAvLyBGb3JjZSByZS1mcmVzaCB0YXJnZXRFbC5fcGFyZW50IHZhbHVlIHRvIHRyaWdnZXIgaW5zZXJ0ZWQgY2FsbGJhY2tcblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBwcmVwZW5kVG8gPSBmdW5jdGlvbiBwcmVwZW5kVG8odGFyZ2V0RWwpIHtcbiAgaWYgKHRhcmdldEVsKSB7XG4gICAgdGFyZ2V0RWwgPSBub3JtYWxpemVFbGVtZW50QXJnKHRhcmdldEVsKTtcblxuICAgIGlmIChJUyQxLnF1aWNrRG9tRWwodGFyZ2V0RWwpKSB7XG4gICAgICB0YXJnZXRFbC5wcmVwZW5kKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBhZnRlciA9IGZ1bmN0aW9uIGFmdGVyKHRhcmdldEVsKSB7XG4gIHZhciBteUluZGV4O1xuXG4gIGlmICh0YXJnZXRFbCAmJiB0aGlzLnBhcmVudCkge1xuICAgIHRhcmdldEVsID0gbm9ybWFsaXplRWxlbWVudEFyZyh0YXJnZXRFbCk7XG5cbiAgICBpZiAoSVMkMS5xdWlja0RvbUVsKHRhcmdldEVsKSkge1xuICAgICAgbXlJbmRleCA9IHRoaXMucGFyZW50Ll9jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuXG4gICAgICB0aGlzLnBhcmVudC5fY2hpbGRyZW4uc3BsaWNlKG15SW5kZXggKyAxLCAwLCB0YXJnZXRFbCk7XG5cbiAgICAgIHRoaXMuZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGFyZ2V0RWwuZWwsIHRoaXMuZWwubmV4dFNpYmxpbmcpO1xuXG4gICAgICB0YXJnZXRFbC5fcmVmcmVzaFBhcmVudCgpOyAvLyBGb3JjZSByZS1mcmVzaCB0YXJnZXRFbC5fcGFyZW50IHZhbHVlIHRvIHRyaWdnZXIgaW5zZXJ0ZWQgY2FsbGJhY2tcblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBpbnNlcnRBZnRlciA9IGZ1bmN0aW9uIGluc2VydEFmdGVyKHRhcmdldEVsKSB7XG4gIGlmICh0YXJnZXRFbCkge1xuICAgIHRhcmdldEVsID0gbm9ybWFsaXplRWxlbWVudEFyZyh0YXJnZXRFbCk7XG5cbiAgICBpZiAoSVMkMS5xdWlja0RvbUVsKHRhcmdldEVsKSkge1xuICAgICAgdGFyZ2V0RWwuYWZ0ZXIodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGJlZm9yZSA9IGZ1bmN0aW9uIGJlZm9yZSh0YXJnZXRFbCkge1xuICB2YXIgbXlJbmRleDtcblxuICBpZiAodGFyZ2V0RWwgJiYgdGhpcy5wYXJlbnQpIHtcbiAgICB0YXJnZXRFbCA9IG5vcm1hbGl6ZUVsZW1lbnRBcmcodGFyZ2V0RWwpO1xuXG4gICAgaWYgKElTJDEucXVpY2tEb21FbCh0YXJnZXRFbCkpIHtcbiAgICAgIG15SW5kZXggPSB0aGlzLnBhcmVudC5fY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcblxuICAgICAgdGhpcy5wYXJlbnQuX2NoaWxkcmVuLnNwbGljZShteUluZGV4LCAwLCB0YXJnZXRFbCk7XG5cbiAgICAgIHRoaXMuZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGFyZ2V0RWwuZWwsIHRoaXMuZWwpO1xuXG4gICAgICB0YXJnZXRFbC5fcmVmcmVzaFBhcmVudCgpOyAvLyBGb3JjZSByZS1mcmVzaCB0YXJnZXRFbC5fcGFyZW50IHZhbHVlIHRvIHRyaWdnZXIgaW5zZXJ0ZWQgY2FsbGJhY2tcblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBpbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiBpbnNlcnRCZWZvcmUodGFyZ2V0RWwpIHtcbiAgaWYgKHRhcmdldEVsKSB7XG4gICAgdGFyZ2V0RWwgPSBub3JtYWxpemVFbGVtZW50QXJnKHRhcmdldEVsKTtcblxuICAgIGlmIChJUyQxLnF1aWNrRG9tRWwodGFyZ2V0RWwpKSB7XG4gICAgICB0YXJnZXRFbC5iZWZvcmUodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGRldGFjaCA9IGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgdmFyIHJlZjtcblxuICBpZiAoKHJlZiA9IHRoaXMucGFyZW50KSAhPSBudWxsKSB7XG4gICAgcmVmLl9yZW1vdmVDaGlsZCh0aGlzKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gIHZhciBldmVudE5hbWU7XG4gIHRoaXMuZGV0YWNoKCk7XG4gIHRoaXMucmVzZXRTdGF0ZSgpO1xuXG4gIGlmICh0aGlzLl9ldmVudENhbGxiYWNrcykge1xuICAgIGZvciAoZXZlbnROYW1lIGluIHRoaXMuX2V2ZW50Q2FsbGJhY2tzKSB7XG4gICAgICB0aGlzLl9ldmVudENhbGxiYWNrc1tldmVudE5hbWVdLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGVtcHR5ID0gZnVuY3Rpb24gZW1wdHkoKSB7XG4gIHZhciBjaGlsZCwgaSwgbGVuLCByZWY7XG4gIHJlZiA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcblxuICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjaGlsZCA9IHJlZltpXTtcblxuICAgIHRoaXMuX3JlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciB3cmFwID0gZnVuY3Rpb24gd3JhcCh0YXJnZXRFbCkge1xuICB2YXIgY3VycmVudFBhcmVudDtcblxuICBpZiAodGFyZ2V0RWwpIHtcbiAgICB0YXJnZXRFbCA9IG5vcm1hbGl6ZUVsZW1lbnRBcmcodGFyZ2V0RWwpO1xuICAgIGN1cnJlbnRQYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuICAgIGlmIChJUyQxLnF1aWNrRG9tRWwodGFyZ2V0RWwpICYmIHRhcmdldEVsICE9PSB0aGlzICYmIHRhcmdldEVsICE9PSB0aGlzLnBhcmVudCkge1xuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgY3VycmVudFBhcmVudC5fcmVtb3ZlQ2hpbGQodGhpcywgIXRhcmdldEVsLnBhcmVudCA/IHRhcmdldEVsIDogdm9pZCAwKTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0RWwuYXBwZW5kKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciB1bndyYXAgPSBmdW5jdGlvbiB1bndyYXAoKSB7XG4gIHZhciBncmFuZFBhcmVudCwgcGFyZW50LCBwYXJlbnRDaGlsZHJlbiwgcGFyZW50U2libGluZztcbiAgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudENoaWxkcmVuID0gX3F1aWNrZG9tLmJhdGNoKHBhcmVudC5jaGlsZHJlbik7XG4gICAgcGFyZW50U2libGluZyA9IHBhcmVudC5uZXh0O1xuICAgIGdyYW5kUGFyZW50ID0gcGFyZW50LnBhcmVudDtcblxuICAgIGlmIChncmFuZFBhcmVudCkge1xuICAgICAgcGFyZW50LmRldGFjaCgpO1xuXG4gICAgICBpZiAocGFyZW50U2libGluZykge1xuICAgICAgICBwYXJlbnRDaGlsZHJlbi5pbnNlcnRCZWZvcmUocGFyZW50U2libGluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnRDaGlsZHJlbi5hcHBlbmRUbyhncmFuZFBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHRhcmdldEVsKSB7XG4gIHZhciByZWY7XG5cbiAgaWYgKHRhcmdldEVsKSB7XG4gICAgdGFyZ2V0RWwgPSBub3JtYWxpemVFbGVtZW50QXJnKHRhcmdldEVsKTtcblxuICAgIGlmIChJUyQxLnF1aWNrRG9tRWwodGFyZ2V0RWwpICYmIHRhcmdldEVsICE9PSB0aGlzKSB7XG4gICAgICB0YXJnZXRFbC5kZXRhY2goKTtcblxuICAgICAgaWYgKChyZWYgPSB0aGlzLnBhcmVudCkgIT0gbnVsbCkge1xuICAgICAgICByZWYuX3JlbW92ZUNoaWxkKHRoaXMsIHRhcmdldEVsKTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0RWwuX3JlZnJlc2hQYXJlbnQoKTsgLy8gRm9yY2UgcmUtZnJlc2ggdGFyZ2V0RWwuX3BhcmVudCB2YWx1ZSB0byB0cmlnZ2VyIGluc2VydGVkIGNhbGxiYWNrXG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgaGFzQ2xhc3MgPSBmdW5jdGlvbiBoYXNDbGFzcyh0YXJnZXQpIHtcbiAgcmV0dXJuIGluY2x1ZGVzKHRoaXMuY2xhc3NMaXN0LCB0YXJnZXQpO1xufTtcbnZhciBhZGRDbGFzcyA9IGZ1bmN0aW9uIGFkZENsYXNzKHRhcmdldCkge1xuICB2YXIgY2xhc3NMaXN0LCB0YXJnZXRJbmRleDtcbiAgY2xhc3NMaXN0ID0gdGhpcy5jbGFzc0xpc3Q7XG4gIHRhcmdldEluZGV4ID0gY2xhc3NMaXN0LmluZGV4T2YodGFyZ2V0KTtcblxuICBpZiAodGFyZ2V0SW5kZXggPT09IC0xKSB7XG4gICAgY2xhc3NMaXN0LnB1c2godGFyZ2V0KTtcbiAgICB0aGlzLmNsYXNzTmFtZSA9IGNsYXNzTGlzdC5sZW5ndGggPiAxID8gY2xhc3NMaXN0LmpvaW4oJyAnKSA6IGNsYXNzTGlzdFswXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKHRhcmdldCkge1xuICB2YXIgY2xhc3NMaXN0LCB0YXJnZXRJbmRleDtcbiAgY2xhc3NMaXN0ID0gdGhpcy5jbGFzc0xpc3Q7XG4gIHRhcmdldEluZGV4ID0gY2xhc3NMaXN0LmluZGV4T2YodGFyZ2V0KTtcblxuICBpZiAodGFyZ2V0SW5kZXggIT09IC0xKSB7XG4gICAgY2xhc3NMaXN0LnNwbGljZSh0YXJnZXRJbmRleCwgMSk7XG4gICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc0xpc3QubGVuZ3RoID8gY2xhc3NMaXN0LmpvaW4oJyAnKSA6ICcnO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHRvZ2dsZUNsYXNzID0gZnVuY3Rpb24gdG9nZ2xlQ2xhc3ModGFyZ2V0KSB7XG4gIGlmICh0aGlzLmhhc0NsYXNzKHRhcmdldCkpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKHRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hZGRDbGFzcyh0YXJnZXQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHNldFJlZiA9IGZ1bmN0aW9uIHNldFJlZih0YXJnZXQpIHtcbiAgdGhpcy5yZWYgPSB0aGlzLm9wdGlvbnMucmVmID0gdGFyZ2V0O1xuICB0aGlzLmF0dHIoJ2RhdGEtcmVmJywgdGFyZ2V0KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIF9yZWZyZXNoUGFyZW50ID0gZnVuY3Rpb24gX3JlZnJlc2hQYXJlbnQoKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudDtcbn07XG52YXIgX3JlbW92ZUNoaWxkID0gZnVuY3Rpb24gX3JlbW92ZUNoaWxkKHRhcmdldENoaWxkLCByZXBsYWNlbWVudENoaWxkKSB7XG4gIHZhciBpbmRleE9mQ2hpbGQ7XG4gIGluZGV4T2ZDaGlsZCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZih0YXJnZXRDaGlsZCk7XG5cbiAgaWYgKGluZGV4T2ZDaGlsZCAhPT0gLTEpIHtcbiAgICBpZiAocmVwbGFjZW1lbnRDaGlsZCkge1xuICAgICAgdGhpcy5lbC5yZXBsYWNlQ2hpbGQocmVwbGFjZW1lbnRDaGlsZC5lbCwgdGFyZ2V0Q2hpbGQuZWwpO1xuXG4gICAgICB0aGlzLl9jaGlsZHJlbi5zcGxpY2UoaW5kZXhPZkNoaWxkLCAxLCByZXBsYWNlbWVudENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbC5yZW1vdmVDaGlsZCh0YXJnZXRDaGlsZC5lbCk7XG5cbiAgICAgIHRoaXMuX2NoaWxkcmVuLnNwbGljZShpbmRleE9mQ2hpbGQsIDEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvbiAoUXVpY2tFbGVtZW50KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFF1aWNrRWxlbWVudC5wcm90b3R5cGUsIHtcbiAgICAnaHRtbCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5pbm5lckhUTUw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuaW5uZXJIVE1MID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICAndGV4dCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC50ZXh0Q29udGVudDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC50ZXh0Q29udGVudCA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2NsYXNzTmFtZSc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5zdmcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdjbGFzcycpIHx8ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJhdy5jbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5zdmcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdjbGFzcycsIG5ld1ZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yYXcuY2xhc3NOYW1lID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdjbGFzc0xpc3QnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIGxpc3Q7XG4gICAgICAgIGxpc3QgPSB0aGlzLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pO1xuXG4gICAgICAgIGlmIChsaXN0W2xpc3QubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgICAgICAgbGlzdC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0WzBdID09PSAnJykge1xuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUudG9UZW1wbGF0ZSA9IHRvVGVtcGxhdGU7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuY2xvbmUgPSBjbG9uZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5hcHBlbmQgPSBhcHBlbmQ7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuYXBwZW5kVG8gPSBhcHBlbmRUbztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5wcmVwZW5kID0gcHJlcGVuZDtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5wcmVwZW5kVG8gPSBwcmVwZW5kVG87XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuYWZ0ZXIgPSBhZnRlcjtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5pbnNlcnRBZnRlciA9IGluc2VydEFmdGVyO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmJlZm9yZSA9IGJlZm9yZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBpbnNlcnRCZWZvcmU7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuZGV0YWNoID0gZGV0YWNoO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnJlbW92ZSA9IHJlbW92ZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5lbXB0eSA9IGVtcHR5O1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLndyYXAgPSB3cmFwO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnVud3JhcCA9IHVud3JhcDtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5yZXBsYWNlID0gcmVwbGFjZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5oYXNDbGFzcyA9IGhhc0NsYXNzO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmFkZENsYXNzID0gYWRkQ2xhc3M7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSByZW1vdmVDbGFzcztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS50b2dnbGVDbGFzcyA9IHRvZ2dsZUNsYXNzO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnNldFJlZiA9IHNldFJlZjtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fcmVmcmVzaFBhcmVudCA9IF9yZWZyZXNoUGFyZW50O1xuICByZXR1cm4gUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fcmVtb3ZlQ2hpbGQgPSBfcmVtb3ZlQ2hpbGQ7XG59dmFyIHVwZGF0ZU9wdGlvbnMgPSBmdW5jdGlvbiB1cGRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKElTJDEub2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHRoaXMuX25vcm1hbGl6ZU9wdGlvbnMoKTtcblxuICAgIHRoaXMuX2FwcGx5T3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHVwZGF0ZVN0YXRlU3R5bGVzID0gZnVuY3Rpb24gdXBkYXRlU3RhdGVTdHlsZXMoc3R5bGVzKSB7XG4gIHZhciBpLCBsZW4sIHBhcnNlZCwgc3RhdGUsIHVwZGF0ZWRTdGF0ZXM7XG5cbiAgaWYgKElTJDEub2JqZWN0UGxhaW4oc3R5bGVzKSkge1xuICAgIGV4dGVuZC5kZWVwLmNvbmNhdCh0aGlzLCBwYXJzZWQgPSB0aGlzLl9wYXJzZVN0eWxlcyhzdHlsZXMpKTtcblxuICAgIGlmIChwYXJzZWQuX3N0eWxlcykge1xuICAgICAgdXBkYXRlZFN0YXRlcyA9IE9iamVjdC5rZXlzKHBhcnNlZC5fc3R5bGVzKTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gdXBkYXRlZFN0YXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdGF0ZSA9IHVwZGF0ZWRTdGF0ZXNbaV07XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUoc3RhdGUpIHx8IHN0YXRlID09PSAnYmFzZScpIHtcbiAgICAgICAgICB0aGlzLl9hcHBseVJlZ2lzdGVyZWRTdHlsZSh0aGlzLl9zdHlsZXNbc3RhdGVdLCB0aGlzLl9nZXRBY3RpdmVTdGF0ZXMoc3RhdGUpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgdXBkYXRlU3RhdGVUZXh0cyA9IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlVGV4dHModGV4dHMpIHtcbiAgdmFyIHBhcnNlZDtcblxuICBpZiAoSVMkMS5vYmplY3RQbGFpbih0ZXh0cykpIHtcbiAgICBleHRlbmQuZGVlcC5jb25jYXQodGhpcywgcGFyc2VkID0gdGhpcy5fcGFyc2VUZXh0cyh0ZXh0cykpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGFwcGx5RGF0YSA9IGZ1bmN0aW9uIGFwcGx5RGF0YShkYXRhLCBwYXNzVGhyb3VnaCkge1xuICB2YXIgY2hpbGQsIGNvbXB1dGVycywgZGVmYXVsdHMsIGksIGosIGtleSwga2V5cywgbGVuLCBsZW4xLCByZWY7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5wYXNzRGF0YVRvQ2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoICYmIChwYXNzVGhyb3VnaCAhPSBudWxsID8gcGFzc1Rocm91Z2ggOiBwYXNzVGhyb3VnaCA9IHRydWUpKSB7XG4gICAgcmVmID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNoaWxkID0gcmVmW2ldO1xuICAgICAgY2hpbGQuYXBwbHlEYXRhKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb21wdXRlcnMgPSB0aGlzLm9wdGlvbnMuY29tcHV0ZXJzKSB7XG4gICAgZGVmYXVsdHMgPSB0aGlzLm9wdGlvbnMuZGVmYXVsdHM7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGNvbXB1dGVycyk7XG5cbiAgICBmb3IgKGogPSAwLCBsZW4xID0ga2V5cy5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICAgIGtleSA9IGtleXNbal07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW52b2tlQ29tcHV0ZXJzT25jZSkge1xuICAgICAgICBpZiAodGhpcy5faW52b2tlZENvbXB1dGVyc1trZXldKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pbnZva2VkQ29tcHV0ZXJzW2tleV0gPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdGhpcy5fcnVuQ29tcHV0ZXIoa2V5LCBkYXRhW2tleV0sIGRhdGEpO1xuICAgICAgfSBlbHNlIGlmIChkZWZhdWx0cyAmJiBkZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHRoaXMuX3J1bkNvbXB1dGVyKGtleSwgZGVmYXVsdHNba2V5XSwgZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIF9ydW5Db21wdXRlciA9IGZ1bmN0aW9uIF9ydW5Db21wdXRlcihjb21wdXRlciwgYXJnLCBkYXRhKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMuY29tcHV0ZXJzW2NvbXB1dGVyXS5jYWxsKHRoaXMsIGFyZywgZGF0YSk7XG59O1xuZnVuY3Rpb24gYXBwbGljYXRpb24gKFF1aWNrRWxlbWVudCkge1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnVwZGF0ZU9wdGlvbnMgPSB1cGRhdGVPcHRpb25zO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnVwZGF0ZVN0YXRlU3R5bGVzID0gdXBkYXRlU3RhdGVTdHlsZXM7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUudXBkYXRlU3RhdGVUZXh0cyA9IHVwZGF0ZVN0YXRlVGV4dHM7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuYXBwbHlEYXRhID0gYXBwbHlEYXRhO1xuICByZXR1cm4gUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fcnVuQ29tcHV0ZXIgPSBfcnVuQ29tcHV0ZXI7XG59dmFyIGF0dHIgPSBmdW5jdGlvbiBhdHRyKHRhcmdldCwgbmV3VmFsdWUpIHtcbiAgdmFyIGksIGtleSwga2V5cztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKHRhcmdldCk7XG4gICAgfVxuXG4gICAgaWYgKElTJDEub2JqZWN0KHRhcmdldCkpIHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh0YXJnZXQpO1xuICAgICAgaSA9IC0xO1xuXG4gICAgICB3aGlsZSAoa2V5ID0ga2V5c1srK2ldKSB7XG4gICAgICAgIHRoaXMuYXR0cihrZXksIHRhcmdldFtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobmV3VmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUodGFyZ2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSh0YXJnZXQsIG5ld1ZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBwcm9wID0gZnVuY3Rpb24gcHJvcCh0YXJnZXQsIG5ld1ZhbHVlKSB7XG4gIHZhciBpLCBrZXksIGtleXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsW3RhcmdldF07XG4gICAgfVxuXG4gICAgaWYgKElTJDEub2JqZWN0KHRhcmdldCkpIHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh0YXJnZXQpO1xuICAgICAgaSA9IC0xO1xuXG4gICAgICB3aGlsZSAoa2V5ID0ga2V5c1srK2ldKSB7XG4gICAgICAgIHRoaXMucHJvcChrZXksIHRhcmdldFtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5lbFt0YXJnZXRdID0gbmV3VmFsdWU7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5mdW5jdGlvbiBhdHRyaWJ1dGVzQW5kUHJvcGVydGllcyAoUXVpY2tFbGVtZW50KSB7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuYXR0ciA9IGF0dHI7XG4gIHJldHVybiBRdWlja0VsZW1lbnQucHJvdG90eXBlLnByb3AgPSBwcm9wO1xufXZhciBRdWlja0VsZW1lbnQkMSwgc3ZnTmFtZXNwYWNlO1xuc3ZnTmFtZXNwYWNlID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbnZhciBRdWlja0VsZW1lbnQkMiA9IFF1aWNrRWxlbWVudCQxID0gZnVuY3Rpb24gKCkge1xuICB2YXIgUXVpY2tFbGVtZW50ID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUXVpY2tFbGVtZW50KHR5cGUsIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRdWlja0VsZW1lbnQpO1xuXG4gICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIFF1aWNrRWxlbWVudC5jb3VudCsrO1xuXG4gICAgICBpZiAodGhpcy50eXBlWzBdID09PSAnKicpIHtcbiAgICAgICAgdGhpcy5zdmcgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsID0gdGhpcy5vcHRpb25zLmV4aXN0aW5nIHx8ICh0aGlzLnR5cGUgPT09ICd0ZXh0JyA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHR5cGVvZiB0aGlzLm9wdGlvbnMudGV4dCA9PT0gJ3N0cmluZycgPyB0aGlzLm9wdGlvbnMudGV4dCA6ICcnKSA6IHRoaXMuc3ZnID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05hbWVzcGFjZSwgdGhpcy50eXBlLnNsaWNlKDEpKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy50eXBlKSk7XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICB0aGlzLmFwcGVuZCA9IHRoaXMucHJlcGVuZCA9IHRoaXMuYXR0ciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgfSAvLyBAX3RleHRzID0ge30gIyBkZWZpbmVkIGNvbmRpdGlvbmFsbHlcblxuXG4gICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgdGhpcy5fc3R5bGVzID0ge307XG4gICAgICB0aGlzLl9zdGF0ZSA9IFtdO1xuICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTsgLy8gQF9wcm92aWRlZFN0YXRlcyA9IFtdXHRcdFx0XHQjIGRlZmluZWQgY29uZGl0aW9uYWxseVxuICAgICAgLy8gQF9wcm92aWRlZFN0YXRlc1NoYXJlZCA9IFtdXHRcdCMgZGVmaW5lZCBjb25kaXRpb25hbGx5XG4gICAgICAvLyBAX2V2ZW50Q2FsbGJhY2tzID0ge19fcmVmczp7fX1cdCMgZGVmaW5lZCBjb25kaXRpb25hbGx5XG5cbiAgICAgIHRoaXMuX25vcm1hbGl6ZU9wdGlvbnMoKTtcblxuICAgICAgdGhpcy5fYXBwbHlPcHRpb25zKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaFN0YXRlRXZlbnRzKCk7XG5cbiAgICAgIHRoaXMuX3Byb3h5UGFyZW50KCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXhpc3RpbmcpIHtcbiAgICAgICAgdGhpcy5fcmVmcmVzaFBhcmVudCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsLl9xdWlja0VsZW1lbnQgPSB0aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhRdWlja0VsZW1lbnQsIFt7XG4gICAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICB2YXIgY2hpbGQsIGNoaWxkcmVuLCBpLCBsZW4sIG91dHB1dDtcbiAgICAgICAgb3V0cHV0ID0gW3RoaXMudHlwZSwgZXh0ZW5kLmNsb25lLmtleXMoZWxlbWVudCkodGhpcy5vcHRpb25zKV07XG4gICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgb3V0cHV0LnB1c2goY2hpbGQudG9KU09OKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUXVpY2tFbGVtZW50O1xuICB9KCk7XG4gIFF1aWNrRWxlbWVudC5jb3VudCA9IDA7XG4gIHJldHVybiBRdWlja0VsZW1lbnQ7XG59LmNhbGwodW5kZWZpbmVkKTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbmlmIChRdWlja0VsZW1lbnQkMS5uYW1lID09IG51bGwpIHtcbiAgUXVpY2tFbGVtZW50JDEubmFtZSA9ICdRdWlja0VsZW1lbnQnO1xufVxuaW5pdCQxKFF1aWNrRWxlbWVudCQxKTtcbmFsaWFzZXMoUXVpY2tFbGVtZW50JDEpO1xudHJhdmVyc2luZyhRdWlja0VsZW1lbnQkMSk7XG5ldmVudHMoUXVpY2tFbGVtZW50JDEpO1xuc3RhdGUkMShRdWlja0VsZW1lbnQkMSk7XG5zdHlsZSQxKFF1aWNrRWxlbWVudCQxKTtcbm1hbmlwdWxhdGlvbihRdWlja0VsZW1lbnQkMSk7XG5hcHBsaWNhdGlvbihRdWlja0VsZW1lbnQkMSk7XG5hdHRyaWJ1dGVzQW5kUHJvcGVydGllcyhRdWlja0VsZW1lbnQkMSk7dmFyIHNjaGVtYSA9IHtcbiAgdHlwZTogJ2RpdicsXG4gIHJlZjogdm9pZCAwLFxuICBvcHRpb25zOiB7fSxcbiAgY2hpbGRyZW46IFtdXG59O1xudmFyIG1hdGNoZXNTY2hlbWEgPSBmdW5jdGlvbiBtYXRjaGVzU2NoZW1hKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdC50eXBlICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygb2JqZWN0LnJlZiAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIG9iamVjdC5vcHRpb25zICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygb2JqZWN0LmNoaWxkcmVuICE9PSAndW5kZWZpbmVkJztcbn07dmFyIFBBUlNFX0VSUk9SX1BSRUZJWCwgcGFyc2VUcmVlO1xuUEFSU0VfRVJST1JfUFJFRklYID0gJ1RlbXBsYXRlIFBhcnNlIEVycm9yOiBleHBlY3RlZCc7XG52YXIgcGFyc2VUcmVlJDEgPSBwYXJzZVRyZWUgPSBmdW5jdGlvbiBwYXJzZVRyZWUodHJlZSwgcGFyc2VDaGlsZHJlbikge1xuICB2YXIgb3V0cHV0O1xuXG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICFJUyQxLmFycmF5KHRyZWUpOlxuICAgICAgb3V0cHV0ID0ge307XG5cbiAgICAgIGlmICghSVMkMS5zdHJpbmcodHJlZVswXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KFBBUlNFX0VSUk9SX1BSRUZJWCwgXCIgc3RyaW5nIGZvciAndHlwZScsIGdvdCAnXCIpLmNvbmNhdChTdHJpbmcodHJlZVswXSksIFwiJ1wiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQudHlwZSA9IHRyZWVbMF07XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDEgJiYgIUlTJDEub2JqZWN0KHRyZWVbMV0pICYmIHRyZWVbMV0gIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KFBBUlNFX0VSUk9SX1BSRUZJWCwgXCIgb2JqZWN0IGZvciAnb3B0aW9ucycsIGdvdCAnXCIpLmNvbmNhdChTdHJpbmcodHJlZVsxXSksIFwiJ1wiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQub3B0aW9ucyA9IHRyZWVbMV0gPyBleHRlbmQuZGVlcC5jbG9uZSh0cmVlWzFdKSA6IHNjaGVtYS5vcHRpb25zO1xuXG4gICAgICAgIGlmICh0cmVlWzFdKSB7XG4gICAgICAgICAgb3V0cHV0LnJlZiA9IHRyZWVbMV0uaWQgfHwgdHJlZVsxXS5yZWY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3V0cHV0LmNoaWxkcmVuID0gdHJlZS5zbGljZSgyKTtcblxuICAgICAgaWYgKHBhcnNlQ2hpbGRyZW4gPT09IGZhbHNlKSB7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA9PT0gMyAmJiBJUyQxLm9iamVjdFBsYWluKHRyZWVbMl0pICYmICFJUyQxLnRlbXBsYXRlKHRyZWVbMl0pKSB7XG4gICAgICAgICAgb3V0cHV0LmNoaWxkcmVuID0gdHJlZVsyXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LmNoaWxkcmVuID0gb3V0cHV0LmNoaWxkcmVuLm1hcChxdWlja2RvbS50ZW1wbGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG5cbiAgICBjYXNlICEoSVMkMS5zdHJpbmcodHJlZSkgfHwgSVMkMS5kb21UZXh0KHRyZWUpKTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHRleHQ6IHRyZWUudGV4dENvbnRlbnQgfHwgdHJlZVxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogc2NoZW1hLmNoaWxkcmVuXG4gICAgICB9O1xuXG4gICAgY2FzZSAhSVMkMS5kb21FbCh0cmVlKTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRyZWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgcmVmOiB0cmVlLmlkLFxuICAgICAgICBvcHRpb25zOiBleHRlbmQuY2xvbmUua2V5cyh0ZW1wbGF0ZSkodHJlZSksXG4gICAgICAgIGNoaWxkcmVuOiBzY2hlbWEuY2hpbGRyZW4ubWFwLmNhbGwodHJlZS5jaGlsZE5vZGVzLCBxdWlja2RvbS50ZW1wbGF0ZSlcbiAgICAgIH07XG5cbiAgICBjYXNlICFJUyQxLnF1aWNrRG9tRWwodHJlZSk6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0cmVlLnR5cGUsXG4gICAgICAgIHJlZjogdHJlZS5yZWYsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuZC5jbG9uZS5kZWVwLm5vdEtleXMoWydyZWxhdGVkSW5zdGFuY2UnLCAncmVsYXRlZCddKSh0cmVlLm9wdGlvbnMpLFxuICAgICAgICBjaGlsZHJlbjogdHJlZS5jaGlsZHJlbi5tYXAocXVpY2tkb20udGVtcGxhdGUpXG4gICAgICB9O1xuXG4gICAgY2FzZSAhSVMkMS50ZW1wbGF0ZSh0cmVlKTpcbiAgICAgIHJldHVybiB0cmVlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdChQQVJTRV9FUlJPUl9QUkVGSVgsIFwiIChhcnJheSB8fCBzdHJpbmcgfHwgZG9tRWwgfHwgcXVpY2tEb21FbCB8fCB0ZW1wbGF0ZSksIGdvdCBcIikuY29uY2F0KFN0cmluZyh0cmVlKSkpO1xuICB9XG59O3ZhciBOT1RfREVFUF9LRVlTLCBOT1RfS0VZUywgX2V4dGVuZEJ5UmVmLCBleHRlbmRUZW1wbGF0ZTtcbk5PVF9ERUVQX0tFWVMgPSBbJ3JlbGF0ZWRJbnN0YW5jZScsICdyZWxhdGVkJywgJ2RhdGEnXTtcbk5PVF9LRVlTID0gWydjaGlsZHJlbicsICdfY2hpbGRSZWZzJ107XG52YXIgZXh0ZW5kVGVtcGxhdGUkMSA9IGV4dGVuZFRlbXBsYXRlID0gZnVuY3Rpb24gZXh0ZW5kVGVtcGxhdGUoY3VycmVudE9wdHMsIG5ld09wdHMsIGdsb2JhbE9wdHMpIHtcbiAgdmFyIGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkcmVuLCBnbG9iYWxPcHRzVHJhbnNmb3JtLCBpbmRleCwgbWF4TGVuZ3RoLCBuZWVkc1RlbXBsYXRlV3JhcCwgbmV3Q2hpbGQsIG5ld0NoaWxkUHJvY2Vzc2VkLCBuZXdDaGlsZHJlbiwgbm9DaGFuZ2VzLCBvdXRwdXQsIHJlZiwgcmVtYWluaW5nTmV3Q2hpbGRyZW47XG5cbiAgaWYgKGdsb2JhbE9wdHMpIHtcbiAgICBnbG9iYWxPcHRzVHJhbnNmb3JtID0ge1xuICAgICAgb3B0aW9uczogZnVuY3Rpb24gb3B0aW9ucyhvcHRzKSB7XG4gICAgICAgIHJldHVybiBleHRlbmQob3B0cywgZ2xvYmFsT3B0cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGlmIChJUyQxLmFycmF5KG5ld09wdHMpKSB7XG4gICAgbmV3T3B0cyA9IHBhcnNlVHJlZSQxKG5ld09wdHMsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChuZXdPcHRzICYmICFtYXRjaGVzU2NoZW1hKG5ld09wdHMpKSB7XG4gICAgbmV3T3B0cyA9IHtcbiAgICAgIG9wdGlvbnM6IG5ld09wdHNcbiAgICB9O1xuICB9XG5cbiAgb3V0cHV0ID0gZXh0ZW5kLmRlZXAubnVsbERlbGV0ZXMubm90S2V5cyhOT1RfS0VZUykubm90RGVlcChOT1RfREVFUF9LRVlTKS50cmFuc2Zvcm0oZ2xvYmFsT3B0c1RyYW5zZm9ybSkuY2xvbmUoY3VycmVudE9wdHMsIG5ld09wdHMpO1xuICBjdXJyZW50Q2hpbGRyZW4gPSBjdXJyZW50T3B0cy5jaGlsZHJlbjtcbiAgbmV3Q2hpbGRyZW4gPSAobmV3T3B0cyAhPSBudWxsID8gbmV3T3B0cy5jaGlsZHJlbiA6IHZvaWQgMCkgfHwgW107XG4gIG91dHB1dC5jaGlsZHJlbiA9IFtdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gIGlmIChJUyQxLmFycmF5KG5ld0NoaWxkcmVuKSkge1xuICAgIG1heExlbmd0aCA9IE1hdGgubWF4KGN1cnJlbnRDaGlsZHJlbi5sZW5ndGgsIG5ld0NoaWxkcmVuLmxlbmd0aCk7XG4gICAgaW5kZXggPSAtMTtcblxuICAgIHdoaWxlICgrK2luZGV4ICE9PSBtYXhMZW5ndGgpIHtcbiAgICAgIG5lZWRzVGVtcGxhdGVXcmFwID0gbm9DaGFuZ2VzID0gZmFsc2U7XG4gICAgICBjdXJyZW50Q2hpbGQgPSBjdXJyZW50Q2hpbGRyZW5baW5kZXhdO1xuICAgICAgbmV3Q2hpbGQgPSBuZXdDaGlsZHJlbltpbmRleF07XG5cbiAgICAgIG5ld0NoaWxkUHJvY2Vzc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgY2FzZSAhSVMkMS50ZW1wbGF0ZShuZXdDaGlsZCk6XG4gICAgICAgICAgICByZXR1cm4gbmV3Q2hpbGQ7XG5cbiAgICAgICAgICBjYXNlICFJUyQxLmFycmF5KG5ld0NoaWxkKTpcbiAgICAgICAgICAgIHJldHVybiBuZWVkc1RlbXBsYXRlV3JhcCA9IHBhcnNlVHJlZSQxKG5ld0NoaWxkKTtcblxuICAgICAgICAgIGNhc2UgIUlTJDEuc3RyaW5nKG5ld0NoaWxkKTpcbiAgICAgICAgICAgIHJldHVybiBuZWVkc1RlbXBsYXRlV3JhcCA9IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdGV4dDogbmV3Q2hpbGRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIGNhc2UgISghbmV3Q2hpbGQgJiYgIWdsb2JhbE9wdHMpOlxuICAgICAgICAgICAgcmV0dXJuIG5vQ2hhbmdlcyA9IHRydWU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG5lZWRzVGVtcGxhdGVXcmFwID0gbmV3Q2hpbGQgfHwgdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuXG4gICAgICBpZiAobm9DaGFuZ2VzKSB7XG4gICAgICAgIG5ld0NoaWxkUHJvY2Vzc2VkID0gY3VycmVudENoaWxkO1xuICAgICAgfSBlbHNlIGlmIChuZWVkc1RlbXBsYXRlV3JhcCkge1xuICAgICAgICBuZXdDaGlsZFByb2Nlc3NlZCA9IGN1cnJlbnRDaGlsZCA/IGN1cnJlbnRDaGlsZC5leHRlbmQobmV3Q2hpbGRQcm9jZXNzZWQsIGdsb2JhbE9wdHMpIDogbmV3IFF1aWNrVGVtcGxhdGUkMShleHRlbmQuY2xvbmUoc2NoZW1hLCBuZXdDaGlsZFByb2Nlc3NlZCkpO1xuICAgICAgfVxuXG4gICAgICBvdXRwdXQuY2hpbGRyZW4ucHVzaChuZXdDaGlsZFByb2Nlc3NlZCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKElTJDEub2JqZWN0KG5ld0NoaWxkcmVuKSkge1xuICAgIG5ld0NoaWxkcmVuID0gZXh0ZW5kLmFsbG93TnVsbC5jbG9uZShuZXdDaGlsZHJlbik7XG4gICAgb3V0cHV0LmNoaWxkcmVuID0gX2V4dGVuZEJ5UmVmKG5ld0NoaWxkcmVuLCBjdXJyZW50Q2hpbGRyZW4sIGdsb2JhbE9wdHMpO1xuICAgIHJlbWFpbmluZ05ld0NoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG5cbiAgICBmb3IgKHJlZiBpbiByZW1haW5pbmdOZXdDaGlsZHJlbikge1xuICAgICAgbmV3Q2hpbGQgPSByZW1haW5pbmdOZXdDaGlsZHJlbltyZWZdO1xuICAgICAgbmV3Q2hpbGRQcm9jZXNzZWQgPSBJUyQxLm9iamVjdFBsYWluKG5ld0NoaWxkKSAmJiAhSVMkMS50ZW1wbGF0ZShuZXdDaGlsZCkgPyBuZXdDaGlsZCA6IHBhcnNlVHJlZSQxKG5ld0NoaWxkKTtcbiAgICAgIG91dHB1dC5jaGlsZHJlbi5wdXNoKG5ldyBRdWlja1RlbXBsYXRlJDEobmV3Q2hpbGRQcm9jZXNzZWQpKTtcbiAgICAgIGRlbGV0ZSByZW1haW5pbmdOZXdDaGlsZHJlbltyZWZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5fZXh0ZW5kQnlSZWYgPSBmdW5jdGlvbiBleHRlbmRCeVJlZihuZXdDaGlsZHJlblJlZnMsIGN1cnJlbnRDaGlsZHJlbiwgZ2xvYmFsT3B0cykge1xuICB2YXIgY3VycmVudENoaWxkLCBpLCBsZW4sIG5ld0NoaWxkLCBuZXdDaGlsZFByb2Nlc3NlZCwgb3V0cHV0O1xuXG4gIGlmICghY3VycmVudENoaWxkcmVuLmxlbmd0aCkge1xuICAgIHJldHVybiBjdXJyZW50Q2hpbGRyZW47XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0gW107XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjdXJyZW50Q2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZHJlbltpXTtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGRyZW5SZWZzW2N1cnJlbnRDaGlsZC5yZWZdO1xuXG4gICAgICBpZiAobmV3Q2hpbGQpIHtcbiAgICAgICAgbmV3Q2hpbGRQcm9jZXNzZWQgPSBjdXJyZW50Q2hpbGQuZXh0ZW5kKG5ld0NoaWxkLCBnbG9iYWxPcHRzKTtcbiAgICAgICAgZGVsZXRlIG5ld0NoaWxkcmVuUmVmc1tjdXJyZW50Q2hpbGQucmVmXTtcbiAgICAgIH0gZWxzZSBpZiAobmV3Q2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIG5ld0NoaWxkcmVuUmVmc1tjdXJyZW50Q2hpbGQucmVmXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdDaGlsZFByb2Nlc3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgICBjYXNlICFnbG9iYWxPcHRzOlxuICAgICAgICAgICAgICByZXR1cm4gY3VycmVudENoaWxkLmV4dGVuZChudWxsLCBnbG9iYWxPcHRzKTtcblxuICAgICAgICAgICAgY2FzZSAhT2JqZWN0LmtleXMobmV3Q2hpbGRyZW5SZWZzKS5sZW5ndGg6XG4gICAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q2hpbGQuZXh0ZW5kKCk7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q2hpbGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KCk7XG4gICAgICB9XG5cbiAgICAgIG5ld0NoaWxkUHJvY2Vzc2VkLmNoaWxkcmVuID0gX2V4dGVuZEJ5UmVmKG5ld0NoaWxkcmVuUmVmcywgbmV3Q2hpbGRQcm9jZXNzZWQuY2hpbGRyZW4pO1xuICAgICAgb3V0cHV0LnB1c2gobmV3Q2hpbGRQcm9jZXNzZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbn07dmFyIFF1aWNrVGVtcGxhdGU7XG52YXIgUXVpY2tUZW1wbGF0ZSQxID0gUXVpY2tUZW1wbGF0ZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFF1aWNrVGVtcGxhdGUoY29uZmlnLCBpc1RyZWUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUXVpY2tUZW1wbGF0ZSk7XG5cbiAgICBpZiAoSVMkMS50ZW1wbGF0ZShjb25maWcpKSB7XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGNvbmZpZyA9IGlzVHJlZSA/IHBhcnNlVHJlZSQxKGNvbmZpZykgOiBjb25maWc7XG4gICAgZXh0ZW5kKHRoaXMsIGNvbmZpZyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUXVpY2tUZW1wbGF0ZSwgW3tcbiAgICBrZXk6IFwiZXh0ZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZCQkMShuZXdWYWx1ZXMsIGdsb2JhbE9wdHMpIHtcbiAgICAgIHJldHVybiBuZXcgUXVpY2tUZW1wbGF0ZShleHRlbmRUZW1wbGF0ZSQxKHRoaXMsIG5ld1ZhbHVlcywgZ2xvYmFsT3B0cykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzcGF3blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGF3bihuZXdWYWx1ZXMsIGdsb2JhbE9wdHMsIGRhdGEpIHtcbiAgICAgIHZhciBjaGlsZCwgY2hpbGREYXRhLCBjaGlsZHJlbiwgZWxlbWVudCwgaSwgbGVuLCBvcHRpb25zLCB0eXBlO1xuXG4gICAgICBpZiAobmV3VmFsdWVzICYmIG5ld1ZhbHVlcy5kYXRhKSB7XG4gICAgICAgIGRhdGEgPSBuZXdWYWx1ZXMuZGF0YTtcblxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobmV3VmFsdWVzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBuZXdWYWx1ZXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdWYWx1ZXMgfHwgZ2xvYmFsT3B0cykge1xuICAgICAgICB2YXIgX2V4dGVuZFRlbXBsYXRlID0gZXh0ZW5kVGVtcGxhdGUkMSh0aGlzLCBuZXdWYWx1ZXMsIGdsb2JhbE9wdHMpO1xuXG4gICAgICAgIG9wdGlvbnMgPSBfZXh0ZW5kVGVtcGxhdGUub3B0aW9ucztcbiAgICAgICAgY2hpbGRyZW4gPSBfZXh0ZW5kVGVtcGxhdGUuY2hpbGRyZW47XG4gICAgICAgIHR5cGUgPSBfZXh0ZW5kVGVtcGxhdGUudHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgdHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgb3B0aW9ucyA9IGV4dGVuZC5jbG9uZShvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudCA9IF9xdWlja2RvbS5jcmVhdGUoW3R5cGUsIG9wdGlvbnNdKTtcblxuICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIGNoaWxkRGF0YSA9IG9wdGlvbnMucGFzc0RhdGFUb0NoaWxkcmVuID8gZGF0YSB8fCBvcHRpb25zLmRhdGEgOiB2b2lkIDA7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKGNoaWxkLnNwYXduKG51bGwsIG51bGwsIGNoaWxkRGF0YSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuX3Bvc3RDcmVhdGlvbihkYXRhKTtcblxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFF1aWNrVGVtcGxhdGU7XG59KCk7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5pZiAoUXVpY2tUZW1wbGF0ZS5uYW1lID09IG51bGwpIHtcbiAgUXVpY2tUZW1wbGF0ZS5uYW1lID0gJ1F1aWNrVGVtcGxhdGUnO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUXVpY2tUZW1wbGF0ZS5wcm90b3R5cGUsICdjaGlsZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkUmVmcyB8fCBfZ2V0Q2hpbGRSZWZzKHRoaXMpO1xuICB9XG59KTtcblxuX3F1aWNrZG9tLnRlbXBsYXRlID0gZnVuY3Rpb24gKHRyZWUpIHtcbiAgcmV0dXJuIG5ldyBRdWlja1RlbXBsYXRlKHRyZWUsIHRydWUpO1xufTtcblxuX3F1aWNrZG9tLmlzVGVtcGxhdGUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHJldHVybiBJUyQxLnRlbXBsYXRlKHRhcmdldCk7XG59O3ZhciBRdWlja0JhdGNoO1xudmFyIFF1aWNrQmF0Y2gkMSA9IFF1aWNrQmF0Y2ggPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBRdWlja0JhdGNoKGVsZW1lbnRzLCByZXR1cm5SZXN1bHRzMSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRdWlja0JhdGNoKTtcblxuICAgIHRoaXMucmV0dXJuUmVzdWx0cyA9IHJldHVyblJlc3VsdHMxO1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cy5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gX3F1aWNrZG9tKGVsKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhRdWlja0JhdGNoLCBbe1xuICAgIGtleTogXCJyZXZlcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzID0gdGhpcy5lbGVtZW50cy5yZXZlcnNlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmV0dXJuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXR1cm4ocmV0dXJuTmV4dCkge1xuICAgICAgaWYgKHJldHVybk5leHQpIHtcbiAgICAgICAgdGhpcy5yZXR1cm5SZXN1bHRzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0UmVzdWx0cztcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUXVpY2tCYXRjaDtcbn0oKTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbmlmIChRdWlja0JhdGNoLm5hbWUgPT0gbnVsbCkge1xuICBRdWlja0JhdGNoLm5hbWUgPSAnUXVpY2tCYXRjaCc7XG59XG5cbk9iamVjdC5rZXlzKFF1aWNrRWxlbWVudCQyLnByb3RvdHlwZSkuY29uY2F0KCdjc3MnLCAncmVwbGFjZVdpdGgnLCAnaHRtbCcsICd0ZXh0JykuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIHJldHVybiBRdWlja0JhdGNoLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgdmFyIGVsZW1lbnQsIHJlc3VsdHM7XG5cbiAgICByZXN1bHRzID0gdGhpcy5sYXN0UmVzdWx0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpLCBsZW4sIHJlZiwgcmVzdWx0czE7XG4gICAgICByZWYgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgcmVzdWx0czEgPSBbXTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGVsZW1lbnQgPSByZWZbaV07XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ2h0bWwnIHx8IG1ldGhvZCA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHRzMS5wdXNoKGVsZW1lbnRbbWV0aG9kXSA9IG5ld1ZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0czEucHVzaChlbGVtZW50W21ldGhvZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2VsZW1lbnQ7XG5cbiAgICAgICAgICByZXN1bHRzMS5wdXNoKChfZWxlbWVudCA9IGVsZW1lbnQpW21ldGhvZF0uYXBwbHkoX2VsZW1lbnQsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRzMTtcbiAgICB9LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAodGhpcy5yZXR1cm5SZXN1bHRzKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xufSk7XG5cbl9xdWlja2RvbS5iYXRjaCA9IGZ1bmN0aW9uIChlbGVtZW50cywgcmV0dXJuUmVzdWx0cykge1xuICBpZiAoIUlTJDEuaXRlcmFibGUoZWxlbWVudHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQmF0Y2g6IGV4cGVjdGVkIGFuIGl0ZXJhYmxlLCBnb3QgXCIuY29uY2F0KFN0cmluZyhlbGVtZW50cykpKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUXVpY2tCYXRjaChlbGVtZW50cywgcmV0dXJuUmVzdWx0cyk7XG59O3ZhciB2ZXJzaW9uID0gXCIxLjAuOTNcIjt2YXIgU0hPUlRDVVRTLCBpLCBsZW4sIHNob3J0Y3V0O1xuU0hPUlRDVVRTID0gWydsaW5rOmEnLCAnYW5jaG9yOmEnLCAnYScsICd0ZXh0JywgJ2RpdicsICdzcGFuJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWRlcicsICdmb290ZXInLCAnc2VjdGlvbicsICdidXR0b24nLCAnYnInLCAndWwnLCAnb2wnLCAnbGknLCAnZmllbGRzZXQnLCAnaW5wdXQnLCAndGV4dGFyZWEnLCAnc2VsZWN0JywgJ29wdGlvbicsICdmb3JtJywgJ2ZyYW1lJywgJ2hyJywgJ2lmcmFtZScsICdpbWcnLCAncGljdHVyZScsICdtYWluJywgJ25hdicsICdtZXRhJywgJ29iamVjdCcsICdwcmUnLCAnc3R5bGUnLCAndGFibGUnLCAndGJvZHknLCAndGgnLCAndHInLCAndGQnLCAndGZvb3QnLCAvLyAndGVtcGxhdGUnXG4ndmlkZW8nXTtcblxuZm9yIChpID0gMCwgbGVuID0gU0hPUlRDVVRTLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIHNob3J0Y3V0ID0gU0hPUlRDVVRTW2ldO1xuXG4gIChmdW5jdGlvbiAoc2hvcnRjdXQpIHtcbiAgICB2YXIgcHJvcCwgc3BsaXQsIHR5cGU7XG4gICAgcHJvcCA9IHR5cGUgPSBzaG9ydGN1dDtcblxuICAgIGlmIChpbmNsdWRlcyhzaG9ydGN1dCwgJzonKSkge1xuICAgICAgc3BsaXQgPSBzaG9ydGN1dC5zcGxpdCgnOicpO1xuICAgICAgcHJvcCA9IHNwbGl0WzBdO1xuICAgICAgdHlwZSA9IHNwbGl0WzFdO1xuICAgIH1cblxuICAgIHJldHVybiBfcXVpY2tkb21bcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3F1aWNrZG9tLmFwcGx5KHZvaWQgMCwgW3R5cGVdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcbiAgfSkoc2hvcnRjdXQpO1xufWluaXQoUXVpY2tFbGVtZW50JDIsIFF1aWNrV2luZG93JDIpO1xuX3F1aWNrZG9tLlF1aWNrRWxlbWVudCA9IFF1aWNrRWxlbWVudCQyO1xuX3F1aWNrZG9tLlF1aWNrVGVtcGxhdGUgPSBRdWlja1RlbXBsYXRlJDE7XG5fcXVpY2tkb20uUXVpY2tXaW5kb3cgPSBRdWlja1dpbmRvdyQyO1xuX3F1aWNrZG9tLlF1aWNrQmF0Y2ggPSBRdWlja0JhdGNoJDE7XG5fcXVpY2tkb20udmVyc2lvbiA9IHZlcnNpb247XG5fcXVpY2tkb20uQ1NTID0gQ1NTO1xudmFyIHF1aWNrZG9tID0gX3F1aWNrZG9tOyAvLyBleHBvcnQge3F1aWNrZG9tIGFzIGRlZmF1bHQsIFF1aWNrRWxlbWVudCwgUXVpY2tUZW1wbGF0ZSwgUXVpY2tXaW5kb3csIFF1aWNrQmF0Y2h9XG5leHBvcnQgZGVmYXVsdCBxdWlja2RvbTsiLCJpbXBvcnQgRE9NIGZyb20gJ3F1aWNrZG9tJ1xuXG5leHBvcnQgZGVmYXVsdCByZXN0YXJ0U2FuZGJveCA9ICgpLT5cblx0aWYgd2luZG93LnNhbmRib3hcblx0XHRkZWxldGUgcXVpY2tmaWVsZC5pbnN0YW5jZXNbaWRdIGZvciBpZCxmaWVsZCBvZiBxdWlja2ZpZWxkLmluc3RhbmNlc1xuXHRcdHdpbmRvdy5zYW5kYm94LnJlbW92ZSgpXG5cdFxuXHR3aW5kb3cuc2FuZGJveCA9IERPTS5kaXYoaWQ6J3NhbmRib3gnLCBzdHlsZTp7Ym9yZGVyOicxcHggc29saWQnLCBwYWRkaW5nOicyMHB4JywgYm94U2l6aW5nOidib3JkZXItYm94J30pLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpXG4iLCJpbXBvcnQgRE9NIGZyb20gJ3F1aWNrZG9tJ1xuXG5leHBvcnQgZGVmYXVsdCAodGl0bGUsIG1hcmdpbj0yMCktPlxuXHRET00uZGl2KFxuXHRcdHJlZjogJ3Rlc3RUaXRsZSdcblx0XHRzdHlsZTp7bWFyZ2luVG9wOm1hcmdpbiwgbWFyZ2luQm90dG9tOm1hcmdpbiwgZm9udFNpemU6MTYsIGZvbnRXZWlnaHQ6NjAwLCBmb250RmFtaWx5OidzeXN0ZW0tdWksIHNhbnMtc2VyaWYnfVxuXHQsdGl0bGUpLmFwcGVuZFRvKHNhbmRib3gpXG4iLCJpbXBvcnQgRE9NIGZyb20gJ3F1aWNrZG9tJ1xuXG5leHBvcnQgZGVmYXVsdCAoKS0+XG5cdG1hcmdpbiA9IGFyZ3VtZW50c1swXVxuXHRtYXJnaW4gPSAyMCBpZiBpc05hTihtYXJnaW4pXG5cdERPTS5kaXYoXG5cdFx0cmVmOiAndGVzdFRpdGxlJ1xuXHRcdHN0eWxlOiB7bWFyZ2luVG9wOm1hcmdpbiwgbWFyZ2luQm90dG9tOm1hcmdpbn1cblx0KS5hcHBlbmRUbyhzYW5kYm94KVxuIiwiZXhwb3J0IGRlZmF1bHQgKGVsKS0+XG5cdHRvcDogZWwuc3R5bGUoJ2JvcmRlclRvcFdpZHRoJylcblx0Ym90dG9tOiBlbC5zdHlsZSgnYm9yZGVyQm90dG9tV2lkdGgnKVxuXHRsZWZ0OiBlbC5zdHlsZSgnYm9yZGVyTGVmdFdpZHRoJylcblx0cmlnaHQ6IGVsLnN0eWxlKCdib3JkZXJSaWdodFdpZHRoJykiLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IChwcm9taXNlLCBvbkZpbmFsbHkpID0+IHtcblx0b25GaW5hbGx5ID0gb25GaW5hbGx5IHx8ICgoKSA9PiB7fSk7XG5cblx0cmV0dXJuIHByb21pc2UudGhlbihcblx0XHR2YWwgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG5cdFx0XHRyZXNvbHZlKG9uRmluYWxseSgpKTtcblx0XHR9KS50aGVuKCgpID0+IHZhbCksXG5cdFx0ZXJyID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRcdFx0cmVzb2x2ZShvbkZpbmFsbHkoKSk7XG5cdFx0fSkudGhlbigoKSA9PiB7XG5cdFx0XHR0aHJvdyBlcnI7XG5cdFx0fSlcblx0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwRmluYWxseSA9IHJlcXVpcmUoJ3AtZmluYWxseScpO1xuXG5jbGFzcyBUaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHR0aGlzLm5hbWUgPSAnVGltZW91dEVycm9yJztcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9taXNlLCBtcywgZmFsbGJhY2spID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0aWYgKHR5cGVvZiBtcyAhPT0gJ251bWJlcicgJiYgbXMgPj0gMCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBtc2AgdG8gYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcblx0fVxuXG5cdGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0aWYgKHR5cGVvZiBmYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmVzb2x2ZShmYWxsYmFjaygpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBtZXNzYWdlID0gdHlwZW9mIGZhbGxiYWNrID09PSAnc3RyaW5nJyA/IGZhbGxiYWNrIDogYFByb21pc2UgdGltZWQgb3V0IGFmdGVyICR7bXN9IG1pbGxpc2Vjb25kc2A7XG5cdFx0Y29uc3QgZXJyID0gZmFsbGJhY2sgaW5zdGFuY2VvZiBFcnJvciA/IGZhbGxiYWNrIDogbmV3IFRpbWVvdXRFcnJvcihtZXNzYWdlKTtcblxuXHRcdHJlamVjdChlcnIpO1xuXHR9LCBtcyk7XG5cblx0cEZpbmFsbHkoXG5cdFx0cHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCksXG5cdFx0KCkgPT4ge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHR9XG5cdCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMuVGltZW91dEVycm9yID0gVGltZW91dEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcFRpbWVvdXQgPSByZXF1aXJlKCdwLXRpbWVvdXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZW1pdHRlciwgZXZlbnQsIG9wdHMpID0+IHtcblx0bGV0IGNhbmNlbDtcblxuXHRjb25zdCByZXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0aWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRvcHRzID0ge2ZpbHRlcjogb3B0c307XG5cdFx0fVxuXG5cdFx0b3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdFx0cmVqZWN0aW9uRXZlbnRzOiBbJ2Vycm9yJ10sXG5cdFx0XHRtdWx0aUFyZ3M6IGZhbHNlXG5cdFx0fSwgb3B0cyk7XG5cblx0XHRsZXQgYWRkTGlzdGVuZXIgPSBlbWl0dGVyLm9uIHx8IGVtaXR0ZXIuYWRkTGlzdGVuZXIgfHwgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyO1xuXHRcdGxldCByZW1vdmVMaXN0ZW5lciA9IGVtaXR0ZXIub2ZmIHx8IGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgfHwgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyO1xuXG5cdFx0aWYgKCFhZGRMaXN0ZW5lciB8fCAhcmVtb3ZlTGlzdGVuZXIpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0VtaXR0ZXIgaXMgbm90IGNvbXBhdGlibGUnKTtcblx0XHR9XG5cblx0XHRhZGRMaXN0ZW5lciA9IGFkZExpc3RlbmVyLmJpbmQoZW1pdHRlcik7XG5cdFx0cmVtb3ZlTGlzdGVuZXIgPSByZW1vdmVMaXN0ZW5lci5iaW5kKGVtaXR0ZXIpO1xuXG5cdFx0Y29uc3QgcmVzb2x2ZUhhbmRsZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdGlmIChvcHRzLm11bHRpQXJncykge1xuXHRcdFx0XHR2YWx1ZSA9IFtdLnNsaWNlLmFwcGx5KGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRzLmZpbHRlciAmJiAhb3B0cy5maWx0ZXIodmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y2FuY2VsKCk7XG5cdFx0XHRyZXNvbHZlKHZhbHVlKTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgcmVqZWN0SGFuZGxlciA9IGZ1bmN0aW9uIChyZWFzb24pIHtcblx0XHRcdGNhbmNlbCgpO1xuXG5cdFx0XHRpZiAob3B0cy5tdWx0aUFyZ3MpIHtcblx0XHRcdFx0cmVqZWN0KFtdLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVqZWN0KHJlYXNvbik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGNhbmNlbCA9ICgpID0+IHtcblx0XHRcdHJlbW92ZUxpc3RlbmVyKGV2ZW50LCByZXNvbHZlSGFuZGxlcik7XG5cblx0XHRcdGZvciAoY29uc3QgcmVqZWN0aW9uRXZlbnQgb2Ygb3B0cy5yZWplY3Rpb25FdmVudHMpIHtcblx0XHRcdFx0cmVtb3ZlTGlzdGVuZXIocmVqZWN0aW9uRXZlbnQsIHJlamVjdEhhbmRsZXIpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRhZGRMaXN0ZW5lcihldmVudCwgcmVzb2x2ZUhhbmRsZXIpO1xuXG5cdFx0Zm9yIChjb25zdCByZWplY3Rpb25FdmVudCBvZiBvcHRzLnJlamVjdGlvbkV2ZW50cykge1xuXHRcdFx0YWRkTGlzdGVuZXIocmVqZWN0aW9uRXZlbnQsIHJlamVjdEhhbmRsZXIpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0LmNhbmNlbCA9IGNhbmNlbDtcblxuXHRpZiAodHlwZW9mIG9wdHMudGltZW91dCA9PT0gJ251bWJlcicpIHtcblx0XHRyZXR1cm4gcFRpbWVvdXQocmV0LCBvcHRzLnRpbWVvdXQpO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG4iLCJleHBvcnQgZGVmYXVsdFxuXHRyZWQ6ICcjY2M0ODIwJ1xuXHRncmVlbjogJyM3MmMzMjInXG5cdG9yYW5nZTogJyNmZjljMDAnXG5cdGJsYWNrOiAnIzE4MTgxOCdcblx0Z3JleV9kYXJrOiAnIzVlNWU1ZSdcblx0Z3JleTogJyM5MDkwOTAnXG5cdGdyZXlfc2VtaV9saWdodDogJyNiZWJlYmUnXG5cdGdyZXlfbGlnaHQ6ICcjZDNkM2QzJ1xuXHRncmV5X2xpZ2h0MjogJyNkZGRkZGQnXG5cdGdyZXlfbGlnaHQzOiAnI2YyZjVmNydcblx0Z3JleV9saWdodDQ6ICcjZTVlNWU1J1xuIiwiLyohXG4gKiBhc3NlcnRpb24tZXJyb3JcbiAqIENvcHlyaWdodChjKSAyMDEzIEpha2UgTHVlciA8amFrZUBxdWFsaWFuY3kuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHdpbGwgY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIG9uZSBvYmplY3QgdG8gYW5vdGhlciBleGNsdWRpbmcgYW55IG9yaWdpbmFsbHlcbiAqIGxpc3RlZC4gUmV0dXJuZWQgZnVuY3Rpb24gd2lsbCBjcmVhdGUgYSBuZXcgYHt9YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhjbHVkZWQgcHJvcGVydGllcyAuLi5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGV4Y2x1ZGUgKCkge1xuICB2YXIgZXhjbHVkZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgZnVuY3Rpb24gZXhjbHVkZVByb3BzIChyZXMsIG9iaikge1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoIX5leGNsdWRlcy5pbmRleE9mKGtleSkpIHJlc1trZXldID0gb2JqW2tleV07XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gZXh0ZW5kRXhjbHVkZSAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICAgICwgaSA9IDBcbiAgICAgICwgcmVzID0ge307XG5cbiAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4Y2x1ZGVQcm9wcyhyZXMsIGFyZ3NbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vKiFcbiAqIFByaW1hcnkgRXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQXNzZXJ0aW9uRXJyb3I7XG5cbi8qKlxuICogIyMjIEFzc2VydGlvbkVycm9yXG4gKlxuICogQW4gZXh0ZW5zaW9uIG9mIHRoZSBKYXZhU2NyaXB0IGBFcnJvcmAgY29uc3RydWN0b3IgZm9yXG4gKiBhc3NlcnRpb24gYW5kIHZhbGlkYXRpb24gc2NlbmFyaW9zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyB0byBpbmNsdWRlIChvcHRpb25hbClcbiAqIEBwYXJhbSB7Y2FsbGVlfSBzdGFydCBzdGFjayBmdW5jdGlvbiAob3B0aW9uYWwpXG4gKi9cblxuZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3IgKG1lc3NhZ2UsIF9wcm9wcywgc3NmKSB7XG4gIHZhciBleHRlbmQgPSBleGNsdWRlKCduYW1lJywgJ21lc3NhZ2UnLCAnc3RhY2snLCAnY29uc3RydWN0b3InLCAndG9KU09OJylcbiAgICAsIHByb3BzID0gZXh0ZW5kKF9wcm9wcyB8fCB7fSk7XG5cbiAgLy8gZGVmYXVsdCB2YWx1ZXNcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVW5zcGVjaWZpZWQgQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLnNob3dEaWZmID0gZmFsc2U7XG5cbiAgLy8gY29weSBmcm9tIHByb3BlcnRpZXNcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdGhpc1trZXldID0gcHJvcHNba2V5XTtcbiAgfVxuXG4gIC8vIGNhcHR1cmUgc3RhY2sgdHJhY2VcbiAgc3NmID0gc3NmIHx8IGFyZ3VtZW50cy5jYWxsZWU7XG4gIGlmIChzc2YgJiYgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzc2YpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHRoaXMuc3RhY2sgPSBlLnN0YWNrO1xuICAgIH1cbiAgfVxufVxuXG4vKiFcbiAqIEluaGVyaXQgZnJvbSBFcnJvci5wcm90b3R5cGVcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5cbi8qIVxuICogU3RhdGljYWxseSBzZXQgbmFtZVxuICovXG5cbkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcblxuLyohXG4gKiBFbnN1cmUgY29ycmVjdCBjb25zdHJ1Y3RvclxuICovXG5cbkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFzc2VydGlvbkVycm9yO1xuXG4vKipcbiAqIEFsbG93IGVycm9ycyB0byBiZSBjb252ZXJ0ZWQgdG8gSlNPTiBmb3Igc3RhdGljIHRyYW5zZmVyLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZSBzdGFjayAoZGVmYXVsdDogYHRydWVgKVxuICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgdGhhdCBjYW4gYmUgYEpTT04uc3RyaW5naWZ5YFxuICovXG5cbkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgdmFyIGV4dGVuZCA9IGV4Y2x1ZGUoJ2NvbnN0cnVjdG9yJywgJ3RvSlNPTicsICdzdGFjaycpXG4gICAgLCBwcm9wcyA9IGV4dGVuZCh7IG5hbWU6IHRoaXMubmFtZSB9LCB0aGlzKTtcblxuICAvLyBpbmNsdWRlIHN0YWNrIGlmIGV4aXN0cyBhbmQgbm90IHR1cm5lZCBvZmZcbiAgaWYgKGZhbHNlICE9PSBzdGFjayAmJiB0aGlzLnN0YWNrKSB7XG4gICAgcHJvcHMuc3RhY2sgPSB0aGlzLnN0YWNrO1xuICB9XG5cbiAgcmV0dXJuIHByb3BzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogIVxuICogQ2hhaSAtIHBhdGh2YWwgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2xvZ2ljYWxwYXJhZG94L2ZpbHRyXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuaGFzUHJvcGVydHkob2JqZWN0LCBuYW1lKVxuICpcbiAqIFRoaXMgYWxsb3dzIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBvd25cbiAqIG9yIGluaGVyaXRlZCBmcm9tIHByb3RvdHlwZSBjaGFpbiBuYW1lZCBwcm9wZXJ0eS5cbiAqXG4gKiBCYXNpY2FsbHkgZG9lcyB0aGUgc2FtZSB0aGluZyBhcyB0aGUgYGluYFxuICogb3BlcmF0b3IgYnV0IHdvcmtzIHByb3Blcmx5IHdpdGggbnVsbC91bmRlZmluZWQgdmFsdWVzXG4gKiBhbmQgb3RoZXIgcHJpbWl0aXZlcy5cbiAqXG4gKiAgICAgdmFyIG9iaiA9IHtcbiAqICAgICAgICAgYXJyOiBbJ2EnLCAnYicsICdjJ11cbiAqICAgICAgICwgc3RyOiAnSGVsbG8nXG4gKiAgICAgfVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgd291bGQgYmUgdGhlIHJlc3VsdHMuXG4gKlxuICogICAgIGhhc1Byb3BlcnR5KG9iaiwgJ3N0cicpOyAgLy8gdHJ1ZVxuICogICAgIGhhc1Byb3BlcnR5KG9iaiwgJ2NvbnN0cnVjdG9yJyk7ICAvLyB0cnVlXG4gKiAgICAgaGFzUHJvcGVydHkob2JqLCAnYmFyJyk7ICAvLyBmYWxzZVxuICpcbiAqICAgICBoYXNQcm9wZXJ0eShvYmouc3RyLCAnbGVuZ3RoJyk7IC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eShvYmouc3RyLCAxKTsgIC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eShvYmouc3RyLCA1KTsgIC8vIGZhbHNlXG4gKlxuICogICAgIGhhc1Byb3BlcnR5KG9iai5hcnIsICdsZW5ndGgnKTsgIC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eShvYmouYXJyLCAyKTsgIC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eShvYmouYXJyLCAzKTsgIC8vIGZhbHNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gd2hldGhlciBpdCBleGlzdHNcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGhhc1Byb3BlcnR5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc1Byb3BlcnR5KG9iaiwgbmFtZSkge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGhlIGBpbmAgb3BlcmF0b3IgZG9lcyBub3Qgd29yayB3aXRoIHByaW1pdGl2ZXMuXG4gIHJldHVybiBuYW1lIGluIE9iamVjdChvYmopO1xufVxuXG4vKiAhXG4gKiAjIyBwYXJzZVBhdGgocGF0aClcbiAqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCB0byBwYXJzZSBzdHJpbmcgb2JqZWN0XG4gKiBwYXRocy4gVXNlIGluIGNvbmp1bmN0aW9uIHdpdGggYGludGVybmFsR2V0UGF0aFZhbHVlYC5cbiAqXG4gKiAgICAgIHZhciBwYXJzZWQgPSBwYXJzZVBhdGgoJ215b2JqZWN0LnByb3BlcnR5LnN1YnByb3AnKTtcbiAqXG4gKiAjIyMgUGF0aHM6XG4gKlxuICogKiBDYW4gYmUgaW5maW5pdGVseSBkZWVwIGFuZCBuZXN0ZWQuXG4gKiAqIEFycmF5cyBhcmUgYWxzbyB2YWxpZCB1c2luZyB0aGUgZm9ybWFsIGBteW9iamVjdC5kb2N1bWVudFszXS5wcm9wZXJ0eWAuXG4gKiAqIExpdGVyYWwgZG90cyBhbmQgYnJhY2tldHMgKG5vdCBkZWxpbWl0ZXIpIG11c3QgYmUgYmFja3NsYXNoLWVzY2FwZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBhcnNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHN0ciA9IHBhdGgucmVwbGFjZSgvKFteXFxcXF0pXFxbL2csICckMS5bJyk7XG4gIHZhciBwYXJ0cyA9IHN0ci5tYXRjaCgvKFxcXFxcXC58W14uXSs/KSsvZyk7XG4gIHJldHVybiBwYXJ0cy5tYXAoZnVuY3Rpb24gbWFwTWF0Y2hlcyh2YWx1ZSkge1xuICAgIHZhciByZWdleHAgPSAvXlxcWyhcXGQrKVxcXSQvO1xuICAgIHZhciBtQXJyID0gcmVnZXhwLmV4ZWModmFsdWUpO1xuICAgIHZhciBwYXJzZWQgPSBudWxsO1xuICAgIGlmIChtQXJyKSB7XG4gICAgICBwYXJzZWQgPSB7IGk6IHBhcnNlRmxvYXQobUFyclsxXSkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkID0geyBwOiB2YWx1ZS5yZXBsYWNlKC9cXFxcKFsuXFxbXFxdXSkvZywgJyQxJykgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9KTtcbn1cblxuLyogIVxuICogIyMgaW50ZXJuYWxHZXRQYXRoVmFsdWUob2JqLCBwYXJzZWRbLCBwYXRoRGVwdGhdKVxuICpcbiAqIEhlbHBlciBjb21wYW5pb24gZnVuY3Rpb24gZm9yIGAucGFyc2VQYXRoYCB0aGF0IHJldHVybnNcbiAqIHRoZSB2YWx1ZSBsb2NhdGVkIGF0IHRoZSBwYXJzZWQgYWRkcmVzcy5cbiAqXG4gKiAgICAgIHZhciB2YWx1ZSA9IGdldFBhdGhWYWx1ZShvYmosIHBhcnNlZCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBzZWFyY2ggYWdhaW5zdFxuICogQHBhcmFtIHtPYmplY3R9IHBhcnNlZCBkZWZpbml0aW9uIGZyb20gYHBhcnNlUGF0aGAuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVwdGggKG5lc3RpbmcgbGV2ZWwpIG9mIHRoZSBwcm9wZXJ0eSB3ZSB3YW50IHRvIHJldHJpZXZlXG4gKiBAcmV0dXJucyB7T2JqZWN0fFVuZGVmaW5lZH0gdmFsdWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGludGVybmFsR2V0UGF0aFZhbHVlKG9iaiwgcGFyc2VkLCBwYXRoRGVwdGgpIHtcbiAgdmFyIHRlbXBvcmFyeVZhbHVlID0gb2JqO1xuICB2YXIgcmVzID0gbnVsbDtcbiAgcGF0aERlcHRoID0gKHR5cGVvZiBwYXRoRGVwdGggPT09ICd1bmRlZmluZWQnID8gcGFyc2VkLmxlbmd0aCA6IHBhdGhEZXB0aCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoRGVwdGg7IGkrKykge1xuICAgIHZhciBwYXJ0ID0gcGFyc2VkW2ldO1xuICAgIGlmICh0ZW1wb3JhcnlWYWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwYXJ0LnAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRlbXBvcmFyeVZhbHVlID0gdGVtcG9yYXJ5VmFsdWVbcGFydC5pXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBvcmFyeVZhbHVlID0gdGVtcG9yYXJ5VmFsdWVbcGFydC5wXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPT09IChwYXRoRGVwdGggLSAxKSkge1xuICAgICAgICByZXMgPSB0ZW1wb3JhcnlWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG4vKiAhXG4gKiAjIyBpbnRlcm5hbFNldFBhdGhWYWx1ZShvYmosIHZhbHVlLCBwYXJzZWQpXG4gKlxuICogQ29tcGFuaW9uIGZ1bmN0aW9uIGZvciBgcGFyc2VQYXRoYCB0aGF0IHNldHNcbiAqIHRoZSB2YWx1ZSBsb2NhdGVkIGF0IGEgcGFyc2VkIGFkZHJlc3MuXG4gKlxuICogIGludGVybmFsU2V0UGF0aFZhbHVlKG9iaiwgJ3ZhbHVlJywgcGFyc2VkKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIHNlYXJjaCBhbmQgZGVmaW5lIG9uXG4gKiBAcGFyYW0geyp9IHZhbHVlIHRvIHVzZSB1cG9uIHNldFxuICogQHBhcmFtIHtPYmplY3R9IHBhcnNlZCBkZWZpbml0aW9uIGZyb20gYHBhcnNlUGF0aGBcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGludGVybmFsU2V0UGF0aFZhbHVlKG9iaiwgdmFsLCBwYXJzZWQpIHtcbiAgdmFyIHRlbXBPYmogPSBvYmo7XG4gIHZhciBwYXRoRGVwdGggPSBwYXJzZWQubGVuZ3RoO1xuICB2YXIgcGFydCA9IG51bGw7XG4gIC8vIEhlcmUgd2UgaXRlcmF0ZSB0aHJvdWdoIGV2ZXJ5IHBhcnQgb2YgdGhlIHBhdGhcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoRGVwdGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IG51bGw7XG4gICAgdmFyIHByb3BWYWwgPSBudWxsO1xuICAgIHBhcnQgPSBwYXJzZWRbaV07XG5cbiAgICAvLyBJZiBpdCdzIHRoZSBsYXN0IHBhcnQgb2YgdGhlIHBhdGgsIHdlIHNldCB0aGUgJ3Byb3BOYW1lJyB2YWx1ZSB3aXRoIHRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgaWYgKGkgPT09IChwYXRoRGVwdGggLSAxKSkge1xuICAgICAgcHJvcE5hbWUgPSB0eXBlb2YgcGFydC5wID09PSAndW5kZWZpbmVkJyA/IHBhcnQuaSA6IHBhcnQucDtcbiAgICAgIC8vIE5vdyB3ZSBzZXQgdGhlIHByb3BlcnR5IHdpdGggdGhlIG5hbWUgaGVsZCBieSAncHJvcE5hbWUnIG9uIG9iamVjdCB3aXRoIHRoZSBkZXNpcmVkIHZhbFxuICAgICAgdGVtcE9ialtwcm9wTmFtZV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGFydC5wICE9PSAndW5kZWZpbmVkJyAmJiB0ZW1wT2JqW3BhcnQucF0pIHtcbiAgICAgIHRlbXBPYmogPSB0ZW1wT2JqW3BhcnQucF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGFydC5pICE9PSAndW5kZWZpbmVkJyAmJiB0ZW1wT2JqW3BhcnQuaV0pIHtcbiAgICAgIHRlbXBPYmogPSB0ZW1wT2JqW3BhcnQuaV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBvYmogZG9lc24ndCBoYXZlIHRoZSBwcm9wZXJ0eSB3ZSBjcmVhdGUgb25lIHdpdGggdGhhdCBuYW1lIHRvIGRlZmluZSBpdFxuICAgICAgdmFyIG5leHQgPSBwYXJzZWRbaSArIDFdO1xuICAgICAgLy8gSGVyZSB3ZSBzZXQgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdoaWNoIHdpbGwgYmUgZGVmaW5lZFxuICAgICAgcHJvcE5hbWUgPSB0eXBlb2YgcGFydC5wID09PSAndW5kZWZpbmVkJyA/IHBhcnQuaSA6IHBhcnQucDtcbiAgICAgIC8vIEhlcmUgd2UgZGVjaWRlIGlmIHRoaXMgcHJvcGVydHkgd2lsbCBiZSBhbiBhcnJheSBvciBhIG5ldyBvYmplY3RcbiAgICAgIHByb3BWYWwgPSB0eXBlb2YgbmV4dC5wID09PSAndW5kZWZpbmVkJyA/IFtdIDoge307XG4gICAgICB0ZW1wT2JqW3Byb3BOYW1lXSA9IHByb3BWYWw7XG4gICAgICB0ZW1wT2JqID0gdGVtcE9ialtwcm9wTmFtZV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogIyMjIC5nZXRQYXRoSW5mbyhvYmplY3QsIHBhdGgpXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIHJldHJpZXZhbCBvZiBwcm9wZXJ0eSBpbmZvIGluIGFuXG4gKiBvYmplY3QgZ2l2ZW4gYSBzdHJpbmcgcGF0aC5cbiAqXG4gKiBUaGUgcGF0aCBpbmZvIGNvbnNpc3RzIG9mIGFuIG9iamVjdCB3aXRoIHRoZVxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogKiBwYXJlbnQgLSBUaGUgcGFyZW50IG9iamVjdCBvZiB0aGUgcHJvcGVydHkgcmVmZXJlbmNlZCBieSBgcGF0aGBcbiAqICogbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaW5hbCBwcm9wZXJ0eSwgYSBudW1iZXIgaWYgaXQgd2FzIGFuIGFycmF5IGluZGV4ZXJcbiAqICogdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5LCBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSBgdW5kZWZpbmVkYFxuICogKiBleGlzdHMgLSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBleGlzdHMgb3Igbm90XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm5zIHtPYmplY3R9IGluZm9cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldFBhdGhJbmZvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGdldFBhdGhJbmZvKG9iaiwgcGF0aCkge1xuICB2YXIgcGFyc2VkID0gcGFyc2VQYXRoKHBhdGgpO1xuICB2YXIgbGFzdCA9IHBhcnNlZFtwYXJzZWQubGVuZ3RoIC0gMV07XG4gIHZhciBpbmZvID0ge1xuICAgIHBhcmVudDogcGFyc2VkLmxlbmd0aCA+IDEgPyBpbnRlcm5hbEdldFBhdGhWYWx1ZShvYmosIHBhcnNlZCwgcGFyc2VkLmxlbmd0aCAtIDEpIDogb2JqLFxuICAgIG5hbWU6IGxhc3QucCB8fCBsYXN0LmksXG4gICAgdmFsdWU6IGludGVybmFsR2V0UGF0aFZhbHVlKG9iaiwgcGFyc2VkKSxcbiAgfTtcbiAgaW5mby5leGlzdHMgPSBoYXNQcm9wZXJ0eShpbmZvLnBhcmVudCwgaW5mby5uYW1lKTtcblxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiAjIyMgLmdldFBhdGhWYWx1ZShvYmplY3QsIHBhdGgpXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIHJldHJpZXZhbCBvZiB2YWx1ZXMgaW4gYW5cbiAqIG9iamVjdCBnaXZlbiBhIHN0cmluZyBwYXRoLlxuICpcbiAqICAgICB2YXIgb2JqID0ge1xuICogICAgICAgICBwcm9wMToge1xuICogICAgICAgICAgICAgYXJyOiBbJ2EnLCAnYicsICdjJ11cbiAqICAgICAgICAgICAsIHN0cjogJ0hlbGxvJ1xuICogICAgICAgICB9XG4gKiAgICAgICAsIHByb3AyOiB7XG4gKiAgICAgICAgICAgICBhcnI6IFsgeyBuZXN0ZWQ6ICdVbml2ZXJzZScgfSBdXG4gKiAgICAgICAgICAgLCBzdHI6ICdIZWxsbyBhZ2FpbiEnXG4gKiAgICAgICAgIH1cbiAqICAgICB9XG4gKlxuICogVGhlIGZvbGxvd2luZyB3b3VsZCBiZSB0aGUgcmVzdWx0cy5cbiAqXG4gKiAgICAgZ2V0UGF0aFZhbHVlKG9iaiwgJ3Byb3AxLnN0cicpOyAvLyBIZWxsb1xuICogICAgIGdldFBhdGhWYWx1ZShvYmosICdwcm9wMS5hdHRbMl0nKTsgLy8gYlxuICogICAgIGdldFBhdGhWYWx1ZShvYmosICdwcm9wMi5hcnJbMF0ubmVzdGVkJyk7IC8vIFVuaXZlcnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm5zIHtPYmplY3R9IHZhbHVlIG9yIGB1bmRlZmluZWRgXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBnZXRQYXRoVmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZ2V0UGF0aFZhbHVlKG9iaiwgcGF0aCkge1xuICB2YXIgaW5mbyA9IGdldFBhdGhJbmZvKG9iaiwgcGF0aCk7XG4gIHJldHVybiBpbmZvLnZhbHVlO1xufVxuXG4vKipcbiAqICMjIyAuc2V0UGF0aFZhbHVlKG9iamVjdCwgcGF0aCwgdmFsdWUpXG4gKlxuICogRGVmaW5lIHRoZSB2YWx1ZSBpbiBhbiBvYmplY3QgYXQgYSBnaXZlbiBzdHJpbmcgcGF0aC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG9iaiA9IHtcbiAqICAgICBwcm9wMToge1xuICogICAgICAgICBhcnI6IFsnYScsICdiJywgJ2MnXVxuICogICAgICAgLCBzdHI6ICdIZWxsbydcbiAqICAgICB9XG4gKiAgICwgcHJvcDI6IHtcbiAqICAgICAgICAgYXJyOiBbIHsgbmVzdGVkOiAnVW5pdmVyc2UnIH0gXVxuICogICAgICAgLCBzdHI6ICdIZWxsbyBhZ2FpbiEnXG4gKiAgICAgfVxuICogfTtcbiAqIGBgYFxuICpcbiAqIFRoZSBmb2xsb3dpbmcgd291bGQgYmUgYWNjZXB0YWJsZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIHByb3BlcnRpZXMgPSByZXF1aXJlKCd0ZWEtcHJvcGVydGllcycpO1xuICogcHJvcGVydGllcy5zZXQob2JqLCAncHJvcDEuc3RyJywgJ0hlbGxvIFVuaXZlcnNlIScpO1xuICogcHJvcGVydGllcy5zZXQob2JqLCAncHJvcDEuYXJyWzJdJywgJ0InKTtcbiAqIHByb3BlcnRpZXMuc2V0KG9iaiwgJ3Byb3AyLmFyclswXS5uZXN0ZWQudmFsdWUnLCB7IGhlbGxvOiAndW5pdmVyc2UnIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXRQYXRoVmFsdWUob2JqLCBwYXRoLCB2YWwpIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlUGF0aChwYXRoKTtcbiAgaW50ZXJuYWxTZXRQYXRoVmFsdWUob2JqLCB2YWwsIHBhcnNlZCk7XG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBoYXNQcm9wZXJ0eTogaGFzUHJvcGVydHksXG4gIGdldFBhdGhJbmZvOiBnZXRQYXRoSW5mbyxcbiAgZ2V0UGF0aFZhbHVlOiBnZXRQYXRoVmFsdWUsXG4gIHNldFBhdGhWYWx1ZTogc2V0UGF0aFZhbHVlLFxufTtcbiIsIi8qIVxuICogQ2hhaSAtIGZsYWcgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5mbGFnKG9iamVjdCwga2V5LCBbdmFsdWVdKVxuICpcbiAqIEdldCBvciBzZXQgYSBmbGFnIHZhbHVlIG9uIGFuIG9iamVjdC4gSWYgYVxuICogdmFsdWUgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBzZXQsIGVsc2UgaXQgd2lsbFxuICogcmV0dXJuIHRoZSBjdXJyZW50bHkgc2V0IHZhbHVlIG9yIGB1bmRlZmluZWRgIGlmXG4gKiB0aGUgdmFsdWUgaXMgbm90IHNldC5cbiAqXG4gKiAgICAgdXRpbHMuZmxhZyh0aGlzLCAnZm9vJywgJ2JhcicpOyAvLyBzZXR0ZXJcbiAqICAgICB1dGlscy5mbGFnKHRoaXMsICdmb28nKTsgLy8gZ2V0dGVyLCByZXR1cm5zIGBiYXJgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBjb25zdHJ1Y3RlZCBBc3NlcnRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIChvcHRpb25hbClcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGZsYWdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmxhZyhvYmosIGtleSwgdmFsdWUpIHtcbiAgdmFyIGZsYWdzID0gb2JqLl9fZmxhZ3MgfHwgKG9iai5fX2ZsYWdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgZmxhZ3Nba2V5XSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmbGFnc1trZXldO1xuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gdGVzdCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kYW5jaWVzXG4gKi9cblxudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcblxuLyoqXG4gKiAjIyMgLnRlc3Qob2JqZWN0LCBleHByZXNzaW9uKVxuICpcbiAqIFRlc3QgYW5kIG9iamVjdCBmb3IgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IChjb25zdHJ1Y3RlZCBBc3NlcnRpb24pXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCBhcmd1bWVudHNcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIHRlc3RcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRlc3Qob2JqLCBhcmdzKSB7XG4gIHZhciBuZWdhdGUgPSBmbGFnKG9iaiwgJ25lZ2F0ZScpXG4gICAgLCBleHByID0gYXJnc1swXTtcbiAgcmV0dXJuIG5lZ2F0ZSA/ICFleHByIDogZXhwcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qICFcbiAqIHR5cGUtZGV0ZWN0XG4gKiBDb3B5cmlnaHQoYykgMjAxMyBqYWtlIGx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG52YXIgcHJvbWlzZUV4aXN0cyA9IHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nO1xudmFyIGdsb2JhbE9iamVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBzZWxmOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG52YXIgaXNEb20gPSAnbG9jYXRpb24nIGluIGdsb2JhbE9iamVjdCAmJiAnZG9jdW1lbnQnIGluIGdsb2JhbE9iamVjdDtcbnZhciBzeW1ib2xFeGlzdHMgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcbnZhciBtYXBFeGlzdHMgPSB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJztcbnZhciBzZXRFeGlzdHMgPSB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJztcbnZhciB3ZWFrTWFwRXhpc3RzID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnO1xudmFyIHdlYWtTZXRFeGlzdHMgPSB0eXBlb2YgV2Vha1NldCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgZGF0YVZpZXdFeGlzdHMgPSB0eXBlb2YgRGF0YVZpZXcgIT09ICd1bmRlZmluZWQnO1xudmFyIHN5bWJvbEl0ZXJhdG9yRXhpc3RzID0gc3ltYm9sRXhpc3RzICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgIT09ICd1bmRlZmluZWQnO1xudmFyIHN5bWJvbFRvU3RyaW5nVGFnRXhpc3RzID0gc3ltYm9sRXhpc3RzICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgIT09ICd1bmRlZmluZWQnO1xudmFyIHNldEVudHJpZXNFeGlzdHMgPSBzZXRFeGlzdHMgJiYgdHlwZW9mIFNldC5wcm90b3R5cGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJztcbnZhciBtYXBFbnRyaWVzRXhpc3RzID0gbWFwRXhpc3RzICYmIHR5cGVvZiBNYXAucHJvdG90eXBlLmVudHJpZXMgPT09ICdmdW5jdGlvbic7XG52YXIgc2V0SXRlcmF0b3JQcm90b3R5cGUgPSBzZXRFbnRyaWVzRXhpc3RzICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgU2V0KCkuZW50cmllcygpKTtcbnZhciBtYXBJdGVyYXRvclByb3RvdHlwZSA9IG1hcEVudHJpZXNFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBNYXAoKS5lbnRyaWVzKCkpO1xudmFyIGFycmF5SXRlcmF0b3JFeGlzdHMgPSBzeW1ib2xJdGVyYXRvckV4aXN0cyAmJiB0eXBlb2YgQXJyYXkucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG52YXIgYXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGFycmF5SXRlcmF0b3JFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk7XG52YXIgc3RyaW5nSXRlcmF0b3JFeGlzdHMgPSBzeW1ib2xJdGVyYXRvckV4aXN0cyAmJiB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xudmFyIHN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlID0gc3RyaW5nSXRlcmF0b3JFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSk7XG52YXIgdG9TdHJpbmdMZWZ0U2xpY2VMZW5ndGggPSA4O1xudmFyIHRvU3RyaW5nUmlnaHRTbGljZUxlbmd0aCA9IC0xO1xuLyoqXG4gKiAjIyMgdHlwZU9mIChvYmopXG4gKlxuICogVXNlcyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGFuIG9iamVjdCxcbiAqIG5vcm1hbGlzaW5nIGJlaGF2aW91ciBhY3Jvc3MgZW5naW5lIHZlcnNpb25zICYgd2VsbCBvcHRpbWlzZWQuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IG9iamVjdCB0eXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHR5cGVEZXRlY3Qob2JqKSB7XG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAqIFByZTpcbiAgICogICBzdHJpbmcgbGl0ZXJhbCAgICAgeCAzLDAzOSwwMzUgb3BzL3NlYyDCsTEuNjIlICg3OCBydW5zIHNhbXBsZWQpXG4gICAqICAgYm9vbGVhbiBsaXRlcmFsICAgIHggMSw0MjQsMTM4IG9wcy9zZWMgwrE0LjU0JSAoNzUgcnVucyBzYW1wbGVkKVxuICAgKiAgIG51bWJlciBsaXRlcmFsICAgICB4IDEsNjUzLDE1MyBvcHMvc2VjIMKxMS45MSUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICogICB1bmRlZmluZWQgICAgICAgICAgeCA5LDk3OCw2NjAgb3BzL3NlYyDCsTEuOTIlICg3NSBydW5zIHNhbXBsZWQpXG4gICAqICAgZnVuY3Rpb24gICAgICAgICAgIHggMiw1NTYsNzY5IG9wcy9zZWMgwrExLjczJSAoNzcgcnVucyBzYW1wbGVkKVxuICAgKiBQb3N0OlxuICAgKiAgIHN0cmluZyBsaXRlcmFsICAgICB4IDM4LDU2NCw3OTYgb3BzL3NlYyDCsTEuMTUlICg3OSBydW5zIHNhbXBsZWQpXG4gICAqICAgYm9vbGVhbiBsaXRlcmFsICAgIHggMzEsMTQ4LDk0MCBvcHMvc2VjIMKxMS4xMCUgKDc5IHJ1bnMgc2FtcGxlZClcbiAgICogICBudW1iZXIgbGl0ZXJhbCAgICAgeCAzMiw2NzksMzMwIG9wcy9zZWMgwrExLjkwJSAoNzggcnVucyBzYW1wbGVkKVxuICAgKiAgIHVuZGVmaW5lZCAgICAgICAgICB4IDMyLDM2MywzNjggb3BzL3NlYyDCsTEuMDclICg4MiBydW5zIHNhbXBsZWQpXG4gICAqICAgZnVuY3Rpb24gICAgICAgICAgIHggMzEsMjk2LDg3MCBvcHMvc2VjIMKxMC45NiUgKDgzIHJ1bnMgc2FtcGxlZClcbiAgICovXG4gIHZhciB0eXBlb2ZPYmogPSB0eXBlb2Ygb2JqO1xuICBpZiAodHlwZW9mT2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0eXBlb2ZPYmo7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgKiBQcmU6XG4gICAqICAgbnVsbCAgICAgICAgICAgICAgIHggMjgsNjQ1LDc2NSBvcHMvc2VjIMKxMS4xNyUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICogUG9zdDpcbiAgICogICBudWxsICAgICAgICAgICAgICAgeCAzNiw0MjgsOTYyIG9wcy9zZWMgwrExLjM3JSAoODQgcnVucyBzYW1wbGVkKVxuICAgKi9cbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH1cblxuICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cpYGBcbiAgICogIC0gTm9kZSA9PT0gXCJbb2JqZWN0IGdsb2JhbF1cIlxuICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBnbG9iYWxdXCJcbiAgICogIC0gRmlyZWZveCA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiAgLSBQaGFudG9tSlMgPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogIC0gU2FmYXJpID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqICAtIElFIDExID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqICAtIElFIEVkZ2UgPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzKWBgXG4gICAqICAtIENocm9tZSBXb3JrZXIgPT09IFwiW29iamVjdCBnbG9iYWxdXCJcbiAgICogIC0gRmlyZWZveCBXb3JrZXIgPT09IFwiW29iamVjdCBEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZV1cIlxuICAgKiAgLSBTYWZhcmkgV29ya2VyID09PSBcIltvYmplY3QgRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVdXCJcbiAgICogIC0gSUUgMTEgV29ya2VyID09PSBcIltvYmplY3QgV29ya2VyR2xvYmFsU2NvcGVdXCJcbiAgICogIC0gSUUgRWRnZSBXb3JrZXIgPT09IFwiW29iamVjdCBXb3JrZXJHbG9iYWxTY29wZV1cIlxuICAgKi9cbiAgaWYgKG9iaiA9PT0gZ2xvYmFsT2JqZWN0KSB7XG4gICAgcmV0dXJuICdnbG9iYWwnO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICogUHJlOlxuICAgKiAgIGFycmF5IGxpdGVyYWwgICAgICB4IDIsODg4LDM1MiBvcHMvc2VjIMKxMC42NyUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICogUG9zdDpcbiAgICogICBhcnJheSBsaXRlcmFsICAgICAgeCAyMiw0NzksNjUwIG9wcy9zZWMgwrEwLjk2JSAoODEgcnVucyBzYW1wbGVkKVxuICAgKi9cbiAgaWYgKFxuICAgIEFycmF5LmlzQXJyYXkob2JqKSAmJlxuICAgIChzeW1ib2xUb1N0cmluZ1RhZ0V4aXN0cyA9PT0gZmFsc2UgfHwgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gb2JqKSlcbiAgKSB7XG4gICAgcmV0dXJuICdBcnJheSc7XG4gIH1cblxuICBpZiAoaXNEb20pIHtcbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvYnJvd3NlcnMuaHRtbCNsb2NhdGlvbilcbiAgICAgKiBXaGF0V0cgSFRNTCQ3LjcuMyAtIFRoZSBgTG9jYXRpb25gIGludGVyZmFjZVxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93LmxvY2F0aW9uKWBgXG4gICAgICogIC0gSUUgPD0xMSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqICAtIElFIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqL1xuICAgIGlmIChvYmogPT09IGdsb2JhbE9iamVjdC5sb2NhdGlvbikge1xuICAgICAgcmV0dXJuICdMb2NhdGlvbic7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2RvY3VtZW50KVxuICAgICAqIFdoYXRXRyBIVE1MJDMuMS4xIC0gVGhlIGBEb2N1bWVudGAgb2JqZWN0XG4gICAgICogTm90ZTogTW9zdCBicm93c2VycyBjdXJyZW50bHkgYWRoZXIgdG8gdGhlIFczQyBET00gTGV2ZWwgMiBzcGVjXG4gICAgICogICAgICAgKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1IVE1ML2h0bWwuaHRtbCNJRC0yNjgwOTI2OClcbiAgICAgKiAgICAgICB3aGljaCBzdWdnZXN0cyB0aGF0IGJyb3dzZXJzIHNob3VsZCB1c2UgSFRNTFRhYmxlQ2VsbEVsZW1lbnQgZm9yXG4gICAgICogICAgICAgYm90aCBURCBhbmQgVEggZWxlbWVudHMuIFdoYXRXRyBzZXBhcmF0ZXMgdGhlc2UuXG4gICAgICogICAgICAgV2hhdFdHIEhUTUwgc3RhdGVzOlxuICAgICAqICAgICAgICAgPiBGb3IgaGlzdG9yaWNhbCByZWFzb25zLCBXaW5kb3cgb2JqZWN0cyBtdXN0IGFsc28gaGF2ZSBhXG4gICAgICogICAgICAgICA+IHdyaXRhYmxlLCBjb25maWd1cmFibGUsIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVkXG4gICAgICogICAgICAgICA+IEhUTUxEb2N1bWVudCB3aG9zZSB2YWx1ZSBpcyB0aGUgRG9jdW1lbnQgaW50ZXJmYWNlIG9iamVjdC5cbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvY3VtZW50KWBgXG4gICAgICogIC0gQ2hyb21lID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICogIC0gRmlyZWZveCA9PT0gXCJbb2JqZWN0IEhUTUxEb2N1bWVudF1cIlxuICAgICAqICAtIFNhZmFyaSA9PT0gXCJbb2JqZWN0IEhUTUxEb2N1bWVudF1cIlxuICAgICAqICAtIElFIDw9MTAgPT09IFwiW29iamVjdCBEb2N1bWVudF1cIlxuICAgICAqICAtIElFIDExID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICogIC0gSUUgRWRnZSA8PTEzID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICovXG4gICAgaWYgKG9iaiA9PT0gZ2xvYmFsT2JqZWN0LmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gJ0RvY3VtZW50JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI21pbWV0eXBlYXJyYXkpXG4gICAgICogV2hhdFdHIEhUTUwkOC42LjEuNSAtIFBsdWdpbnMgLSBJbnRlcmZhY2UgTWltZVR5cGVBcnJheVxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmF2aWdhdG9yLm1pbWVUeXBlcylgYFxuICAgICAqICAtIElFIDw9MTAgPT09IFwiW29iamVjdCBNU01pbWVUeXBlc0NvbGxlY3Rpb25dXCJcbiAgICAgKi9cbiAgICBpZiAob2JqID09PSAoZ2xvYmFsT2JqZWN0Lm5hdmlnYXRvciB8fCB7fSkubWltZVR5cGVzKSB7XG4gICAgICByZXR1cm4gJ01pbWVUeXBlQXJyYXknO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjcGx1Z2luYXJyYXkpXG4gICAgICogV2hhdFdHIEhUTUwkOC42LjEuNSAtIFBsdWdpbnMgLSBJbnRlcmZhY2UgUGx1Z2luQXJyYXlcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5hdmlnYXRvci5wbHVnaW5zKWBgXG4gICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IE1TUGx1Z2luc0NvbGxlY3Rpb25dXCJcbiAgICAgKi9cbiAgICBpZiAob2JqID09PSAoZ2xvYmFsT2JqZWN0Lm5hdmlnYXRvciB8fCB7fSkucGx1Z2lucykge1xuICAgICAgcmV0dXJuICdQbHVnaW5BcnJheSc7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCNwbHVnaW5hcnJheSlcbiAgICAgKiBXaGF0V0cgSFRNTCQ0LjQuNCAtIFRoZSBgYmxvY2txdW90ZWAgZWxlbWVudCAtIEludGVyZmFjZSBgSFRNTFF1b3RlRWxlbWVudGBcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Jsb2NrcXVvdGUnKSlgYFxuICAgICAqICAtIElFIDw9MTAgPT09IFwiW29iamVjdCBIVE1MQmxvY2tFbGVtZW50XVwiXG4gICAgICovXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIG9iai50YWdOYW1lID09PSAnQkxPQ0tRVU9URScpIHtcbiAgICAgIHJldHVybiAnSFRNTFF1b3RlRWxlbWVudCc7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2h0bWx0YWJsZWRhdGFjZWxsZWxlbWVudClcbiAgICAgKiBXaGF0V0cgSFRNTCQ0LjkuOSAtIFRoZSBgdGRgIGVsZW1lbnQgLSBJbnRlcmZhY2UgYEhUTUxUYWJsZURhdGFDZWxsRWxlbWVudGBcbiAgICAgKiBOb3RlOiBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBhZGhlciB0byB0aGUgVzNDIERPTSBMZXZlbCAyIHNwZWNcbiAgICAgKiAgICAgICAoaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUhUTUwvaHRtbC5odG1sI0lELTgyOTE1MDc1KVxuICAgICAqICAgICAgIHdoaWNoIHN1Z2dlc3RzIHRoYXQgYnJvd3NlcnMgc2hvdWxkIHVzZSBIVE1MVGFibGVDZWxsRWxlbWVudCBmb3JcbiAgICAgKiAgICAgICBib3RoIFREIGFuZCBUSCBlbGVtZW50cy4gV2hhdFdHIHNlcGFyYXRlcyB0aGVzZS5cbiAgICAgKiBUZXN0OiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKSlcbiAgICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAqICAtIEZpcmVmb3ggPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAqICAtIFNhZmFyaSA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICovXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIG9iai50YWdOYW1lID09PSAnVEQnKSB7XG4gICAgICByZXR1cm4gJ0hUTUxUYWJsZURhdGFDZWxsRWxlbWVudCc7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2h0bWx0YWJsZWhlYWRlcmNlbGxlbGVtZW50KVxuICAgICAqIFdoYXRXRyBIVE1MJDQuOS45IC0gVGhlIGB0ZGAgZWxlbWVudCAtIEludGVyZmFjZSBgSFRNTFRhYmxlSGVhZGVyQ2VsbEVsZW1lbnRgXG4gICAgICogTm90ZTogTW9zdCBicm93c2VycyBjdXJyZW50bHkgYWRoZXIgdG8gdGhlIFczQyBET00gTGV2ZWwgMiBzcGVjXG4gICAgICogICAgICAgKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1IVE1ML2h0bWwuaHRtbCNJRC04MjkxNTA3NSlcbiAgICAgKiAgICAgICB3aGljaCBzdWdnZXN0cyB0aGF0IGJyb3dzZXJzIHNob3VsZCB1c2UgSFRNTFRhYmxlQ2VsbEVsZW1lbnQgZm9yXG4gICAgICogICAgICAgYm90aCBURCBhbmQgVEggZWxlbWVudHMuIFdoYXRXRyBzZXBhcmF0ZXMgdGhlc2UuXG4gICAgICogVGVzdDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJykpXG4gICAgICogIC0gQ2hyb21lID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgKiAgLSBGaXJlZm94ID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgKiAgLSBTYWZhcmkgPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAqL1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBvYmoudGFnTmFtZSA9PT0gJ1RIJykge1xuICAgICAgcmV0dXJuICdIVE1MVGFibGVIZWFkZXJDZWxsRWxlbWVudCc7XG4gICAgfVxuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICBGbG9hdDY0QXJyYXkgICAgICAgeCA2MjUsNjQ0IG9wcy9zZWMgwrExLjU4JSAoODAgcnVucyBzYW1wbGVkKVxuICAqICAgRmxvYXQzMkFycmF5ICAgICAgIHggMSwyNzksODUyIG9wcy9zZWMgwrEyLjkxJSAoNzcgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDMyQXJyYXkgICAgICAgIHggMSwxNzgsMTg1IG9wcy9zZWMgwrExLjk1JSAoODMgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDE2QXJyYXkgICAgICAgIHggMSwwMDgsMzgwIG9wcy9zZWMgwrEyLjI1JSAoODAgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDhBcnJheSAgICAgICAgIHggMSwxMjgsMDQwIG9wcy9zZWMgwrEyLjExJSAoODEgcnVucyBzYW1wbGVkKVxuICAqICAgSW50MzJBcnJheSAgICAgICAgIHggMSwxNzAsMTE5IG9wcy9zZWMgwrEyLjg4JSAoODAgcnVucyBzYW1wbGVkKVxuICAqICAgSW50MTZBcnJheSAgICAgICAgIHggMSwxNzYsMzQ4IG9wcy9zZWMgwrE1Ljc5JSAoODYgcnVucyBzYW1wbGVkKVxuICAqICAgSW50OEFycmF5ICAgICAgICAgIHggMSwwNTgsNzA3IG9wcy9zZWMgwrE0Ljk0JSAoNzcgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDhDbGFtcGVkQXJyYXkgIHggMSwxMTAsNjMzIG9wcy9zZWMgwrE0LjIwJSAoODAgcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICBGbG9hdDY0QXJyYXkgICAgICAgeCA3LDEwNSw2NzEgb3BzL3NlYyDCsTEzLjQ3JSAoNjQgcnVucyBzYW1wbGVkKVxuICAqICAgRmxvYXQzMkFycmF5ICAgICAgIHggNSw4ODcsOTEyIG9wcy9zZWMgwrExLjQ2JSAoODIgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDMyQXJyYXkgICAgICAgIHggNiw0OTEsNjYxIG9wcy9zZWMgwrExLjc2JSAoNzkgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDE2QXJyYXkgICAgICAgIHggNiw1NTksNzk1IG9wcy9zZWMgwrExLjY3JSAoODIgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDhBcnJheSAgICAgICAgIHggNiw0NjMsOTY2IG9wcy9zZWMgwrExLjQzJSAoODUgcnVucyBzYW1wbGVkKVxuICAqICAgSW50MzJBcnJheSAgICAgICAgIHggNSw2NDEsODQxIG9wcy9zZWMgwrEzLjQ5JSAoODEgcnVucyBzYW1wbGVkKVxuICAqICAgSW50MTZBcnJheSAgICAgICAgIHggNiw1ODMsNTExIG9wcy9zZWMgwrExLjk4JSAoODAgcnVucyBzYW1wbGVkKVxuICAqICAgSW50OEFycmF5ICAgICAgICAgIHggNiw2MDYsMDc4IG9wcy9zZWMgwrExLjc0JSAoODEgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDhDbGFtcGVkQXJyYXkgIHggNiw2MDIsMjI0IG9wcy9zZWMgwrExLjc3JSAoODMgcnVucyBzYW1wbGVkKVxuICAqL1xuICB2YXIgc3RyaW5nVGFnID0gKHN5bWJvbFRvU3RyaW5nVGFnRXhpc3RzICYmIG9ialtTeW1ib2wudG9TdHJpbmdUYWddKTtcbiAgaWYgKHR5cGVvZiBzdHJpbmdUYWcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0cmluZ1RhZztcbiAgfVxuXG4gIHZhciBvYmpQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICByZWdleCBsaXRlcmFsICAgICAgeCAxLDc3MiwzODUgb3BzL3NlYyDCsTEuODUlICg3NyBydW5zIHNhbXBsZWQpXG4gICogICByZWdleCBjb25zdHJ1Y3RvciAgeCAyLDE0Myw2MzQgb3BzL3NlYyDCsTIuNDYlICg3OCBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIHJlZ2V4IGxpdGVyYWwgICAgICB4IDMsOTI4LDAwOSBvcHMvc2VjIMKxMC42NSUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgKiAgIHJlZ2V4IGNvbnN0cnVjdG9yICB4IDMsOTMxLDEwOCBvcHMvc2VjIMKxMC41OCUgKDg0IHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKG9ialByb3RvdHlwZSA9PT0gUmVnRXhwLnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnUmVnRXhwJztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgZGF0ZSAgICAgICAgICAgICAgIHggMiwxMzAsMDc0IG9wcy9zZWMgwrE0LjQyJSAoNjggcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICBkYXRlICAgICAgICAgICAgICAgeCAzLDk1Myw3Nzkgb3BzL3NlYyDCsTEuMzUlICg3NyBydW5zIHNhbXBsZWQpXG4gICovXG4gIGlmIChvYmpQcm90b3R5cGUgPT09IERhdGUucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdEYXRlJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy1wcm9taXNlLnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnKVxuICAgKiBFUzYkMjUuNC41LjQgLSBQcm9taXNlLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJQcm9taXNlXCI6XG4gICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUHJvbWlzZS5yZXNvbHZlKCkpYGBcbiAgICogIC0gQ2hyb21lIDw9NDcgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICogIC0gRWRnZSA8PTIwID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqICAtIEZpcmVmb3ggMjktTGF0ZXN0ID09PSBcIltvYmplY3QgUHJvbWlzZV1cIlxuICAgKiAgLSBTYWZhcmkgNy4xLUxhdGVzdCA9PT0gXCJbb2JqZWN0IFByb21pc2VdXCJcbiAgICovXG4gIGlmIChwcm9taXNlRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gUHJvbWlzZS5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ1Byb21pc2UnO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICBzZXQgICAgICAgICAgICAgICAgeCAyLDIyMiwxODYgb3BzL3NlYyDCsTEuMzElICg4MiBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIHNldCAgICAgICAgICAgICAgICB4IDQsNTQ1LDg3OSBvcHMvc2VjIMKxMS4xMyUgKDgzIHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKHNldEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IFNldC5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ1NldCc7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAqIFByZTpcbiAgKiAgIG1hcCAgICAgICAgICAgICAgICB4IDIsMzk2LDg0MiBvcHMvc2VjIMKxMS41OSUgKDgxIHJ1bnMgc2FtcGxlZClcbiAgKiBQb3N0OlxuICAqICAgbWFwICAgICAgICAgICAgICAgIHggNCwxODMsOTQ1IG9wcy9zZWMgwrE2LjU5JSAoODIgcnVucyBzYW1wbGVkKVxuICAqL1xuICBpZiAobWFwRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gTWFwLnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnTWFwJztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgd2Vha3NldCAgICAgICAgICAgIHggMSwzMjMsMjIwIG9wcy9zZWMgwrEyLjE3JSAoNzYgcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICB3ZWFrc2V0ICAgICAgICAgICAgeCA0LDIzNyw1MTAgb3BzL3NlYyDCsTIuMDElICg3NyBydW5zIHNhbXBsZWQpXG4gICovXG4gIGlmICh3ZWFrU2V0RXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gV2Vha1NldC5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ1dlYWtTZXQnO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICB3ZWFrbWFwICAgICAgICAgICAgeCAxLDUwMCwyNjAgb3BzL3NlYyDCsTIuMDIlICg3OCBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIHdlYWttYXAgICAgICAgICAgICB4IDMsODgxLDM4NCBvcHMvc2VjIMKxMS40NSUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKHdlYWtNYXBFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBXZWFrTWFwLnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnV2Vha01hcCc7XG4gIH1cblxuICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtZGF0YXZpZXcucHJvdG90eXBlLUBAdG9zdHJpbmd0YWcpXG4gICAqIEVTNiQyNC4yLjQuMjEgLSBEYXRhVmlldy5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiRGF0YVZpZXdcIjpcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSlgYFxuICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICovXG4gIGlmIChkYXRhVmlld0V4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IERhdGFWaWV3LnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnRGF0YVZpZXcnO1xuICB9XG5cbiAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLSVtYXBpdGVyYXRvcnByb3RvdHlwZSUtQEB0b3N0cmluZ3RhZylcbiAgICogRVM2JDIzLjEuNS4yLjIgLSAlTWFwSXRlcmF0b3JQcm90b3R5cGUlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIk1hcCBJdGVyYXRvclwiOlxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ldyBNYXAoKS5lbnRyaWVzKCkpYGBcbiAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqL1xuICBpZiAobWFwRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gbWFwSXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ01hcCBJdGVyYXRvcic7XG4gIH1cblxuICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtJXNldGl0ZXJhdG9ycHJvdG90eXBlJS1AQHRvc3RyaW5ndGFnKVxuICAgKiBFUzYkMjMuMi41LjIuMiAtICVTZXRJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiU2V0IEl0ZXJhdG9yXCI6XG4gICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3IFNldCgpLmVudHJpZXMoKSlgYFxuICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICovXG4gIGlmIChzZXRFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBzZXRJdGVyYXRvclByb3RvdHlwZSkge1xuICAgIHJldHVybiAnU2V0IEl0ZXJhdG9yJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUtQEB0b3N0cmluZ3RhZylcbiAgICogRVM2JDIyLjEuNS4yLjIgLSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiQXJyYXkgSXRlcmF0b3JcIjpcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChbXVtTeW1ib2wuaXRlcmF0b3JdKCkpYGBcbiAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqL1xuICBpZiAoYXJyYXlJdGVyYXRvckV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IGFycmF5SXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ0FycmF5IEl0ZXJhdG9yJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy0lc3RyaW5naXRlcmF0b3Jwcm90b3R5cGUlLUBAdG9zdHJpbmd0YWcpXG4gICAqIEVTNiQyMS4xLjUuMi4yIC0gJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJTdHJpbmcgSXRlcmF0b3JcIjpcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCgnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpYGBcbiAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqL1xuICBpZiAoc3RyaW5nSXRlcmF0b3JFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBzdHJpbmdJdGVyYXRvclByb3RvdHlwZSkge1xuICAgIHJldHVybiAnU3RyaW5nIEl0ZXJhdG9yJztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgb2JqZWN0IGZyb20gbnVsbCAgIHggMiw0MjQsMzIwIG9wcy9zZWMgwrExLjY3JSAoNzYgcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICBvYmplY3QgZnJvbSBudWxsICAgeCA1LDgzOCwwMDAgb3BzL3NlYyDCsTAuOTklICg4NCBydW5zIHNhbXBsZWQpXG4gICovXG4gIGlmIChvYmpQcm90b3R5cGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0XG4gICAgLnByb3RvdHlwZVxuICAgIC50b1N0cmluZ1xuICAgIC5jYWxsKG9iailcbiAgICAuc2xpY2UodG9TdHJpbmdMZWZ0U2xpY2VMZW5ndGgsIHRvU3RyaW5nUmlnaHRTbGljZUxlbmd0aCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy50eXBlRGV0ZWN0ID0gbW9kdWxlLmV4cG9ydHM7XG4iLCIvKiFcbiAqIENoYWkgLSBleHBlY3RUeXBlcyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmV4cGVjdFR5cGVzKG9iaiwgdHlwZXMpXG4gKlxuICogRW5zdXJlcyB0aGF0IHRoZSBvYmplY3QgYmVpbmcgdGVzdGVkIGFnYWluc3QgaXMgb2YgYSB2YWxpZCB0eXBlLlxuICpcbiAqICAgICB1dGlscy5leHBlY3RUeXBlcyh0aGlzLCBbJ2FycmF5JywgJ29iamVjdCcsICdzdHJpbmcnXSk7XG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqIGNvbnN0cnVjdGVkIEFzc2VydGlvblxuICogQHBhcmFtIHtBcnJheX0gdHlwZSBBIGxpc3Qgb2YgYWxsb3dlZCB0eXBlcyBmb3IgdGhpcyBhc3NlcnRpb25cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGV4cGVjdFR5cGVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciBBc3NlcnRpb25FcnJvciA9IHJlcXVpcmUoJ2Fzc2VydGlvbi1lcnJvcicpO1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgndHlwZS1kZXRlY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHBlY3RUeXBlcyhvYmosIHR5cGVzKSB7XG4gIHZhciBmbGFnTXNnID0gZmxhZyhvYmosICdtZXNzYWdlJyk7XG4gIHZhciBzc2ZpID0gZmxhZyhvYmosICdzc2ZpJyk7XG5cbiAgZmxhZ01zZyA9IGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyA6ICcnO1xuXG4gIG9iaiA9IGZsYWcob2JqLCAnb2JqZWN0Jyk7XG4gIHR5cGVzID0gdHlwZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnRvTG93ZXJDYXNlKCk7IH0pO1xuICB0eXBlcy5zb3J0KCk7XG5cbiAgLy8gVHJhbnNmb3JtcyBbJ2xvcmVtJywgJ2lwc3VtJ10gaW50byAnYSBsb3JlbSwgb3IgYW4gaXBzdW0nXG4gIHZhciBzdHIgPSB0eXBlcy5tYXAoZnVuY3Rpb24gKHQsIGluZGV4KSB7XG4gICAgdmFyIGFydCA9IH5bICdhJywgJ2UnLCAnaScsICdvJywgJ3UnIF0uaW5kZXhPZih0LmNoYXJBdCgwKSkgPyAnYW4nIDogJ2EnO1xuICAgIHZhciBvciA9IHR5cGVzLmxlbmd0aCA+IDEgJiYgaW5kZXggPT09IHR5cGVzLmxlbmd0aCAtIDEgPyAnb3IgJyA6ICcnO1xuICAgIHJldHVybiBvciArIGFydCArICcgJyArIHQ7XG4gIH0pLmpvaW4oJywgJyk7XG5cbiAgdmFyIG9ialR5cGUgPSB0eXBlKG9iaikudG9Mb3dlckNhc2UoKTtcblxuICBpZiAoIXR5cGVzLnNvbWUoZnVuY3Rpb24gKGV4cGVjdGVkKSB7IHJldHVybiBvYmpUeXBlID09PSBleHBlY3RlZDsgfSkpIHtcbiAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICBmbGFnTXNnICsgJ29iamVjdCB0ZXN0ZWQgbXVzdCBiZSAnICsgc3RyICsgJywgYnV0ICcgKyBvYmpUeXBlICsgJyBnaXZlbicsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBzc2ZpXG4gICAgKTtcbiAgfVxufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldEFjdHVhbCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldEFjdHVhbChvYmplY3QsIFthY3R1YWxdKVxuICpcbiAqIFJldHVybnMgdGhlIGBhY3R1YWxgIHZhbHVlIGZvciBhbiBBc3NlcnRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAoY29uc3RydWN0ZWQgQXNzZXJ0aW9uKVxuICogQHBhcmFtIHtBcmd1bWVudHN9IGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgYXJndW1lbnRzXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBnZXRBY3R1YWxcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEFjdHVhbChvYmosIGFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3MubGVuZ3RoID4gNCA/IGFyZ3NbNF0gOiBvYmouX29iajtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qICFcbiAqIENoYWkgLSBnZXRGdW5jTmFtZSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE2IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldEZ1bmNOYW1lKGNvbnN0cnVjdG9yRm4pXG4gKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uLlxuICogV2hlbiBhIG5vbi1mdW5jdGlvbiBpbnN0YW5jZSBpcyBwYXNzZWQsIHJldHVybnMgYG51bGxgLlxuICogVGhpcyBhbHNvIGluY2x1ZGVzIGEgcG9seWZpbGwgZnVuY3Rpb24gaWYgYGFGdW5jLm5hbWVgIGlzIG5vdCBkZWZpbmVkLlxuICpcbiAqIEBuYW1lIGdldEZ1bmNOYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdFxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY3Rpb25OYW1lTWF0Y2ggPSAvXFxzKmZ1bmN0aW9uKD86XFxzfFxccypcXC9cXCpbXig/OipcXC8pXStcXCpcXC9cXHMqKSooW15cXHNcXChcXC9dKykvO1xuZnVuY3Rpb24gZ2V0RnVuY05hbWUoYUZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBhRnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG5hbWUgPSAnJztcbiAgaWYgKHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGUubmFtZSA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGFGdW5jLm5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gSGVyZSB3ZSBydW4gYSBwb2x5ZmlsbCBpZiBGdW5jdGlvbiBkb2VzIG5vdCBzdXBwb3J0IHRoZSBgbmFtZWAgcHJvcGVydHkgYW5kIGlmIGFGdW5jLm5hbWUgaXMgbm90IGRlZmluZWRcbiAgICB2YXIgbWF0Y2ggPSB0b1N0cmluZy5jYWxsKGFGdW5jKS5tYXRjaChmdW5jdGlvbk5hbWVNYXRjaCk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBuYW1lID0gbWF0Y2hbMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIHdlJ3ZlIGdvdCBhIGBuYW1lYCBwcm9wZXJ0eSB3ZSBqdXN0IHVzZSBpdFxuICAgIG5hbWUgPSBhRnVuYy5uYW1lO1xuICB9XG5cbiAgcmV0dXJuIG5hbWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RnVuY05hbWU7XG4iLCIvKiFcbiAqIENoYWkgLSBnZXRQcm9wZXJ0aWVzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZ2V0UHJvcGVydGllcyhvYmplY3QpXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIHJldHJpZXZhbCBvZiBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QsIGVudW1lcmFibGUgb3Igbm90LFxuICogaW5oZXJpdGVkIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBnZXRQcm9wZXJ0aWVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UHJvcGVydGllcyhvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCk7XG5cbiAgZnVuY3Rpb24gYWRkUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICBpZiAocmVzdWx0LmluZGV4T2YocHJvcGVydHkpID09PSAtMSkge1xuICAgICAgcmVzdWx0LnB1c2gocHJvcGVydHkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICB3aGlsZSAocHJvdG8gIT09IG51bGwpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykuZm9yRWFjaChhZGRQcm9wZXJ0eSk7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBnZXRFbnVtZXJhYmxlUHJvcGVydGllcyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldEVudW1lcmFibGVQcm9wZXJ0aWVzKG9iamVjdClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LFxuICogaW5oZXJpdGVkIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBnZXRFbnVtZXJhYmxlUHJvcGVydGllc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy5pbmNsdWRlU3RhY2tcbiAgICpcbiAgICogVXNlciBjb25maWd1cmFibGUgcHJvcGVydHksIGluZmx1ZW5jZXMgd2hldGhlciBzdGFjayB0cmFjZVxuICAgKiBpcyBpbmNsdWRlZCBpbiBBc3NlcnRpb24gZXJyb3IgbWVzc2FnZS4gRGVmYXVsdCBvZiBmYWxzZVxuICAgKiBzdXBwcmVzc2VzIHN0YWNrIHRyYWNlIGluIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgKlxuICAgKiAgICAgY2hhaS5jb25maWcuaW5jbHVkZVN0YWNrID0gdHJ1ZTsgIC8vIGVuYWJsZSBzdGFjayBvbiBlcnJvclxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGluY2x1ZGVTdGFjazogZmFsc2UsXG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcuc2hvd0RpZmZcbiAgICpcbiAgICogVXNlciBjb25maWd1cmFibGUgcHJvcGVydHksIGluZmx1ZW5jZXMgd2hldGhlciBvciBub3RcbiAgICogdGhlIGBzaG93RGlmZmAgZmxhZyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHRocm93blxuICAgKiBBc3NlcnRpb25FcnJvcnMuIGBmYWxzZWAgd2lsbCBhbHdheXMgYmUgYGZhbHNlYDsgYHRydWVgXG4gICAqIHdpbGwgYmUgdHJ1ZSB3aGVuIHRoZSBhc3NlcnRpb24gaGFzIHJlcXVlc3RlZCBhIGRpZmZcbiAgICogYmUgc2hvd24uXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgc2hvd0RpZmY6IHRydWUsXG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcudHJ1bmNhdGVUaHJlc2hvbGRcbiAgICpcbiAgICogVXNlciBjb25maWd1cmFibGUgcHJvcGVydHksIHNldHMgbGVuZ3RoIHRocmVzaG9sZCBmb3IgYWN0dWFsIGFuZFxuICAgKiBleHBlY3RlZCB2YWx1ZXMgaW4gYXNzZXJ0aW9uIGVycm9ycy4gSWYgdGhpcyB0aHJlc2hvbGQgaXMgZXhjZWVkZWQsIGZvclxuICAgKiBleGFtcGxlIGZvciBsYXJnZSBkYXRhIHN0cnVjdHVyZXMsIHRoZSB2YWx1ZSBpcyByZXBsYWNlZCB3aXRoIHNvbWV0aGluZ1xuICAgKiBsaWtlIGBbIEFycmF5KDMpIF1gIG9yIGB7IE9iamVjdCAocHJvcDEsIHByb3AyKSB9YC5cbiAgICpcbiAgICogU2V0IGl0IHRvIHplcm8gaWYgeW91IHdhbnQgdG8gZGlzYWJsZSB0cnVuY2F0aW5nIGFsdG9nZXRoZXIuXG4gICAqXG4gICAqIFRoaXMgaXMgZXNwZWNpYWxseSB1c2VyZnVsIHdoZW4gZG9pbmcgYXNzZXJ0aW9ucyBvbiBhcnJheXM6IGhhdmluZyB0aGlzXG4gICAqIHNldCB0byBhIHJlYXNvbmFibGUgbGFyZ2UgdmFsdWUgbWFrZXMgdGhlIGZhaWx1cmUgbWVzc2FnZXMgcmVhZGlseVxuICAgKiBpbnNwZWN0YWJsZS5cbiAgICpcbiAgICogICAgIGNoYWkuY29uZmlnLnRydW5jYXRlVGhyZXNob2xkID0gMDsgIC8vIGRpc2FibGUgdHJ1bmNhdGluZ1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgdHJ1bmNhdGVUaHJlc2hvbGQ6IDQwLFxuXG4gIC8qKlxuICAgKiAjIyMgY29uZmlnLnVzZVByb3h5XG4gICAqXG4gICAqIFVzZXIgY29uZmlndXJhYmxlIHByb3BlcnR5LCBkZWZpbmVzIGlmIGNoYWkgd2lsbCB1c2UgYSBQcm94eSB0byB0aHJvd1xuICAgKiBhbiBlcnJvciB3aGVuIGEgbm9uLWV4aXN0ZW50IHByb3BlcnR5IGlzIHJlYWQsIHdoaWNoIHByb3RlY3RzIHVzZXJzXG4gICAqIGZyb20gdHlwb3Mgd2hlbiB1c2luZyBwcm9wZXJ0eS1iYXNlZCBhc3NlcnRpb25zLlxuICAgKlxuICAgKiBTZXQgaXQgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG8gZGlzYWJsZSB0aGlzIGZlYXR1cmUuXG4gICAqXG4gICAqICAgICBjaGFpLmNvbmZpZy51c2VQcm94eSA9IGZhbHNlOyAgLy8gZGlzYWJsZSB1c2Ugb2YgUHJveHlcbiAgICpcbiAgICogVGhpcyBmZWF0dXJlIGlzIGF1dG9tYXRpY2FsbHkgZGlzYWJsZWQgcmVnYXJkbGVzcyBvZiB0aGlzIGNvbmZpZyB2YWx1ZVxuICAgKiBpbiBlbnZpcm9ubWVudHMgdGhhdCBkb24ndCBzdXBwb3J0IHByb3hpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgdXNlUHJveHk6IHRydWUsXG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcucHJveHlFeGNsdWRlZEtleXNcbiAgICpcbiAgICogVXNlciBjb25maWd1cmFibGUgcHJvcGVydHksIGRlZmluZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgaWdub3JlZFxuICAgKiBpbnN0ZWFkIG9mIHRocm93aW5nIGFuIGVycm9yIGlmIHRoZXkgZG8gbm90IGV4aXN0IG9uIHRoZSBhc3NlcnRpb24uXG4gICAqIFRoaXMgaXMgb25seSBhcHBsaWVkIGlmIHRoZSBlbnZpcm9ubWVudCBDaGFpIGlzIHJ1bm5pbmcgaW4gc3VwcG9ydHMgcHJveGllcyBhbmRcbiAgICogaWYgdGhlIGB1c2VQcm94eWAgY29uZmlndXJhdGlvbiBzZXR0aW5nIGlzIGVuYWJsZWQuXG4gICAqIEJ5IGRlZmF1bHQsIGB0aGVuYCBhbmQgYGluc3BlY3RgIHdpbGwgbm90IHRocm93IGFuIGVycm9yIGlmIHRoZXkgZG8gbm90IGV4aXN0IG9uIHRoZVxuICAgKiBhc3NlcnRpb24gb2JqZWN0IGJlY2F1c2UgdGhlIGAuaW5zcGVjdGAgcHJvcGVydHkgaXMgcmVhZCBieSBgdXRpbC5pbnNwZWN0YCAoZm9yIGV4YW1wbGUsIHdoZW5cbiAgICogdXNpbmcgYGNvbnNvbGUubG9nYCBvbiB0aGUgYXNzZXJ0aW9uIG9iamVjdCkgYW5kIGAudGhlbmAgaXMgbmVjZXNzYXJ5IGZvciBwcm9taXNlIHR5cGUtY2hlY2tpbmcuXG4gICAqXG4gICAqICAgICAvLyBCeSBkZWZhdWx0IHRoZXNlIGtleXMgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3IgaWYgdGhleSBkbyBub3QgZXhpc3Qgb24gdGhlIGFzc2VydGlvbiBvYmplY3RcbiAgICogICAgIGNoYWkuY29uZmlnLnByb3h5RXhjbHVkZWRLZXlzID0gWyd0aGVuJywgJ2luc3BlY3QnXTtcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgcHJveHlFeGNsdWRlZEtleXM6IFsndGhlbicsICdpbnNwZWN0JywgJ3RvSlNPTiddXG59O1xuIiwiLy8gVGhpcyBpcyAoYWxtb3N0KSBkaXJlY3RseSBmcm9tIE5vZGUuanMgdXRpbHNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9ibG9iL2Y4YzMzNWQwY2FmNDdmMTZkMzE0MTNmODlhYTI4ZWRhMzg3OGUzYWEvbGliL3V0aWwuanNcblxudmFyIGdldE5hbWUgPSByZXF1aXJlKCdnZXQtZnVuYy1uYW1lJyk7XG52YXIgZ2V0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZ2V0UHJvcGVydGllcycpO1xudmFyIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9nZXRFbnVtZXJhYmxlUHJvcGVydGllcycpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluc3BlY3Q7XG5cbi8qKlxuICogIyMjIC5pbnNwZWN0KG9iaiwgW3Nob3dIaWRkZW5dLCBbZGVwdGhdLCBbY29sb3JzXSlcbiAqXG4gKiBFY2hvZXMgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyaWVzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNob3dIaWRkZW4gRmxhZyB0aGF0IHNob3dzIGhpZGRlbiAobm90IGVudW1lcmFibGUpXG4gKiAgICBwcm9wZXJ0aWVzIG9mIG9iamVjdHMuIERlZmF1bHQgaXMgZmFsc2UuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVwdGggRGVwdGggaW4gd2hpY2ggdG8gZGVzY2VuZCBpbiBvYmplY3QuIERlZmF1bHQgaXMgMi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sb3JzIEZsYWcgdG8gdHVybiBvbiBBTlNJIGVzY2FwZSBjb2RlcyB0byBjb2xvciB0aGVcbiAqICAgIG91dHB1dC4gRGVmYXVsdCBpcyBmYWxzZSAobm8gY29sb3JpbmcpLlxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgaW5zcGVjdFxuICovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycykge1xuICB2YXIgY3R4ID0ge1xuICAgIHNob3dIaWRkZW46IHNob3dIaWRkZW4sXG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyOyB9XG4gIH07XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgKHR5cGVvZiBkZXB0aCA9PT0gJ3VuZGVmaW5lZCcgPyAyIDogZGVwdGgpKTtcbn1cblxuLy8gUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBhIERPTSBlbGVtZW50LlxudmFyIGlzRE9NRWxlbWVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iamVjdCAmJlxuICAgICAgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICdub2RlVHlwZScgaW4gb2JqZWN0ICYmXG4gICAgICBvYmplY3Qubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnO1xuICB9XG59O1xuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnNwZWN0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICh0eXBlb2YgcmV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIElmIHRoaXMgaXMgYSBET00gZWxlbWVudCwgdHJ5IHRvIGdldCB0aGUgb3V0ZXIgSFRNTC5cbiAgaWYgKGlzRE9NRWxlbWVudCh2YWx1ZSkpIHtcbiAgICBpZiAoJ291dGVySFRNTCcgaW4gdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5vdXRlckhUTUw7XG4gICAgICAvLyBUaGlzIHZhbHVlIGRvZXMgbm90IGhhdmUgYW4gb3V0ZXJIVE1MIGF0dHJpYnV0ZSxcbiAgICAgIC8vICAgaXQgY291bGQgc3RpbGwgYmUgYW4gWE1MIGVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXR0ZW1wdCB0byBzZXJpYWxpemUgaXRcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChkb2N1bWVudC54bWxWZXJzaW9uKSB7XG4gICAgICAgICAgdmFyIHhtbFNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuICAgICAgICAgIHJldHVybiB4bWxTZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGaXJlZm94IDExLSBkbyBub3Qgc3VwcG9ydCBvdXRlckhUTUxcbiAgICAgICAgICAvLyAgIEl0IGRvZXMsIGhvd2V2ZXIsIHN1cHBvcnQgaW5uZXJIVE1MXG4gICAgICAgICAgLy8gICBVc2UgdGhlIGZvbGxvd2luZyB0byByZW5kZXIgdGhlIGVsZW1lbnRcbiAgICAgICAgICB2YXIgbnMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCAnXycpO1xuXG4gICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHZhbHVlLmNsb25lTm9kZShmYWxzZSkpO1xuICAgICAgICAgIHZhciBodG1sID0gY29udGFpbmVyLmlubmVySFRNTFxuICAgICAgICAgICAgLnJlcGxhY2UoJz48JywgJz4nICsgdmFsdWUuaW5uZXJIVE1MICsgJzwnKTtcbiAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGEgbm9uLW5hdGl2ZSBET00gaW1wbGVtZW50YXRpb24sXG4gICAgICAgIC8vICAgY29udGludWUgd2l0aCB0aGUgbm9ybWFsIGZsb3c6XG4gICAgICAgIC8vICAgcHJpbnRpbmcgdGhlIGVsZW1lbnQgYXMgaWYgaXQgaXMgYW4gb2JqZWN0LlxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIHZpc2libGVLZXlzID0gZ2V0RW51bWVyYWJsZVByb3BlcnRpZXModmFsdWUpO1xuICB2YXIga2V5cyA9IGN0eC5zaG93SGlkZGVuID8gZ2V0UHJvcGVydGllcyh2YWx1ZSkgOiB2aXNpYmxlS2V5cztcblxuICB2YXIgbmFtZSwgbmFtZVN1ZmZpeDtcblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIC8vIEluIElFLCBlcnJvcnMgaGF2ZSBhIHNpbmdsZSBgc3RhY2tgIHByb3BlcnR5LCBvciBpZiB0aGV5IGFyZSB2YW5pbGxhIGBFcnJvcmAsXG4gIC8vIGEgYHN0YWNrYCBwbHVzIGBkZXNjcmlwdGlvbmAgcHJvcGVydHk7IGlnbm9yZSB0aG9zZSBmb3IgY29uc2lzdGVuY3kuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCB8fCAoaXNFcnJvcih2YWx1ZSkgJiYgKFxuICAgICAgKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09ICdzdGFjaycpIHx8XG4gICAgICAoa2V5cy5sZW5ndGggPT09IDIgJiYga2V5c1swXSA9PT0gJ2Rlc2NyaXB0aW9uJyAmJiBrZXlzWzFdID09PSAnc3RhY2snKVxuICAgICApKSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG5hbWUgPSBnZXROYW1lKHZhbHVlKTtcbiAgICAgIG5hbWVTdWZmaXggPSBuYW1lID8gJzogJyArIG5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWVTdWZmaXggKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnXG4gICAgLCBhcnJheSA9IGZhbHNlXG4gICAgLCB0eXBlZEFycmF5ID0gZmFsc2VcbiAgICAsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgaWYgKGlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICB0eXBlZEFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbmFtZSA9IGdldE5hbWUodmFsdWUpO1xuICAgIG5hbWVTdWZmaXggPSBuYW1lID8gJzogJyArIG5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbmFtZVN1ZmZpeCArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIGlmICh0eXBlZEFycmF5KSB7XG4gICAgcmV0dXJuIGZvcm1hdFR5cGVkQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKHZhbHVlID09PSAwICYmICgxL3ZhbHVlKSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnLTAnLCAnbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUodmFsdWUudG9TdHJpbmcoKSwgJ3N5bWJvbCcpO1xuICB9XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VHlwZWRBcnJheSh2YWx1ZSkge1xuICB2YXIgc3RyID0gJ1sgJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPj0gY29uZmlnLnRydW5jYXRlVGhyZXNob2xkIC0gNykge1xuICAgICAgc3RyICs9ICcuLi4nO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHN0ciArPSB2YWx1ZVtpXSArICcsICc7XG4gIH1cbiAgc3RyICs9ICcgXSc7XG5cbiAgLy8gUmVtb3ZpbmcgdHJhaWxpbmcgYCwgYCBpZiB0aGUgYXJyYXkgd2FzIG5vdCB0cnVuY2F0ZWRcbiAgaWYgKHN0ci5pbmRleE9mKCcsICBdJykgIT09IC0xKSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoJywgIF0nLCAnIF0nKTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWU7XG4gIHZhciBwcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSk7XG4gIHZhciBzdHI7XG5cbiAgaWYgKHByb3BEZXNjcmlwdG9yKSB7XG4gICAgaWYgKHByb3BEZXNjcmlwdG9yLmdldCkge1xuICAgICAgaWYgKHByb3BEZXNjcmlwdG9yLnNldCkge1xuICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wRGVzY3JpcHRvci5zZXQpIHtcbiAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZpc2libGVLZXlzLmluZGV4T2Yoa2V5KSA8IDApIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YodmFsdWVba2V5XSkgPCAwKSB7XG4gICAgICBpZiAocmVjdXJzZVRpbWVzID09PSBudWxsKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgdmFsdWVba2V5XSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlW2tleV0sIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cbmZ1bmN0aW9uIGlzVHlwZWRBcnJheShhcikge1xuICAvLyBVbmZvcnR1bmF0ZWx5IHRoZXJlJ3Mgbm8gd2F5IHRvIGNoZWNrIGlmIGFuIG9iamVjdCBpcyBhIFR5cGVkQXJyYXlcbiAgLy8gV2UgaGF2ZSB0byBjaGVjayBpZiBpdCdzIG9uZSBvZiB0aGVzZSB0eXBlc1xuICByZXR1cm4gKHR5cGVvZiBhciA9PT0gJ29iamVjdCcgJiYgL1xcdytBcnJheV0kLy50ZXN0KG9iamVjdFRvU3RyaW5nKGFyKSkpO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKSB8fFxuICAgICAgICAgKHR5cGVvZiBhciA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcoYXIpID09PSAnW29iamVjdCBBcnJheV0nKTtcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIHR5cGVvZiByZSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIHR5cGVvZiBkID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJztcbn1cblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiLyohXG4gKiBDaGFpIC0gZmxhZyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kYW5jaWVzXG4gKi9cblxudmFyIGluc3BlY3QgPSByZXF1aXJlKCcuL2luc3BlY3QnKTtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcblxuLyoqXG4gKiAjIyMgLm9iakRpc3BsYXkob2JqZWN0KVxuICpcbiAqIERldGVybWluZXMgaWYgYW4gb2JqZWN0IG9yIGFuIGFycmF5IG1hdGNoZXNcbiAqIGNyaXRlcmlhIHRvIGJlIGluc3BlY3RlZCBpbi1saW5lIGZvciBlcnJvclxuICogbWVzc2FnZXMgb3Igc2hvdWxkIGJlIHRydW5jYXRlZC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBqYXZhc2NyaXB0IG9iamVjdCB0byBpbnNwZWN0XG4gKiBAbmFtZSBvYmpEaXNwbGF5XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gb2JqRGlzcGxheShvYmopIHtcbiAgdmFyIHN0ciA9IGluc3BlY3Qob2JqKVxuICAgICwgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuXG4gIGlmIChjb25maWcudHJ1bmNhdGVUaHJlc2hvbGQgJiYgc3RyLmxlbmd0aCA+PSBjb25maWcudHJ1bmNhdGVUaHJlc2hvbGQpIHtcbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgcmV0dXJuICFvYmoubmFtZSB8fCBvYmoubmFtZSA9PT0gJydcbiAgICAgICAgPyAnW0Z1bmN0aW9uXSdcbiAgICAgICAgOiAnW0Z1bmN0aW9uOiAnICsgb2JqLm5hbWUgKyAnXSc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm4gJ1sgQXJyYXkoJyArIG9iai5sZW5ndGggKyAnKSBdJztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iailcbiAgICAgICAgLCBrc3RyID0ga2V5cy5sZW5ndGggPiAyXG4gICAgICAgICAgPyBrZXlzLnNwbGljZSgwLCAyKS5qb2luKCcsICcpICsgJywgLi4uJ1xuICAgICAgICAgIDoga2V5cy5qb2luKCcsICcpO1xuICAgICAgcmV0dXJuICd7IE9iamVjdCAoJyArIGtzdHIgKyAnKSB9JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufTtcbiIsIi8qIVxuICogQ2hhaSAtIG1lc3NhZ2UgY29tcG9zaXRpb24gdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGFuY2llc1xuICovXG5cbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJylcbiAgLCBnZXRBY3R1YWwgPSByZXF1aXJlKCcuL2dldEFjdHVhbCcpXG4gICwgaW5zcGVjdCA9IHJlcXVpcmUoJy4vaW5zcGVjdCcpXG4gICwgb2JqRGlzcGxheSA9IHJlcXVpcmUoJy4vb2JqRGlzcGxheScpO1xuXG4vKipcbiAqICMjIyAuZ2V0TWVzc2FnZShvYmplY3QsIG1lc3NhZ2UsIG5lZ2F0ZU1lc3NhZ2UpXG4gKlxuICogQ29uc3RydWN0IHRoZSBlcnJvciBtZXNzYWdlIGJhc2VkIG9uIGZsYWdzXG4gKiBhbmQgdGVtcGxhdGUgdGFncy4gVGVtcGxhdGUgdGFncyB3aWxsIHJldHVyblxuICogYSBzdHJpbmdpZmllZCBpbnNwZWN0aW9uIG9mIHRoZSBvYmplY3QgcmVmZXJlbmNlZC5cbiAqXG4gKiBNZXNzYWdlIHRlbXBsYXRlIHRhZ3M6XG4gKiAtIGAje3RoaXN9YCBjdXJyZW50IGFzc2VydGVkIG9iamVjdFxuICogLSBgI3thY3R9YCBhY3R1YWwgdmFsdWVcbiAqIC0gYCN7ZXhwfWAgZXhwZWN0ZWQgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IChjb25zdHJ1Y3RlZCBBc3NlcnRpb24pXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCBhcmd1bWVudHNcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldE1lc3NhZ2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRNZXNzYWdlKG9iaiwgYXJncykge1xuICB2YXIgbmVnYXRlID0gZmxhZyhvYmosICduZWdhdGUnKVxuICAgICwgdmFsID0gZmxhZyhvYmosICdvYmplY3QnKVxuICAgICwgZXhwZWN0ZWQgPSBhcmdzWzNdXG4gICAgLCBhY3R1YWwgPSBnZXRBY3R1YWwob2JqLCBhcmdzKVxuICAgICwgbXNnID0gbmVnYXRlID8gYXJnc1syXSA6IGFyZ3NbMV1cbiAgICAsIGZsYWdNc2cgPSBmbGFnKG9iaiwgJ21lc3NhZ2UnKTtcblxuICBpZih0eXBlb2YgbXNnID09PSBcImZ1bmN0aW9uXCIpIG1zZyA9IG1zZygpO1xuICBtc2cgPSBtc2cgfHwgJyc7XG4gIG1zZyA9IG1zZ1xuICAgIC5yZXBsYWNlKC8jXFx7dGhpc1xcfS9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBvYmpEaXNwbGF5KHZhbCk7IH0pXG4gICAgLnJlcGxhY2UoLyNcXHthY3RcXH0vZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqRGlzcGxheShhY3R1YWwpOyB9KVxuICAgIC5yZXBsYWNlKC8jXFx7ZXhwXFx9L2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9iakRpc3BsYXkoZXhwZWN0ZWQpOyB9KTtcblxuICByZXR1cm4gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnICsgbXNnIDogbXNnO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIHRyYW5zZmVyRmxhZ3MgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC50cmFuc2ZlckZsYWdzKGFzc2VydGlvbiwgb2JqZWN0LCBpbmNsdWRlQWxsID0gdHJ1ZSlcbiAqXG4gKiBUcmFuc2ZlciBhbGwgdGhlIGZsYWdzIGZvciBgYXNzZXJ0aW9uYCB0byBgb2JqZWN0YC4gSWZcbiAqIGBpbmNsdWRlQWxsYCBpcyBzZXQgdG8gYGZhbHNlYCwgdGhlbiB0aGUgYmFzZSBDaGFpXG4gKiBhc3NlcnRpb24gZmxhZ3MgKG5hbWVseSBgb2JqZWN0YCwgYHNzZmlgLCBgbG9ja1NzZmlgLFxuICogYW5kIGBtZXNzYWdlYCkgd2lsbCBub3QgYmUgdHJhbnNmZXJyZWQuXG4gKlxuICpcbiAqICAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IEFzc2VydGlvbigpO1xuICogICAgIHV0aWxzLnRyYW5zZmVyRmxhZ3MoYXNzZXJ0aW9uLCBuZXdBc3NlcnRpb24pO1xuICpcbiAqICAgICB2YXIgYW5vdGhlckFzc2VyaXRvbiA9IG5ldyBBc3NlcnRpb24obXlPYmopO1xuICogICAgIHV0aWxzLnRyYW5zZmVyRmxhZ3MoYXNzZXJ0aW9uLCBhbm90aGVyQXNzZXJ0aW9uLCBmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtBc3NlcnRpb259IGFzc2VydGlvbiB0aGUgYXNzZXJ0aW9uIHRvIHRyYW5zZmVyIHRoZSBmbGFncyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRoZSBvYmplY3QgdG8gdHJhbnNmZXIgdGhlIGZsYWdzIHRvOyB1c3VhbGx5IGEgbmV3IGFzc2VydGlvblxuICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlQWxsXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSB0cmFuc2ZlckZsYWdzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZmVyRmxhZ3MoYXNzZXJ0aW9uLCBvYmplY3QsIGluY2x1ZGVBbGwpIHtcbiAgdmFyIGZsYWdzID0gYXNzZXJ0aW9uLl9fZmxhZ3MgfHwgKGFzc2VydGlvbi5fX2ZsYWdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbiAgaWYgKCFvYmplY3QuX19mbGFncykge1xuICAgIG9iamVjdC5fX2ZsYWdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIGluY2x1ZGVBbGwgPSBhcmd1bWVudHMubGVuZ3RoID09PSAzID8gaW5jbHVkZUFsbCA6IHRydWU7XG5cbiAgZm9yICh2YXIgZmxhZyBpbiBmbGFncykge1xuICAgIGlmIChpbmNsdWRlQWxsIHx8XG4gICAgICAgIChmbGFnICE9PSAnb2JqZWN0JyAmJiBmbGFnICE9PSAnc3NmaScgJiYgZmxhZyAhPT0gJ2xvY2tTc2ZpJyAmJiBmbGFnICE9ICdtZXNzYWdlJykpIHtcbiAgICAgIG9iamVjdC5fX2ZsYWdzW2ZsYWddID0gZmxhZ3NbZmxhZ107XG4gICAgfVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFscyBTeW1ib2w6IGZhbHNlLCBVaW50OEFycmF5OiBmYWxzZSwgV2Vha01hcDogZmFsc2UgKi9cbi8qIVxuICogZGVlcC1lcWxcbiAqIENvcHlyaWdodChjKSAyMDEzIEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIHR5cGUgPSByZXF1aXJlKCd0eXBlLWRldGVjdCcpO1xuZnVuY3Rpb24gRmFrZU1hcCgpIHtcbiAgdGhpcy5fa2V5ID0gJ2NoYWkvZGVlcC1lcWxfXycgKyBNYXRoLnJhbmRvbSgpICsgRGF0ZS5ub3coKTtcbn1cblxuRmFrZU1hcC5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24gZ2V0TWFwKGtleSkge1xuICAgIHJldHVybiBrZXlbdGhpcy5fa2V5XTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXRNYXAoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChPYmplY3QuaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShrZXksIHRoaXMuX2tleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbn07XG5cbnZhciBNZW1vaXplTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogRmFrZU1hcDtcbi8qIVxuICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBNZW1vaXplTWFwIGhhcyByZWNvcmRlZCBhIHJlc3VsdCBvZiB0aGUgdHdvIG9wZXJhbmRzXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01lbW9pemVNYXB9IG1lbW9pemVNYXBcbiAqIEByZXR1cm5zIHtCb29sZWFufG51bGx9IHJlc3VsdFxuKi9cbmZ1bmN0aW9uIG1lbW9pemVDb21wYXJlKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgbWVtb2l6ZU1hcCkge1xuICAvLyBUZWNobmljYWxseSwgV2Vha01hcCBrZXlzIGNhbiAqb25seSogYmUgb2JqZWN0cywgbm90IHByaW1pdGl2ZXMuXG4gIGlmICghbWVtb2l6ZU1hcCB8fCBpc1ByaW1pdGl2ZShsZWZ0SGFuZE9wZXJhbmQpIHx8IGlzUHJpbWl0aXZlKHJpZ2h0SGFuZE9wZXJhbmQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGxlZnRIYW5kTWFwID0gbWVtb2l6ZU1hcC5nZXQobGVmdEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kTWFwKSB7XG4gICAgdmFyIHJlc3VsdCA9IGxlZnRIYW5kTWFwLmdldChyaWdodEhhbmRPcGVyYW5kKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyohXG4gKiBTZXQgdGhlIHJlc3VsdCBvZiB0aGUgZXF1YWxpdHkgaW50byB0aGUgTWVtb2l6ZU1hcFxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNZW1vaXplTWFwfSBtZW1vaXplTWFwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJlc3VsdFxuKi9cbmZ1bmN0aW9uIG1lbW9pemVTZXQobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBtZW1vaXplTWFwLCByZXN1bHQpIHtcbiAgLy8gVGVjaG5pY2FsbHksIFdlYWtNYXAga2V5cyBjYW4gKm9ubHkqIGJlIG9iamVjdHMsIG5vdCBwcmltaXRpdmVzLlxuICBpZiAoIW1lbW9pemVNYXAgfHwgaXNQcmltaXRpdmUobGVmdEhhbmRPcGVyYW5kKSB8fCBpc1ByaW1pdGl2ZShyaWdodEhhbmRPcGVyYW5kKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbGVmdEhhbmRNYXAgPSBtZW1vaXplTWFwLmdldChsZWZ0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRNYXApIHtcbiAgICBsZWZ0SGFuZE1hcC5zZXQocmlnaHRIYW5kT3BlcmFuZCwgcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBsZWZ0SGFuZE1hcCA9IG5ldyBNZW1vaXplTWFwKCk7XG4gICAgbGVmdEhhbmRNYXAuc2V0KHJpZ2h0SGFuZE9wZXJhbmQsIHJlc3VsdCk7XG4gICAgbWVtb2l6ZU1hcC5zZXQobGVmdEhhbmRPcGVyYW5kLCBsZWZ0SGFuZE1hcCk7XG4gIH1cbn1cblxuLyohXG4gKiBQcmltYXJ5IEV4cG9ydFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVlcEVxdWFsO1xubW9kdWxlLmV4cG9ydHMuTWVtb2l6ZU1hcCA9IE1lbW9pemVNYXA7XG5cbi8qKlxuICogQXNzZXJ0IGRlZXBseSBuZXN0ZWQgc2FtZVZhbHVlIGVxdWFsaXR5IGJldHdlZW4gdHdvIG9iamVjdHMgb2YgYW55IHR5cGUuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChvcHRpb25hbCkgQWRkaXRpb25hbCBvcHRpb25zXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5jb21wYXJhdG9yXSAob3B0aW9uYWwpIE92ZXJyaWRlIGRlZmF1bHQgYWxnb3JpdGhtLCBkZXRlcm1pbmluZyBjdXN0b20gZXF1YWxpdHkuXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5tZW1vaXplXSAob3B0aW9uYWwpIFByb3ZpZGUgYSBjdXN0b20gbWVtb2l6YXRpb24gb2JqZWN0IHdoaWNoIHdpbGwgY2FjaGUgdGhlIHJlc3VsdHMgb2ZcbiAgICBjb21wbGV4IG9iamVjdHMgZm9yIGEgc3BlZWQgYm9vc3QuIEJ5IHBhc3NpbmcgYGZhbHNlYCB5b3UgY2FuIGRpc2FibGUgbWVtb2l6YXRpb24sIGJ1dCB0aGlzIHdpbGwgY2F1c2UgY2lyY3VsYXJcbiAgICByZWZlcmVuY2VzIHRvIGJsb3cgdGhlIHN0YWNrLlxuICogQHJldHVybiB7Qm9vbGVhbn0gZXF1YWwgbWF0Y2hcbiAqL1xuZnVuY3Rpb24gZGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICAvLyBJZiB3ZSBoYXZlIGEgY29tcGFyYXRvciwgd2UgY2FuJ3QgYXNzdW1lIGFueXRoaW5nOyBzbyBiYWlsIHRvIGl0cyBjaGVjayBmaXJzdC5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIGV4dGVuc2l2ZURlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHNpbXBsZVJlc3VsdCA9IHNpbXBsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCk7XG4gIGlmIChzaW1wbGVSZXN1bHQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc2ltcGxlUmVzdWx0O1xuICB9XG5cbiAgLy8gRGVlcGVyIGNvbXBhcmlzb25zIGFyZSBwdXNoZWQgdGhyb3VnaCB0byBhIGxhcmdlciBmdW5jdGlvblxuICByZXR1cm4gZXh0ZW5zaXZlRGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogTWFueSBjb21wYXJpc29ucyBjYW4gYmUgY2FuY2VsZWQgb3V0IGVhcmx5IHZpYSBzaW1wbGUgZXF1YWxpdHkgb3IgcHJpbWl0aXZlIGNoZWNrcy5cbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHJldHVybiB7Qm9vbGVhbnxudWxsfSBlcXVhbCBtYXRjaFxuICovXG5mdW5jdGlvbiBzaW1wbGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpIHtcbiAgLy8gRXF1YWwgcmVmZXJlbmNlcyAoZXhjZXB0IGZvciBOdW1iZXJzKSBjYW4gYmUgcmV0dXJuZWQgZWFybHlcbiAgaWYgKGxlZnRIYW5kT3BlcmFuZCA9PT0gcmlnaHRIYW5kT3BlcmFuZCkge1xuICAgIC8vIEhhbmRsZSArLTAgY2FzZXNcbiAgICByZXR1cm4gbGVmdEhhbmRPcGVyYW5kICE9PSAwIHx8IDEgLyBsZWZ0SGFuZE9wZXJhbmQgPT09IDEgLyByaWdodEhhbmRPcGVyYW5kO1xuICB9XG5cbiAgLy8gaGFuZGxlIE5hTiBjYXNlc1xuICBpZiAoXG4gICAgbGVmdEhhbmRPcGVyYW5kICE9PSBsZWZ0SGFuZE9wZXJhbmQgJiYgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByaWdodEhhbmRPcGVyYW5kICE9PSByaWdodEhhbmRPcGVyYW5kIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gQW55dGhpbmcgdGhhdCBpcyBub3QgYW4gJ29iamVjdCcsIGkuZS4gc3ltYm9scywgZnVuY3Rpb25zLCBib29sZWFucywgbnVtYmVycyxcbiAgLy8gc3RyaW5ncywgYW5kIHVuZGVmaW5lZCwgY2FuIGJlIGNvbXBhcmVkIGJ5IHJlZmVyZW5jZS5cbiAgaWYgKGlzUHJpbWl0aXZlKGxlZnRIYW5kT3BlcmFuZCkgfHwgaXNQcmltaXRpdmUocmlnaHRIYW5kT3BlcmFuZCkpIHtcbiAgICAvLyBFYXN5IG91dCBiL2MgaXQgd291bGQgaGF2ZSBwYXNzZWQgdGhlIGZpcnN0IGVxdWFsaXR5IGNoZWNrXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKiFcbiAqIFRoZSBtYWluIGxvZ2ljIG9mIHRoZSBgZGVlcEVxdWFsYCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKG9wdGlvbmFsKSBBZGRpdGlvbmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmNvbXBhcmF0b3JdIChvcHRpb25hbCkgT3ZlcnJpZGUgZGVmYXVsdCBhbGdvcml0aG0sIGRldGVybWluaW5nIGN1c3RvbSBlcXVhbGl0eS5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm1lbW9pemVdIChvcHRpb25hbCkgUHJvdmlkZSBhIGN1c3RvbSBtZW1vaXphdGlvbiBvYmplY3Qgd2hpY2ggd2lsbCBjYWNoZSB0aGUgcmVzdWx0cyBvZlxuICAgIGNvbXBsZXggb2JqZWN0cyBmb3IgYSBzcGVlZCBib29zdC4gQnkgcGFzc2luZyBgZmFsc2VgIHlvdSBjYW4gZGlzYWJsZSBtZW1vaXphdGlvbiwgYnV0IHRoaXMgd2lsbCBjYXVzZSBjaXJjdWxhclxuICAgIHJlZmVyZW5jZXMgdG8gYmxvdyB0aGUgc3RhY2suXG4gKiBAcmV0dXJuIHtCb29sZWFufSBlcXVhbCBtYXRjaFxuKi9cbmZ1bmN0aW9uIGV4dGVuc2l2ZURlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMubWVtb2l6ZSA9IG9wdGlvbnMubWVtb2l6ZSA9PT0gZmFsc2UgPyBmYWxzZSA6IG9wdGlvbnMubWVtb2l6ZSB8fCBuZXcgTWVtb2l6ZU1hcCgpO1xuICB2YXIgY29tcGFyYXRvciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wYXJhdG9yO1xuXG4gIC8vIENoZWNrIGlmIGEgbWVtb2l6ZWQgcmVzdWx0IGV4aXN0cy5cbiAgdmFyIG1lbW9pemVSZXN1bHRMZWZ0ID0gbWVtb2l6ZUNvbXBhcmUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUpO1xuICBpZiAobWVtb2l6ZVJlc3VsdExlZnQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gbWVtb2l6ZVJlc3VsdExlZnQ7XG4gIH1cbiAgdmFyIG1lbW9pemVSZXN1bHRSaWdodCA9IG1lbW9pemVDb21wYXJlKHJpZ2h0SGFuZE9wZXJhbmQsIGxlZnRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplKTtcbiAgaWYgKG1lbW9pemVSZXN1bHRSaWdodCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBtZW1vaXplUmVzdWx0UmlnaHQ7XG4gIH1cblxuICAvLyBJZiBhIGNvbXBhcmF0b3IgaXMgcHJlc2VudCwgdXNlIGl0LlxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIHZhciBjb21wYXJhdG9yUmVzdWx0ID0gY29tcGFyYXRvcihsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIC8vIENvbXBhcmF0b3JzIG1heSByZXR1cm4gbnVsbCwgaW4gd2hpY2ggY2FzZSB3ZSB3YW50IHRvIGdvIGJhY2sgdG8gZGVmYXVsdCBiZWhhdmlvci5cbiAgICBpZiAoY29tcGFyYXRvclJlc3VsdCA9PT0gZmFsc2UgfHwgY29tcGFyYXRvclJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgbWVtb2l6ZVNldChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSwgY29tcGFyYXRvclJlc3VsdCk7XG4gICAgICByZXR1cm4gY29tcGFyYXRvclJlc3VsdDtcbiAgICB9XG4gICAgLy8gVG8gYWxsb3cgY29tcGFyYXRvcnMgdG8gb3ZlcnJpZGUgKmFueSogYmVoYXZpb3IsIHdlIHJhbiB0aGVtIGZpcnN0LiBTaW5jZSBpdCBkaWRuJ3QgZGVjaWRlXG4gICAgLy8gd2hhdCB0byBkbywgd2UgbmVlZCB0byBtYWtlIHN1cmUgdG8gcmV0dXJuIHRoZSBiYXNpYyB0ZXN0cyBmaXJzdCBiZWZvcmUgd2UgbW92ZSBvbi5cbiAgICB2YXIgc2ltcGxlUmVzdWx0ID0gc2ltcGxlRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKTtcbiAgICBpZiAoc2ltcGxlUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAvLyBEb24ndCBtZW1vaXplIHRoaXMsIGl0IHRha2VzIGxvbmdlciB0byBzZXQvcmV0cmlldmUgdGhhbiB0byBqdXN0IGNvbXBhcmUuXG4gICAgICByZXR1cm4gc2ltcGxlUmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIHZhciBsZWZ0SGFuZFR5cGUgPSB0eXBlKGxlZnRIYW5kT3BlcmFuZCk7XG4gIGlmIChsZWZ0SGFuZFR5cGUgIT09IHR5cGUocmlnaHRIYW5kT3BlcmFuZCkpIHtcbiAgICBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplLCBmYWxzZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVtcG9yYXJpbHkgc2V0IHRoZSBvcGVyYW5kcyBpbiB0aGUgbWVtb2l6ZSBvYmplY3QgdG8gcHJldmVudCBibG93aW5nIHRoZSBzdGFja1xuICBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplLCB0cnVlKTtcblxuICB2YXIgcmVzdWx0ID0gZXh0ZW5zaXZlRGVlcEVxdWFsQnlUeXBlKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgbGVmdEhhbmRUeXBlLCBvcHRpb25zKTtcbiAgbWVtb2l6ZVNldChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5zaXZlRGVlcEVxdWFsQnlUeXBlKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgbGVmdEhhbmRUeXBlLCBvcHRpb25zKSB7XG4gIHN3aXRjaCAobGVmdEhhbmRUeXBlKSB7XG4gICAgY2FzZSAnU3RyaW5nJzpcbiAgICBjYXNlICdOdW1iZXInOlxuICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgLy8gSWYgdGhlc2UgdHlwZXMgYXJlIHRoZWlyIGluc3RhbmNlIHR5cGVzIChlLmcuIGBuZXcgTnVtYmVyYCkgdGhlbiByZS1kZWVwRXF1YWwgYWdhaW5zdCB0aGVpciB2YWx1ZXNcbiAgICAgIHJldHVybiBkZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kLnZhbHVlT2YoKSwgcmlnaHRIYW5kT3BlcmFuZC52YWx1ZU9mKCkpO1xuICAgIGNhc2UgJ1Byb21pc2UnOlxuICAgIGNhc2UgJ1N5bWJvbCc6XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgIGNhc2UgJ1dlYWtNYXAnOlxuICAgIGNhc2UgJ1dlYWtTZXQnOlxuICAgIGNhc2UgJ0Vycm9yJzpcbiAgICAgIHJldHVybiBsZWZ0SGFuZE9wZXJhbmQgPT09IHJpZ2h0SGFuZE9wZXJhbmQ7XG4gICAgY2FzZSAnQXJndW1lbnRzJzpcbiAgICBjYXNlICdJbnQ4QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQ4QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQ4Q2xhbXBlZEFycmF5JzpcbiAgICBjYXNlICdJbnQxNkFycmF5JzpcbiAgICBjYXNlICdVaW50MTZBcnJheSc6XG4gICAgY2FzZSAnSW50MzJBcnJheSc6XG4gICAgY2FzZSAnVWludDMyQXJyYXknOlxuICAgIGNhc2UgJ0Zsb2F0MzJBcnJheSc6XG4gICAgY2FzZSAnRmxvYXQ2NEFycmF5JzpcbiAgICBjYXNlICdBcnJheSc6XG4gICAgICByZXR1cm4gaXRlcmFibGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICByZXR1cm4gcmVnZXhwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKTtcbiAgICBjYXNlICdHZW5lcmF0b3InOlxuICAgICAgcmV0dXJuIGdlbmVyYXRvckVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gICAgY2FzZSAnRGF0YVZpZXcnOlxuICAgICAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobmV3IFVpbnQ4QXJyYXkobGVmdEhhbmRPcGVyYW5kLmJ1ZmZlciksIG5ldyBVaW50OEFycmF5KHJpZ2h0SGFuZE9wZXJhbmQuYnVmZmVyKSwgb3B0aW9ucyk7XG4gICAgY2FzZSAnQXJyYXlCdWZmZXInOlxuICAgICAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobmV3IFVpbnQ4QXJyYXkobGVmdEhhbmRPcGVyYW5kKSwgbmV3IFVpbnQ4QXJyYXkocmlnaHRIYW5kT3BlcmFuZCksIG9wdGlvbnMpO1xuICAgIGNhc2UgJ1NldCc6XG4gICAgICByZXR1cm4gZW50cmllc0VxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gICAgY2FzZSAnTWFwJzpcbiAgICAgIHJldHVybiBlbnRyaWVzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG9iamVjdEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuLyohXG4gKiBDb21wYXJlIHR3byBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gcmVnZXhwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKSB7XG4gIHJldHVybiBsZWZ0SGFuZE9wZXJhbmQudG9TdHJpbmcoKSA9PT0gcmlnaHRIYW5kT3BlcmFuZC50b1N0cmluZygpO1xufVxuXG4vKiFcbiAqIENvbXBhcmUgdHdvIFNldHMvTWFwcyBmb3IgZXF1YWxpdHkuIEZhc3RlciB0aGFuIG90aGVyIGVxdWFsaXR5IGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge1NldH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge1NldH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAoT3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBlbnRyaWVzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIC8vIElFMTEgZG9lc24ndCBzdXBwb3J0IFNldCNlbnRyaWVzIG9yIFNldCNAQGl0ZXJhdG9yLCBzbyB3ZSBuZWVkIG1hbnVhbGx5IHBvcHVsYXRlIHVzaW5nIFNldCNmb3JFYWNoXG4gIGlmIChsZWZ0SGFuZE9wZXJhbmQuc2l6ZSAhPT0gcmlnaHRIYW5kT3BlcmFuZC5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChsZWZ0SGFuZE9wZXJhbmQuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBsZWZ0SGFuZEl0ZW1zID0gW107XG4gIHZhciByaWdodEhhbmRJdGVtcyA9IFtdO1xuICBsZWZ0SGFuZE9wZXJhbmQuZm9yRWFjaChmdW5jdGlvbiBnYXRoZXJFbnRyaWVzKGtleSwgdmFsdWUpIHtcbiAgICBsZWZ0SGFuZEl0ZW1zLnB1c2goWyBrZXksIHZhbHVlIF0pO1xuICB9KTtcbiAgcmlnaHRIYW5kT3BlcmFuZC5mb3JFYWNoKGZ1bmN0aW9uIGdhdGhlckVudHJpZXMoa2V5LCB2YWx1ZSkge1xuICAgIHJpZ2h0SGFuZEl0ZW1zLnB1c2goWyBrZXksIHZhbHVlIF0pO1xuICB9KTtcbiAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobGVmdEhhbmRJdGVtcy5zb3J0KCksIHJpZ2h0SGFuZEl0ZW1zLnNvcnQoKSwgb3B0aW9ucyk7XG59XG5cbi8qIVxuICogU2ltcGxlIGVxdWFsaXR5IGZvciBmbGF0IGl0ZXJhYmxlIG9iamVjdHMgc3VjaCBhcyBBcnJheXMsIFR5cGVkQXJyYXlzIG9yIE5vZGUuanMgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7SXRlcmFibGV9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gaXRlcmFibGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlbmd0aCA9IGxlZnRIYW5kT3BlcmFuZC5sZW5ndGg7XG4gIGlmIChsZW5ndGggIT09IHJpZ2h0SGFuZE9wZXJhbmQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaW5kZXggPSAtMTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoZGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZFtpbmRleF0sIHJpZ2h0SGFuZE9wZXJhbmRbaW5kZXhdLCBvcHRpb25zKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qIVxuICogU2ltcGxlIGVxdWFsaXR5IGZvciBnZW5lcmF0b3Igb2JqZWN0cyBzdWNoIGFzIHRob3NlIHJldHVybmVkIGJ5IGdlbmVyYXRvciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtJdGVyYWJsZX0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChPcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGdlbmVyYXRvckVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICByZXR1cm4gaXRlcmFibGVFcXVhbChnZXRHZW5lcmF0b3JFbnRyaWVzKGxlZnRIYW5kT3BlcmFuZCksIGdldEdlbmVyYXRvckVudHJpZXMocmlnaHRIYW5kT3BlcmFuZCksIG9wdGlvbnMpO1xufVxuXG4vKiFcbiAqIERldGVybWluZSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBhbiBAQGl0ZXJhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgb2JqZWN0IGhhcyBhbiBAQGl0ZXJhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBoYXNJdGVyYXRvckZ1bmN0aW9uKHRhcmdldCkge1xuICByZXR1cm4gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHRhcmdldFtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKiFcbiAqIEdldHMgYWxsIGl0ZXJhdG9yIGVudHJpZXMgZnJvbSB0aGUgZ2l2ZW4gT2JqZWN0LiBJZiB0aGUgT2JqZWN0IGhhcyBubyBAQGl0ZXJhdG9yIGZ1bmN0aW9uLCByZXR1cm5zIGFuIGVtcHR5IGFycmF5LlxuICogVGhpcyB3aWxsIGNvbnN1bWUgdGhlIGl0ZXJhdG9yIC0gd2hpY2ggY291bGQgaGF2ZSBzaWRlIGVmZmVjdHMgZGVwZW5kaW5nIG9uIHRoZSBAQGl0ZXJhdG9yIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2YgZW50cmllcyBmcm9tIHRoZSBAQGl0ZXJhdG9yIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRW50cmllcyh0YXJnZXQpIHtcbiAgaWYgKGhhc0l0ZXJhdG9yRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZ2V0R2VuZXJhdG9yRW50cmllcyh0YXJnZXRbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbiAgICB9IGNhdGNoIChpdGVyYXRvckVycm9yKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTtcbn1cblxuLyohXG4gKiBHZXRzIGFsbCBlbnRyaWVzIGZyb20gYSBHZW5lcmF0b3IuIFRoaXMgd2lsbCBjb25zdW1lIHRoZSBnZW5lcmF0b3IgLSB3aGljaCBjb3VsZCBoYXZlIHNpZGUgZWZmZWN0cy5cbiAqXG4gKiBAcGFyYW0ge0dlbmVyYXRvcn0gdGFyZ2V0XG4gKiBAcmV0dXJucyB7QXJyYXl9IGFuIGFycmF5IG9mIGVudHJpZXMgZnJvbSB0aGUgR2VuZXJhdG9yLlxuICovXG5mdW5jdGlvbiBnZXRHZW5lcmF0b3JFbnRyaWVzKGdlbmVyYXRvcikge1xuICB2YXIgZ2VuZXJhdG9yUmVzdWx0ID0gZ2VuZXJhdG9yLm5leHQoKTtcbiAgdmFyIGFjY3VtdWxhdG9yID0gWyBnZW5lcmF0b3JSZXN1bHQudmFsdWUgXTtcbiAgd2hpbGUgKGdlbmVyYXRvclJlc3VsdC5kb25lID09PSBmYWxzZSkge1xuICAgIGdlbmVyYXRvclJlc3VsdCA9IGdlbmVyYXRvci5uZXh0KCk7XG4gICAgYWNjdW11bGF0b3IucHVzaChnZW5lcmF0b3JSZXN1bHQudmFsdWUpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxuLyohXG4gKiBHZXRzIGFsbCBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIGtleXMgZnJvbSBhIHRhcmdldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcmV0dXJucyB7QXJyYXl9IGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUga2V5cyBmcm9tIHRoZSB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVLZXlzKHRhcmdldCkge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbi8qIVxuICogRGV0ZXJtaW5lcyBpZiB0d28gb2JqZWN0cyBoYXZlIG1hdGNoaW5nIHZhbHVlcywgZ2l2ZW4gYSBzZXQgb2Yga2V5cy4gRGVmZXJzIHRvIGRlZXBFcXVhbCBmb3IgdGhlIGVxdWFsaXR5IGNoZWNrIG9mXG4gKiBlYWNoIGtleS4gSWYgYW55IHZhbHVlIG9mIHRoZSBnaXZlbiBrZXkgaXMgbm90IGVxdWFsLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gZmFsc2UgKGVhcmx5KS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7QXJyYXl9IGtleXMgQW4gYXJyYXkgb2Yga2V5cyB0byBjb21wYXJlIHRoZSB2YWx1ZXMgb2YgbGVmdEhhbmRPcGVyYW5kIGFuZCByaWdodEhhbmRPcGVyYW5kIGFnYWluc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGtleXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChkZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kW2tleXNbaV1dLCByaWdodEhhbmRPcGVyYW5kW2tleXNbaV1dLCBvcHRpb25zKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qIVxuICogUmVjdXJzaXZlbHkgY2hlY2sgdGhlIGVxdWFsaXR5IG9mIHR3byBPYmplY3RzLiBPbmNlIGJhc2ljIHNhbWVuZXNzIGhhcyBiZWVuIGVzdGFibGlzaGVkIGl0IHdpbGwgZGVmZXIgdG8gYGRlZXBFcXVhbGBcbiAqIGZvciBlYWNoIGVudW1lcmFibGUga2V5IGluIHRoZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChPcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIG9iamVjdEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICB2YXIgbGVmdEhhbmRLZXlzID0gZ2V0RW51bWVyYWJsZUtleXMobGVmdEhhbmRPcGVyYW5kKTtcbiAgdmFyIHJpZ2h0SGFuZEtleXMgPSBnZXRFbnVtZXJhYmxlS2V5cyhyaWdodEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kS2V5cy5sZW5ndGggJiYgbGVmdEhhbmRLZXlzLmxlbmd0aCA9PT0gcmlnaHRIYW5kS2V5cy5sZW5ndGgpIHtcbiAgICBsZWZ0SGFuZEtleXMuc29ydCgpO1xuICAgIHJpZ2h0SGFuZEtleXMuc29ydCgpO1xuICAgIGlmIChpdGVyYWJsZUVxdWFsKGxlZnRIYW5kS2V5cywgcmlnaHRIYW5kS2V5cykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBrZXlzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBsZWZ0SGFuZEtleXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIGxlZnRIYW5kRW50cmllcyA9IGdldEl0ZXJhdG9yRW50cmllcyhsZWZ0SGFuZE9wZXJhbmQpO1xuICB2YXIgcmlnaHRIYW5kRW50cmllcyA9IGdldEl0ZXJhdG9yRW50cmllcyhyaWdodEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kRW50cmllcy5sZW5ndGggJiYgbGVmdEhhbmRFbnRyaWVzLmxlbmd0aCA9PT0gcmlnaHRIYW5kRW50cmllcy5sZW5ndGgpIHtcbiAgICBsZWZ0SGFuZEVudHJpZXMuc29ydCgpO1xuICAgIHJpZ2h0SGFuZEVudHJpZXMuc29ydCgpO1xuICAgIHJldHVybiBpdGVyYWJsZUVxdWFsKGxlZnRIYW5kRW50cmllcywgcmlnaHRIYW5kRW50cmllcywgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAobGVmdEhhbmRLZXlzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgbGVmdEhhbmRFbnRyaWVzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgcmlnaHRIYW5kS2V5cy5sZW5ndGggPT09IDAgJiZcbiAgICAgIHJpZ2h0SGFuZEVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qIVxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhIHByaW1pdGl2ZS5cbiAqXG4gKiBUaGlzIGludGVudGlvbmFsbHkgcmV0dXJucyB0cnVlIGZvciBhbGwgb2JqZWN0cyB0aGF0IGNhbiBiZSBjb21wYXJlZCBieSByZWZlcmVuY2UsXG4gKiBpbmNsdWRpbmcgZnVuY3Rpb25zIGFuZCBzeW1ib2xzLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCc7XG59XG4iLCJ2YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbi8qIVxuICogQ2hhaSAtIGlzUHJveHlFbmFibGVkIGhlbHBlclxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5pc1Byb3h5RW5hYmxlZCgpXG4gKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIENoYWkncyBwcm94eSBwcm90ZWN0aW9uIGZlYXR1cmUgaXMgZW5hYmxlZC4gSWZcbiAqIHByb3hpZXMgYXJlIHVuc3VwcG9ydGVkIG9yIGRpc2FibGVkIHZpYSB0aGUgdXNlcidzIENoYWkgY29uZmlnLCB0aGVuIHJldHVyblxuICogZmFsc2UuIE90aGVyd2lzZSwgcmV0dXJuIHRydWUuXG4gKlxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgaXNQcm94eUVuYWJsZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUHJveHlFbmFibGVkKCkge1xuICByZXR1cm4gY29uZmlnLnVzZVByb3h5ICYmIFxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCc7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gYWRkUHJvcGVydHkgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBjaGFpID0gcmVxdWlyZSgnLi4vLi4vY2hhaScpO1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcbnZhciBpc1Byb3h5RW5hYmxlZCA9IHJlcXVpcmUoJy4vaXNQcm94eUVuYWJsZWQnKTtcbnZhciB0cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG5cbi8qKlxuICogIyMjIC5hZGRQcm9wZXJ0eShjdHgsIG5hbWUsIGdldHRlcilcbiAqXG4gKiBBZGRzIGEgcHJvcGVydHkgdG8gdGhlIHByb3RvdHlwZSBvZiBhbiBvYmplY3QuXG4gKlxuICogICAgIHV0aWxzLmFkZFByb3BlcnR5KGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2ZvbycsIGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmopLnRvLmJlLmluc3RhbmNlb2YoRm9vKTtcbiAqICAgICB9KTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdmb28nLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmJlLmZvbztcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB0byB3aGljaCB0aGUgcHJvcGVydHkgaXMgYWRkZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHByb3BlcnR5IHRvIGFkZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGFkZFByb3BlcnR5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYWRkUHJvcGVydHkoY3R4LCBuYW1lLCBnZXR0ZXIpIHtcbiAgZ2V0dGVyID0gZ2V0dGVyID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoKSB7fSA6IGdldHRlcjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBuYW1lLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiBwcm9wZXJ0eUdldHRlcigpIHtcbiAgICAgICAgLy8gU2V0dGluZyB0aGUgYHNzZmlgIGZsYWcgdG8gYHByb3BlcnR5R2V0dGVyYCBjYXVzZXMgdGhpcyBmdW5jdGlvbiB0b1xuICAgICAgICAvLyBiZSB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHJlbW92aW5nIGltcGxlbWVudGF0aW9uIGZyYW1lcyBmcm9tIHRoZVxuICAgICAgICAvLyBzdGFjayB0cmFjZSBvZiBhIGZhaWxlZCBhc3NlcnRpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byB1c2UgdGhpcyBmdW5jdGlvbiBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgaWZcbiAgICAgICAgLy8gdGhlIGBsb2NrU3NmaWAgZmxhZyBpc24ndCBzZXQgYW5kIHByb3h5IHByb3RlY3Rpb24gaXMgZGlzYWJsZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXMgc2V0LCB0aGVuIGVpdGhlciB0aGlzIGFzc2VydGlvbiBoYXMgYmVlblxuICAgICAgICAvLyBvdmVyd3JpdHRlbiBieSBhbm90aGVyIGFzc2VydGlvbiwgb3IgdGhpcyBhc3NlcnRpb24gaXMgYmVpbmcgaW52b2tlZFxuICAgICAgICAvLyBmcm9tIGluc2lkZSBvZiBhbm90aGVyIGFzc2VydGlvbi4gSW4gdGhlIGZpcnN0IGNhc2UsIHRoZSBgc3NmaWAgZmxhZ1xuICAgICAgICAvLyBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3ZlcndyaXRpbmcgYXNzZXJ0aW9uLiBJbiB0aGUgc2Vjb25kXG4gICAgICAgIC8vIGNhc2UsIHRoZSBgc3NmaWAgZmxhZyBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3V0ZXIgYXNzZXJ0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiBwcm94eSBwcm90ZWN0aW9uIGlzIGVuYWJsZWQsIHRoZW4gdGhlIGBzc2ZpYCBmbGFnIGhhcyBhbHJlYWR5IGJlZW5cbiAgICAgICAgLy8gc2V0IGJ5IHRoZSBwcm94eSBnZXR0ZXIuXG4gICAgICAgIGlmICghaXNQcm94eUVuYWJsZWQoKSAmJiAhZmxhZyh0aGlzLCAnbG9ja1NzZmknKSkge1xuICAgICAgICAgIGZsYWcodGhpcywgJ3NzZmknLCBwcm9wZXJ0eUdldHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgY2hhaS5Bc3NlcnRpb24oKTtcbiAgICAgICAgdHJhbnNmZXJGbGFncyh0aGlzLCBuZXdBc3NlcnRpb24pO1xuICAgICAgICByZXR1cm4gbmV3QXNzZXJ0aW9uO1xuICAgICAgfVxuICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufTtcbiIsInZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcblxudmFyIGZuTGVuZ3RoRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZnVuY3Rpb24gKCkge30sICdsZW5ndGgnKTtcblxuLyohXG4gKiBDaGFpIC0gYWRkTGVuZ3RoR3VhcmQgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5hZGRMZW5ndGhHdWFyZChmbiwgYXNzZXJ0aW9uTmFtZSwgaXNDaGFpbmFibGUpXG4gKlxuICogRGVmaW5lIGBsZW5ndGhgIGFzIGEgZ2V0dGVyIG9uIHRoZSBnaXZlbiB1bmludm9rZWQgbWV0aG9kIGFzc2VydGlvbi4gVGhlXG4gKiBnZXR0ZXIgYWN0cyBhcyBhIGd1YXJkIGFnYWluc3QgY2hhaW5pbmcgYGxlbmd0aGAgZGlyZWN0bHkgb2ZmIG9mIGFuIHVuaW52b2tlZFxuICogbWV0aG9kIGFzc2VydGlvbiwgd2hpY2ggaXMgYSBwcm9ibGVtIGJlY2F1c2UgaXQgcmVmZXJlbmNlcyBgZnVuY3Rpb25gJ3NcbiAqIGJ1aWx0LWluIGBsZW5ndGhgIHByb3BlcnR5IGluc3RlYWQgb2YgQ2hhaSdzIGBsZW5ndGhgIGFzc2VydGlvbi4gV2hlbiB0aGVcbiAqIGdldHRlciBjYXRjaGVzIHRoZSB1c2VyIG1ha2luZyB0aGlzIG1pc3Rha2UsIGl0IHRocm93cyBhbiBlcnJvciB3aXRoIGFcbiAqIGhlbHBmdWwgbWVzc2FnZS5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIHdheXMgaW4gd2hpY2ggdGhpcyBtaXN0YWtlIGNhbiBiZSBtYWRlLiBUaGUgZmlyc3Qgd2F5IGlzIGJ5XG4gKiBjaGFpbmluZyB0aGUgYGxlbmd0aGAgYXNzZXJ0aW9uIGRpcmVjdGx5IG9mZiBvZiBhbiB1bmludm9rZWQgY2hhaW5hYmxlXG4gKiBtZXRob2QuIEluIHRoaXMgY2FzZSwgQ2hhaSBzdWdnZXN0cyB0aGF0IHRoZSB1c2VyIHVzZSBgbGVuZ3RoT2ZgIGluc3RlYWQuIFRoZVxuICogc2Vjb25kIHdheSBpcyBieSBjaGFpbmluZyB0aGUgYGxlbmd0aGAgYXNzZXJ0aW9uIGRpcmVjdGx5IG9mZiBvZiBhbiB1bmludm9rZWRcbiAqIG5vbi1jaGFpbmFibGUgbWV0aG9kLiBOb24tY2hhaW5hYmxlIG1ldGhvZHMgbXVzdCBiZSBpbnZva2VkIHByaW9yIHRvXG4gKiBjaGFpbmluZy4gSW4gdGhpcyBjYXNlLCBDaGFpIHN1Z2dlc3RzIHRoYXQgdGhlIHVzZXIgY29uc3VsdCB0aGUgZG9jcyBmb3IgdGhlXG4gKiBnaXZlbiBhc3NlcnRpb24uXG4gKlxuICogSWYgdGhlIGBsZW5ndGhgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyB1bmNvbmZpZ3VyYWJsZSwgdGhlbiByZXR1cm4gYGZuYFxuICogd2l0aG91dCBtb2RpZmljYXRpb24uXG4gKlxuICogTm90ZSB0aGF0IGluIEVTNiwgdGhlIGZ1bmN0aW9uJ3MgYGxlbmd0aGAgcHJvcGVydHkgaXMgY29uZmlndXJhYmxlLCBzbyBvbmNlXG4gKiBzdXBwb3J0IGZvciBsZWdhY3kgZW52aXJvbm1lbnRzIGlzIGRyb3BwZWQsIENoYWkncyBgbGVuZ3RoYCBwcm9wZXJ0eSBjYW5cbiAqIHJlcGxhY2UgdGhlIGJ1aWx0LWluIGZ1bmN0aW9uJ3MgYGxlbmd0aGAgcHJvcGVydHksIGFuZCB0aGlzIGxlbmd0aCBndWFyZCB3aWxsXG4gKiBubyBsb25nZXIgYmUgbmVjZXNzYXJ5LiBJbiB0aGUgbWVhbiB0aW1lLCBtYWludGFpbmluZyBjb25zaXN0ZW5jeSBhY3Jvc3MgYWxsXG4gKiBlbnZpcm9ubWVudHMgaXMgdGhlIHByaW9yaXR5LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge1N0cmluZ30gYXNzZXJ0aW9uTmFtZVxuICogQHBhcmFtIHtCb29sZWFufSBpc0NoYWluYWJsZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgYWRkTGVuZ3RoR3VhcmRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFkZExlbmd0aEd1YXJkIChmbiwgYXNzZXJ0aW9uTmFtZSwgaXNDaGFpbmFibGUpIHtcbiAgaWYgKCFmbkxlbmd0aERlc2MuY29uZmlndXJhYmxlKSByZXR1cm4gZm47XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnbGVuZ3RoJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQ2hhaW5hYmxlKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIENoYWkgcHJvcGVydHk6ICcgKyBhc3NlcnRpb25OYW1lICsgJy5sZW5ndGguIER1ZScgK1xuICAgICAgICAgICcgdG8gYSBjb21wYXRpYmlsaXR5IGlzc3VlLCBcImxlbmd0aFwiIGNhbm5vdCBkaXJlY3RseSBmb2xsb3cgXCInICtcbiAgICAgICAgICBhc3NlcnRpb25OYW1lICsgJ1wiLiBVc2UgXCInICsgYXNzZXJ0aW9uTmFtZSArICcubGVuZ3RoT2ZcIiBpbnN0ZWFkLicpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBDaGFpIHByb3BlcnR5OiAnICsgYXNzZXJ0aW9uTmFtZSArICcubGVuZ3RoLiBTZWUnICtcbiAgICAgICAgJyBkb2NzIGZvciBwcm9wZXIgdXNhZ2Ugb2YgXCInICsgYXNzZXJ0aW9uTmFtZSArICdcIi4nKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBmbjtcbn07XG4iLCJ2YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIGdldFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2dldFByb3BlcnRpZXMnKTtcbnZhciBpc1Byb3h5RW5hYmxlZCA9IHJlcXVpcmUoJy4vaXNQcm94eUVuYWJsZWQnKTtcblxuLyohXG4gKiBDaGFpIC0gcHJveGlmeSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLnByb3hpZnkob2JqZWN0KVxuICpcbiAqIFJldHVybiBhIHByb3h5IG9mIGdpdmVuIG9iamVjdCB0aGF0IHRocm93cyBhbiBlcnJvciB3aGVuIGEgbm9uLWV4aXN0ZW50XG4gKiBwcm9wZXJ0eSBpcyByZWFkLiBCeSBkZWZhdWx0LCB0aGUgcm9vdCBjYXVzZSBpcyBhc3N1bWVkIHRvIGJlIGEgbWlzc3BlbGxlZFxuICogcHJvcGVydHksIGFuZCB0aHVzIGFuIGF0dGVtcHQgaXMgbWFkZSB0byBvZmZlciBhIHJlYXNvbmFibGUgc3VnZ2VzdGlvbiBmcm9tXG4gKiB0aGUgbGlzdCBvZiBleGlzdGluZyBwcm9wZXJ0aWVzLiBIb3dldmVyLCBpZiBhIG5vbkNoYWluYWJsZU1ldGhvZE5hbWUgaXNcbiAqIHByb3ZpZGVkLCB0aGVuIHRoZSByb290IGNhdXNlIGlzIGluc3RlYWQgYSBmYWlsdXJlIHRvIGludm9rZSBhIG5vbi1jaGFpbmFibGVcbiAqIG1ldGhvZCBwcmlvciB0byByZWFkaW5nIHRoZSBub24tZXhpc3RlbnQgcHJvcGVydHkuXG4gKiBcbiAqIElmIHByb3hpZXMgYXJlIHVuc3VwcG9ydGVkIG9yIGRpc2FibGVkIHZpYSB0aGUgdXNlcidzIENoYWkgY29uZmlnLCB0aGVuXG4gKiByZXR1cm4gb2JqZWN0IHdpdGhvdXQgbW9kaWZpY2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBub25DaGFpbmFibGVNZXRob2ROYW1lXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBwcm94aWZ5XG4gKi9cblxudmFyIGJ1aWx0aW5zID0gWydfX2ZsYWdzJywgJ19fbWV0aG9kcycsICdfb2JqJywgJ2Fzc2VydCddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHByb3hpZnkob2JqLCBub25DaGFpbmFibGVNZXRob2ROYW1lKSB7XG4gIGlmICghaXNQcm94eUVuYWJsZWQoKSkgcmV0dXJuIG9iajtcblxuICByZXR1cm4gbmV3IFByb3h5KG9iaiwge1xuICAgIGdldDogZnVuY3Rpb24gcHJveHlHZXR0ZXIodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgICAgLy8gVGhpcyBjaGVjayBpcyBoZXJlIGJlY2F1c2Ugd2Ugc2hvdWxkIG5vdCB0aHJvdyBlcnJvcnMgb24gU3ltYm9sIHByb3BlcnRpZXNcbiAgICAgIC8vIHN1Y2ggYXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AuXG4gICAgICAvLyBUaGUgdmFsdWVzIGZvciB3aGljaCBhbiBlcnJvciBzaG91bGQgYmUgdGhyb3duIGNhbiBiZSBjb25maWd1cmVkIHVzaW5nXG4gICAgICAvLyB0aGUgYGNvbmZpZy5wcm94eUV4Y2x1ZGVkS2V5c2Agc2V0dGluZy5cbiAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgY29uZmlnLnByb3h5RXhjbHVkZWRLZXlzLmluZGV4T2YocHJvcGVydHkpID09PSAtMSAmJlxuICAgICAgICAgICFSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3BlcnR5KSkge1xuICAgICAgICAvLyBTcGVjaWFsIG1lc3NhZ2UgZm9yIGludmFsaWQgcHJvcGVydHkgYWNjZXNzIG9mIG5vbi1jaGFpbmFibGUgbWV0aG9kcy5cbiAgICAgICAgaWYgKG5vbkNoYWluYWJsZU1ldGhvZE5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBDaGFpIHByb3BlcnR5OiAnICsgbm9uQ2hhaW5hYmxlTWV0aG9kTmFtZSArICcuJyArXG4gICAgICAgICAgICBwcm9wZXJ0eSArICcuIFNlZSBkb2NzIGZvciBwcm9wZXIgdXNhZ2Ugb2YgXCInICtcbiAgICAgICAgICAgIG5vbkNoYWluYWJsZU1ldGhvZE5hbWUgKyAnXCIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3JkZXJlZFByb3BlcnRpZXMgPSBnZXRQcm9wZXJ0aWVzKHRhcmdldCkuZmlsdGVyKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgcmV0dXJuICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3BlcnR5KSAmJlxuICAgICAgICAgICAgYnVpbHRpbnMuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xO1xuICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nRGlzdGFuY2UocHJvcGVydHksIGEpIC0gc3RyaW5nRGlzdGFuY2UocHJvcGVydHksIGIpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAob3JkZXJlZFByb3BlcnRpZXMubGVuZ3RoICYmXG4gICAgICAgICAgICBzdHJpbmdEaXN0YW5jZShvcmRlcmVkUHJvcGVydGllc1swXSwgcHJvcGVydHkpIDwgNCkge1xuICAgICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBpcyByZWFzb25hYmx5IGNsb3NlIHRvIGFuIGV4aXN0aW5nIENoYWkgcHJvcGVydHksXG4gICAgICAgICAgLy8gc3VnZ2VzdCB0aGF0IHByb3BlcnR5IHRvIHRoZSB1c2VyLlxuICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIENoYWkgcHJvcGVydHk6ICcgKyBwcm9wZXJ0eSArXG4gICAgICAgICAgICAnLiBEaWQgeW91IG1lYW4gXCInICsgb3JkZXJlZFByb3BlcnRpZXNbMF0gKyAnXCI/Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgQ2hhaSBwcm9wZXJ0eTogJyArIHByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVc2UgdGhpcyBwcm94eSBnZXR0ZXIgYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciByZW1vdmluZyBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gZnJhbWVzIGZyb20gdGhlIHN0YWNrIHRyYWNlIG9mIGEgZmFpbGVkIGFzc2VydGlvbi4gRm9yIHByb3BlcnR5XG4gICAgICAvLyBhc3NlcnRpb25zLCB0aGlzIHByZXZlbnRzIHRoZSBwcm94eSBnZXR0ZXIgZnJvbSBzaG93aW5nIHVwIGluIHRoZSBzdGFja1xuICAgICAgLy8gdHJhY2Ugc2luY2UgaXQncyBpbnZva2VkIGJlZm9yZSB0aGUgcHJvcGVydHkgZ2V0dGVyLiBGb3IgbWV0aG9kIGFuZFxuICAgICAgLy8gY2hhaW5hYmxlIG1ldGhvZCBhc3NlcnRpb25zLCB0aGlzIGZsYWcgd2lsbCBlbmQgdXAgZ2V0dGluZyBjaGFuZ2VkIHRvXG4gICAgICAvLyB0aGUgbWV0aG9kIHdyYXBwZXIsIHdoaWNoIGlzIGdvb2Qgc2luY2UgdGhpcyBmcmFtZSB3aWxsIG5vIGxvbmdlciBiZSBpblxuICAgICAgLy8gdGhlIHN0YWNrIG9uY2UgdGhlIG1ldGhvZCBpcyBpbnZva2VkLiBOb3RlIHRoYXQgQ2hhaSBidWlsdGluIGFzc2VydGlvblxuICAgICAgLy8gcHJvcGVydGllcyBzdWNoIGFzIGBfX2ZsYWdzYCBhcmUgc2tpcHBlZCBzaW5jZSB0aGlzIGlzIG9ubHkgbWVhbnQgdG9cbiAgICAgIC8vIGNhcHR1cmUgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIGFuIGFzc2VydGlvbi4gVGhpcyBzdGVwIGlzIGFsc28gc2tpcHBlZFxuICAgICAgLy8gaWYgdGhlIGBsb2NrU3NmaWAgZmxhZyBpcyBzZXQsIHRodXMgaW5kaWNhdGluZyB0aGF0IHRoaXMgYXNzZXJ0aW9uIGlzXG4gICAgICAvLyBiZWluZyBjYWxsZWQgZnJvbSB3aXRoaW4gYW5vdGhlciBhc3NlcnRpb24uIEluIHRoYXQgY2FzZSwgdGhlIGBzc2ZpYFxuICAgICAgLy8gZmxhZyBpcyBhbHJlYWR5IHNldCB0byB0aGUgb3V0ZXIgYXNzZXJ0aW9uJ3Mgc3RhcnRpbmcgcG9pbnQuXG4gICAgICBpZiAoYnVpbHRpbnMuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xICYmICFmbGFnKHRhcmdldCwgJ2xvY2tTc2ZpJykpIHtcbiAgICAgICAgZmxhZyh0YXJnZXQsICdzc2ZpJywgcHJveHlHZXR0ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogIyBzdHJpbmdEaXN0YW5jZShzdHJBLCBzdHJCKVxuICogUmV0dXJuIHRoZSBMZXZlbnNodGVpbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byBzdHJpbmdzLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ckFcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJCXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBzdHJpbmcgZGlzdGFuY2UgYmV0d2VlbiBzdHJBIGFuZCBzdHJCXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdEaXN0YW5jZShzdHJBLCBzdHJCLCBtZW1vKSB7XG4gIGlmICghbWVtbykge1xuICAgIC8vIGBtZW1vYCBpcyBhIHR3by1kaW1lbnNpb25hbCBhcnJheSBjb250YWluaW5nIGEgY2FjaGUgb2YgZGlzdGFuY2VzXG4gICAgLy8gbWVtb1tpXVtqXSBpcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiBzdHJBLnNsaWNlKDAsIGkpIGFuZFxuICAgIC8vIHN0ckIuc2xpY2UoMCwgaikuXG4gICAgbWVtbyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHN0ckEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1lbW9baV0gPSBbXTtcbiAgICB9XG4gIH1cblxuICBpZiAoIW1lbW9bc3RyQS5sZW5ndGhdIHx8ICFtZW1vW3N0ckEubGVuZ3RoXVtzdHJCLmxlbmd0aF0pIHtcbiAgICBpZiAoc3RyQS5sZW5ndGggPT09IDAgfHwgc3RyQi5sZW5ndGggPT09IDApIHtcbiAgICAgIG1lbW9bc3RyQS5sZW5ndGhdW3N0ckIubGVuZ3RoXSA9IE1hdGgubWF4KHN0ckEubGVuZ3RoLCBzdHJCLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lbW9bc3RyQS5sZW5ndGhdW3N0ckIubGVuZ3RoXSA9IE1hdGgubWluKFxuICAgICAgICBzdHJpbmdEaXN0YW5jZShzdHJBLnNsaWNlKDAsIC0xKSwgc3RyQiwgbWVtbykgKyAxLFxuICAgICAgICBzdHJpbmdEaXN0YW5jZShzdHJBLCBzdHJCLnNsaWNlKDAsIC0xKSwgbWVtbykgKyAxLFxuICAgICAgICBzdHJpbmdEaXN0YW5jZShzdHJBLnNsaWNlKDAsIC0xKSwgc3RyQi5zbGljZSgwLCAtMSksIG1lbW8pICtcbiAgICAgICAgICAoc3RyQS5zbGljZSgtMSkgPT09IHN0ckIuc2xpY2UoLTEpID8gMCA6IDEpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZW1vW3N0ckEubGVuZ3RoXVtzdHJCLmxlbmd0aF07XG59XG4iLCIvKiFcbiAqIENoYWkgLSBhZGRNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBhZGRMZW5ndGhHdWFyZCA9IHJlcXVpcmUoJy4vYWRkTGVuZ3RoR3VhcmQnKTtcbnZhciBjaGFpID0gcmVxdWlyZSgnLi4vLi4vY2hhaScpO1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcbnZhciBwcm94aWZ5ID0gcmVxdWlyZSgnLi9wcm94aWZ5Jyk7XG52YXIgdHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKipcbiAqICMjIyAuYWRkTWV0aG9kKGN0eCwgbmFtZSwgbWV0aG9kKVxuICpcbiAqIEFkZHMgYSBtZXRob2QgdG8gdGhlIHByb3RvdHlwZSBvZiBhbiBvYmplY3QuXG4gKlxuICogICAgIHV0aWxzLmFkZE1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdmb28nLCBmdW5jdGlvbiAoc3RyKSB7XG4gKiAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqKS50by5iZS5lcXVhbChzdHIpO1xuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24uYWRkTWV0aG9kKCdmb28nLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QoZm9vU3RyKS50by5iZS5mb28oJ2JhcicpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHRvIHdoaWNoIHRoZSBtZXRob2QgaXMgYWRkZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIG1ldGhvZCB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBhZGRNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhZGRNZXRob2QoY3R4LCBuYW1lLCBtZXRob2QpIHtcbiAgdmFyIG1ldGhvZFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2V0dGluZyB0aGUgYHNzZmlgIGZsYWcgdG8gYG1ldGhvZFdyYXBwZXJgIGNhdXNlcyB0aGlzIGZ1bmN0aW9uIHRvIGJlIHRoZVxuICAgIC8vIHN0YXJ0aW5nIHBvaW50IGZvciByZW1vdmluZyBpbXBsZW1lbnRhdGlvbiBmcmFtZXMgZnJvbSB0aGUgc3RhY2sgdHJhY2Ugb2ZcbiAgICAvLyBhIGZhaWxlZCBhc3NlcnRpb24uXG4gICAgLy9cbiAgICAvLyBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24gYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGlmIHRoZVxuICAgIC8vIGBsb2NrU3NmaWAgZmxhZyBpc24ndCBzZXQuXG4gICAgLy9cbiAgICAvLyBJZiB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzIHNldCwgdGhlbiBlaXRoZXIgdGhpcyBhc3NlcnRpb24gaGFzIGJlZW5cbiAgICAvLyBvdmVyd3JpdHRlbiBieSBhbm90aGVyIGFzc2VydGlvbiwgb3IgdGhpcyBhc3NlcnRpb24gaXMgYmVpbmcgaW52b2tlZCBmcm9tXG4gICAgLy8gaW5zaWRlIG9mIGFub3RoZXIgYXNzZXJ0aW9uLiBJbiB0aGUgZmlyc3QgY2FzZSwgdGhlIGBzc2ZpYCBmbGFnIGhhc1xuICAgIC8vIGFscmVhZHkgYmVlbiBzZXQgYnkgdGhlIG92ZXJ3cml0aW5nIGFzc2VydGlvbi4gSW4gdGhlIHNlY29uZCBjYXNlLCB0aGVcbiAgICAvLyBgc3NmaWAgZmxhZyBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3V0ZXIgYXNzZXJ0aW9uLlxuICAgIGlmICghZmxhZyh0aGlzLCAnbG9ja1NzZmknKSkge1xuICAgICAgZmxhZyh0aGlzLCAnc3NmaScsIG1ldGhvZFdyYXBwZXIpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgdmFyIG5ld0Fzc2VydGlvbiA9IG5ldyBjaGFpLkFzc2VydGlvbigpO1xuICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgbmV3QXNzZXJ0aW9uKTtcbiAgICByZXR1cm4gbmV3QXNzZXJ0aW9uO1xuICB9O1xuXG4gIGFkZExlbmd0aEd1YXJkKG1ldGhvZFdyYXBwZXIsIG5hbWUsIGZhbHNlKTtcbiAgY3R4W25hbWVdID0gcHJveGlmeShtZXRob2RXcmFwcGVyLCBuYW1lKTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBvdmVyd3JpdGVQcm9wZXJ0eSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGNoYWkgPSByZXF1aXJlKCcuLi8uLi9jaGFpJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIGlzUHJveHlFbmFibGVkID0gcmVxdWlyZSgnLi9pc1Byb3h5RW5hYmxlZCcpO1xudmFyIHRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcblxuLyoqXG4gKiAjIyMgLm92ZXJ3cml0ZVByb3BlcnR5KGN0eCwgbmFtZSwgZm4pXG4gKlxuICogT3ZlcndpdGVzIGFuIGFscmVhZHkgZXhpc3RpbmcgcHJvcGVydHkgZ2V0dGVyIGFuZCBwcm92aWRlc1xuICogYWNjZXNzIHRvIHByZXZpb3VzIHZhbHVlLiBNdXN0IHJldHVybiBmdW5jdGlvbiB0byB1c2UgYXMgZ2V0dGVyLlxuICpcbiAqICAgICB1dGlscy5vdmVyd3JpdGVQcm9wZXJ0eShjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdvaycsIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEZvbykge1xuICogICAgICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmoubmFtZSkudG8uZXF1YWwoJ2JhcicpO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlUHJvcGVydHkoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uYmUub2s7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgaXMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHByb3BlcnR5IHRvIG92ZXJ3cml0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGdldHRlciBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBvdmVyd3JpdGVQcm9wZXJ0eVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG92ZXJ3cml0ZVByb3BlcnR5KGN0eCwgbmFtZSwgZ2V0dGVyKSB7XG4gIHZhciBfZ2V0ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdHgsIG5hbWUpXG4gICAgLCBfc3VwZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBpZiAoX2dldCAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgX2dldC5nZXQpXG4gICAgX3N1cGVyID0gX2dldC5nZXRcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBuYW1lLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiBvdmVyd3JpdGluZ1Byb3BlcnR5R2V0dGVyKCkge1xuICAgICAgICAvLyBTZXR0aW5nIHRoZSBgc3NmaWAgZmxhZyB0byBgb3ZlcndyaXRpbmdQcm9wZXJ0eUdldHRlcmAgY2F1c2VzIHRoaXNcbiAgICAgICAgLy8gZnVuY3Rpb24gdG8gYmUgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciByZW1vdmluZyBpbXBsZW1lbnRhdGlvbiBmcmFtZXNcbiAgICAgICAgLy8gZnJvbSB0aGUgc3RhY2sgdHJhY2Ugb2YgYSBmYWlsZWQgYXNzZXJ0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24gYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGlmXG4gICAgICAgIC8vIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXNuJ3Qgc2V0IGFuZCBwcm94eSBwcm90ZWN0aW9uIGlzIGRpc2FibGVkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzIHNldCwgdGhlbiBlaXRoZXIgdGhpcyBhc3NlcnRpb24gaGFzIGJlZW5cbiAgICAgICAgLy8gb3ZlcndyaXR0ZW4gYnkgYW5vdGhlciBhc3NlcnRpb24sIG9yIHRoaXMgYXNzZXJ0aW9uIGlzIGJlaW5nIGludm9rZWRcbiAgICAgICAgLy8gZnJvbSBpbnNpZGUgb2YgYW5vdGhlciBhc3NlcnRpb24uIEluIHRoZSBmaXJzdCBjYXNlLCB0aGUgYHNzZmlgIGZsYWdcbiAgICAgICAgLy8gaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgdGhlIG92ZXJ3cml0aW5nIGFzc2VydGlvbi4gSW4gdGhlIHNlY29uZFxuICAgICAgICAvLyBjYXNlLCB0aGUgYHNzZmlgIGZsYWcgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgdGhlIG91dGVyIGFzc2VydGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgcHJveHkgcHJvdGVjdGlvbiBpcyBlbmFibGVkLCB0aGVuIHRoZSBgc3NmaWAgZmxhZyBoYXMgYWxyZWFkeSBiZWVuXG4gICAgICAgIC8vIHNldCBieSB0aGUgcHJveHkgZ2V0dGVyLlxuICAgICAgICBpZiAoIWlzUHJveHlFbmFibGVkKCkgJiYgIWZsYWcodGhpcywgJ2xvY2tTc2ZpJykpIHtcbiAgICAgICAgICBmbGFnKHRoaXMsICdzc2ZpJywgb3ZlcndyaXRpbmdQcm9wZXJ0eUdldHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXR0aW5nIHRoZSBgbG9ja1NzZmlgIGZsYWcgdG8gYHRydWVgIHByZXZlbnRzIHRoZSBvdmVyd3JpdHRlblxuICAgICAgICAvLyBhc3NlcnRpb24gZnJvbSBjaGFuZ2luZyB0aGUgYHNzZmlgIGZsYWcuIEJ5IHRoaXMgcG9pbnQsIHRoZSBgc3NmaWBcbiAgICAgICAgLy8gZmxhZyBpcyBhbHJlYWR5IHNldCB0byB0aGUgY29ycmVjdCBzdGFydGluZyBwb2ludCBmb3IgdGhpcyBhc3NlcnRpb24uXG4gICAgICAgIHZhciBvcmlnTG9ja1NzZmkgPSBmbGFnKHRoaXMsICdsb2NrU3NmaScpO1xuICAgICAgICBmbGFnKHRoaXMsICdsb2NrU3NmaScsIHRydWUpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0dGVyKF9zdXBlcikuY2FsbCh0aGlzKTtcbiAgICAgICAgZmxhZyh0aGlzLCAnbG9ja1NzZmknLCBvcmlnTG9ja1NzZmkpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IGNoYWkuQXNzZXJ0aW9uKCk7XG4gICAgICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgbmV3QXNzZXJ0aW9uKTtcbiAgICAgICAgcmV0dXJuIG5ld0Fzc2VydGlvbjtcbiAgICAgIH1cbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBvdmVyd3JpdGVNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBhZGRMZW5ndGhHdWFyZCA9IHJlcXVpcmUoJy4vYWRkTGVuZ3RoR3VhcmQnKTtcbnZhciBjaGFpID0gcmVxdWlyZSgnLi4vLi4vY2hhaScpO1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcbnZhciBwcm94aWZ5ID0gcmVxdWlyZSgnLi9wcm94aWZ5Jyk7XG52YXIgdHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKipcbiAqICMjIyAub3ZlcndyaXRlTWV0aG9kKGN0eCwgbmFtZSwgZm4pXG4gKlxuICogT3ZlcndpdGVzIGFuIGFscmVhZHkgZXhpc3RpbmcgbWV0aG9kIGFuZCBwcm92aWRlc1xuICogYWNjZXNzIHRvIHByZXZpb3VzIGZ1bmN0aW9uLiBNdXN0IHJldHVybiBmdW5jdGlvblxuICogdG8gYmUgdXNlZCBmb3IgbmFtZS5cbiAqXG4gKiAgICAgdXRpbHMub3ZlcndyaXRlTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2VxdWFsJywgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHtcbiAqICAgICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgRm9vKSB7XG4gKiAgICAgICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iai52YWx1ZSkudG8uZXF1YWwoc3RyKTtcbiAqICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAqICAgICAgICAgfVxuICogICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdmb28nLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmVxdWFsKCdiYXInKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB3aG9zZSBtZXRob2QgaXMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIG1ldGhvZCB0byBvdmVyd3JpdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBvdmVyd3JpdGVNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBvdmVyd3JpdGVNZXRob2QoY3R4LCBuYW1lLCBtZXRob2QpIHtcbiAgdmFyIF9tZXRob2QgPSBjdHhbbmFtZV1cbiAgICAsIF9zdXBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgIH07XG5cbiAgaWYgKF9tZXRob2QgJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIF9tZXRob2QpXG4gICAgX3N1cGVyID0gX21ldGhvZDtcblxuICB2YXIgb3ZlcndyaXRpbmdNZXRob2RXcmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFNldHRpbmcgdGhlIGBzc2ZpYCBmbGFnIHRvIGBvdmVyd3JpdGluZ01ldGhvZFdyYXBwZXJgIGNhdXNlcyB0aGlzXG4gICAgLy8gZnVuY3Rpb24gdG8gYmUgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciByZW1vdmluZyBpbXBsZW1lbnRhdGlvbiBmcmFtZXMgZnJvbVxuICAgIC8vIHRoZSBzdGFjayB0cmFjZSBvZiBhIGZhaWxlZCBhc3NlcnRpb24uXG4gICAgLy9cbiAgICAvLyBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24gYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGlmIHRoZVxuICAgIC8vIGBsb2NrU3NmaWAgZmxhZyBpc24ndCBzZXQuXG4gICAgLy9cbiAgICAvLyBJZiB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzIHNldCwgdGhlbiBlaXRoZXIgdGhpcyBhc3NlcnRpb24gaGFzIGJlZW5cbiAgICAvLyBvdmVyd3JpdHRlbiBieSBhbm90aGVyIGFzc2VydGlvbiwgb3IgdGhpcyBhc3NlcnRpb24gaXMgYmVpbmcgaW52b2tlZCBmcm9tXG4gICAgLy8gaW5zaWRlIG9mIGFub3RoZXIgYXNzZXJ0aW9uLiBJbiB0aGUgZmlyc3QgY2FzZSwgdGhlIGBzc2ZpYCBmbGFnIGhhc1xuICAgIC8vIGFscmVhZHkgYmVlbiBzZXQgYnkgdGhlIG92ZXJ3cml0aW5nIGFzc2VydGlvbi4gSW4gdGhlIHNlY29uZCBjYXNlLCB0aGVcbiAgICAvLyBgc3NmaWAgZmxhZyBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3V0ZXIgYXNzZXJ0aW9uLlxuICAgIGlmICghZmxhZyh0aGlzLCAnbG9ja1NzZmknKSkge1xuICAgICAgZmxhZyh0aGlzLCAnc3NmaScsIG92ZXJ3cml0aW5nTWV0aG9kV3JhcHBlcik7XG4gICAgfVxuXG4gICAgLy8gU2V0dGluZyB0aGUgYGxvY2tTc2ZpYCBmbGFnIHRvIGB0cnVlYCBwcmV2ZW50cyB0aGUgb3ZlcndyaXR0ZW4gYXNzZXJ0aW9uXG4gICAgLy8gZnJvbSBjaGFuZ2luZyB0aGUgYHNzZmlgIGZsYWcuIEJ5IHRoaXMgcG9pbnQsIHRoZSBgc3NmaWAgZmxhZyBpcyBhbHJlYWR5XG4gICAgLy8gc2V0IHRvIHRoZSBjb3JyZWN0IHN0YXJ0aW5nIHBvaW50IGZvciB0aGlzIGFzc2VydGlvbi5cbiAgICB2YXIgb3JpZ0xvY2tTc2ZpID0gZmxhZyh0aGlzLCAnbG9ja1NzZmknKTtcbiAgICBmbGFnKHRoaXMsICdsb2NrU3NmaScsIHRydWUpO1xuICAgIHZhciByZXN1bHQgPSBtZXRob2QoX3N1cGVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZsYWcodGhpcywgJ2xvY2tTc2ZpJywgb3JpZ0xvY2tTc2ZpKTtcblxuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IGNoYWkuQXNzZXJ0aW9uKCk7XG4gICAgdHJhbnNmZXJGbGFncyh0aGlzLCBuZXdBc3NlcnRpb24pO1xuICAgIHJldHVybiBuZXdBc3NlcnRpb247XG4gIH1cblxuICBhZGRMZW5ndGhHdWFyZChvdmVyd3JpdGluZ01ldGhvZFdyYXBwZXIsIG5hbWUsIGZhbHNlKTtcbiAgY3R4W25hbWVdID0gcHJveGlmeShvdmVyd3JpdGluZ01ldGhvZFdyYXBwZXIsIG5hbWUpO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGFkZENoYWluaW5nTWV0aG9kIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgYWRkTGVuZ3RoR3VhcmQgPSByZXF1aXJlKCcuL2FkZExlbmd0aEd1YXJkJyk7XG52YXIgY2hhaSA9IHJlcXVpcmUoJy4uLy4uL2NoYWknKTtcbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG52YXIgcHJveGlmeSA9IHJlcXVpcmUoJy4vcHJveGlmeScpO1xudmFyIHRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcblxuLyohXG4gKiBNb2R1bGUgdmFyaWFibGVzXG4gKi9cblxuLy8gQ2hlY2sgd2hldGhlciBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBpcyBzdXBwb3J0ZWRcbnZhciBjYW5TZXRQcm90b3R5cGUgPSB0eXBlb2YgT2JqZWN0LnNldFByb3RvdHlwZU9mID09PSAnZnVuY3Rpb24nO1xuXG4vLyBXaXRob3V0IGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIHN1cHBvcnQsIHRoaXMgbW9kdWxlIHdpbGwgbmVlZCB0byBhZGQgcHJvcGVydGllcyB0byBhIGZ1bmN0aW9uLlxuLy8gSG93ZXZlciwgc29tZSBvZiBmdW5jdGlvbnMnIG93biBwcm9wcyBhcmUgbm90IGNvbmZpZ3VyYWJsZSBhbmQgc2hvdWxkIGJlIHNraXBwZWQuXG52YXIgdGVzdEZuID0gZnVuY3Rpb24oKSB7fTtcbnZhciBleGNsdWRlTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0Rm4pLmZpbHRlcihmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBwcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGVzdEZuLCBuYW1lKTtcblxuICAvLyBOb3RlOiBQaGFudG9tSlMgMS54IGluY2x1ZGVzIGBjYWxsZWVgIGFzIG9uZSBvZiBgdGVzdEZuYCdzIG93biBwcm9wZXJ0aWVzLFxuICAvLyBidXQgdGhlbiByZXR1cm5zIGB1bmRlZmluZWRgIGFzIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciBgY2FsbGVlYC4gQXMgYVxuICAvLyB3b3JrYXJvdW5kLCB3ZSBwZXJmb3JtIGFuIG90aGVyd2lzZSB1bm5lY2Vzc2FyeSB0eXBlLWNoZWNrIGZvciBgcHJvcERlc2NgLFxuICAvLyBhbmQgdGhlbiBmaWx0ZXIgaXQgb3V0IGlmIGl0J3Mgbm90IGFuIG9iamVjdCBhcyBpdCBzaG91bGQgYmUuXG4gIGlmICh0eXBlb2YgcHJvcERlc2MgIT09ICdvYmplY3QnKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHJldHVybiAhcHJvcERlc2MuY29uZmlndXJhYmxlO1xufSk7XG5cbi8vIENhY2hlIGBGdW5jdGlvbmAgcHJvcGVydGllc1xudmFyIGNhbGwgID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwsXG4gICAgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8qKlxuICogIyMjIC5hZGRDaGFpbmFibGVNZXRob2QoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpXG4gKlxuICogQWRkcyBhIG1ldGhvZCB0byBhbiBvYmplY3QsIHN1Y2ggdGhhdCB0aGUgbWV0aG9kIGNhbiBhbHNvIGJlIGNoYWluZWQuXG4gKlxuICogICAgIHV0aWxzLmFkZENoYWluYWJsZU1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdmb28nLCBmdW5jdGlvbiAoc3RyKSB7XG4gKiAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqKS50by5iZS5lcXVhbChzdHIpO1xuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdmb28nLCBmbiwgY2hhaW5pbmdCZWhhdmlvcik7XG4gKlxuICogVGhlIHJlc3VsdCBjYW4gdGhlbiBiZSB1c2VkIGFzIGJvdGggYSBtZXRob2QgYXNzZXJ0aW9uLCBleGVjdXRpbmcgYm90aCBgbWV0aG9kYCBhbmRcbiAqIGBjaGFpbmluZ0JlaGF2aW9yYCwgb3IgYXMgYSBsYW5ndWFnZSBjaGFpbiwgd2hpY2ggb25seSBleGVjdXRlcyBgY2hhaW5pbmdCZWhhdmlvcmAuXG4gKlxuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvbygnYmFyJyk7XG4gKiAgICAgZXhwZWN0KGZvb1N0cikudG8uYmUuZm9vLmVxdWFsKCdmb28nKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB0byB3aGljaCB0aGUgbWV0aG9kIGlzIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgdG8gYWRkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgYG5hbWVgLCB3aGVuIGNhbGxlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hhaW5pbmdCZWhhdmlvciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWRcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGFkZENoYWluYWJsZU1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFkZENoYWluYWJsZU1ldGhvZChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcikge1xuICBpZiAodHlwZW9mIGNoYWluaW5nQmVoYXZpb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGFpbmluZ0JlaGF2aW9yID0gZnVuY3Rpb24gKCkgeyB9O1xuICB9XG5cbiAgdmFyIGNoYWluYWJsZUJlaGF2aW9yID0ge1xuICAgICAgbWV0aG9kOiBtZXRob2RcbiAgICAsIGNoYWluaW5nQmVoYXZpb3I6IGNoYWluaW5nQmVoYXZpb3JcbiAgfTtcblxuICAvLyBzYXZlIHRoZSBtZXRob2RzIHNvIHdlIGNhbiBvdmVyd3JpdGUgdGhlbSBsYXRlciwgaWYgd2UgbmVlZCB0by5cbiAgaWYgKCFjdHguX19tZXRob2RzKSB7XG4gICAgY3R4Ll9fbWV0aG9kcyA9IHt9O1xuICB9XG4gIGN0eC5fX21ldGhvZHNbbmFtZV0gPSBjaGFpbmFibGVCZWhhdmlvcjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBuYW1lLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiBjaGFpbmFibGVNZXRob2RHZXR0ZXIoKSB7XG4gICAgICAgIGNoYWluYWJsZUJlaGF2aW9yLmNoYWluaW5nQmVoYXZpb3IuY2FsbCh0aGlzKTtcblxuICAgICAgICB2YXIgY2hhaW5hYmxlTWV0aG9kV3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIHRoZSBgc3NmaWAgZmxhZyB0byBgY2hhaW5hYmxlTWV0aG9kV3JhcHBlcmAgY2F1c2VzIHRoaXNcbiAgICAgICAgICAvLyBmdW5jdGlvbiB0byBiZSB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHJlbW92aW5nIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgLy8gZnJhbWVzIGZyb20gdGhlIHN0YWNrIHRyYWNlIG9mIGEgZmFpbGVkIGFzc2VydGlvbi5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byB1c2UgdGhpcyBmdW5jdGlvbiBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgaWZcbiAgICAgICAgICAvLyB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzbid0IHNldC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElmIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXMgc2V0LCB0aGVuIHRoaXMgYXNzZXJ0aW9uIGlzIGJlaW5nXG4gICAgICAgICAgLy8gaW52b2tlZCBmcm9tIGluc2lkZSBvZiBhbm90aGVyIGFzc2VydGlvbi4gSW4gdGhpcyBjYXNlLCB0aGUgYHNzZmlgXG4gICAgICAgICAgLy8gZmxhZyBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3V0ZXIgYXNzZXJ0aW9uLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IG92ZXJ3cml0aW5nIGEgY2hhaW5hYmxlIG1ldGhvZCBtZXJlbHkgcmVwbGFjZXMgdGhlIHNhdmVkXG4gICAgICAgICAgLy8gbWV0aG9kcyBpbiBgY3R4Ll9fbWV0aG9kc2AgaW5zdGVhZCBvZiBjb21wbGV0ZWx5IHJlcGxhY2luZyB0aGVcbiAgICAgICAgICAvLyBvdmVyd3JpdHRlbiBhc3NlcnRpb24uIFRoZXJlZm9yZSwgYW4gb3ZlcndyaXRpbmcgYXNzZXJ0aW9uIHdvbid0XG4gICAgICAgICAgLy8gc2V0IHRoZSBgc3NmaWAgb3IgYGxvY2tTc2ZpYCBmbGFncy5cbiAgICAgICAgICBpZiAoIWZsYWcodGhpcywgJ2xvY2tTc2ZpJykpIHtcbiAgICAgICAgICAgIGZsYWcodGhpcywgJ3NzZmknLCBjaGFpbmFibGVNZXRob2RXcmFwcGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY2hhaW5hYmxlQmVoYXZpb3IubWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgY2hhaS5Bc3NlcnRpb24oKTtcbiAgICAgICAgICB0cmFuc2ZlckZsYWdzKHRoaXMsIG5ld0Fzc2VydGlvbik7XG4gICAgICAgICAgcmV0dXJuIG5ld0Fzc2VydGlvbjtcbiAgICAgICAgfTtcblxuICAgICAgICBhZGRMZW5ndGhHdWFyZChjaGFpbmFibGVNZXRob2RXcmFwcGVyLCBuYW1lLCB0cnVlKTtcblxuICAgICAgICAvLyBVc2UgYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChjYW5TZXRQcm90b3R5cGUpIHtcbiAgICAgICAgICAvLyBJbmhlcml0IGFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIG9iamVjdCBieSByZXBsYWNpbmcgdGhlIGBGdW5jdGlvbmAgcHJvdG90eXBlXG4gICAgICAgICAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgICAgICAgLy8gUmVzdG9yZSB0aGUgYGNhbGxgIGFuZCBgYXBwbHlgIG1ldGhvZHMgZnJvbSBgRnVuY3Rpb25gXG4gICAgICAgICAgcHJvdG90eXBlLmNhbGwgPSBjYWxsO1xuICAgICAgICAgIHByb3RvdHlwZS5hcHBseSA9IGFwcGx5O1xuICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihjaGFpbmFibGVNZXRob2RXcmFwcGVyLCBwcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgcmVkZWZpbmUgYWxsIHByb3BlcnRpZXMgKHNsb3chKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgYXNzZXJ0ZXJOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGN0eCk7XG4gICAgICAgICAgYXNzZXJ0ZXJOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChhc3NlcnRlck5hbWUpIHtcbiAgICAgICAgICAgIGlmIChleGNsdWRlTmFtZXMuaW5kZXhPZihhc3NlcnRlck5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY3R4LCBhc3NlcnRlck5hbWUpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoYWluYWJsZU1ldGhvZFdyYXBwZXIsIGFzc2VydGVyTmFtZSwgcGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNmZXJGbGFncyh0aGlzLCBjaGFpbmFibGVNZXRob2RXcmFwcGVyKTtcbiAgICAgICAgcmV0dXJuIHByb3hpZnkoY2hhaW5hYmxlTWV0aG9kV3JhcHBlcik7XG4gICAgICB9XG4gICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgY2hhaSA9IHJlcXVpcmUoJy4uLy4uL2NoYWknKTtcbnZhciB0cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG5cbi8qKlxuICogIyMjIC5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpXG4gKlxuICogT3ZlcndpdGVzIGFuIGFscmVhZHkgZXhpc3RpbmcgY2hhaW5hYmxlIG1ldGhvZFxuICogYW5kIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgcHJldmlvdXMgZnVuY3Rpb24gb3JcbiAqIHByb3BlcnR5LiAgTXVzdCByZXR1cm4gZnVuY3Rpb25zIHRvIGJlIHVzZWQgZm9yXG4gKiBuYW1lLlxuICpcbiAqICAgICB1dGlscy5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnbGVuZ3RoT2YnLFxuICogICAgICAgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgfVxuICogICAgICwgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgfVxuICogICAgICk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoJ2ZvbycsIGZuLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmhhdmUubGVuZ3RoT2YoMyk7XG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5oYXZlLmxlbmd0aE9mLmFib3ZlKDMpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHdob3NlIG1ldGhvZCAvIHByb3BlcnR5IGlzIHRvIGJlIG92ZXJ3cml0dGVuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgLyBwcm9wZXJ0eSB0byBvdmVyd3JpdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGFpbmluZ0JlaGF2aW9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIHByb3BlcnR5XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBvdmVyd3JpdGVDaGFpbmFibGVNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBvdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgdmFyIGNoYWluYWJsZUJlaGF2aW9yID0gY3R4Ll9fbWV0aG9kc1tuYW1lXTtcblxuICB2YXIgX2NoYWluaW5nQmVoYXZpb3IgPSBjaGFpbmFibGVCZWhhdmlvci5jaGFpbmluZ0JlaGF2aW9yO1xuICBjaGFpbmFibGVCZWhhdmlvci5jaGFpbmluZ0JlaGF2aW9yID0gZnVuY3Rpb24gb3ZlcndyaXRpbmdDaGFpbmFibGVNZXRob2RHZXR0ZXIoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNoYWluaW5nQmVoYXZpb3IoX2NoYWluaW5nQmVoYXZpb3IpLmNhbGwodGhpcyk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgY2hhaS5Bc3NlcnRpb24oKTtcbiAgICB0cmFuc2ZlckZsYWdzKHRoaXMsIG5ld0Fzc2VydGlvbik7XG4gICAgcmV0dXJuIG5ld0Fzc2VydGlvbjtcbiAgfTtcblxuICB2YXIgX21ldGhvZCA9IGNoYWluYWJsZUJlaGF2aW9yLm1ldGhvZDtcbiAgY2hhaW5hYmxlQmVoYXZpb3IubWV0aG9kID0gZnVuY3Rpb24gb3ZlcndyaXRpbmdDaGFpbmFibGVNZXRob2RXcmFwcGVyKCkge1xuICAgIHZhciByZXN1bHQgPSBtZXRob2QoX21ldGhvZCkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIG5ld0Fzc2VydGlvbiA9IG5ldyBjaGFpLkFzc2VydGlvbigpO1xuICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgbmV3QXNzZXJ0aW9uKTtcbiAgICByZXR1cm4gbmV3QXNzZXJ0aW9uO1xuICB9O1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGNvbXBhcmVCeUluc3BlY3QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNiBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGFuY2llc1xuICovXG5cbnZhciBpbnNwZWN0ID0gcmVxdWlyZSgnLi9pbnNwZWN0Jyk7XG5cbi8qKlxuICogIyMjIC5jb21wYXJlQnlJbnNwZWN0KG1peGVkLCBtaXhlZClcbiAqXG4gKiBUbyBiZSB1c2VkIGFzIGEgY29tcGFyZUZ1bmN0aW9uIHdpdGggQXJyYXkucHJvdG90eXBlLnNvcnQuIENvbXBhcmVzIGVsZW1lbnRzXG4gKiB1c2luZyBpbnNwZWN0IGluc3RlYWQgb2YgZGVmYXVsdCBiZWhhdmlvciBvZiB1c2luZyB0b1N0cmluZyBzbyB0aGF0IFN5bWJvbHNcbiAqIGFuZCBvYmplY3RzIHdpdGggaXJyZWd1bGFyL21pc3NpbmcgdG9TdHJpbmcgY2FuIHN0aWxsIGJlIHNvcnRlZCB3aXRob3V0IGFcbiAqIFR5cGVFcnJvci5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBmaXJzdCBlbGVtZW50IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7TWl4ZWR9IHNlY29uZCBlbGVtZW50IHRvIGNvbXBhcmVcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IC0xIGlmICdhJyBzaG91bGQgY29tZSBiZWZvcmUgJ2InOyBvdGhlcndpc2UgMSBcbiAqIEBuYW1lIGNvbXBhcmVCeUluc3BlY3RcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21wYXJlQnlJbnNwZWN0KGEsIGIpIHtcbiAgcmV0dXJuIGluc3BlY3QoYSkgPCBpbnNwZWN0KGIpID8gLTEgOiAxO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNiBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5nZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzKG9iamVjdClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIGRpcmVjdGx5LW93bmVkIGVudW1lcmFibGUgcHJvcGVydHkgc3ltYm9scyBvZiBhblxuICogb2JqZWN0LiBUaGlzIGZ1bmN0aW9uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbiAqIHJldHVybnMgYm90aCBlbnVtZXJhYmxlIGFuZCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBzeW1ib2xzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzKG9iaikge1xuICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHJldHVybiBbXTtcblxuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pLmVudW1lcmFibGU7XG4gIH0pO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldE93bkVudW1lcmFibGVQcm9wZXJ0aWVzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTYgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRhbmNpZXNcbiAqL1xuXG52YXIgZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9scyA9IHJlcXVpcmUoJy4vZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9scycpO1xuXG4vKipcbiAqICMjIyAuZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMob2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgZGlyZWN0bHktb3duZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYW4gb2JqZWN0LiBUaGlzIGZ1bmN0aW9uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIE9iamVjdC5rZXlzIG9ubHlcbiAqIHJldHVybnMgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcywgbm90IGVudW1lcmFibGUgcHJvcGVydHkgc3ltYm9scy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBnZXRPd25FbnVtZXJhYmxlUHJvcGVydGllc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE93bkVudW1lcmFibGVQcm9wZXJ0aWVzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5jb25jYXQoZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9scyhvYmopKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qICFcbiAqIENoYWkgLSBjaGVja0Vycm9yIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTYgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuY2hlY2tFcnJvclxuICpcbiAqIENoZWNrcyB0aGF0IGFuIGVycm9yIGNvbmZvcm1zIHRvIGEgZ2l2ZW4gc2V0IG9mIGNyaXRlcmlhIGFuZC9vciByZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgaXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqICMjIyAuY29tcGF0aWJsZUluc3RhbmNlKHRocm93biwgZXJyb3JMaWtlKVxuICpcbiAqIENoZWNrcyBpZiB0d28gaW5zdGFuY2VzIGFyZSBjb21wYXRpYmxlIChzdHJpY3QgZXF1YWwpLlxuICogUmV0dXJucyBmYWxzZSBpZiBlcnJvckxpa2UgaXMgbm90IGFuIGluc3RhbmNlIG9mIEVycm9yLCBiZWNhdXNlIGluc3RhbmNlc1xuICogY2FuIG9ubHkgYmUgY29tcGF0aWJsZSBpZiB0aGV5J3JlIGJvdGggZXJyb3IgaW5zdGFuY2VzLlxuICpcbiAqIEBuYW1lIGNvbXBhdGlibGVJbnN0YW5jZVxuICogQHBhcmFtIHtFcnJvcn0gdGhyb3duIGVycm9yXG4gKiBAcGFyYW0ge0Vycm9yfEVycm9yQ29uc3RydWN0b3J9IGVycm9yTGlrZSBvYmplY3QgdG8gY29tcGFyZSBhZ2FpbnN0XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNvbXBhdGlibGVJbnN0YW5jZSh0aHJvd24sIGVycm9yTGlrZSkge1xuICByZXR1cm4gZXJyb3JMaWtlIGluc3RhbmNlb2YgRXJyb3IgJiYgdGhyb3duID09PSBlcnJvckxpa2U7XG59XG5cbi8qKlxuICogIyMjIC5jb21wYXRpYmxlQ29uc3RydWN0b3IodGhyb3duLCBlcnJvckxpa2UpXG4gKlxuICogQ2hlY2tzIGlmIHR3byBjb25zdHJ1Y3RvcnMgYXJlIGNvbXBhdGlibGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiByZWNlaXZlIGVpdGhlciBhbiBlcnJvciBjb25zdHJ1Y3RvciBvclxuICogYW4gZXJyb3IgaW5zdGFuY2UgYXMgdGhlIGBlcnJvckxpa2VgIGFyZ3VtZW50LlxuICogQ29uc3RydWN0b3JzIGFyZSBjb21wYXRpYmxlIGlmIHRoZXkncmUgdGhlIHNhbWUgb3IgaWYgb25lIGlzXG4gKiBhbiBpbnN0YW5jZSBvZiBhbm90aGVyLlxuICpcbiAqIEBuYW1lIGNvbXBhdGlibGVDb25zdHJ1Y3RvclxuICogQHBhcmFtIHtFcnJvcn0gdGhyb3duIGVycm9yXG4gKiBAcGFyYW0ge0Vycm9yfEVycm9yQ29uc3RydWN0b3J9IGVycm9yTGlrZSBvYmplY3QgdG8gY29tcGFyZSBhZ2FpbnN0XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNvbXBhdGlibGVDb25zdHJ1Y3Rvcih0aHJvd24sIGVycm9yTGlrZSkge1xuICBpZiAoZXJyb3JMaWtlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAvLyBJZiBgZXJyb3JMaWtlYCBpcyBhbiBpbnN0YW5jZSBvZiBhbnkgZXJyb3Igd2UgY29tcGFyZSB0aGVpciBjb25zdHJ1Y3RvcnNcbiAgICByZXR1cm4gdGhyb3duLmNvbnN0cnVjdG9yID09PSBlcnJvckxpa2UuY29uc3RydWN0b3IgfHwgdGhyb3duIGluc3RhbmNlb2YgZXJyb3JMaWtlLmNvbnN0cnVjdG9yO1xuICB9IGVsc2UgaWYgKGVycm9yTGlrZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBFcnJvciB8fCBlcnJvckxpa2UgPT09IEVycm9yKSB7XG4gICAgLy8gSWYgYGVycm9yTGlrZWAgaXMgYSBjb25zdHJ1Y3RvciB0aGF0IGluaGVyaXRzIGZyb20gRXJyb3IsIHdlIGNvbXBhcmUgYHRocm93bmAgdG8gYGVycm9yTGlrZWAgZGlyZWN0bHlcbiAgICByZXR1cm4gdGhyb3duLmNvbnN0cnVjdG9yID09PSBlcnJvckxpa2UgfHwgdGhyb3duIGluc3RhbmNlb2YgZXJyb3JMaWtlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqICMjIyAuY29tcGF0aWJsZU1lc3NhZ2UodGhyb3duLCBlcnJNYXRjaGVyKVxuICpcbiAqIENoZWNrcyBpZiBhbiBlcnJvcidzIG1lc3NhZ2UgaXMgY29tcGF0aWJsZSB3aXRoIGEgbWF0Y2hlciAoU3RyaW5nIG9yIFJlZ0V4cCkuXG4gKiBJZiB0aGUgbWVzc2FnZSBjb250YWlucyB0aGUgU3RyaW5nIG9yIHBhc3NlcyB0aGUgUmVnRXhwIHRlc3QsXG4gKiBpdCBpcyBjb25zaWRlcmVkIGNvbXBhdGlibGUuXG4gKlxuICogQG5hbWUgY29tcGF0aWJsZU1lc3NhZ2VcbiAqIEBwYXJhbSB7RXJyb3J9IHRocm93biBlcnJvclxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBlcnJNYXRjaGVyIHRvIGxvb2sgZm9yIGludG8gdGhlIG1lc3NhZ2VcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY29tcGF0aWJsZU1lc3NhZ2UodGhyb3duLCBlcnJNYXRjaGVyKSB7XG4gIHZhciBjb21wYXJpc29uU3RyaW5nID0gdHlwZW9mIHRocm93biA9PT0gJ3N0cmluZycgPyB0aHJvd24gOiB0aHJvd24ubWVzc2FnZTtcbiAgaWYgKGVyck1hdGNoZXIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gZXJyTWF0Y2hlci50ZXN0KGNvbXBhcmlzb25TdHJpbmcpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJNYXRjaGVyID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBjb21wYXJpc29uU3RyaW5nLmluZGV4T2YoZXJyTWF0Y2hlcikgIT09IC0xOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW1hZ2ljLW51bWJlcnNcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiAjIyMgLmdldEZ1bmN0aW9uTmFtZShjb25zdHJ1Y3RvckZuKVxuICpcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBmdW5jdGlvbi5cbiAqIFRoaXMgYWxzbyBpbmNsdWRlcyBhIHBvbHlmaWxsIGZ1bmN0aW9uIGlmIGBjb25zdHJ1Y3RvckZuLm5hbWVgIGlzIG5vdCBkZWZpbmVkLlxuICpcbiAqIEBuYW1lIGdldEZ1bmN0aW9uTmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3JGblxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIGZ1bmN0aW9uTmFtZU1hdGNoID0gL1xccypmdW5jdGlvbig/Olxcc3xcXHMqXFwvXFwqW14oPzoqXFwvKV0rXFwqXFwvXFxzKikqKFteXFwoXFwvXSspLztcbmZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShjb25zdHJ1Y3RvckZuKSB7XG4gIHZhciBuYW1lID0gJyc7XG4gIGlmICh0eXBlb2YgY29uc3RydWN0b3JGbi5uYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEhlcmUgd2UgcnVuIGEgcG9seWZpbGwgaWYgY29uc3RydWN0b3JGbi5uYW1lIGlzIG5vdCBkZWZpbmVkXG4gICAgdmFyIG1hdGNoID0gU3RyaW5nKGNvbnN0cnVjdG9yRm4pLm1hdGNoKGZ1bmN0aW9uTmFtZU1hdGNoKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIG5hbWUgPSBtYXRjaFsxXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IGNvbnN0cnVjdG9yRm4ubmFtZTtcbiAgfVxuXG4gIHJldHVybiBuYW1lO1xufVxuXG4vKipcbiAqICMjIyAuZ2V0Q29uc3RydWN0b3JOYW1lKGVycm9yTGlrZSlcbiAqXG4gKiBHZXRzIHRoZSBjb25zdHJ1Y3RvciBuYW1lIGZvciBhbiBFcnJvciBpbnN0YW5jZSBvciBjb25zdHJ1Y3RvciBpdHNlbGYuXG4gKlxuICogQG5hbWUgZ2V0Q29uc3RydWN0b3JOYW1lXG4gKiBAcGFyYW0ge0Vycm9yfEVycm9yQ29uc3RydWN0b3J9IGVycm9yTGlrZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBnZXRDb25zdHJ1Y3Rvck5hbWUoZXJyb3JMaWtlKSB7XG4gIHZhciBjb25zdHJ1Y3Rvck5hbWUgPSBlcnJvckxpa2U7XG4gIGlmIChlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIGNvbnN0cnVjdG9yTmFtZSA9IGdldEZ1bmN0aW9uTmFtZShlcnJvckxpa2UuY29uc3RydWN0b3IpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJvckxpa2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJZiBgZXJyYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgRXJyb3IgaXQgaXMgYW4gZXJyb3IgY29uc3RydWN0b3IgaXRzZWxmIG9yIGFub3RoZXIgZnVuY3Rpb24uXG4gICAgLy8gSWYgd2UndmUgZ290IGEgY29tbW9uIGZ1bmN0aW9uIHdlIGdldCBpdHMgbmFtZSwgb3RoZXJ3aXNlIHdlIG1heSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZVxuICAgIC8vIG9mIHRoZSBlcnJvciBqdXN0IGluIGNhc2UgaXQncyBhIHBvb3JseS1jb25zdHJ1Y3RlZCBlcnJvci4gUGxlYXNlIHNlZSBjaGFpanMvY2hhaS9pc3N1ZXMvNDUgdG8ga25vdyBtb3JlLlxuICAgIGNvbnN0cnVjdG9yTmFtZSA9IGdldEZ1bmN0aW9uTmFtZShlcnJvckxpa2UpLnRyaW0oKSB8fFxuICAgICAgICBnZXRGdW5jdGlvbk5hbWUobmV3IGVycm9yTGlrZSgpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gIH1cblxuICByZXR1cm4gY29uc3RydWN0b3JOYW1lO1xufVxuXG4vKipcbiAqICMjIyAuZ2V0TWVzc2FnZShlcnJvckxpa2UpXG4gKlxuICogR2V0cyB0aGUgZXJyb3IgbWVzc2FnZSBmcm9tIGFuIGVycm9yLlxuICogSWYgYGVycmAgaXMgYSBTdHJpbmcgaXRzZWxmLCB3ZSByZXR1cm4gaXQuXG4gKiBJZiB0aGUgZXJyb3IgaGFzIG5vIG1lc3NhZ2UsIHdlIHJldHVybiBhbiBlbXB0eSBzdHJpbmcuXG4gKlxuICogQG5hbWUgZ2V0TWVzc2FnZVxuICogQHBhcmFtIHtFcnJvcnxTdHJpbmd9IGVycm9yTGlrZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBnZXRNZXNzYWdlKGVycm9yTGlrZSkge1xuICB2YXIgbXNnID0gJyc7XG4gIGlmIChlcnJvckxpa2UgJiYgZXJyb3JMaWtlLm1lc3NhZ2UpIHtcbiAgICBtc2cgPSBlcnJvckxpa2UubWVzc2FnZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXJyb3JMaWtlID09PSAnc3RyaW5nJykge1xuICAgIG1zZyA9IGVycm9yTGlrZTtcbiAgfVxuXG4gIHJldHVybiBtc2c7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb21wYXRpYmxlSW5zdGFuY2U6IGNvbXBhdGlibGVJbnN0YW5jZSxcbiAgY29tcGF0aWJsZUNvbnN0cnVjdG9yOiBjb21wYXRpYmxlQ29uc3RydWN0b3IsXG4gIGNvbXBhdGlibGVNZXNzYWdlOiBjb21wYXRpYmxlTWVzc2FnZSxcbiAgZ2V0TWVzc2FnZTogZ2V0TWVzc2FnZSxcbiAgZ2V0Q29uc3RydWN0b3JOYW1lOiBnZXRDb25zdHJ1Y3Rvck5hbWUsXG59O1xuIiwiLyohXG4gKiBDaGFpIC0gaXNOYU4gdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNSBTYWt0aGlwcml5YW4gVmFpcmFtYW5pIDx0aGVjaGFyZ2luZ3ZvbGNhbm9AZ21haWwuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmlzTmFOKHZhbHVlKVxuICpcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgTmFOIG9yIG5vdC5cbiAqXG4gKiAgICAgdXRpbHMuaXNOYU4oTmFOKTsgLy8gdHJ1ZVxuICpcbiAqIEBwYXJhbSB7VmFsdWV9IFRoZSB2YWx1ZSB3aGljaCBoYXMgdG8gYmUgY2hlY2tlZCBpZiBpdCBpcyBOYU5cbiAqIEBuYW1lIGlzTmFOXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAvLyBSZWZlciBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtaXNuYW4tbnVtYmVyXG4gIC8vIHNlY3Rpb24ncyBOT1RFLlxuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG4vLyBJZiBFQ01BU2NyaXB0IDYncyBOdW1iZXIuaXNOYU4gaXMgcHJlc2VudCwgcHJlZmVyIHRoYXQuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc05hTiB8fCBpc05hTjtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIERlcGVuZGVuY2llcyB0aGF0IGFyZSB1c2VkIGZvciBtdWx0aXBsZSBleHBvcnRzIGFyZSByZXF1aXJlZCBoZXJlIG9ubHkgb25jZVxuICovXG5cbnZhciBwYXRodmFsID0gcmVxdWlyZSgncGF0aHZhbCcpO1xuXG4vKiFcbiAqIHRlc3QgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMudGVzdCA9IHJlcXVpcmUoJy4vdGVzdCcpO1xuXG4vKiFcbiAqIHR5cGUgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMudHlwZSA9IHJlcXVpcmUoJ3R5cGUtZGV0ZWN0Jyk7XG5cbi8qIVxuICogZXhwZWN0VHlwZXMgdXRpbGl0eVxuICovXG5leHBvcnRzLmV4cGVjdFR5cGVzID0gcmVxdWlyZSgnLi9leHBlY3RUeXBlcycpO1xuXG4vKiFcbiAqIG1lc3NhZ2UgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZ2V0TWVzc2FnZSA9IHJlcXVpcmUoJy4vZ2V0TWVzc2FnZScpO1xuXG4vKiFcbiAqIGFjdHVhbCB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5nZXRBY3R1YWwgPSByZXF1aXJlKCcuL2dldEFjdHVhbCcpO1xuXG4vKiFcbiAqIEluc3BlY3QgdXRpbFxuICovXG5cbmV4cG9ydHMuaW5zcGVjdCA9IHJlcXVpcmUoJy4vaW5zcGVjdCcpO1xuXG4vKiFcbiAqIE9iamVjdCBEaXNwbGF5IHV0aWxcbiAqL1xuXG5leHBvcnRzLm9iakRpc3BsYXkgPSByZXF1aXJlKCcuL29iakRpc3BsYXknKTtcblxuLyohXG4gKiBGbGFnIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcblxuLyohXG4gKiBGbGFnIHRyYW5zZmVycmluZyB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy50cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG5cbi8qIVxuICogRGVlcCBlcXVhbCB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5lcWwgPSByZXF1aXJlKCdkZWVwLWVxbCcpO1xuXG4vKiFcbiAqIERlZXAgcGF0aCBpbmZvXG4gKi9cblxuZXhwb3J0cy5nZXRQYXRoSW5mbyA9IHBhdGh2YWwuZ2V0UGF0aEluZm87XG5cbi8qIVxuICogQ2hlY2sgaWYgYSBwcm9wZXJ0eSBleGlzdHNcbiAqL1xuXG5leHBvcnRzLmhhc1Byb3BlcnR5ID0gcGF0aHZhbC5oYXNQcm9wZXJ0eTtcblxuLyohXG4gKiBGdW5jdGlvbiBuYW1lXG4gKi9cblxuZXhwb3J0cy5nZXROYW1lID0gcmVxdWlyZSgnZ2V0LWZ1bmMtbmFtZScpO1xuXG4vKiFcbiAqIGFkZCBQcm9wZXJ0eVxuICovXG5cbmV4cG9ydHMuYWRkUHJvcGVydHkgPSByZXF1aXJlKCcuL2FkZFByb3BlcnR5Jyk7XG5cbi8qIVxuICogYWRkIE1ldGhvZFxuICovXG5cbmV4cG9ydHMuYWRkTWV0aG9kID0gcmVxdWlyZSgnLi9hZGRNZXRob2QnKTtcblxuLyohXG4gKiBvdmVyd3JpdGUgUHJvcGVydHlcbiAqL1xuXG5leHBvcnRzLm92ZXJ3cml0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9vdmVyd3JpdGVQcm9wZXJ0eScpO1xuXG4vKiFcbiAqIG92ZXJ3cml0ZSBNZXRob2RcbiAqL1xuXG5leHBvcnRzLm92ZXJ3cml0ZU1ldGhvZCA9IHJlcXVpcmUoJy4vb3ZlcndyaXRlTWV0aG9kJyk7XG5cbi8qIVxuICogQWRkIGEgY2hhaW5hYmxlIG1ldGhvZFxuICovXG5cbmV4cG9ydHMuYWRkQ2hhaW5hYmxlTWV0aG9kID0gcmVxdWlyZSgnLi9hZGRDaGFpbmFibGVNZXRob2QnKTtcblxuLyohXG4gKiBPdmVyd3JpdGUgY2hhaW5hYmxlIG1ldGhvZFxuICovXG5cbmV4cG9ydHMub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kID0gcmVxdWlyZSgnLi9vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QnKTtcblxuLyohXG4gKiBDb21wYXJlIGJ5IGluc3BlY3QgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5jb21wYXJlQnlJbnNwZWN0ID0gcmVxdWlyZSgnLi9jb21wYXJlQnlJbnNwZWN0Jyk7XG5cbi8qIVxuICogR2V0IG93biBlbnVtZXJhYmxlIHByb3BlcnR5IHN5bWJvbHMgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5nZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzID0gcmVxdWlyZSgnLi9nZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzJyk7XG5cbi8qIVxuICogR2V0IG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5nZXRPd25FbnVtZXJhYmxlUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMnKTtcblxuLyohXG4gKiBDaGVja3MgZXJyb3IgYWdhaW5zdCBhIGdpdmVuIHNldCBvZiBjcml0ZXJpYVxuICovXG5cbmV4cG9ydHMuY2hlY2tFcnJvciA9IHJlcXVpcmUoJ2NoZWNrLWVycm9yJyk7XG5cbi8qIVxuICogUHJveGlmeSB1dGlsXG4gKi9cblxuZXhwb3J0cy5wcm94aWZ5ID0gcmVxdWlyZSgnLi9wcm94aWZ5Jyk7XG5cbi8qIVxuICogYWRkTGVuZ3RoR3VhcmQgdXRpbFxuICovXG5cbmV4cG9ydHMuYWRkTGVuZ3RoR3VhcmQgPSByZXF1aXJlKCcuL2FkZExlbmd0aEd1YXJkJyk7XG5cbi8qIVxuICogaXNQcm94eUVuYWJsZWQgaGVscGVyXG4gKi9cblxuZXhwb3J0cy5pc1Byb3h5RW5hYmxlZCA9IHJlcXVpcmUoJy4vaXNQcm94eUVuYWJsZWQnKTtcblxuLyohXG4gKiBpc05hTiBtZXRob2RcbiAqL1xuXG5leHBvcnRzLmlzTmFOID0gcmVxdWlyZSgnLi9pc05hTicpO1xuIiwiLyohXG4gKiBjaGFpXG4gKiBodHRwOi8vY2hhaWpzLmNvbVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfY2hhaSwgdXRpbCkge1xuICAvKiFcbiAgICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAgICovXG5cbiAgdmFyIEFzc2VydGlvbkVycm9yID0gX2NoYWkuQXNzZXJ0aW9uRXJyb3JcbiAgICAsIGZsYWcgPSB1dGlsLmZsYWc7XG5cbiAgLyohXG4gICAqIE1vZHVsZSBleHBvcnQuXG4gICAqL1xuXG4gIF9jaGFpLkFzc2VydGlvbiA9IEFzc2VydGlvbjtcblxuICAvKiFcbiAgICogQXNzZXJ0aW9uIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIENyZWF0ZXMgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICpcbiAgICogYEFzc2VydGlvbmAgb2JqZWN0cyBjb250YWluIG1ldGFkYXRhIGluIHRoZSBmb3JtIG9mIGZsYWdzLiBUaHJlZSBmbGFncyBjYW5cbiAgICogYmUgYXNzaWduZWQgZHVyaW5nIGluc3RhbnRpYXRpb24gYnkgcGFzc2luZyBhcmd1bWVudHMgdG8gdGhpcyBjb25zdHJ1Y3RvcjpcbiAgICpcbiAgICogLSBgb2JqZWN0YDogVGhpcyBmbGFnIGNvbnRhaW5zIHRoZSB0YXJnZXQgb2YgdGhlIGFzc2VydGlvbi4gRm9yIGV4YW1wbGUsIGluXG4gICAqICAgdGhlIGFzc2VydGlvbiBgZXhwZWN0KG51bUtpdHRlbnMpLnRvLmVxdWFsKDcpO2AsIHRoZSBgb2JqZWN0YCBmbGFnIHdpbGxcbiAgICogICBjb250YWluIGBudW1LaXR0ZW5zYCBzbyB0aGF0IHRoZSBgZXF1YWxgIGFzc2VydGlvbiBjYW4gcmVmZXJlbmNlIGl0IHdoZW5cbiAgICogICBuZWVkZWQuXG4gICAqXG4gICAqIC0gYG1lc3NhZ2VgOiBUaGlzIGZsYWcgY29udGFpbnMgYW4gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2UgdG8gYmVcbiAgICogICBwcmVwZW5kZWQgdG8gdGhlIGVycm9yIG1lc3NhZ2UgdGhhdCdzIGdlbmVyYXRlZCBieSB0aGUgYXNzZXJ0aW9uIHdoZW4gaXRcbiAgICogICBmYWlscy5cbiAgICpcbiAgICogLSBgc3NmaWA6IFRoaXMgZmxhZyBzdGFuZHMgZm9yIFwic3RhcnQgc3RhY2sgZnVuY3Rpb24gaW5kaWNhdG9yXCIuIEl0XG4gICAqICAgY29udGFpbnMgYSBmdW5jdGlvbiByZWZlcmVuY2UgdGhhdCBzZXJ2ZXMgYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGZvclxuICAgKiAgIHJlbW92aW5nIGZyYW1lcyBmcm9tIHRoZSBzdGFjayB0cmFjZSBvZiB0aGUgZXJyb3IgdGhhdCdzIGNyZWF0ZWQgYnkgdGhlXG4gICAqICAgYXNzZXJ0aW9uIHdoZW4gaXQgZmFpbHMuIFRoZSBnb2FsIGlzIHRvIHByb3ZpZGUgYSBjbGVhbmVyIHN0YWNrIHRyYWNlIHRvXG4gICAqICAgZW5kIHVzZXJzIGJ5IHJlbW92aW5nIENoYWkncyBpbnRlcm5hbCBmdW5jdGlvbnMuIE5vdGUgdGhhdCBpdCBvbmx5IHdvcmtzXG4gICAqICAgaW4gZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2VgLCBhbmQgb25seSB3aGVuXG4gICAqICAgYENoYWkuY29uZmlnLmluY2x1ZGVTdGFja2AgaGFzbid0IGJlZW4gc2V0IHRvIGBmYWxzZWAuXG4gICAqXG4gICAqIC0gYGxvY2tTc2ZpYDogVGhpcyBmbGFnIGNvbnRyb2xzIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBgc3NmaWAgZmxhZ1xuICAgKiAgIHNob3VsZCByZXRhaW4gaXRzIGN1cnJlbnQgdmFsdWUsIGV2ZW4gYXMgYXNzZXJ0aW9ucyBhcmUgY2hhaW5lZCBvZmYgb2ZcbiAgICogICB0aGlzIG9iamVjdC4gVGhpcyBpcyB1c3VhbGx5IHNldCB0byBgdHJ1ZWAgd2hlbiBjcmVhdGluZyBhIG5ldyBhc3NlcnRpb25cbiAgICogICBmcm9tIHdpdGhpbiBhbm90aGVyIGFzc2VydGlvbi4gSXQncyBhbHNvIHRlbXBvcmFyaWx5IHNldCB0byBgdHJ1ZWAgYmVmb3JlXG4gICAqICAgYW4gb3ZlcndyaXR0ZW4gYXNzZXJ0aW9uIGdldHMgY2FsbGVkIGJ5IHRoZSBvdmVyd3JpdGluZyBhc3NlcnRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iaiB0YXJnZXQgb2YgdGhlIGFzc2VydGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIChvcHRpb25hbCkgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3NmaSAob3B0aW9uYWwpIHN0YXJ0aW5nIHBvaW50IGZvciByZW1vdmluZyBzdGFjayBmcmFtZXNcbiAgICogQHBhcmFtIHtCb29sZWFufSBsb2NrU3NmaSAob3B0aW9uYWwpIHdoZXRoZXIgb3Igbm90IHRoZSBzc2ZpIGZsYWcgaXMgbG9ja2VkXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiBBc3NlcnRpb24gKG9iaiwgbXNnLCBzc2ZpLCBsb2NrU3NmaSkge1xuICAgIGZsYWcodGhpcywgJ3NzZmknLCBzc2ZpIHx8IEFzc2VydGlvbik7XG4gICAgZmxhZyh0aGlzLCAnbG9ja1NzZmknLCBsb2NrU3NmaSk7XG4gICAgZmxhZyh0aGlzLCAnb2JqZWN0Jywgb2JqKTtcbiAgICBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcblxuICAgIHJldHVybiB1dGlsLnByb3hpZnkodGhpcyk7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXNzZXJ0aW9uLCAnaW5jbHVkZVN0YWNrJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5pbmNsdWRlU3RhY2sgaXMgZGVwcmVjYXRlZCwgdXNlIGNoYWkuY29uZmlnLmluY2x1ZGVTdGFjayBpbnN0ZWFkLicpO1xuICAgICAgcmV0dXJuIGNvbmZpZy5pbmNsdWRlU3RhY2s7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5pbmNsdWRlU3RhY2sgaXMgZGVwcmVjYXRlZCwgdXNlIGNoYWkuY29uZmlnLmluY2x1ZGVTdGFjayBpbnN0ZWFkLicpO1xuICAgICAgY29uZmlnLmluY2x1ZGVTdGFjayA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzc2VydGlvbiwgJ3Nob3dEaWZmJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5zaG93RGlmZiBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuc2hvd0RpZmYgaW5zdGVhZC4nKTtcbiAgICAgIHJldHVybiBjb25maWcuc2hvd0RpZmY7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5zaG93RGlmZiBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuc2hvd0RpZmYgaW5zdGVhZC4nKTtcbiAgICAgIGNvbmZpZy5zaG93RGlmZiA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5hZGRQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLmFkZE1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgICB1dGlsLmFkZENoYWluYWJsZU1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpO1xuICB9O1xuXG4gIEFzc2VydGlvbi5vdmVyd3JpdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwub3ZlcndyaXRlUHJvcGVydHkodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5vdmVyd3JpdGVNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24ub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKSB7XG4gICAgdXRpbC5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5hc3NlcnQoZXhwcmVzc2lvbiwgbWVzc2FnZSwgbmVnYXRlTWVzc2FnZSwgZXhwZWN0ZWQsIGFjdHVhbCwgc2hvd0RpZmYpXG4gICAqXG4gICAqIEV4ZWN1dGVzIGFuIGV4cHJlc3Npb24gYW5kIGNoZWNrIGV4cGVjdGF0aW9ucy4gVGhyb3dzIEFzc2VydGlvbkVycm9yIGZvciByZXBvcnRpbmcgaWYgdGVzdCBkb2Vzbid0IHBhc3MuXG4gICAqXG4gICAqIEBuYW1lIGFzc2VydFxuICAgKiBAcGFyYW0ge1BoaWxvc29waGljYWx9IGV4cHJlc3Npb24gdG8gYmUgdGVzdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBtZXNzYWdlIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBtZXNzYWdlIHRvIGRpc3BsYXkgaWYgZXhwcmVzc2lvbiBmYWlsc1xuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gbmVnYXRlZE1lc3NhZ2Ugb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG5lZ2F0ZWRNZXNzYWdlIHRvIGRpc3BsYXkgaWYgbmVnYXRlZCBleHByZXNzaW9uIGZhaWxzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkIHZhbHVlIChyZW1lbWJlciB0byBjaGVjayBmb3IgbmVnYXRpb24pXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbCAob3B0aW9uYWwpIHdpbGwgZGVmYXVsdCB0byBgdGhpcy5vYmpgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvd0RpZmYgKG9wdGlvbmFsKSB3aGVuIHNldCB0byBgdHJ1ZWAsIGFzc2VydCB3aWxsIGRpc3BsYXkgYSBkaWZmIGluIGFkZGl0aW9uIHRvIHRoZSBtZXNzYWdlIGlmIGV4cHJlc3Npb24gZmFpbHNcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIEFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0ID0gZnVuY3Rpb24gKGV4cHIsIG1zZywgbmVnYXRlTXNnLCBleHBlY3RlZCwgX2FjdHVhbCwgc2hvd0RpZmYpIHtcbiAgICB2YXIgb2sgPSB1dGlsLnRlc3QodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoZmFsc2UgIT09IHNob3dEaWZmKSBzaG93RGlmZiA9IHRydWU7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gZXhwZWN0ZWQgJiYgdW5kZWZpbmVkID09PSBfYWN0dWFsKSBzaG93RGlmZiA9IGZhbHNlO1xuICAgIGlmICh0cnVlICE9PSBjb25maWcuc2hvd0RpZmYpIHNob3dEaWZmID0gZmFsc2U7XG5cbiAgICBpZiAoIW9rKSB7XG4gICAgICBtc2cgPSB1dGlsLmdldE1lc3NhZ2UodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHZhciBhY3R1YWwgPSB1dGlsLmdldEFjdHVhbCh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG1zZywge1xuICAgICAgICAgIGFjdHVhbDogYWN0dWFsXG4gICAgICAgICwgZXhwZWN0ZWQ6IGV4cGVjdGVkXG4gICAgICAgICwgc2hvd0RpZmY6IHNob3dEaWZmXG4gICAgICB9LCAoY29uZmlnLmluY2x1ZGVTdGFjaykgPyB0aGlzLmFzc2VydCA6IGZsYWcodGhpcywgJ3NzZmknKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qIVxuICAgKiAjIyMgLl9vYmpcbiAgICpcbiAgICogUXVpY2sgcmVmZXJlbmNlIHRvIHN0b3JlZCBgYWN0dWFsYCB2YWx1ZSBmb3IgcGx1Z2luIGRldmVsb3BlcnMuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ19vYmonLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICAgIH1cbiAgICAsIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnLCB2YWwpO1xuICAgICAgfVxuICB9KTtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIGh0dHA6Ly9jaGFpanMuY29tXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgXykge1xuICB2YXIgQXNzZXJ0aW9uID0gY2hhaS5Bc3NlcnRpb25cbiAgICAsIEFzc2VydGlvbkVycm9yID0gY2hhaS5Bc3NlcnRpb25FcnJvclxuICAgICwgZmxhZyA9IF8uZmxhZztcblxuICAvKipcbiAgICogIyMjIExhbmd1YWdlIENoYWluc1xuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGFyZSBwcm92aWRlZCBhcyBjaGFpbmFibGUgZ2V0dGVycyB0byBpbXByb3ZlIHRoZSByZWFkYWJpbGl0eVxuICAgKiBvZiB5b3VyIGFzc2VydGlvbnMuXG4gICAqXG4gICAqICoqQ2hhaW5zKipcbiAgICpcbiAgICogLSB0b1xuICAgKiAtIGJlXG4gICAqIC0gYmVlblxuICAgKiAtIGlzXG4gICAqIC0gdGhhdFxuICAgKiAtIHdoaWNoXG4gICAqIC0gYW5kXG4gICAqIC0gaGFzXG4gICAqIC0gaGF2ZVxuICAgKiAtIHdpdGhcbiAgICogLSBhdFxuICAgKiAtIG9mXG4gICAqIC0gc2FtZVxuICAgKiAtIGJ1dFxuICAgKiAtIGRvZXNcbiAgICpcbiAgICogQG5hbWUgbGFuZ3VhZ2UgY2hhaW5zXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIFsgJ3RvJywgJ2JlJywgJ2JlZW4nXG4gICwgJ2lzJywgJ2FuZCcsICdoYXMnLCAnaGF2ZSdcbiAgLCAnd2l0aCcsICd0aGF0JywgJ3doaWNoJywgJ2F0J1xuICAsICdvZicsICdzYW1lJywgJ2J1dCcsICdkb2VzJyBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KGNoYWluKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAubm90XG4gICAqXG4gICAqIE5lZ2F0ZXMgYWxsIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZ1bmN0aW9uICgpIHt9KS50by5ub3QudGhyb3coKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5oYXZlLnByb3BlcnR5KCdiJyk7XG4gICAqICAgICBleHBlY3QoWzEsIDJdKS50by5iZS5hbignYXJyYXknKS50aGF0LmRvZXMubm90LmluY2x1ZGUoMyk7XG4gICAqXG4gICAqIEp1c3QgYmVjYXVzZSB5b3UgY2FuIG5lZ2F0ZSBhbnkgYXNzZXJ0aW9uIHdpdGggYC5ub3RgIGRvZXNuJ3QgbWVhbiB5b3VcbiAgICogc2hvdWxkLiBXaXRoIGdyZWF0IHBvd2VyIGNvbWVzIGdyZWF0IHJlc3BvbnNpYmlsaXR5LiBJdCdzIG9mdGVuIGJlc3QgdG9cbiAgICogYXNzZXJ0IHRoYXQgdGhlIG9uZSBleHBlY3RlZCBvdXRwdXQgd2FzIHByb2R1Y2VkLCByYXRoZXIgdGhhbiBhc3NlcnRpbmdcbiAgICogdGhhdCBvbmUgb2YgY291bnRsZXNzIHVuZXhwZWN0ZWQgb3V0cHV0cyB3YXNuJ3QgcHJvZHVjZWQuIFNlZSBpbmRpdmlkdWFsXG4gICAqIGFzc2VydGlvbnMgZm9yIHNwZWNpZmljIGd1aWRhbmNlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmVxdWFsKDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLm5vdC5lcXVhbCgxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEBuYW1lIG5vdFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ25vdCcsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICduZWdhdGUnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFxuICAgKlxuICAgKiBDYXVzZXMgYWxsIGAuZXF1YWxgLCBgLmluY2x1ZGVgLCBgLm1lbWJlcnNgLCBgLmtleXNgLCBhbmQgYC5wcm9wZXJ0eWBcbiAgICogYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4gdG8gdXNlIGRlZXAgZXF1YWxpdHkgaW5zdGVhZCBvZiBzdHJpY3RcbiAgICogKGA9PT1gKSBlcXVhbGl0eS4gU2VlIHRoZSBgZGVlcC1lcWxgIHByb2plY3QgcGFnZSBmb3IgaW5mbyBvbiB0aGUgZGVlcFxuICAgKiBlcXVhbGl0eSBhbGdvcml0aG06IGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWwuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgZXF1YWxzIGB7YTogMX1gXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5kZWVwLmVxdWFsKHthOiAxfSk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuZXF1YWwoe2E6IDF9KTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBhcnJheSBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGluY2x1ZGVzIGB7YTogMX1gXG4gICAqICAgICBleHBlY3QoW3thOiAxfV0pLnRvLmRlZXAuaW5jbHVkZSh7YTogMX0pO1xuICAgKiAgICAgZXhwZWN0KFt7YTogMX1dKS50by5ub3QuaW5jbHVkZSh7YTogMX0pO1xuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGluY2x1ZGVzIGB4OiB7YTogMX1gXG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLmRlZXAuaW5jbHVkZSh7eDoge2E6IDF9fSk7XG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLm5vdC5pbmNsdWRlKHt4OiB7YTogMX19KTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBhcnJheSBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGhhcyBtZW1iZXIgYHthOiAxfWBcbiAgICogICAgIGV4cGVjdChbe2E6IDF9XSkudG8uaGF2ZS5kZWVwLm1lbWJlcnMoW3thOiAxfV0pO1xuICAgKiAgICAgZXhwZWN0KFt7YTogMX1dKS50by5ub3QuaGF2ZS5tZW1iZXJzKFt7YTogMX1dKTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBzZXQgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBoYXMga2V5IGB7YTogMX1gXG4gICAqICAgICBleHBlY3QobmV3IFNldChbe2E6IDF9XSkpLnRvLmhhdmUuZGVlcC5rZXlzKFt7YTogMX1dKTtcbiAgICogICAgIGV4cGVjdChuZXcgU2V0KFt7YTogMX1dKSkudG8ubm90LmhhdmUua2V5cyhbe2E6IDF9XSk7XG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaGFzIHByb3BlcnR5IGB4OiB7YTogMX1gXG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgneCcsIHthOiAxfSk7XG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLm5vdC5oYXZlLnByb3BlcnR5KCd4Jywge2E6IDF9KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2RlZXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnZGVlcCcsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5uZXN0ZWRcbiAgICpcbiAgICogRW5hYmxlcyBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGluIGFsbCBgLnByb3BlcnR5YCBhbmQgYC5pbmNsdWRlYFxuICAgKiBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbi5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YToge2I6IFsneCcsICd5J119fSkudG8uaGF2ZS5uZXN0ZWQucHJvcGVydHkoJ2EuYlsxXScpO1xuICAgKiAgICAgZXhwZWN0KHthOiB7YjogWyd4JywgJ3knXX19KS50by5uZXN0ZWQuaW5jbHVkZSh7J2EuYlsxXSc6ICd5J30pO1xuICAgKlxuICAgKiBJZiBgLmAgb3IgYFtdYCBhcmUgcGFydCBvZiBhbiBhY3R1YWwgcHJvcGVydHkgbmFtZSwgdGhleSBjYW4gYmUgZXNjYXBlZCBieVxuICAgKiBhZGRpbmcgdHdvIGJhY2tzbGFzaGVzIGJlZm9yZSB0aGVtLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHsnLmEnOiB7J1tiXSc6ICd4J319KS50by5oYXZlLm5lc3RlZC5wcm9wZXJ0eSgnXFxcXC5hLlxcXFxbYlxcXFxdJyk7XG4gICAqICAgICBleHBlY3QoeycuYSc6IHsnW2JdJzogJ3gnfX0pLnRvLm5lc3RlZC5pbmNsdWRlKHsnXFxcXC5hLlxcXFxbYlxcXFxdJzogJ3gnfSk7XG4gICAqXG4gICAqIGAubmVzdGVkYCBjYW5ub3QgYmUgY29tYmluZWQgd2l0aCBgLm93bmAuXG4gICAqXG4gICAqIEBuYW1lIG5lc3RlZFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ25lc3RlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICduZXN0ZWQnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAub3duXG4gICAqXG4gICAqIENhdXNlcyBhbGwgYC5wcm9wZXJ0eWAgYW5kIGAuaW5jbHVkZWAgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW5cbiAgICogdG8gaWdub3JlIGluaGVyaXRlZCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiAgICAgT2JqZWN0LnByb3RvdHlwZS5iID0gMjtcbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUub3duLnByb3BlcnR5KCdhJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLnByb3BlcnR5KCdiJykuYnV0Lm5vdC5vd24ucHJvcGVydHkoJ2InKTsgXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5vd24uaW5jbHVkZSh7YTogMX0pO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaW5jbHVkZSh7YjogMn0pLmJ1dC5ub3Qub3duLmluY2x1ZGUoe2I6IDJ9KTtcbiAgICpcbiAgICogYC5vd25gIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIGAubmVzdGVkYC5cbiAgICpcbiAgICogQG5hbWUgb3duXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnb3duJywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ293bicsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5vcmRlcmVkXG4gICAqXG4gICAqIENhdXNlcyBhbGwgYC5tZW1iZXJzYCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0byByZXF1aXJlIHRoYXRcbiAgICogbWVtYmVycyBiZSBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLmhhdmUub3JkZXJlZC5tZW1iZXJzKFsxLCAyXSlcbiAgICogICAgICAgLmJ1dC5ub3QuaGF2ZS5vcmRlcmVkLm1lbWJlcnMoWzIsIDFdKTtcbiAgICpcbiAgICogV2hlbiBgLmluY2x1ZGVgIGFuZCBgLm9yZGVyZWRgIGFyZSBjb21iaW5lZCwgdGhlIG9yZGVyaW5nIGJlZ2lucyBhdCB0aGVcbiAgICogc3RhcnQgb2YgYm90aCBhcnJheXMuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5pbmNsdWRlLm9yZGVyZWQubWVtYmVycyhbMSwgMl0pXG4gICAqICAgICAgIC5idXQubm90LmluY2x1ZGUub3JkZXJlZC5tZW1iZXJzKFsyLCAzXSk7XG4gICAqXG4gICAqIEBuYW1lIG9yZGVyZWRcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdvcmRlcmVkJywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ29yZGVyZWQnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuYW55XG4gICAqXG4gICAqIENhdXNlcyBhbGwgYC5rZXlzYCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0byBvbmx5IHJlcXVpcmUgdGhhdFxuICAgKiB0aGUgdGFyZ2V0IGhhdmUgYXQgbGVhc3Qgb25lIG9mIHRoZSBnaXZlbiBrZXlzLiBUaGlzIGlzIHRoZSBvcHBvc2l0ZSBvZlxuICAgKiBgLmFsbGAsIHdoaWNoIHJlcXVpcmVzIHRoYXQgdGhlIHRhcmdldCBoYXZlIGFsbCBvZiB0aGUgZ2l2ZW4ga2V5cy5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLm5vdC5oYXZlLmFueS5rZXlzKCdjJywgJ2QnKTtcbiAgICpcbiAgICogU2VlIHRoZSBgLmtleXNgIGRvYyBmb3IgZ3VpZGFuY2Ugb24gd2hlbiB0byB1c2UgYC5hbnlgIG9yIGAuYWxsYC5cbiAgICpcbiAgICogQG5hbWUgYW55XG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnYW55JywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ2FueScsIHRydWUpO1xuICAgIGZsYWcodGhpcywgJ2FsbCcsIGZhbHNlKTtcbiAgfSk7XG5cblxuICAvKipcbiAgICogIyMjIC5hbGxcbiAgICpcbiAgICogQ2F1c2VzIGFsbCBgLmtleXNgIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvIHJlcXVpcmUgdGhhdCB0aGVcbiAgICogdGFyZ2V0IGhhdmUgYWxsIG9mIHRoZSBnaXZlbiBrZXlzLiBUaGlzIGlzIHRoZSBvcHBvc2l0ZSBvZiBgLmFueWAsIHdoaWNoXG4gICAqIG9ubHkgcmVxdWlyZXMgdGhhdCB0aGUgdGFyZ2V0IGhhdmUgYXQgbGVhc3Qgb25lIG9mIHRoZSBnaXZlbiBrZXlzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8uaGF2ZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqXG4gICAqIE5vdGUgdGhhdCBgLmFsbGAgaXMgdXNlZCBieSBkZWZhdWx0IHdoZW4gbmVpdGhlciBgLmFsbGAgbm9yIGAuYW55YCBhcmVcbiAgICogYWRkZWQgZWFybGllciBpbiB0aGUgY2hhaW4uIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhZGQgYC5hbGxgIGFueXdheVxuICAgKiBiZWNhdXNlIGl0IGltcHJvdmVzIHJlYWRhYmlsaXR5LlxuICAgKlxuICAgKiBTZWUgdGhlIGAua2V5c2AgZG9jIGZvciBndWlkYW5jZSBvbiB3aGVuIHRvIHVzZSBgLmFueWAgb3IgYC5hbGxgLlxuICAgKlxuICAgKiBAbmFtZSBhbGxcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdhbGwnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnYWxsJywgdHJ1ZSk7XG4gICAgZmxhZyh0aGlzLCAnYW55JywgZmFsc2UpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hKHR5cGVbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzIHR5cGUgaXMgZXF1YWwgdG8gdGhlIGdpdmVuIHN0cmluZyBgdHlwZWAuIFR5cGVzXG4gICAqIGFyZSBjYXNlIGluc2Vuc2l0aXZlLiBTZWUgdGhlIGB0eXBlLWRldGVjdGAgcHJvamVjdCBwYWdlIGZvciBpbmZvIG9uIHRoZVxuICAgKiB0eXBlIGRldGVjdGlvbiBhbGdvcml0aG06IGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvdHlwZS1kZXRlY3QuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmJlLmEoJ3N0cmluZycpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uYmUuYW4oJ29iamVjdCcpO1xuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLmJlLmEoJ251bGwnKTtcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLmJlLmFuKCd1bmRlZmluZWQnKTtcbiAgICogICAgIGV4cGVjdChuZXcgRXJyb3IpLnRvLmJlLmFuKCdlcnJvcicpO1xuICAgKiAgICAgZXhwZWN0KFByb21pc2UucmVzb2x2ZSgpKS50by5iZS5hKCdwcm9taXNlJyk7XG4gICAqICAgICBleHBlY3QobmV3IEZsb2F0MzJBcnJheSkudG8uYmUuYSgnZmxvYXQzMmFycmF5Jyk7XG4gICAqICAgICBleHBlY3QoU3ltYm9sKCkpLnRvLmJlLmEoJ3N5bWJvbCcpO1xuICAgKlxuICAgKiBgLmFgIHN1cHBvcnRzIG9iamVjdHMgdGhhdCBoYXZlIGEgY3VzdG9tIHR5cGUgc2V0IHZpYSBgU3ltYm9sLnRvU3RyaW5nVGFnYC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHtcbiAgICogICAgICAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdteUN1c3RvbVR5cGUnXG4gICAqICAgICB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG15T2JqKS50by5iZS5hKCdteUN1c3RvbVR5cGUnKS5idXQubm90LmFuKCdvYmplY3QnKTtcbiAgICpcbiAgICogSXQncyBvZnRlbiBiZXN0IHRvIHVzZSBgLmFgIHRvIGNoZWNrIGEgdGFyZ2V0J3MgdHlwZSBiZWZvcmUgbWFraW5nIG1vcmVcbiAgICogYXNzZXJ0aW9ucyBvbiB0aGUgc2FtZSB0YXJnZXQuIFRoYXQgd2F5LCB5b3UgYXZvaWQgdW5leHBlY3RlZCBiZWhhdmlvciBmcm9tXG4gICAqIGFueSBhc3NlcnRpb24gdGhhdCBkb2VzIGRpZmZlcmVudCB0aGluZ3MgYmFzZWQgb24gdGhlIHRhcmdldCdzIHR5cGUuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5iZS5hbignYXJyYXknKS50aGF0LmluY2x1ZGVzKDIpO1xuICAgKiAgICAgZXhwZWN0KFtdKS50by5iZS5hbignYXJyYXknKS50aGF0LmlzLmVtcHR5O1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmFgLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG9cbiAgICogYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyB0aGUgZXhwZWN0ZWQgdHlwZSwgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIHRoYXQgaXRcbiAgICogaXNuJ3Qgb25lIG9mIG1hbnkgdW5leHBlY3RlZCB0eXBlcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uYmUuYSgnc3RyaW5nJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLm5vdC5iZS5hbignYXJyYXknKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAuYWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlIHRvXG4gICAqIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kXG4gICAqIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLmEoJ3N0cmluZycsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgxLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuYSgnc3RyaW5nJyk7XG4gICAqXG4gICAqIGAuYWAgY2FuIGFsc28gYmUgdXNlZCBhcyBhIGxhbmd1YWdlIGNoYWluIHRvIGltcHJvdmUgdGhlIHJlYWRhYmlsaXR5IG9mXG4gICAqIHlvdXIgYXNzZXJ0aW9ucy4gXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2I6IDJ9KS50by5oYXZlLmEucHJvcGVydHkoJ2InKTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuYW5gIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuYWAuXG4gICAqXG4gICAqIEBuYW1lIGFcbiAgICogQGFsaWFzIGFuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhbiAodHlwZSwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgYXJ0aWNsZSA9IH5bICdhJywgJ2UnLCAnaScsICdvJywgJ3UnIF0uaW5kZXhPZih0eXBlLmNoYXJBdCgwKSkgPyAnYW4gJyA6ICdhICc7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgdHlwZSA9PT0gXy50eXBlKG9iaikudG9Mb3dlckNhc2UoKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSAnICsgYXJ0aWNsZSArIHR5cGVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlICcgKyBhcnRpY2xlICsgdHlwZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdhbicsIGFuKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnYScsIGFuKTtcblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlKHZhbFssIG1zZ10pXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhIHN0cmluZywgYC5pbmNsdWRlYCBhc3NlcnRzIHRoYXQgdGhlIGdpdmVuIHN0cmluZyBgdmFsYFxuICAgKiBpcyBhIHN1YnN0cmluZyBvZiB0aGUgdGFyZ2V0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5pbmNsdWRlKCdmb28nKTtcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGFuIGFycmF5LCBgLmluY2x1ZGVgIGFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gYHZhbGAgaXMgYVxuICAgKiBtZW1iZXIgb2YgdGhlIHRhcmdldC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmluY2x1ZGUoMik7XG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhbiBvYmplY3QsIGAuaW5jbHVkZWAgYXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBvYmplY3RcbiAgICogYHZhbGAncyBwcm9wZXJ0aWVzIGFyZSBhIHN1YnNldCBvZiB0aGUgdGFyZ2V0J3MgcHJvcGVydGllcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMiwgYzogM30pLnRvLmluY2x1ZGUoe2E6IDEsIGI6IDJ9KTtcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgU2V0IG9yIFdlYWtTZXQsIGAuaW5jbHVkZWAgYXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBgdmFsYCBpcyBhXG4gICAqIG1lbWJlciBvZiB0aGUgdGFyZ2V0LiBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobSBpcyB1c2VkLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG5ldyBTZXQoWzEsIDJdKSkudG8uaW5jbHVkZSgyKTtcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgTWFwLCBgLmluY2x1ZGVgIGFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gYHZhbGAgaXMgb25lIG9mXG4gICAqIHRoZSB2YWx1ZXMgb2YgdGhlIHRhcmdldC4gU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG0gaXMgdXNlZC5cbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgTWFwKFtbJ2EnLCAxXSwgWydiJywgMl1dKSkudG8uaW5jbHVkZSgyKTtcbiAgICpcbiAgICogQmVjYXVzZSBgLmluY2x1ZGVgIGRvZXMgZGlmZmVyZW50IHRoaW5ncyBiYXNlZCBvbiB0aGUgdGFyZ2V0J3MgdHlwZSwgaXQnc1xuICAgKiBpbXBvcnRhbnQgdG8gY2hlY2sgdGhlIHRhcmdldCdzIHR5cGUgYmVmb3JlIHVzaW5nIGAuaW5jbHVkZWAuIFNlZSB0aGUgYC5hYFxuICAgKiBkb2MgZm9yIGluZm8gb24gdGVzdGluZyBhIHRhcmdldCdzIHR5cGUuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5iZS5hbignYXJyYXknKS50aGF0LmluY2x1ZGVzKDIpO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBzdHJpY3QgKGA9PT1gKSBlcXVhbGl0eSBpcyB1c2VkIHRvIGNvbXBhcmUgYXJyYXkgbWVtYmVycyBhbmRcbiAgICogb2JqZWN0IHByb3BlcnRpZXMuIEFkZCBgLmRlZXBgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIHVzZSBkZWVwIGVxdWFsaXR5XG4gICAqIGluc3RlYWQgKFdlYWtTZXQgdGFyZ2V0cyBhcmUgbm90IHN1cHBvcnRlZCkuIFNlZSB0aGUgYGRlZXAtZXFsYCBwcm9qZWN0XG4gICAqIHBhZ2UgZm9yIGluZm8gb24gdGhlIGRlZXAgZXF1YWxpdHkgYWxnb3JpdGhtOiBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IGFycmF5IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaW5jbHVkZXMgYHthOiAxfWBcbiAgICogICAgIGV4cGVjdChbe2E6IDF9XSkudG8uZGVlcC5pbmNsdWRlKHthOiAxfSk7XG4gICAqICAgICBleHBlY3QoW3thOiAxfV0pLnRvLm5vdC5pbmNsdWRlKHthOiAxfSk7XG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaW5jbHVkZXMgYHg6IHthOiAxfWBcbiAgICogICAgIGV4cGVjdCh7eDoge2E6IDF9fSkudG8uZGVlcC5pbmNsdWRlKHt4OiB7YTogMX19KTtcbiAgICogICAgIGV4cGVjdCh7eDoge2E6IDF9fSkudG8ubm90LmluY2x1ZGUoe3g6IHthOiAxfX0pO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBhbGwgb2YgdGhlIHRhcmdldCdzIHByb3BlcnRpZXMgYXJlIHNlYXJjaGVkIHdoZW4gd29ya2luZyB3aXRoXG4gICAqIG9iamVjdHMuIFRoaXMgaW5jbHVkZXMgcHJvcGVydGllcyB0aGF0IGFyZSBpbmhlcml0ZWQgYW5kL29yIG5vbi1lbnVtZXJhYmxlLlxuICAgKiBBZGQgYC5vd25gIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIGV4Y2x1ZGUgdGhlIHRhcmdldCdzIGluaGVyaXRlZFxuICAgKiBwcm9wZXJ0aWVzIGZyb20gdGhlIHNlYXJjaC5cbiAgICpcbiAgICogICAgIE9iamVjdC5wcm90b3R5cGUuYiA9IDI7XG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5vd24uaW5jbHVkZSh7YTogMX0pO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaW5jbHVkZSh7YjogMn0pLmJ1dC5ub3Qub3duLmluY2x1ZGUoe2I6IDJ9KTtcbiAgICpcbiAgICogTm90ZSB0aGF0IGEgdGFyZ2V0IG9iamVjdCBpcyBhbHdheXMgb25seSBzZWFyY2hlZCBmb3IgYHZhbGAncyBvd25cbiAgICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBgLmRlZXBgIGFuZCBgLm93bmAgY2FuIGJlIGNvbWJpbmVkLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiB7YjogMn19KS50by5kZWVwLm93bi5pbmNsdWRlKHthOiB7YjogMn19KTtcbiAgICpcbiAgICogQWRkIGAubmVzdGVkYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBlbmFibGUgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiB3aGVuXG4gICAqIHJlZmVyZW5jaW5nIG5lc3RlZCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiB7YjogWyd4JywgJ3knXX19KS50by5uZXN0ZWQuaW5jbHVkZSh7J2EuYlsxXSc6ICd5J30pO1xuICAgKlxuICAgKiBJZiBgLmAgb3IgYFtdYCBhcmUgcGFydCBvZiBhbiBhY3R1YWwgcHJvcGVydHkgbmFtZSwgdGhleSBjYW4gYmUgZXNjYXBlZCBieVxuICAgKiBhZGRpbmcgdHdvIGJhY2tzbGFzaGVzIGJlZm9yZSB0aGVtLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHsnLmEnOiB7J1tiXSc6IDJ9fSkudG8ubmVzdGVkLmluY2x1ZGUoeydcXFxcLmEuXFxcXFtiXFxcXF0nOiAyfSk7XG4gICAqXG4gICAqIGAuZGVlcGAgYW5kIGAubmVzdGVkYCBjYW4gYmUgY29tYmluZWQuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IHtiOiBbe2M6IDN9XX19KS50by5kZWVwLm5lc3RlZC5pbmNsdWRlKHsnYS5iWzBdJzoge2M6IDN9fSk7XG4gICAqXG4gICAqIGAub3duYCBhbmQgYC5uZXN0ZWRgIGNhbm5vdCBiZSBjb21iaW5lZC5cbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5pbmNsdWRlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8ubm90LmluY2x1ZGUoJ3RhY28nKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLm5vdC5pbmNsdWRlKDQpO1xuICAgKiBcbiAgICogSG93ZXZlciwgaXQncyBkYW5nZXJvdXMgdG8gbmVnYXRlIGAuaW5jbHVkZWAgd2hlbiB0aGUgdGFyZ2V0IGlzIGFuIG9iamVjdC5cbiAgICogVGhlIHByb2JsZW0gaXMgdGhhdCBpdCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnMgYnkgYXNzZXJ0aW5nIHRoYXQgdGhlXG4gICAqIHRhcmdldCBvYmplY3QgZG9lc24ndCBoYXZlIGFsbCBvZiBgdmFsYCdzIGtleS92YWx1ZSBwYWlycyBidXQgbWF5IG9yIG1heVxuICAgKiBub3QgaGF2ZSBzb21lIG9mIHRoZW0uIEl0J3Mgb2Z0ZW4gYmVzdCB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQnc1xuICAgKiBleHBlY3RlZCwgYW5kIHRoZW4gd3JpdGUgYW4gYXNzZXJ0aW9uIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgb2JqZWN0IGlzbid0IGV2ZW4gZXhwZWN0ZWQgdG8gaGF2ZSBgdmFsYCdzIGtleXMsIGl0J3NcbiAgICogb2Z0ZW4gYmVzdCB0byBhc3NlcnQgZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHtjOiAzfSkudG8ubm90LmhhdmUuYW55LmtleXMoJ2EnLCAnYicpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHtjOiAzfSkudG8ubm90LmluY2x1ZGUoe2E6IDEsIGI6IDJ9KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBvYmplY3QgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBgdmFsYCdzIGtleXMsIGl0J3Mgb2Z0ZW4gYmVzdCB0b1xuICAgKiBhc3NlcnQgdGhhdCBlYWNoIG9mIHRoZSBwcm9wZXJ0aWVzIGhhcyBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlciB0aGFuXG4gICAqIGFzc2VydGluZyB0aGF0IGVhY2ggcHJvcGVydHkgZG9lc24ndCBoYXZlIG9uZSBvZiBtYW55IHVuZXhwZWN0ZWQgdmFsdWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAzLCBiOiA0fSkudG8uaW5jbHVkZSh7YTogMywgYjogNH0pOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAzLCBiOiA0fSkudG8ubm90LmluY2x1ZGUoe2E6IDEsIGI6IDJ9KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAuaW5jbHVkZWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaW5jbHVkZSg0LCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaW5jbHVkZSg0KTtcbiAgICpcbiAgICogYC5pbmNsdWRlYCBjYW4gYWxzbyBiZSB1c2VkIGFzIGEgbGFuZ3VhZ2UgY2hhaW4sIGNhdXNpbmcgYWxsIGAubWVtYmVyc2AgYW5kXG4gICAqIGAua2V5c2AgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4gdG8gcmVxdWlyZSB0aGUgdGFyZ2V0IHRvIGJlIGFcbiAgICogc3VwZXJzZXQgb2YgdGhlIGV4cGVjdGVkIHNldCwgcmF0aGVyIHRoYW4gYW4gaWRlbnRpY2FsIHNldC4gTm90ZSB0aGF0XG4gICAqIGAubWVtYmVyc2AgaWdub3JlcyBkdXBsaWNhdGVzIGluIHRoZSBzdWJzZXQgd2hlbiBgLmluY2x1ZGVgIGlzIGFkZGVkLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCdzIGtleXMgYXJlIGEgc3VwZXJzZXQgb2YgWydhJywgJ2InXSBidXQgbm90IGlkZW50aWNhbFxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyLCBjOiAzfSkudG8uaW5jbHVkZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDIsIGM6IDN9KS50by5ub3QuaGF2ZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgYXJyYXkgaXMgYSBzdXBlcnNldCBvZiBbMSwgMl0gYnV0IG5vdCBpZGVudGljYWxcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmluY2x1ZGUubWVtYmVycyhbMSwgMl0pO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8ubm90LmhhdmUubWVtYmVycyhbMSwgMl0pO1xuICAgKlxuICAgKiAgICAgLy8gRHVwbGljYXRlcyBpbiB0aGUgc3Vic2V0IGFyZSBpZ25vcmVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5pbmNsdWRlLm1lbWJlcnMoWzEsIDIsIDIsIDJdKTtcbiAgICpcbiAgICogTm90ZSB0aGF0IGFkZGluZyBgLmFueWAgZWFybGllciBpbiB0aGUgY2hhaW4gY2F1c2VzIHRoZSBgLmtleXNgIGFzc2VydGlvblxuICAgKiB0byBpZ25vcmUgYC5pbmNsdWRlYC5cbiAgICpcbiAgICogICAgIC8vIEJvdGggYXNzZXJ0aW9ucyBhcmUgaWRlbnRpY2FsXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5pbmNsdWRlLmFueS5rZXlzKCdhJywgJ2InKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUuYW55LmtleXMoJ2EnLCAnYicpO1xuICAgKlxuICAgKiBUaGUgYWxpYXNlcyBgLmluY2x1ZGVzYCwgYC5jb250YWluYCwgYW5kIGAuY29udGFpbnNgIGNhbiBiZSB1c2VkXG4gICAqIGludGVyY2hhbmdlYWJseSB3aXRoIGAuaW5jbHVkZWAuXG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVcbiAgICogQGFsaWFzIGNvbnRhaW5cbiAgICogQGFsaWFzIGluY2x1ZGVzXG4gICAqIEBhbGlhcyBjb250YWluc1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIFNhbWVWYWx1ZVplcm8oYSwgYikge1xuICAgIHJldHVybiAoXy5pc05hTihhKSAmJiBfLmlzTmFOKGIpKSB8fCBhID09PSBiO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IgKCkge1xuICAgIGZsYWcodGhpcywgJ2NvbnRhaW5zJywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbmNsdWRlICh2YWwsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIFxuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBvYmpUeXBlID0gXy50eXBlKG9iaikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIG5lZ2F0ZSA9IGZsYWcodGhpcywgJ25lZ2F0ZScpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgaXNEZWVwID0gZmxhZyh0aGlzLCAnZGVlcCcpXG4gICAgICAsIGRlc2NyaXB0b3IgPSBpc0RlZXAgPyAnZGVlcCAnIDogJyc7XG5cbiAgICBmbGFnTXNnID0gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnIDogJyc7XG5cbiAgICB2YXIgaW5jbHVkZWQgPSBmYWxzZTtcblxuICAgIHN3aXRjaCAob2JqVHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgaW5jbHVkZWQgPSBvYmouaW5kZXhPZih2YWwpICE9PSAtMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3dlYWtzZXQnOlxuICAgICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICAgICAgZmxhZ01zZyArICd1bmFibGUgdG8gdXNlIC5kZWVwLmluY2x1ZGUgd2l0aCBXZWFrU2V0JyxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNzZmlcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5jbHVkZWQgPSBvYmouaGFzKHZhbCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtYXAnOlxuICAgICAgICB2YXIgaXNFcWwgPSBpc0RlZXAgPyBfLmVxbCA6IFNhbWVWYWx1ZVplcm87XG4gICAgICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaW5jbHVkZWQgPSBpbmNsdWRlZCB8fCBpc0VxbChpdGVtLCB2YWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgICBvYmouZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaW5jbHVkZWQgPSBpbmNsdWRlZCB8fCBfLmVxbChpdGVtLCB2YWwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluY2x1ZGVkID0gb2JqLmhhcyh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgICBpbmNsdWRlZCA9IG9iai5zb21lKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5lcWwoaXRlbSwgdmFsKTtcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluY2x1ZGVkID0gb2JqLmluZGV4T2YodmFsKSAhPT0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIFRoaXMgYmxvY2sgaXMgZm9yIGFzc2VydGluZyBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuIG9iamVjdC5cbiAgICAgICAgLy8gYF8uZXhwZWN0VHlwZXNgIGlzbid0IHVzZWQgaGVyZSBiZWNhdXNlIGAuaW5jbHVkZWAgc2hvdWxkIHdvcmsgd2l0aFxuICAgICAgICAvLyBvYmplY3RzIHdpdGggYSBjdXN0b20gYEBAdG9TdHJpbmdUYWdgLlxuICAgICAgICBpZiAodmFsICE9PSBPYmplY3QodmFsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgICAgIGZsYWdNc2cgKyAnb2JqZWN0IHRlc3RlZCBtdXN0IGJlIGFuIGFycmF5LCBhIG1hcCwgYW4gb2JqZWN0LCdcbiAgICAgICAgICAgICAgKyAnIGEgc2V0LCBhIHN0cmluZywgb3IgYSB3ZWFrc2V0LCBidXQgJyArIG9ialR5cGUgKyAnIGdpdmVuJyxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNzZmlcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3BzID0gT2JqZWN0LmtleXModmFsKVxuICAgICAgICAgICwgZmlyc3RFcnIgPSBudWxsXG4gICAgICAgICAgLCBudW1FcnJzID0gMDtcbiAgXG4gICAgICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICB2YXIgcHJvcEFzc2VydGlvbiA9IG5ldyBBc3NlcnRpb24ob2JqKTtcbiAgICAgICAgICBfLnRyYW5zZmVyRmxhZ3ModGhpcywgcHJvcEFzc2VydGlvbiwgdHJ1ZSk7XG4gICAgICAgICAgZmxhZyhwcm9wQXNzZXJ0aW9uLCAnbG9ja1NzZmknLCB0cnVlKTtcbiAgXG4gICAgICAgICAgaWYgKCFuZWdhdGUgfHwgcHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBwcm9wQXNzZXJ0aW9uLnByb3BlcnR5KHByb3AsIHZhbFtwcm9wXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvcEFzc2VydGlvbi5wcm9wZXJ0eShwcm9wLCB2YWxbcHJvcF0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKCFfLmNoZWNrRXJyb3IuY29tcGF0aWJsZUNvbnN0cnVjdG9yKGVyciwgQXNzZXJ0aW9uRXJyb3IpKSB7XG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdEVyciA9PT0gbnVsbCkgZmlyc3RFcnIgPSBlcnI7XG4gICAgICAgICAgICBudW1FcnJzKys7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgXG4gICAgICAgIC8vIFdoZW4gdmFsaWRhdGluZyAubm90LmluY2x1ZGUgd2l0aCBtdWx0aXBsZSBwcm9wZXJ0aWVzLCB3ZSBvbmx5IHdhbnRcbiAgICAgICAgLy8gdG8gdGhyb3cgYW4gYXNzZXJ0aW9uIGVycm9yIGlmIGFsbCBvZiB0aGUgcHJvcGVydGllcyBhcmUgaW5jbHVkZWQsXG4gICAgICAgIC8vIGluIHdoaWNoIGNhc2Ugd2UgdGhyb3cgdGhlIGZpcnN0IHByb3BlcnR5IGFzc2VydGlvbiBlcnJvciB0aGF0IHdlXG4gICAgICAgIC8vIGVuY291bnRlcmVkLlxuICAgICAgICBpZiAobmVnYXRlICYmIHByb3BzLmxlbmd0aCA+IDEgJiYgbnVtRXJycyA9PT0gcHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgZmlyc3RFcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEFzc2VydCBpbmNsdXNpb24gaW4gY29sbGVjdGlvbiBvciBzdWJzdHJpbmcgaW4gYSBzdHJpbmcuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBpbmNsdWRlZFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byAnICsgZGVzY3JpcHRvciArICdpbmNsdWRlICcgKyBfLmluc3BlY3QodmFsKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgJyArIGRlc2NyaXB0b3IgKyAnaW5jbHVkZSAnICsgXy5pbnNwZWN0KHZhbCkpO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnaW5jbHVkZScsIGluY2x1ZGUsIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnY29udGFpbicsIGluY2x1ZGUsIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnY29udGFpbnMnLCBpbmNsdWRlLCBpbmNsdWRlQ2hhaW5pbmdCZWhhdmlvcik7XG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2luY2x1ZGVzJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuXG4gIC8qKlxuICAgKiAjIyMgLm9rXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGxvb3NlbHkgKGA9PWApIGVxdWFsIHRvIGB0cnVlYC4gSG93ZXZlciwgaXQnc1xuICAgKiBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgc3RyaWN0bHkgKGA9PT1gKSBvciBkZWVwbHkgZXF1YWwgdG9cbiAgICogaXRzIGV4cGVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLm9rOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdCh0cnVlKS50by5iZS50cnVlOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHRydWUpLnRvLmJlLm9rOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5va2AuXG4gICAqXG4gICAqICAgICBleHBlY3QoMCkudG8uZXF1YWwoMCk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMCkudG8ubm90LmJlLm9rOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChmYWxzZSkudG8uYmUuZmFsc2U7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoZmFsc2UpLnRvLm5vdC5iZS5vazsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QobnVsbCkudG8uYmUubnVsbDsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChudWxsKS50by5ub3QuYmUub2s7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkudG8uYmUudW5kZWZpbmVkOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkudG8ubm90LmJlLm9rOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdChmYWxzZSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLm9rO1xuICAgKlxuICAgKiBAbmFtZSBva1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ29rJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB0cnV0aHknXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHN5Jyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnRydWVcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgc3RyaWN0bHkgKGA9PT1gKSBlcXVhbCB0byBgdHJ1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QodHJ1ZSkudG8uYmUudHJ1ZTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC50cnVlYC4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0XG4gICAqIHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXIgdGhhbiBub3RcbiAgICogZXF1YWwgdG8gYHRydWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZhbHNlKS50by5iZS5mYWxzZTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChmYWxzZSkudG8ubm90LmJlLnRydWU7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS50cnVlOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdChmYWxzZSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLnRydWU7XG4gICAqXG4gICAqIEBuYW1lIHRydWVcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCd0cnVlJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0cnVlID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB0cnVlJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBmYWxzZSdcbiAgICAgICwgZmxhZyh0aGlzLCAnbmVnYXRlJykgPyBmYWxzZSA6IHRydWVcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5mYWxzZVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBzdHJpY3RseSAoYD09PWApIGVxdWFsIHRvIGBmYWxzZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoZmFsc2UpLnRvLmJlLmZhbHNlO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmZhbHNlYC4gSG93ZXZlciwgaXQncyBvZnRlblxuICAgKiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXIgdGhhblxuICAgKiBub3QgZXF1YWwgdG8gYGZhbHNlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh0cnVlKS50by5iZS50cnVlOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHRydWUpLnRvLm5vdC5iZS5mYWxzZTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmJlLmZhbHNlOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh0cnVlLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuZmFsc2U7XG4gICAqXG4gICAqIEBuYW1lIGZhbHNlXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZmFsc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGZhbHNlID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBmYWxzZSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgdHJ1ZSdcbiAgICAgICwgZmxhZyh0aGlzLCAnbmVnYXRlJykgPyB0cnVlIDogZmFsc2VcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5udWxsXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHN0cmljdGx5IChgPT09YCkgZXF1YWwgdG8gYG51bGxgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLmJlLm51bGw7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAubnVsbGAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdFxuICAgKiB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZCB2YWx1ZSwgcmF0aGVyIHRoYW4gbm90XG4gICAqIGVxdWFsIHRvIGBudWxsYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUubnVsbDsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoNDIsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5udWxsO1xuICAgKlxuICAgKiBAbmFtZSBudWxsXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnbnVsbCcsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgbnVsbCA9PT0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgbnVsbCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIG51bGwnXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAudW5kZWZpbmVkXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHN0cmljdGx5IChgPT09YCkgZXF1YWwgdG8gYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5iZS51bmRlZmluZWQ7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAudW5kZWZpbmVkYC4gSG93ZXZlciwgaXQncyBvZnRlblxuICAgKiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXIgdGhhblxuICAgKiBub3QgZXF1YWwgdG8gYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmJlLnVuZGVmaW5lZDsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoNDIsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS51bmRlZmluZWQ7XG4gICAqXG4gICAqIEBuYW1lIHVuZGVmaW5lZFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ3VuZGVmaW5lZCcsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgdW5kZWZpbmVkID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB1bmRlZmluZWQnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSB1bmRlZmluZWQnXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuTmFOXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGV4YWN0bHkgYE5hTmAuXG4gICAqXG4gICAqICAgICBleHBlY3QoTmFOKS50by5iZS5OYU47XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuTmFOYC4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0XG4gICAqIHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXIgdGhhbiBub3RcbiAgICogZXF1YWwgdG8gYE5hTmAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmVxdWFsKCdmb28nKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8ubm90LmJlLk5hTjsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoNDIsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5OYU47XG4gICAqXG4gICAqIEBuYW1lIE5hTlxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ05hTicsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgXy5pc05hTihmbGFnKHRoaXMsICdvYmplY3QnKSlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBOYU4nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIE5hTidcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5leGlzdFxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBub3Qgc3RyaWN0bHkgKGA9PT1gKSBlcXVhbCB0byBlaXRoZXIgYG51bGxgIG9yXG4gICAqIGB1bmRlZmluZWRgLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0b1xuICAgKiBpdHMgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8uZXhpc3Q7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KDApLnRvLmVxdWFsKDApOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDApLnRvLmV4aXN0OyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5leGlzdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QobnVsbCkudG8uYmUubnVsbDsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChudWxsKS50by5ub3QuZXhpc3Q7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkudG8uYmUudW5kZWZpbmVkOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkudG8ubm90LmV4aXN0OyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdChudWxsLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uZXhpc3Q7XG4gICAqXG4gICAqIEBuYW1lIGV4aXN0XG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZXhpc3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbCA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB2YWwgIT09IG51bGwgJiYgdmFsICE9PSB1bmRlZmluZWRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXhpc3QnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBleGlzdCdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5lbXB0eVxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBzdHJpbmcgb3IgYXJyYXksIGAuZW1wdHlgIGFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0J3NcbiAgICogYGxlbmd0aGAgcHJvcGVydHkgaXMgc3RyaWN0bHkgKGA9PT1gKSBlcXVhbCB0byBgMGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoW10pLnRvLmJlLmVtcHR5O1xuICAgKiAgICAgZXhwZWN0KCcnKS50by5iZS5lbXB0eTtcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgbWFwIG9yIHNldCwgYC5lbXB0eWAgYXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQncyBgc2l6ZWBcbiAgICogcHJvcGVydHkgaXMgc3RyaWN0bHkgZXF1YWwgdG8gYDBgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG5ldyBTZXQoKSkudG8uYmUuZW1wdHk7XG4gICAqICAgICBleHBlY3QobmV3IE1hcCgpKS50by5iZS5lbXB0eTtcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgbm9uLWZ1bmN0aW9uIG9iamVjdCwgYC5lbXB0eWAgYXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXRcbiAgICogZG9lc24ndCBoYXZlIGFueSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBQcm9wZXJ0aWVzIHdpdGggU3ltYm9sLWJhc2VkXG4gICAqIGtleXMgYXJlIGV4Y2x1ZGVkIGZyb20gdGhlIGNvdW50LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHt9KS50by5iZS5lbXB0eTtcbiAgICpcbiAgICogQmVjYXVzZSBgLmVtcHR5YCBkb2VzIGRpZmZlcmVudCB0aGluZ3MgYmFzZWQgb24gdGhlIHRhcmdldCdzIHR5cGUsIGl0J3NcbiAgICogaW1wb3J0YW50IHRvIGNoZWNrIHRoZSB0YXJnZXQncyB0eXBlIGJlZm9yZSB1c2luZyBgLmVtcHR5YC4gU2VlIHRoZSBgLmFgXG4gICAqIGRvYyBmb3IgaW5mbyBvbiB0ZXN0aW5nIGEgdGFyZ2V0J3MgdHlwZS5cbiAgICpcbiAgICogICAgIGV4cGVjdChbXSkudG8uYmUuYW4oJ2FycmF5JykudGhhdC5pcy5lbXB0eTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5lbXB0eWAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW5cbiAgICogYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGNvbnRhaW5zIGl0cyBleHBlY3RlZCBudW1iZXIgb2YgdmFsdWVzLFxuICAgKiByYXRoZXIgdGhhbiBhc3NlcnRpbmcgdGhhdCBpdCdzIG5vdCBlbXB0eS5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5ub3QuYmUuZW1wdHk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KG5ldyBTZXQoWzEsIDIsIDNdKSkudG8uaGF2ZS5wcm9wZXJ0eSgnc2l6ZScsIDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KG5ldyBTZXQoWzEsIDIsIDNdKSkudG8ubm90LmJlLmVtcHR5OyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChPYmplY3Qua2V5cyh7YTogMX0pKS50by5oYXZlLmxlbmd0aE9mKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmJlLmVtcHR5OyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10sICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5lbXB0eTtcbiAgICpcbiAgICogQG5hbWUgZW1wdHlcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdlbXB0eScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIGl0ZW1zQ291bnQ7XG5cbiAgICBmbGFnTXNnID0gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnIDogJyc7XG5cbiAgICBzd2l0Y2ggKF8udHlwZSh2YWwpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGl0ZW1zQ291bnQgPSB2YWwubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21hcCc6XG4gICAgICBjYXNlICdzZXQnOlxuICAgICAgICBpdGVtc0NvdW50ID0gdmFsLnNpemU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2Vha21hcCc6XG4gICAgICBjYXNlICd3ZWFrc2V0JzpcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICAgIGZsYWdNc2cgKyAnLmVtcHR5IHdhcyBwYXNzZWQgYSB3ZWFrIGNvbGxlY3Rpb24nLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBzc2ZpXG4gICAgICAgICk7XG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIHZhciBtc2cgPSBmbGFnTXNnICsgJy5lbXB0eSB3YXMgcGFzc2VkIGEgZnVuY3Rpb24gJyArIF8uZ2V0TmFtZSh2YWwpO1xuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobXNnLnRyaW0oKSwgdW5kZWZpbmVkLCBzc2ZpKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh2YWwgIT09IE9iamVjdCh2YWwpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICAgICAgZmxhZ01zZyArICcuZW1wdHkgd2FzIHBhc3NlZCBub24tc3RyaW5nIHByaW1pdGl2ZSAnICsgXy5pbnNwZWN0KHZhbCksXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICBzc2ZpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpdGVtc0NvdW50ID0gT2JqZWN0LmtleXModmFsKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIDAgPT09IGl0ZW1zQ291bnRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZW1wdHknXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSBlbXB0eSdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hcmd1bWVudHNcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gdGVzdCAoKSB7XG4gICAqICAgICAgIGV4cGVjdChhcmd1bWVudHMpLnRvLmJlLmFyZ3VtZW50cztcbiAgICogICAgIH1cbiAgICpcbiAgICogICAgIHRlc3QoKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5hcmd1bWVudHNgLiBIb3dldmVyLCBpdCdzIG9mdGVuXG4gICAqIGJlc3QgdG8gYXNzZXJ0IHdoaWNoIHR5cGUgdGhlIHRhcmdldCBpcyBleHBlY3RlZCB0byBiZSwgcmF0aGVyIHRoYW5cbiAgICogYXNzZXJ0aW5nIHRoYXQgaXRzIG5vdCBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmJlLmEoJ3N0cmluZycpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5ub3QuYmUuYXJndW1lbnRzOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7fSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmFyZ3VtZW50cztcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuQXJndW1lbnRzYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmFyZ3VtZW50c2AuXG4gICAqXG4gICAqIEBuYW1lIGFyZ3VtZW50c1xuICAgKiBAYWxpYXMgQXJndW1lbnRzXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNoZWNrQXJndW1lbnRzICgpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgdHlwZSA9IF8udHlwZShvYmopO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAnQXJndW1lbnRzJyA9PT0gdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhcmd1bWVudHMgYnV0IGdvdCAnICsgdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYXJndW1lbnRzJ1xuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2FyZ3VtZW50cycsIGNoZWNrQXJndW1lbnRzKTtcbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdBcmd1bWVudHMnLCBjaGVja0FyZ3VtZW50cyk7XG5cbiAgLyoqXG4gICAqICMjIyAuZXF1YWwodmFsWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgc3RyaWN0bHkgKGA9PT1gKSBlcXVhbCB0byB0aGUgZ2l2ZW4gYHZhbGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7XG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmVxdWFsKCdmb28nKTtcbiAgICogXG4gICAqIEFkZCBgLmRlZXBgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIHVzZSBkZWVwIGVxdWFsaXR5IGluc3RlYWQuIFNlZSB0aGVcbiAgICogYGRlZXAtZXFsYCBwcm9qZWN0IHBhZ2UgZm9yIGluZm8gb24gdGhlIGRlZXAgZXF1YWxpdHkgYWxnb3JpdGhtOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGVxdWFscyBge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uZGVlcC5lcXVhbCh7YTogMX0pO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmVxdWFsKHthOiAxfSk7XG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgYXJyYXkgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBlcXVhbHMgYFsxLCAyXWBcbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLmRlZXAuZXF1YWwoWzEsIDJdKTtcbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLm5vdC5lcXVhbChbMSwgMl0pO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmVxdWFsYC4gSG93ZXZlciwgaXQncyBvZnRlblxuICAgKiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXIgdGhhblxuICAgKiBub3QgZXF1YWwgdG8gb25lIG9mIGNvdW50bGVzcyB1bmV4cGVjdGVkIHZhbHVlcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuZXF1YWwoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmVxdWFsYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMiwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDEsICdub29vIHdoeSBmYWlsPz8nKS50by5lcXVhbCgyKTtcbiAgICpcbiAgICogVGhlIGFsaWFzZXMgYC5lcXVhbHNgIGFuZCBgZXFgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuZXF1YWxgLlxuICAgKlxuICAgKiBAbmFtZSBlcXVhbFxuICAgKiBAYWxpYXMgZXF1YWxzXG4gICAqIEBhbGlhcyBlcVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEVxdWFsICh2YWwsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBpZiAoZmxhZyh0aGlzLCAnZGVlcCcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcWwodmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgdmFsID09PSBvYmpcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBlcXVhbCAje2V4cH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGVxdWFsICN7ZXhwfSdcbiAgICAgICAgLCB2YWxcbiAgICAgICAgLCB0aGlzLl9vYmpcbiAgICAgICAgLCB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxdWFsJywgYXNzZXJ0RXF1YWwpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcXVhbHMnLCBhc3NlcnRFcXVhbCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxJywgYXNzZXJ0RXF1YWwpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmVxbChvYmpbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBkZWVwbHkgZXF1YWwgdG8gdGhlIGdpdmVuIGBvYmpgLiBTZWUgdGhlXG4gICAqIGBkZWVwLWVxbGAgcHJvamVjdCBwYWdlIGZvciBpbmZvIG9uIHRoZSBkZWVwIGVxdWFsaXR5IGFsZ29yaXRobTpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9kZWVwLWVxbC5cbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBvYmplY3QgaXMgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBlcXVhbCB0byB7YTogMX1cbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmVxbCh7YTogMX0pLmJ1dC5ub3QuZXF1YWwoe2E6IDF9KTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBhcnJheSBpcyBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGVxdWFsIHRvIFsxLCAyXVxuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8uZXFsKFsxLCAyXSkuYnV0Lm5vdC5lcXVhbChbMSwgMl0pO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmVxbGAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdFxuICAgKiB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGRlZXBseSBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlclxuICAgKiB0aGFuIG5vdCBkZWVwbHkgZXF1YWwgdG8gb25lIG9mIGNvdW50bGVzcyB1bmV4cGVjdGVkIHZhbHVlcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmVxbCh7YTogMX0pOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmVxbCh7YjogMn0pOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5lcWxgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmVxbCh7YjogMn0sICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0sICdub29vIHdoeSBmYWlsPz8nKS50by5lcWwoe2I6IDJ9KTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuZXFsc2AgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5lcWxgLlxuICAgKlxuICAgKiBUaGUgYC5kZWVwLmVxdWFsYCBhc3NlcnRpb24gaXMgYWxtb3N0IGlkZW50aWNhbCB0byBgLmVxbGAgYnV0IHdpdGggb25lXG4gICAqIGRpZmZlcmVuY2U6IGAuZGVlcC5lcXVhbGAgY2F1c2VzIGRlZXAgZXF1YWxpdHkgY29tcGFyaXNvbnMgdG8gYWxzbyBiZSB1c2VkXG4gICAqIGZvciBhbnkgb3RoZXIgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4uXG4gICAqXG4gICAqIEBuYW1lIGVxbFxuICAgKiBAYWxpYXMgZXFsc1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEVxbChvYmosIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBfLmVxbChvYmosIGZsYWcodGhpcywgJ29iamVjdCcpKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBkZWVwbHkgZXF1YWwgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZGVlcGx5IGVxdWFsICN7ZXhwfSdcbiAgICAgICwgb2JqXG4gICAgICAsIHRoaXMuX29ialxuICAgICAgLCB0cnVlXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxbCcsIGFzc2VydEVxbCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxbHMnLCBhc3NlcnRFcWwpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmFib3ZlKG5bLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIG51bWJlciBvciBhIGRhdGUgZ3JlYXRlciB0aGFuIHRoZSBnaXZlbiBudW1iZXIgb3IgZGF0ZSBgbmAgcmVzcGVjdGl2ZWx5LlxuICAgKiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWRcbiAgICogdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoMikudG8uZXF1YWwoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMikudG8uYmUuYWJvdmUoMSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5sZW5ndGhPZmAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gYXNzZXJ0IHRoYXQgdGhlIHZhbHVlIG9mIHRoZVxuICAgKiB0YXJnZXQncyBgbGVuZ3RoYCBwcm9wZXJ0eSBpcyBncmVhdGVyIHRoYW4gdGhlIGdpdmVuIG51bWJlciBgbmAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YuYWJvdmUoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YuYWJvdmUoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmFib3ZlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgyKS50by5lcXVhbCgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUuYWJvdmUoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmFib3ZlYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuYWJvdmUoMiwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDEsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5hYm92ZSgyKTtcbiAgICpcbiAgICogVGhlIGFsaWFzZXMgYC5ndGAgYW5kIGAuZ3JlYXRlclRoYW5gIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoXG4gICAqIGAuYWJvdmVgLlxuICAgKlxuICAgKiBAbmFtZSBhYm92ZVxuICAgKiBAYWxpYXMgZ3RcbiAgICogQGFsaWFzIGdyZWF0ZXJUaGFuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRBYm92ZSAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGRvTGVuZ3RoID0gZmxhZyh0aGlzLCAnZG9MZW5ndGgnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIG1zZ1ByZWZpeCA9ICgoZmxhZ01zZykgPyBmbGFnTXNnICsgJzogJyA6ICcnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIG9ialR5cGUgPSBfLnR5cGUob2JqKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIG5UeXBlID0gXy50eXBlKG4pLnRvTG93ZXJDYXNlKClcbiAgICAgICwgc2hvdWxkVGhyb3cgPSB0cnVlO1xuXG4gICAgaWYgKGRvTGVuZ3RoKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgfVxuICAgIFxuICAgIGlmICghZG9MZW5ndGggJiYgKG9ialR5cGUgPT09ICdkYXRlJyAmJiBuVHlwZSAhPT0gJ2RhdGUnKSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ3RoZSBhcmd1bWVudCB0byBhYm92ZSBtdXN0IGJlIGEgZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChuVHlwZSAhPT0gJ251bWJlcicgJiYgKGRvTGVuZ3RoIHx8IG9ialR5cGUgPT09ICdudW1iZXInKSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ3RoZSBhcmd1bWVudCB0byBhYm92ZSBtdXN0IGJlIGEgbnVtYmVyJztcbiAgICB9IGVsc2UgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSAhPT0gJ2RhdGUnICYmIG9ialR5cGUgIT09ICdudW1iZXInKSkge1xuICAgICAgdmFyIHByaW50T2JqID0gKG9ialR5cGUgPT09ICdzdHJpbmcnKSA/IFwiJ1wiICsgb2JqICsgXCInXCIgOiBvYmo7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAnZXhwZWN0ZWQgJyArIHByaW50T2JqICsgJyB0byBiZSBhIG51bWJlciBvciBhIGRhdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRUaHJvdyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKGVycm9yTWVzc2FnZSwgdW5kZWZpbmVkLCBzc2ZpKTtcbiAgICB9XG5cbiAgICBpZiAoZG9MZW5ndGgpIHtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuID4gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYWJvdmUgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgbGVuZ3RoIGFib3ZlICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICAgICwgbGVuXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPiBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYWJvdmUgI3tleHB9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGF0IG1vc3QgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYWJvdmUnLCBhc3NlcnRBYm92ZSk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2d0JywgYXNzZXJ0QWJvdmUpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdncmVhdGVyVGhhbicsIGFzc2VydEFib3ZlKTtcblxuICAvKipcbiAgICogIyMjIC5sZWFzdChuWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYSBudW1iZXIgb3IgYSBkYXRlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW5cbiAgICogbnVtYmVyIG9yIGRhdGUgYG5gIHJlc3BlY3RpdmVseS4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG9cbiAgICogaXRzIGV4cGVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmVxdWFsKDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmJlLmF0LmxlYXN0KDEpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgyKS50by5iZS5hdC5sZWFzdCgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLmxlbmd0aE9mYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBhc3NlcnQgdGhhdCB0aGUgdmFsdWUgb2YgdGhlXG4gICAqIHRhcmdldCdzIGBsZW5ndGhgIHByb3BlcnR5IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gbnVtYmVyXG4gICAqIGBuYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZi5hdC5sZWFzdCgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZi5hdC5sZWFzdCgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAubGVhc3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS5hdC5sZWFzdCgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAubGVhc3RgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5hdC5sZWFzdCgyLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoMSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmF0LmxlYXN0KDIpO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5ndGVgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAubGVhc3RgLlxuICAgKlxuICAgKiBAbmFtZSBsZWFzdFxuICAgKiBAYWxpYXMgZ3RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRMZWFzdCAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGRvTGVuZ3RoID0gZmxhZyh0aGlzLCAnZG9MZW5ndGgnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIG1zZ1ByZWZpeCA9ICgoZmxhZ01zZykgPyBmbGFnTXNnICsgJzogJyA6ICcnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIG9ialR5cGUgPSBfLnR5cGUob2JqKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIG5UeXBlID0gXy50eXBlKG4pLnRvTG93ZXJDYXNlKClcbiAgICAgICwgc2hvdWxkVGhyb3cgPSB0cnVlO1xuXG4gICAgaWYgKGRvTGVuZ3RoKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSA9PT0gJ2RhdGUnICYmIG5UeXBlICE9PSAnZGF0ZScpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50IHRvIGxlYXN0IG11c3QgYmUgYSBkYXRlJztcbiAgICB9IGVsc2UgaWYgKG5UeXBlICE9PSAnbnVtYmVyJyAmJiAoZG9MZW5ndGggfHwgb2JqVHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50IHRvIGxlYXN0IG11c3QgYmUgYSBudW1iZXInO1xuICAgIH0gZWxzZSBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlICE9PSAnZGF0ZScgJiYgb2JqVHlwZSAhPT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgcHJpbnRPYmogPSAob2JqVHlwZSA9PT0gJ3N0cmluZycpID8gXCInXCIgKyBvYmogKyBcIidcIiA6IG9iajtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICdleHBlY3RlZCAnICsgcHJpbnRPYmogKyAnIHRvIGJlIGEgbnVtYmVyIG9yIGEgZGF0ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFRocm93ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyb3JNZXNzYWdlLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgIH1cblxuICAgIGlmIChkb0xlbmd0aCkge1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPj0gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYXQgbGVhc3QgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYmVsb3cgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA+PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbGVhc3QgI3tleHB9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGJlbG93ICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2xlYXN0JywgYXNzZXJ0TGVhc3QpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdndGUnLCBhc3NlcnRMZWFzdCk7XG5cbiAgLyoqXG4gICAqICMjIyAuYmVsb3coblssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyIG9yIGEgZGF0ZSBsZXNzIHRoYW4gdGhlIGdpdmVuIG51bWJlciBvciBkYXRlIGBuYCByZXNwZWN0aXZlbHkuXG4gICAqIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZFxuICAgKiB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5iZWxvdygyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLmxlbmd0aE9mYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBhc3NlcnQgdGhhdCB0aGUgdmFsdWUgb2YgdGhlXG4gICAqIHRhcmdldCdzIGBsZW5ndGhgIHByb3BlcnR5IGlzIGxlc3MgdGhhbiB0aGUgZ2l2ZW4gbnVtYmVyIGBuYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZi5iZWxvdyg0KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aCgzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YuYmVsb3coNCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmJlbG93YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgyKS50by5lcXVhbCgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgyKS50by5ub3QuYmUuYmVsb3coMSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmJlbG93YCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMikudG8uYmUuYmVsb3coMSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDIsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5iZWxvdygxKTtcbiAgICpcbiAgICogVGhlIGFsaWFzZXMgYC5sdGAgYW5kIGAubGVzc1RoYW5gIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoXG4gICAqIGAuYmVsb3dgLlxuICAgKlxuICAgKiBAbmFtZSBiZWxvd1xuICAgKiBAYWxpYXMgbHRcbiAgICogQGFsaWFzIGxlc3NUaGFuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRCZWxvdyAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGRvTGVuZ3RoID0gZmxhZyh0aGlzLCAnZG9MZW5ndGgnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIG1zZ1ByZWZpeCA9ICgoZmxhZ01zZykgPyBmbGFnTXNnICsgJzogJyA6ICcnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIG9ialR5cGUgPSBfLnR5cGUob2JqKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIG5UeXBlID0gXy50eXBlKG4pLnRvTG93ZXJDYXNlKClcbiAgICAgICwgc2hvdWxkVGhyb3cgPSB0cnVlO1xuXG4gICAgaWYgKGRvTGVuZ3RoKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSA9PT0gJ2RhdGUnICYmIG5UeXBlICE9PSAnZGF0ZScpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50IHRvIGJlbG93IG11c3QgYmUgYSBkYXRlJztcbiAgICB9IGVsc2UgaWYgKG5UeXBlICE9PSAnbnVtYmVyJyAmJiAoZG9MZW5ndGggfHwgb2JqVHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50IHRvIGJlbG93IG11c3QgYmUgYSBudW1iZXInO1xuICAgIH0gZWxzZSBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlICE9PSAnZGF0ZScgJiYgb2JqVHlwZSAhPT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgcHJpbnRPYmogPSAob2JqVHlwZSA9PT0gJ3N0cmluZycpID8gXCInXCIgKyBvYmogKyBcIidcIiA6IG9iajtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICdleHBlY3RlZCAnICsgcHJpbnRPYmogKyAnIHRvIGJlIGEgbnVtYmVyIG9yIGEgZGF0ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFRocm93ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyb3JNZXNzYWdlLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgIH1cblxuICAgIGlmIChkb0xlbmd0aCkge1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPCBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBiZWxvdyAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSBsZW5ndGggYmVsb3cgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA8IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBiZWxvdyAje2V4cH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbGVhc3QgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYmVsb3cnLCBhc3NlcnRCZWxvdyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2x0JywgYXNzZXJ0QmVsb3cpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsZXNzVGhhbicsIGFzc2VydEJlbG93KTtcblxuICAvKipcbiAgICogIyMjIC5tb3N0KG5bLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIG51bWJlciBvciBhIGRhdGUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiBudW1iZXJcbiAgICogb3IgZGF0ZSBgbmAgcmVzcGVjdGl2ZWx5LiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHNcbiAgICogZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuYXQubW9zdCgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuYXQubW9zdCgxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLmxlbmd0aE9mYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBhc3NlcnQgdGhhdCB0aGUgdmFsdWUgb2YgdGhlXG4gICAqIHRhcmdldCdzIGBsZW5ndGhgIHByb3BlcnR5IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gbnVtYmVyIGBuYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZi5hdC5tb3N0KDQpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLmF0Lm1vc3QoNCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLm1vc3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmVxdWFsKDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLm5vdC5iZS5hdC5tb3N0KDEpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5tb3N0YCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMikudG8uYmUuYXQubW9zdCgxLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoMiwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmF0Lm1vc3QoMSk7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmx0ZWAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5tb3N0YC5cbiAgICpcbiAgICogQG5hbWUgbW9zdFxuICAgKiBAYWxpYXMgbHRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRNb3N0IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZG9MZW5ndGggPSBmbGFnKHRoaXMsICdkb0xlbmd0aCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgbXNnUHJlZml4ID0gKChmbGFnTXNnKSA/IGZsYWdNc2cgKyAnOiAnIDogJycpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgb2JqVHlwZSA9IF8udHlwZShvYmopLnRvTG93ZXJDYXNlKClcbiAgICAgICwgblR5cGUgPSBfLnR5cGUobikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBzaG91bGRUaHJvdyA9IHRydWU7XG5cbiAgICBpZiAoZG9MZW5ndGgpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSA9PT0gJ2RhdGUnICYmIG5UeXBlICE9PSAnZGF0ZScpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50IHRvIG1vc3QgbXVzdCBiZSBhIGRhdGUnO1xuICAgIH0gZWxzZSBpZiAoblR5cGUgIT09ICdudW1iZXInICYmIChkb0xlbmd0aCB8fCBvYmpUeXBlID09PSAnbnVtYmVyJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnQgdG8gbW9zdCBtdXN0IGJlIGEgbnVtYmVyJztcbiAgICB9IGVsc2UgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSAhPT0gJ2RhdGUnICYmIG9ialR5cGUgIT09ICdudW1iZXInKSkge1xuICAgICAgdmFyIHByaW50T2JqID0gKG9ialR5cGUgPT09ICdzdHJpbmcnKSA/IFwiJ1wiICsgb2JqICsgXCInXCIgOiBvYmo7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAnZXhwZWN0ZWQgJyArIHByaW50T2JqICsgJyB0byBiZSBhIG51bWJlciBvciBhIGRhdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRUaHJvdyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKGVycm9yTWVzc2FnZSwgdW5kZWZpbmVkLCBzc2ZpKTtcbiAgICB9XG5cbiAgICBpZiAoZG9MZW5ndGgpIHtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuIDw9IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIGF0IG1vc3QgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYWJvdmUgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA8PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbW9zdCAje2V4cH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYWJvdmUgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbW9zdCcsIGFzc2VydE1vc3QpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsdGUnLCBhc3NlcnRNb3N0KTtcblxuICAvKipcbiAgICogIyMjIC53aXRoaW4oc3RhcnQsIGZpbmlzaFssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyIG9yIGEgZGF0ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuXG4gICAqIG51bWJlciBvciBkYXRlIGBzdGFydGAsIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIG51bWJlciBvciBkYXRlIGBmaW5pc2hgIHJlc3BlY3RpdmVseS5cbiAgICogSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkXG4gICAqIHZhbHVlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmVxdWFsKDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmJlLndpdGhpbigxLCAzKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMikudG8uYmUud2l0aGluKDIsIDMpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgyKS50by5iZS53aXRoaW4oMSwgMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5sZW5ndGhPZmAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gYXNzZXJ0IHRoYXQgdGhlIHZhbHVlIG9mIHRoZVxuICAgKiB0YXJnZXQncyBgbGVuZ3RoYCBwcm9wZXJ0eSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIG51bWJlclxuICAgKiBgc3RhcnRgLCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiBudW1iZXIgYGZpbmlzaGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2Yud2l0aGluKDIsIDQpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLndpdGhpbigyLCA0KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAud2l0aGluYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUud2l0aGluKDIsIDQpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC53aXRoaW5gIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg0KS50by5iZS53aXRoaW4oMSwgMywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDQsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS53aXRoaW4oMSwgMyk7XG4gICAqXG4gICAqIEBuYW1lIHdpdGhpblxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgbG93ZXIgYm91bmQgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmaW5pc2ggdXBwZXIgYm91bmQgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCd3aXRoaW4nLCBmdW5jdGlvbiAoc3RhcnQsIGZpbmlzaCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGRvTGVuZ3RoID0gZmxhZyh0aGlzLCAnZG9MZW5ndGgnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIG1zZ1ByZWZpeCA9ICgoZmxhZ01zZykgPyBmbGFnTXNnICsgJzogJyA6ICcnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIG9ialR5cGUgPSBfLnR5cGUob2JqKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIHN0YXJ0VHlwZSA9IF8udHlwZShzdGFydCkudG9Mb3dlckNhc2UoKVxuICAgICAgLCBmaW5pc2hUeXBlID0gXy50eXBlKGZpbmlzaCkudG9Mb3dlckNhc2UoKVxuICAgICAgLCBzaG91bGRUaHJvdyA9IHRydWVcbiAgICAgICwgcmFuZ2UgPSAoc3RhcnRUeXBlID09PSAnZGF0ZScgJiYgZmluaXNoVHlwZSA9PT0gJ2RhdGUnKVxuICAgICAgICAgID8gc3RhcnQudG9VVENTdHJpbmcoKSArICcuLicgKyBmaW5pc2gudG9VVENTdHJpbmcoKVxuICAgICAgICAgIDogc3RhcnQgKyAnLi4nICsgZmluaXNoO1xuXG4gICAgaWYgKGRvTGVuZ3RoKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSA9PT0gJ2RhdGUnICYmIChzdGFydFR5cGUgIT09ICdkYXRlJyB8fCBmaW5pc2hUeXBlICE9PSAnZGF0ZScpKSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ3RoZSBhcmd1bWVudHMgdG8gd2l0aGluIG11c3QgYmUgZGF0ZXMnO1xuICAgIH0gZWxzZSBpZiAoKHN0YXJ0VHlwZSAhPT0gJ251bWJlcicgfHwgZmluaXNoVHlwZSAhPT0gJ251bWJlcicpICYmIChkb0xlbmd0aCB8fCBvYmpUeXBlID09PSAnbnVtYmVyJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnRzIHRvIHdpdGhpbiBtdXN0IGJlIG51bWJlcnMnO1xuICAgIH0gZWxzZSBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlICE9PSAnZGF0ZScgJiYgb2JqVHlwZSAhPT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgcHJpbnRPYmogPSAob2JqVHlwZSA9PT0gJ3N0cmluZycpID8gXCInXCIgKyBvYmogKyBcIidcIiA6IG9iajtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICdleHBlY3RlZCAnICsgcHJpbnRPYmogKyAnIHRvIGJlIGEgbnVtYmVyIG9yIGEgZGF0ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFRocm93ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyb3JNZXNzYWdlLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgIH1cblxuICAgIGlmIChkb0xlbmd0aCkge1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPj0gc3RhcnQgJiYgbGVuIDw9IGZpbmlzaFxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggd2l0aGluICcgKyByYW5nZVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgbGVuZ3RoIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA+PSBzdGFydCAmJiBvYmogPD0gZmluaXNoXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgd2l0aGluICcgKyByYW5nZVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSB3aXRoaW4gJyArIHJhbmdlXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuaW5zdGFuY2VvZihjb25zdHJ1Y3RvclssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBnaXZlbiBgY29uc3RydWN0b3JgLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gQ2F0ICgpIHsgfVxuICAgKlxuICAgKiAgICAgZXhwZWN0KG5ldyBDYXQoKSkudG8uYmUuYW4uaW5zdGFuY2VvZihDYXQpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8uYmUuYW4uaW5zdGFuY2VvZihBcnJheSk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuaW5zdGFuY2VvZmAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuYmUuYW4uaW5zdGFuY2VvZihBcnJheSk7XG4gICAqXG4gICAqIGAuaW5zdGFuY2VvZmAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLmFuLmluc3RhbmNlb2YoQXJyYXksICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgxLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuYW4uaW5zdGFuY2VvZihBcnJheSk7XG4gICAqXG4gICAqIER1ZSB0byBsaW1pdGF0aW9ucyBpbiBFUzUsIGAuaW5zdGFuY2VvZmAgbWF5IG5vdCBhbHdheXMgd29yayBhcyBleHBlY3RlZFxuICAgKiB3aGVuIHVzaW5nIGEgdHJhbnNwaWxlciBzdWNoIGFzIEJhYmVsIG9yIFR5cGVTY3JpcHQuIEluIHBhcnRpY3VsYXIsIGl0IG1heVxuICAgKiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cyB3aGVuIHN1YmNsYXNzaW5nIGJ1aWx0LWluIG9iamVjdCBzdWNoIGFzXG4gICAqIGBBcnJheWAsIGBFcnJvcmAsIGFuZCBgTWFwYC4gU2VlIHlvdXIgdHJhbnNwaWxlcidzIGRvY3MgZm9yIGRldGFpbHM6XG4gICAqXG4gICAqIC0gKFtCYWJlbF0oaHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvdXNhZ2UvY2F2ZWF0cy8jY2xhc3NlcykpXG4gICAqIC0gKFtUeXBlU2NyaXB0XShodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvd2lraS9CcmVha2luZy1DaGFuZ2VzI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29yaykpXG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmluc3RhbmNlT2ZgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuaW5zdGFuY2VvZmAuXG4gICAqXG4gICAqIEBuYW1lIGluc3RhbmNlb2ZcbiAgICogQHBhcmFtIHtDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBhbGlhcyBpbnN0YW5jZU9mXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEluc3RhbmNlT2YgKGNvbnN0cnVjdG9yLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcblxuICAgIHZhciB0YXJnZXQgPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgIHZhciBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgIHZhciBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0luc3RhbmNlT2YgPSB0YXJnZXQgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvcjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgZmxhZ01zZyA9IGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyA6ICcnO1xuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgICAgZmxhZ01zZyArICdUaGUgaW5zdGFuY2VvZiBhc3NlcnRpb24gbmVlZHMgYSBjb25zdHJ1Y3RvciBidXQgJ1xuICAgICAgICAgICAgKyBfLnR5cGUoY29uc3RydWN0b3IpICsgJyB3YXMgZ2l2ZW4uJyxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgc3NmaVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIHZhciBuYW1lID0gXy5nZXROYW1lKGNvbnN0cnVjdG9yKTtcbiAgICBpZiAobmFtZSA9PT0gbnVsbCkge1xuICAgICAgbmFtZSA9ICdhbiB1bm5hbWVkIGNvbnN0cnVjdG9yJztcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgaXNJbnN0YW5jZU9mXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFuIGluc3RhbmNlIG9mICcgKyBuYW1lXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBhbiBpbnN0YW5jZSBvZiAnICsgbmFtZVxuICAgICk7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnaW5zdGFuY2VvZicsIGFzc2VydEluc3RhbmNlT2YpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdpbnN0YW5jZU9mJywgYXNzZXJ0SW5zdGFuY2VPZik7XG5cbiAgLyoqXG4gICAqICMjIyAucHJvcGVydHkobmFtZVssIHZhbFssIG1zZ11dKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBoYXMgYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBrZXkgYG5hbWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5wcm9wZXJ0eSgnYScpO1xuICAgKlxuICAgKiBXaGVuIGB2YWxgIGlzIHByb3ZpZGVkLCBgLnByb3BlcnR5YCBhbHNvIGFzc2VydHMgdGhhdCB0aGUgcHJvcGVydHkncyB2YWx1ZVxuICAgKiBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gYHZhbGAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLnByb3BlcnR5KCdhJywgMSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHN0cmljdCAoYD09PWApIGVxdWFsaXR5IGlzIHVzZWQuIEFkZCBgLmRlZXBgIGVhcmxpZXIgaW4gdGhlXG4gICAqIGNoYWluIHRvIHVzZSBkZWVwIGVxdWFsaXR5IGluc3RlYWQuIFNlZSB0aGUgYGRlZXAtZXFsYCBwcm9qZWN0IHBhZ2UgZm9yXG4gICAqIGluZm8gb24gdGhlIGRlZXAgZXF1YWxpdHkgYWxnb3JpdGhtOiBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGhhcyBwcm9wZXJ0eSBgeDoge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5oYXZlLmRlZXAucHJvcGVydHkoJ3gnLCB7YTogMX0pO1xuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5ub3QuaGF2ZS5wcm9wZXJ0eSgneCcsIHthOiAxfSk7XG4gICAqXG4gICAqIFRoZSB0YXJnZXQncyBlbnVtZXJhYmxlIGFuZCBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBhbHdheXMgaW5jbHVkZWRcbiAgICogaW4gdGhlIHNlYXJjaC4gQnkgZGVmYXVsdCwgYm90aCBvd24gYW5kIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGFyZSBpbmNsdWRlZC5cbiAgICogQWRkIGAub3duYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBleGNsdWRlIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGZyb20gdGhlXG4gICAqIHNlYXJjaC5cbiAgICpcbiAgICogICAgIE9iamVjdC5wcm90b3R5cGUuYiA9IDI7XG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLm93bi5wcm9wZXJ0eSgnYScpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5vd24ucHJvcGVydHkoJ2EnLCAxKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUucHJvcGVydHkoJ2InKS5idXQubm90Lm93bi5wcm9wZXJ0eSgnYicpOyBcbiAgICpcbiAgICogYC5kZWVwYCBhbmQgYC5vd25gIGNhbiBiZSBjb21iaW5lZC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7eDoge2E6IDF9fSkudG8uaGF2ZS5kZWVwLm93bi5wcm9wZXJ0eSgneCcsIHthOiAxfSk7XG4gICAqXG4gICAqIEFkZCBgLm5lc3RlZGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gZW5hYmxlIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gd2hlblxuICAgKiByZWZlcmVuY2luZyBuZXN0ZWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YToge2I6IFsneCcsICd5J119fSkudG8uaGF2ZS5uZXN0ZWQucHJvcGVydHkoJ2EuYlsxXScpO1xuICAgKiAgICAgZXhwZWN0KHthOiB7YjogWyd4JywgJ3knXX19KS50by5oYXZlLm5lc3RlZC5wcm9wZXJ0eSgnYS5iWzFdJywgJ3knKTtcbiAgICpcbiAgICogSWYgYC5gIG9yIGBbXWAgYXJlIHBhcnQgb2YgYW4gYWN0dWFsIHByb3BlcnR5IG5hbWUsIHRoZXkgY2FuIGJlIGVzY2FwZWQgYnlcbiAgICogYWRkaW5nIHR3byBiYWNrc2xhc2hlcyBiZWZvcmUgdGhlbS5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7Jy5hJzogeydbYl0nOiAneCd9fSkudG8uaGF2ZS5uZXN0ZWQucHJvcGVydHkoJ1xcXFwuYS5cXFxcW2JcXFxcXScpO1xuICAgKlxuICAgKiBgLmRlZXBgIGFuZCBgLm5lc3RlZGAgY2FuIGJlIGNvbWJpbmVkLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiB7YjogW3tjOiAzfV19fSlcbiAgICogICAgICAgLnRvLmhhdmUuZGVlcC5uZXN0ZWQucHJvcGVydHkoJ2EuYlswXScsIHtjOiAzfSk7XG4gICAqXG4gICAqIGAub3duYCBhbmQgYC5uZXN0ZWRgIGNhbm5vdCBiZSBjb21iaW5lZC5cbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5wcm9wZXJ0eWAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuaGF2ZS5wcm9wZXJ0eSgnYicpO1xuICAgKiBcbiAgICogSG93ZXZlciwgaXQncyBkYW5nZXJvdXMgdG8gbmVnYXRlIGAucHJvcGVydHlgIHdoZW4gcHJvdmlkaW5nIGB2YWxgLiBUaGVcbiAgICogcHJvYmxlbSBpcyB0aGF0IGl0IGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9ucyBieSBhc3NlcnRpbmcgdGhhdCB0aGVcbiAgICogdGFyZ2V0IGVpdGhlciBkb2Vzbid0IGhhdmUgYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBrZXkgYG5hbWVgLCBvciB0aGF0IGl0XG4gICAqIGRvZXMgaGF2ZSBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIGtleSBgbmFtZWAgYnV0IGl0cyB2YWx1ZSBpc24ndCBlcXVhbCB0b1xuICAgKiB0aGUgZ2l2ZW4gYHZhbGAuIEl0J3Mgb2Z0ZW4gYmVzdCB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQnc1xuICAgKiBleHBlY3RlZCwgYW5kIHRoZW4gd3JpdGUgYW4gYXNzZXJ0aW9uIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXNuJ3QgZXhwZWN0ZWQgdG8gaGF2ZSBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIGtleVxuICAgKiBgbmFtZWAsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHtiOiAyfSkudG8ubm90LmhhdmUucHJvcGVydHkoJ2EnKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YjogMn0pLnRvLm5vdC5oYXZlLnByb3BlcnR5KCdhJywgMSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIGtleSBgbmFtZWAsXG4gICAqIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgcHJvcGVydHkgaGFzIGl0cyBleHBlY3RlZCB2YWx1ZSwgcmF0aGVyXG4gICAqIHRoYW4gYXNzZXJ0aW5nIHRoYXQgaXQgZG9lc24ndCBoYXZlIG9uZSBvZiBtYW55IHVuZXhwZWN0ZWQgdmFsdWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAzfSkudG8uaGF2ZS5wcm9wZXJ0eSgnYScsIDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAzfSkudG8ubm90LmhhdmUucHJvcGVydHkoJ2EnLCAxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAucHJvcGVydHlgIGNoYW5nZXMgdGhlIHRhcmdldCBvZiBhbnkgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW5cbiAgICogdG8gYmUgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBmcm9tIHRoZSBvcmlnaW5hbCB0YXJnZXQgb2JqZWN0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5wcm9wZXJ0eSgnYScpLnRoYXQuaXMuYSgnbnVtYmVyJyk7XG4gICAqXG4gICAqIGAucHJvcGVydHlgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC4gV2hlbiBub3QgcHJvdmlkaW5nIGB2YWxgLCBvbmx5IHVzZSB0aGVcbiAgICogc2Vjb25kIGZvcm0uXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5wcm9wZXJ0eSgnYScsIDIsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0sICdub29vIHdoeSBmYWlsPz8nKS50by5oYXZlLnByb3BlcnR5KCdhJywgMik7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaGF2ZS5wcm9wZXJ0eSgnYicpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLnByb3BlcnR5KCdiJywgdW5kZWZpbmVkLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqIFxuICAgKiBUaGUgYWJvdmUgYXNzZXJ0aW9uIGlzbid0IHRoZSBzYW1lIHRoaW5nIGFzIG5vdCBwcm92aWRpbmcgYHZhbGAuIEluc3RlYWQsXG4gICAqIGl0J3MgYXNzZXJ0aW5nIHRoYXQgdGhlIHRhcmdldCBvYmplY3QgaGFzIGEgYGJgIHByb3BlcnR5IHRoYXQncyBlcXVhbCB0b1xuICAgKiBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogVGhlIGFzc2VydGlvbnMgYC5vd25Qcm9wZXJ0eWAgYW5kIGAuaGF2ZU93blByb3BlcnR5YCBjYW4gYmUgdXNlZFxuICAgKiBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLm93bi5wcm9wZXJ0eWAuXG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbCAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAcmV0dXJucyB2YWx1ZSBvZiBwcm9wZXJ0eSBmb3IgY2hhaW5pbmdcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0UHJvcGVydHkgKG5hbWUsIHZhbCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG5cbiAgICB2YXIgaXNOZXN0ZWQgPSBmbGFnKHRoaXMsICduZXN0ZWQnKVxuICAgICAgLCBpc093biA9IGZsYWcodGhpcywgJ293bicpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcblxuICAgIGlmIChpc05lc3RlZCAmJiBpc093bikge1xuICAgICAgZmxhZ01zZyA9IGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyA6ICcnO1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICBmbGFnTXNnICsgJ1RoZSBcIm5lc3RlZFwiIGFuZCBcIm93blwiIGZsYWdzIGNhbm5vdCBiZSBjb21iaW5lZC4nLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHNzZmlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmxhZ01zZyA9IGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyA6ICcnO1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICBmbGFnTXNnICsgJ1RhcmdldCBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJyxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBzc2ZpXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBpc0RlZXAgPSBmbGFnKHRoaXMsICdkZWVwJylcbiAgICAgICwgbmVnYXRlID0gZmxhZyh0aGlzLCAnbmVnYXRlJylcbiAgICAgICwgcGF0aEluZm8gPSBpc05lc3RlZCA/IF8uZ2V0UGF0aEluZm8ob2JqLCBuYW1lKSA6IG51bGxcbiAgICAgICwgdmFsdWUgPSBpc05lc3RlZCA/IHBhdGhJbmZvLnZhbHVlIDogb2JqW25hbWVdO1xuXG4gICAgdmFyIGRlc2NyaXB0b3IgPSAnJztcbiAgICBpZiAoaXNEZWVwKSBkZXNjcmlwdG9yICs9ICdkZWVwICc7XG4gICAgaWYgKGlzT3duKSBkZXNjcmlwdG9yICs9ICdvd24gJztcbiAgICBpZiAoaXNOZXN0ZWQpIGRlc2NyaXB0b3IgKz0gJ25lc3RlZCAnO1xuICAgIGRlc2NyaXB0b3IgKz0gJ3Byb3BlcnR5ICc7XG5cbiAgICB2YXIgaGFzUHJvcGVydHk7XG4gICAgaWYgKGlzT3duKSBoYXNQcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIG5hbWUpO1xuICAgIGVsc2UgaWYgKGlzTmVzdGVkKSBoYXNQcm9wZXJ0eSA9IHBhdGhJbmZvLmV4aXN0cztcbiAgICBlbHNlIGhhc1Byb3BlcnR5ID0gXy5oYXNQcm9wZXJ0eShvYmosIG5hbWUpO1xuXG4gICAgLy8gV2hlbiBwZXJmb3JtaW5nIGEgbmVnYXRlZCBhc3NlcnRpb24gZm9yIGJvdGggbmFtZSBhbmQgdmFsLCBtZXJlbHkgaGF2aW5nXG4gICAgLy8gYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBuYW1lIGlzbid0IGVub3VnaCB0byBjYXVzZSB0aGUgYXNzZXJ0aW9uIHRvXG4gICAgLy8gZmFpbC4gSXQgbXVzdCBib3RoIGhhdmUgYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBuYW1lLCBhbmQgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhhdCBwcm9wZXJ0eSBtdXN0IGVxdWFsIHRoZSBnaXZlbiB2YWwuIFRoZXJlZm9yZSwgc2tpcCB0aGlzIGFzc2VydGlvbiBpblxuICAgIC8vIGZhdm9yIG9mIHRoZSBuZXh0LlxuICAgIGlmICghbmVnYXRlIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGhhc1Byb3BlcnR5XG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGhhc1Byb3BlcnR5ICYmIChpc0RlZXAgPyBfLmVxbCh2YWwsIHZhbHVlKSA6IHZhbCA9PT0gdmFsdWUpXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKSArICcgb2YgI3tleHB9LCBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKSArICcgb2YgI3thY3R9J1xuICAgICAgICAsIHZhbFxuICAgICAgICAsIHZhbHVlXG4gICAgICApO1xuICAgIH1cblxuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIHZhbHVlKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Byb3BlcnR5JywgYXNzZXJ0UHJvcGVydHkpO1xuXG4gIGZ1bmN0aW9uIGFzc2VydE93blByb3BlcnR5IChuYW1lLCB2YWx1ZSwgbXNnKSB7XG4gICAgZmxhZyh0aGlzLCAnb3duJywgdHJ1ZSk7XG4gICAgYXNzZXJ0UHJvcGVydHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ293blByb3BlcnR5JywgYXNzZXJ0T3duUHJvcGVydHkpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdoYXZlT3duUHJvcGVydHknLCBhc3NlcnRPd25Qcm9wZXJ0eSk7XG5cbiAgLyoqXG4gICAqICMjIyAub3duUHJvcGVydHlEZXNjcmlwdG9yKG5hbWVbLCBkZXNjcmlwdG9yWywgbXNnXV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGhhcyBpdHMgb3duIHByb3BlcnR5IGRlc2NyaXB0b3Igd2l0aCB0aGUgZ2l2ZW4ga2V5XG4gICAqIGBuYW1lYC4gRW51bWVyYWJsZSBhbmQgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgaW5jbHVkZWQgaW4gdGhlXG4gICAqIHNlYXJjaC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdhJyk7XG4gICAqXG4gICAqIFdoZW4gYGRlc2NyaXB0b3JgIGlzIHByb3ZpZGVkLCBgLm93blByb3BlcnR5RGVzY3JpcHRvcmAgYWxzbyBhc3NlcnRzIHRoYXRcbiAgICogdGhlIHByb3BlcnR5J3MgZGVzY3JpcHRvciBpcyBkZWVwbHkgZXF1YWwgdG8gdGhlIGdpdmVuIGBkZXNjcmlwdG9yYC4gU2VlXG4gICAqIHRoZSBgZGVlcC1lcWxgIHByb2plY3QgcGFnZSBmb3IgaW5mbyBvbiB0aGUgZGVlcCBlcXVhbGl0eSBhbGdvcml0aG06XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWwuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScsIHtcbiAgICogICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICogICAgICAgdmFsdWU6IDEsXG4gICAqICAgICB9KTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5vd25Qcm9wZXJ0eURlc2NyaXB0b3JgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdiJyk7XG4gICAqIFxuICAgKiBIb3dldmVyLCBpdCdzIGRhbmdlcm91cyB0byBuZWdhdGUgYC5vd25Qcm9wZXJ0eURlc2NyaXB0b3JgIHdoZW4gcHJvdmlkaW5nXG4gICAqIGEgYGRlc2NyaXB0b3JgLiBUaGUgcHJvYmxlbSBpcyB0aGF0IGl0IGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9ucyBieVxuICAgKiBhc3NlcnRpbmcgdGhhdCB0aGUgdGFyZ2V0IGVpdGhlciBkb2Vzbid0IGhhdmUgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHdpdGhcbiAgICogdGhlIGdpdmVuIGtleSBgbmFtZWAsIG9yIHRoYXQgaXQgZG9lcyBoYXZlIGEgcHJvcGVydHkgZGVzY3JpcHRvciB3aXRoIHRoZVxuICAgKiBnaXZlbiBrZXkgYG5hbWVgIGJ1dCBpdHMgbm90IGRlZXBseSBlcXVhbCB0byB0aGUgZ2l2ZW4gYGRlc2NyaXB0b3JgLiBJdCdzXG4gICAqIG9mdGVuIGJlc3QgdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3MgZXhwZWN0ZWQsIGFuZCB0aGVuIHdyaXRlIGFuXG4gICAqIGFzc2VydGlvbiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzbid0IGV4cGVjdGVkIHRvIGhhdmUgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHdpdGggdGhlIGdpdmVuXG4gICAqIGtleSBgbmFtZWAsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YjogMn0pLnRvLm5vdC5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2I6IDJ9KS50by5ub3QuaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2EnLCB7XG4gICAqICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAqICAgICAgIHZhbHVlOiAxLFxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBleHBlY3RlZCB0byBoYXZlIGEgcHJvcGVydHkgZGVzY3JpcHRvciB3aXRoIHRoZSBnaXZlblxuICAgKiBrZXkgYG5hbWVgLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHByb3BlcnR5IGhhcyBpdHMgZXhwZWN0ZWRcbiAgICogZGVzY3JpcHRvciwgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIHRoYXQgaXQgZG9lc24ndCBoYXZlIG9uZSBvZiBtYW55XG4gICAqIHVuZXhwZWN0ZWQgZGVzY3JpcHRvcnMuXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAzfSkudG8uaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2EnLCB7XG4gICAqICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAqICAgICAgIHZhbHVlOiAzLFxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogM30pLnRvLm5vdC5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScsIHtcbiAgICogICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICogICAgICAgdmFsdWU6IDEsXG4gICAqICAgICB9KTtcbiAgICpcbiAgICogYC5vd25Qcm9wZXJ0eURlc2NyaXB0b3JgIGNoYW5nZXMgdGhlIHRhcmdldCBvZiBhbnkgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvd1xuICAgKiBpbiB0aGUgY2hhaW4gdG8gYmUgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZyb20gdGhlIG9yaWdpbmFsXG4gICAqIHRhcmdldCBvYmplY3QuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScpXG4gICAqICAgICAgIC50aGF0Lmhhcy5wcm9wZXJ0eSgnZW51bWVyYWJsZScsIHRydWUpO1xuICAgKlxuICAgKiBgLm93blByb3BlcnR5RGVzY3JpcHRvcmAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhXG4gICAqIGN1c3RvbSBlcnJvciBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzb1xuICAgKiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLiBXaGVuIG5vdCBwcm92aWRpbmdcbiAgICogYGRlc2NyaXB0b3JgLCBvbmx5IHVzZSB0aGUgc2Vjb25kIGZvcm0uXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2EnLCB7XG4gICAqICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAqICAgICAgIHZhbHVlOiAyLFxuICAgKiAgICAgfSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMX0sICdub29vIHdoeSBmYWlsPz8nKS50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScsIHtcbiAgICogICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICogICAgICAgdmFsdWU6IDIsXG4gICAqICAgICB9KTtcbiAgICogXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdiJyk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMX0pXG4gICAqICAgICAgIC50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYicsIHVuZGVmaW5lZCwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKlxuICAgKiBUaGUgYWJvdmUgYXNzZXJ0aW9uIGlzbid0IHRoZSBzYW1lIHRoaW5nIGFzIG5vdCBwcm92aWRpbmcgYGRlc2NyaXB0b3JgLlxuICAgKiBJbnN0ZWFkLCBpdCdzIGFzc2VydGluZyB0aGF0IHRoZSB0YXJnZXQgb2JqZWN0IGhhcyBhIGBiYCBwcm9wZXJ0eVxuICAgKiBkZXNjcmlwdG9yIHRoYXQncyBkZWVwbHkgZXF1YWwgdG8gYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmhhdmVPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoXG4gICAqIGAub3duUHJvcGVydHlEZXNjcmlwdG9yYC5cbiAgICpcbiAgICogQG5hbWUgb3duUHJvcGVydHlEZXNjcmlwdG9yXG4gICAqIEBhbGlhcyBoYXZlT3duUHJvcGVydHlEZXNjcmlwdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXNjcmlwdG9yIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydE93blByb3BlcnR5RGVzY3JpcHRvciAobmFtZSwgZGVzY3JpcHRvciwgbXNnKSB7XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgbXNnID0gZGVzY3JpcHRvcjtcbiAgICAgIGRlc2NyaXB0b3IgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdmFyIGFjdHVhbERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdChvYmopLCBuYW1lKTtcbiAgICBpZiAoYWN0dWFsRGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBfLmVxbChkZXNjcmlwdG9yLCBhY3R1YWxEZXNjcmlwdG9yKVxuICAgICAgICAsICdleHBlY3RlZCB0aGUgb3duIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yICcgKyBfLmluc3BlY3QobmFtZSkgKyAnIG9uICN7dGhpc30gdG8gbWF0Y2ggJyArIF8uaW5zcGVjdChkZXNjcmlwdG9yKSArICcsIGdvdCAnICsgXy5pbnNwZWN0KGFjdHVhbERlc2NyaXB0b3IpXG4gICAgICAgICwgJ2V4cGVjdGVkIHRoZSBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgJyArIF8uaW5zcGVjdChuYW1lKSArICcgb24gI3t0aGlzfSB0byBub3QgbWF0Y2ggJyArIF8uaW5zcGVjdChkZXNjcmlwdG9yKVxuICAgICAgICAsIGRlc2NyaXB0b3JcbiAgICAgICAgLCBhY3R1YWxEZXNjcmlwdG9yXG4gICAgICAgICwgdHJ1ZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgYWN0dWFsRGVzY3JpcHRvclxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYW4gb3duIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yICcgKyBfLmluc3BlY3QobmFtZSlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhbiBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgJyArIF8uaW5zcGVjdChuYW1lKVxuICAgICAgKTtcbiAgICB9XG4gICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgYWN0dWFsRGVzY3JpcHRvcik7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdvd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBhc3NlcnRPd25Qcm9wZXJ0eURlc2NyaXB0b3IpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdoYXZlT3duUHJvcGVydHlEZXNjcmlwdG9yJywgYXNzZXJ0T3duUHJvcGVydHlEZXNjcmlwdG9yKTtcblxuICAvKipcbiAgICogIyMjIC5sZW5ndGhPZihuWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQncyBgbGVuZ3RoYCBwcm9wZXJ0eSBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gbnVtYmVyXG4gICAqIGBuYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMyk7XG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YoMyk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAubGVuZ3RoT2ZgLiBIb3dldmVyLCBpdCdzIG9mdGVuXG4gICAqIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCdzIGBsZW5ndGhgIHByb3BlcnR5IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZFxuICAgKiB2YWx1ZSwgcmF0aGVyIHRoYW4gbm90IGVxdWFsIHRvIG9uZSBvZiBtYW55IHVuZXhwZWN0ZWQgdmFsdWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5ub3QuaGF2ZS5sZW5ndGhPZig0KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAubGVuZ3RoT2ZgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMiwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmhhdmUubGVuZ3RoT2YoMik7XG4gICAqXG4gICAqIGAubGVuZ3RoT2ZgIGNhbiBhbHNvIGJlIHVzZWQgYXMgYSBsYW5ndWFnZSBjaGFpbiwgY2F1c2luZyBhbGwgYC5hYm92ZWAsXG4gICAqIGAuYmVsb3dgLCBgLmxlYXN0YCwgYC5tb3N0YCwgYW5kIGAud2l0aGluYCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZVxuICAgKiBjaGFpbiB0byB1c2UgdGhlIHRhcmdldCdzIGBsZW5ndGhgIHByb3BlcnR5IGFzIHRoZSB0YXJnZXQuIEhvd2V2ZXIsIGl0J3NcbiAgICogb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGAgcHJvcGVydHkgaXMgZXF1YWwgdG8gaXRzXG4gICAqIGV4cGVjdGVkIGxlbmd0aCwgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIHRoYXQgaXRzIGBsZW5ndGhgIHByb3BlcnR5IGZhbGxzXG4gICAqIHdpdGhpbiBzb21lIHJhbmdlIG9mIHZhbHVlcy5cbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mKDMpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLmFib3ZlKDIpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZi5iZWxvdyg0KTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YuYXQubGVhc3QoMyk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLmF0Lm1vc3QoMyk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLndpdGhpbigyLDQpO1xuICAgKlxuICAgKiBEdWUgdG8gYSBjb21wYXRpYmlsaXR5IGlzc3VlLCB0aGUgYWxpYXMgYC5sZW5ndGhgIGNhbid0IGJlIGNoYWluZWQgZGlyZWN0bHlcbiAgICogb2ZmIG9mIGFuIHVuaW52b2tlZCBtZXRob2Qgc3VjaCBhcyBgLmFgLiBUaGVyZWZvcmUsIGAubGVuZ3RoYCBjYW4ndCBiZSB1c2VkXG4gICAqIGludGVyY2hhbmdlYWJseSB3aXRoIGAubGVuZ3RoT2ZgIGluIGV2ZXJ5IHNpdHVhdGlvbi4gSXQncyByZWNvbW1lbmRlZCB0b1xuICAgKiBhbHdheXMgdXNlIGAubGVuZ3RoT2ZgIGluc3RlYWQgb2YgYC5sZW5ndGhgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5hLmxlbmd0aCgzKTsgLy8gaW5jb21wYXRpYmxlOyB0aHJvd3MgZXJyb3JcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUuYS5sZW5ndGhPZigzKTsgIC8vIHBhc3NlcyBhcyBleHBlY3RlZFxuICAgKlxuICAgKiBAbmFtZSBsZW5ndGhPZlxuICAgKiBAYWxpYXMgbGVuZ3RoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRMZW5ndGhDaGFpbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnZG9MZW5ndGgnLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydExlbmd0aCAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgbGVuID09IG5cbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBvZiAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgbGVuZ3RoIG9mICN7YWN0fSdcbiAgICAgICwgblxuICAgICAgLCBsZW5cbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnbGVuZ3RoJywgYXNzZXJ0TGVuZ3RoLCBhc3NlcnRMZW5ndGhDaGFpbik7XG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2xlbmd0aE9mJywgYXNzZXJ0TGVuZ3RoLCBhc3NlcnRMZW5ndGhDaGFpbik7XG5cbiAgLyoqXG4gICAqICMjIyAubWF0Y2gocmVbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBtYXRjaGVzIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gYHJlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8ubWF0Y2goL15mb28vKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5tYXRjaGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLm5vdC5tYXRjaCgvdGFjby8pO1xuICAgKlxuICAgKiBgLm1hdGNoYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLm1hdGNoKC90YWNvLywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KCdmb29iYXInLCAnbm9vbyB3aHkgZmFpbD8/JykudG8ubWF0Y2goL3RhY28vKTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAubWF0Y2hlc2AgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5tYXRjaGAuXG4gICAqXG4gICAqIEBuYW1lIG1hdGNoXG4gICAqIEBhbGlhcyBtYXRjaGVzXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIGZ1bmN0aW9uIGFzc2VydE1hdGNoKHJlLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHJlLmV4ZWMob2JqKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBtYXRjaCAnICsgcmVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIG1hdGNoICcgKyByZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdtYXRjaCcsIGFzc2VydE1hdGNoKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbWF0Y2hlcycsIGFzc2VydE1hdGNoKTtcblxuICAvKipcbiAgICogIyMjIC5zdHJpbmcoc3RyWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgc3RyaW5nIGNvbnRhaW5zIHRoZSBnaXZlbiBzdWJzdHJpbmcgYHN0cmAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLmhhdmUuc3RyaW5nKCdiYXInKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5zdHJpbmdgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5ub3QuaGF2ZS5zdHJpbmcoJ3RhY28nKTtcbiAgICpcbiAgICogYC5zdHJpbmdgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8uaGF2ZS5zdHJpbmcoL3RhY28vLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicsICdub29vIHdoeSBmYWlsPz8nKS50by5oYXZlLnN0cmluZygvdGFjby8pO1xuICAgKlxuICAgKiBAbmFtZSBzdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnc3RyaW5nJywgZnVuY3Rpb24gKHN0ciwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnc3RyaW5nJyk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgfm9iai5pbmRleE9mKHN0cilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gY29udGFpbiAnICsgXy5pbnNwZWN0KHN0cilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGNvbnRhaW4gJyArIF8uaW5zcGVjdChzdHIpXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAua2V5cyhrZXkxWywga2V5MlssIC4uLl1dKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBvYmplY3QsIGFycmF5LCBtYXAsIG9yIHNldCBoYXMgdGhlIGdpdmVuIGtleXMuIE9ubHlcbiAgICogdGhlIHRhcmdldCdzIG93biBpbmhlcml0ZWQgcHJvcGVydGllcyBhcmUgaW5jbHVkZWQgaW4gdGhlIHNlYXJjaC4gXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhbiBvYmplY3Qgb3IgYXJyYXksIGtleXMgY2FuIGJlIHByb3ZpZGVkIGFzIG9uZSBvciBtb3JlXG4gICAqIHN0cmluZyBhcmd1bWVudHMsIGEgc2luZ2xlIGFycmF5IGFyZ3VtZW50LCBvciBhIHNpbmdsZSBvYmplY3QgYXJndW1lbnQuIEluXG4gICAqIHRoZSBsYXR0ZXIgY2FzZSwgb25seSB0aGUga2V5cyBpbiB0aGUgZ2l2ZW4gb2JqZWN0IG1hdHRlcjsgdGhlIHZhbHVlcyBhcmVcbiAgICogaWdub3JlZC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLmhhdmUuYWxsLmtleXMoJ2EnLCAnYicpO1xuICAgKiAgICAgZXhwZWN0KFsneCcsICd5J10pLnRvLmhhdmUuYWxsLmtleXMoMCwgMSk7XG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5oYXZlLmFsbC5rZXlzKFsnYScsICdiJ10pO1xuICAgKiAgICAgZXhwZWN0KFsneCcsICd5J10pLnRvLmhhdmUuYWxsLmtleXMoWzAsIDFdKTtcbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLmhhdmUuYWxsLmtleXMoe2E6IDQsIGI6IDV9KTsgLy8gaWdub3JlIDQgYW5kIDVcbiAgICogICAgIGV4cGVjdChbJ3gnLCAneSddKS50by5oYXZlLmFsbC5rZXlzKHswOiA0LCAxOiA1fSk7IC8vIGlnbm9yZSA0IGFuZCA1XG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhIG1hcCBvciBzZXQsIGVhY2gga2V5IG11c3QgYmUgcHJvdmlkZWQgYXMgYSBzZXBhcmF0ZVxuICAgKiBhcmd1bWVudC5cbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgTWFwKFtbJ2EnLCAxXSwgWydiJywgMl1dKSkudG8uaGF2ZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqICAgICBleHBlY3QobmV3IFNldChbJ2EnLCAnYiddKSkudG8uaGF2ZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqXG4gICAqIEJlY2F1c2UgYC5rZXlzYCBkb2VzIGRpZmZlcmVudCB0aGluZ3MgYmFzZWQgb24gdGhlIHRhcmdldCdzIHR5cGUsIGl0J3NcbiAgICogaW1wb3J0YW50IHRvIGNoZWNrIHRoZSB0YXJnZXQncyB0eXBlIGJlZm9yZSB1c2luZyBgLmtleXNgLiBTZWUgdGhlIGAuYWAgZG9jXG4gICAqIGZvciBpbmZvIG9uIHRlc3RpbmcgYSB0YXJnZXQncyB0eXBlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8uYmUuYW4oJ29iamVjdCcpLnRoYXQuaGFzLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgc3RyaWN0IChgPT09YCkgZXF1YWxpdHkgaXMgdXNlZCB0byBjb21wYXJlIGtleXMgb2YgbWFwcyBhbmRcbiAgICogc2V0cy4gQWRkIGAuZGVlcGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gdXNlIGRlZXAgZXF1YWxpdHkgaW5zdGVhZC4gU2VlXG4gICAqIHRoZSBgZGVlcC1lcWxgIHByb2plY3QgcGFnZSBmb3IgaW5mbyBvbiB0aGUgZGVlcCBlcXVhbGl0eSBhbGdvcml0aG06XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWwuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgc2V0IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaGFzIGtleSBge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KG5ldyBTZXQoW3thOiAxfV0pKS50by5oYXZlLmFsbC5kZWVwLmtleXMoW3thOiAxfV0pO1xuICAgKiAgICAgZXhwZWN0KG5ldyBTZXQoW3thOiAxfV0pKS50by5ub3QuaGF2ZS5hbGwua2V5cyhbe2E6IDF9XSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSB0YXJnZXQgbXVzdCBoYXZlIGFsbCBvZiB0aGUgZ2l2ZW4ga2V5cyBhbmQgbm8gbW9yZS4gQWRkXG4gICAqIGAuYW55YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBvbmx5IHJlcXVpcmUgdGhhdCB0aGUgdGFyZ2V0IGhhdmUgYXQgbGVhc3RcbiAgICogb25lIG9mIHRoZSBnaXZlbiBrZXlzLiBBbHNvLCBhZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZVxuICAgKiBgLmtleXNgLiBJdCdzIG9mdGVuIGJlc3QgdG8gYWRkIGAuYW55YCB3aGVuIG5lZ2F0aW5nIGAua2V5c2AsIGFuZCB0byB1c2VcbiAgICogYC5hbGxgIHdoZW4gYXNzZXJ0aW5nIGAua2V5c2Agd2l0aG91dCBuZWdhdGlvbi5cbiAgICpcbiAgICogV2hlbiBuZWdhdGluZyBgLmtleXNgLCBgLmFueWAgaXMgcHJlZmVycmVkIGJlY2F1c2UgYC5ub3QuYW55LmtleXNgIGFzc2VydHNcbiAgICogZXhhY3RseSB3aGF0J3MgZXhwZWN0ZWQgb2YgdGhlIG91dHB1dCwgd2hlcmVhcyBgLm5vdC5hbGwua2V5c2AgY3JlYXRlc1xuICAgKiB1bmNlcnRhaW4gZXhwZWN0YXRpb25zLlxuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWQ7IGFzc2VydHMgdGhhdCB0YXJnZXQgZG9lc24ndCBoYXZlIGFueSBvZiB0aGUgZ2l2ZW4ga2V5c1xuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8ubm90LmhhdmUuYW55LmtleXMoJ2MnLCAnZCcpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkOyBhc3NlcnRzIHRoYXQgdGFyZ2V0IGRvZXNuJ3QgaGF2ZSBhbGwgb2YgdGhlIGdpdmVuXG4gICAqICAgICAvLyBrZXlzIGJ1dCBtYXkgb3IgbWF5IG5vdCBoYXZlIHNvbWUgb2YgdGhlbVxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8ubm90LmhhdmUuYWxsLmtleXMoJ2MnLCAnZCcpO1xuICAgKlxuICAgKiBXaGVuIGFzc2VydGluZyBgLmtleXNgIHdpdGhvdXQgbmVnYXRpb24sIGAuYWxsYCBpcyBwcmVmZXJyZWQgYmVjYXVzZVxuICAgKiBgLmFsbC5rZXlzYCBhc3NlcnRzIGV4YWN0bHkgd2hhdCdzIGV4cGVjdGVkIG9mIHRoZSBvdXRwdXQsIHdoZXJlYXNcbiAgICogYC5hbnkua2V5c2AgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zLlxuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWQ7IGFzc2VydHMgdGhhdCB0YXJnZXQgaGFzIGFsbCB0aGUgZ2l2ZW4ga2V5c1xuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8uaGF2ZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWQ7IGFzc2VydHMgdGhhdCB0YXJnZXQgaGFzIGF0IGxlYXN0IG9uZSBvZiB0aGUgZ2l2ZW5cbiAgICogICAgIC8vIGtleXMgYnV0IG1heSBvciBtYXkgbm90IGhhdmUgbW9yZSBvZiB0aGVtXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5oYXZlLmFueS5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogTm90ZSB0aGF0IGAuYWxsYCBpcyB1c2VkIGJ5IGRlZmF1bHQgd2hlbiBuZWl0aGVyIGAuYWxsYCBub3IgYC5hbnlgIGFwcGVhclxuICAgKiBlYXJsaWVyIGluIHRoZSBjaGFpbi4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFkZCBgLmFsbGAgYW55d2F5IGJlY2F1c2VcbiAgICogaXQgaW1wcm92ZXMgcmVhZGFiaWxpdHkuXG4gICAqXG4gICAqICAgICAvLyBCb3RoIGFzc2VydGlvbnMgYXJlIGlkZW50aWNhbFxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8uaGF2ZS5hbGwua2V5cygnYScsICdiJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5oYXZlLmtleXMoJ2EnLCAnYicpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAuaW5jbHVkZWAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gcmVxdWlyZSB0aGF0IHRoZSB0YXJnZXQncyBrZXlzIGJlIGFcbiAgICogc3VwZXJzZXQgb2YgdGhlIGV4cGVjdGVkIGtleXMsIHJhdGhlciB0aGFuIGlkZW50aWNhbCBzZXRzLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCdzIGtleXMgYXJlIGEgc3VwZXJzZXQgb2YgWydhJywgJ2InXSBidXQgbm90IGlkZW50aWNhbFxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyLCBjOiAzfSkudG8uaW5jbHVkZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDIsIGM6IDN9KS50by5ub3QuaGF2ZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqXG4gICAqIEhvd2V2ZXIsIGlmIGAuYW55YCBhbmQgYC5pbmNsdWRlYCBhcmUgY29tYmluZWQsIG9ubHkgdGhlIGAuYW55YCB0YWtlc1xuICAgKiBlZmZlY3QuIFRoZSBgLmluY2x1ZGVgIGlzIGlnbm9yZWQgaW4gdGhpcyBjYXNlLlxuICAgKlxuICAgKiAgICAgLy8gQm90aCBhc3NlcnRpb25zIGFyZSBpZGVudGljYWxcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUuYW55LmtleXMoJ2EnLCAnYicpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaW5jbHVkZS5hbnkua2V5cygnYScsICdiJyk7XG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaGF2ZS5rZXkoJ2InKTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAua2V5YCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmtleXNgLlxuICAgKlxuICAgKiBAbmFtZSBrZXlzXG4gICAqIEBhbGlhcyBrZXlcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd8QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEtleXMgKGtleXMpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgb2JqVHlwZSA9IF8udHlwZShvYmopXG4gICAgICAsIGtleXNUeXBlID0gXy50eXBlKGtleXMpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgaXNEZWVwID0gZmxhZyh0aGlzLCAnZGVlcCcpXG4gICAgICAsIHN0clxuICAgICAgLCBkZWVwU3RyID0gJydcbiAgICAgICwgb2sgPSB0cnVlXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJyk7XG5cbiAgICBmbGFnTXNnID0gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnIDogJyc7XG4gICAgdmFyIG1peGVkQXJnc01zZyA9IGZsYWdNc2cgKyAnd2hlbiB0ZXN0aW5nIGtleXMgYWdhaW5zdCBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgeW91IG11c3QgZ2l2ZSBhIHNpbmdsZSBBcnJheXxPYmplY3R8U3RyaW5nIGFyZ3VtZW50IG9yIG11bHRpcGxlIFN0cmluZyBhcmd1bWVudHMnO1xuXG4gICAgaWYgKG9ialR5cGUgPT09ICdNYXAnIHx8IG9ialR5cGUgPT09ICdTZXQnKSB7XG4gICAgICBkZWVwU3RyID0gaXNEZWVwID8gJ2RlZXBseSAnIDogJyc7XG4gICAgICBhY3R1YWwgPSBbXTtcblxuICAgICAgLy8gTWFwIGFuZCBTZXQgJy5rZXlzJyBhcmVuJ3Qgc3VwcG9ydGVkIGluIElFIDExLiBUaGVyZWZvcmUsIHVzZSAuZm9yRWFjaC5cbiAgICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uICh2YWwsIGtleSkgeyBhY3R1YWwucHVzaChrZXkpIH0pO1xuXG4gICAgICBpZiAoa2V5c1R5cGUgIT09ICdBcnJheScpIHtcbiAgICAgICAga2V5cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgYWN0dWFsID0gXy5nZXRPd25FbnVtZXJhYmxlUHJvcGVydGllcyhvYmopO1xuXG4gICAgICBzd2l0Y2ggKGtleXNUeXBlKSB7XG4gICAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihtaXhlZEFyZ3NNc2csIHVuZGVmaW5lZCwgc3NmaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdPYmplY3QnOlxuICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG1peGVkQXJnc01zZywgdW5kZWZpbmVkLCBzc2ZpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGtleXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGtleXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICAvLyBPbmx5IHN0cmluZ2lmeSBub24tU3ltYm9scyBiZWNhdXNlIFN5bWJvbHMgd291bGQgYmVjb21lIFwiU3ltYm9sKClcIlxuICAgICAga2V5cyA9IGtleXMubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzeW1ib2wnID8gdmFsIDogU3RyaW5nKHZhbCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoZmxhZ01zZyArICdrZXlzIHJlcXVpcmVkJywgdW5kZWZpbmVkLCBzc2ZpKTtcbiAgICB9XG5cbiAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGhcbiAgICAgICwgYW55ID0gZmxhZyh0aGlzLCAnYW55JylcbiAgICAgICwgYWxsID0gZmxhZyh0aGlzLCAnYWxsJylcbiAgICAgICwgZXhwZWN0ZWQgPSBrZXlzXG4gICAgICAsIGFjdHVhbDtcblxuICAgIGlmICghYW55ICYmICFhbGwpIHtcbiAgICAgIGFsbCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gSGFzIGFueVxuICAgIGlmIChhbnkpIHtcbiAgICAgIG9rID0gZXhwZWN0ZWQuc29tZShmdW5jdGlvbihleHBlY3RlZEtleSkge1xuICAgICAgICByZXR1cm4gYWN0dWFsLnNvbWUoZnVuY3Rpb24oYWN0dWFsS2V5KSB7XG4gICAgICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIF8uZXFsKGV4cGVjdGVkS2V5LCBhY3R1YWxLZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWRLZXkgPT09IGFjdHVhbEtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gSGFzIGFsbFxuICAgIGlmIChhbGwpIHtcbiAgICAgIG9rID0gZXhwZWN0ZWQuZXZlcnkoZnVuY3Rpb24oZXhwZWN0ZWRLZXkpIHtcbiAgICAgICAgcmV0dXJuIGFjdHVhbC5zb21lKGZ1bmN0aW9uKGFjdHVhbEtleSkge1xuICAgICAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgICAgIHJldHVybiBfLmVxbChleHBlY3RlZEtleSwgYWN0dWFsS2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkS2V5ID09PSBhY3R1YWxLZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWZsYWcodGhpcywgJ2NvbnRhaW5zJykpIHtcbiAgICAgICAgb2sgPSBvayAmJiBrZXlzLmxlbmd0aCA9PSBhY3R1YWwubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEtleSBzdHJpbmdcbiAgICBpZiAobGVuID4gMSkge1xuICAgICAga2V5cyA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gXy5pbnNwZWN0KGtleSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBsYXN0ID0ga2V5cy5wb3AoKTtcbiAgICAgIGlmIChhbGwpIHtcbiAgICAgICAgc3RyID0ga2V5cy5qb2luKCcsICcpICsgJywgYW5kICcgKyBsYXN0O1xuICAgICAgfVxuICAgICAgaWYgKGFueSkge1xuICAgICAgICBzdHIgPSBrZXlzLmpvaW4oJywgJykgKyAnLCBvciAnICsgbGFzdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gXy5pbnNwZWN0KGtleXNbMF0pO1xuICAgIH1cblxuICAgIC8vIEZvcm1cbiAgICBzdHIgPSAobGVuID4gMSA/ICdrZXlzICcgOiAna2V5ICcpICsgc3RyO1xuXG4gICAgLy8gSGF2ZSAvIGluY2x1ZGVcbiAgICBzdHIgPSAoZmxhZyh0aGlzLCAnY29udGFpbnMnKSA/ICdjb250YWluICcgOiAnaGF2ZSAnKSArIHN0cjtcblxuICAgIC8vIEFzc2VydGlvblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBva1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byAnICsgZGVlcFN0ciArIHN0clxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgJyArIGRlZXBTdHIgKyBzdHJcbiAgICAgICwgZXhwZWN0ZWQuc2xpY2UoMCkuc29ydChfLmNvbXBhcmVCeUluc3BlY3QpXG4gICAgICAsIGFjdHVhbC5zb3J0KF8uY29tcGFyZUJ5SW5zcGVjdClcbiAgICAgICwgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdrZXlzJywgYXNzZXJ0S2V5cyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2tleScsIGFzc2VydEtleXMpO1xuXG4gIC8qKlxuICAgKiAjIyMgLnRocm93KFtlcnJvckxpa2VdLCBbZXJyTXNnTWF0Y2hlcl0sIFttc2ddKVxuICAgKlxuICAgKiBXaGVuIG5vIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIGAudGhyb3dgIGludm9rZXMgdGhlIHRhcmdldCBmdW5jdGlvbiBhbmRcbiAgICogYXNzZXJ0cyB0aGF0IGFuIGVycm9yIGlzIHRocm93bi5cbiAgICogXG4gICAqICAgICB2YXIgYmFkRm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgc2FsbW9uIScpOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdygpO1xuICAgKlxuICAgKiBXaGVuIG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCwgYW5kIGl0J3MgYW4gZXJyb3IgY29uc3RydWN0b3IsIGAudGhyb3dgXG4gICAqIGludm9rZXMgdGhlIHRhcmdldCBmdW5jdGlvbiBhbmQgYXNzZXJ0cyB0aGF0IGFuIGVycm9yIGlzIHRocm93biB0aGF0J3MgYW5cbiAgICogaW5zdGFuY2Ugb2YgdGhhdCBlcnJvciBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogICAgIHZhciBiYWRGbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBzYWxtb24hJyk7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KFR5cGVFcnJvcik7XG4gICAqXG4gICAqIFdoZW4gb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBhbmQgaXQncyBhbiBlcnJvciBpbnN0YW5jZSwgYC50aHJvd2AgaW52b2tlc1xuICAgKiB0aGUgdGFyZ2V0IGZ1bmN0aW9uIGFuZCBhc3NlcnRzIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duIHRoYXQncyBzdHJpY3RseVxuICAgKiAoYD09PWApIGVxdWFsIHRvIHRoYXQgZXJyb3IgaW5zdGFuY2UuXG4gICAqXG4gICAqICAgICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcignSWxsZWdhbCBzYWxtb24hJyk7XG4gICAqICAgICB2YXIgYmFkRm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coZXJyKTtcbiAgICpcbiAgICogV2hlbiBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQsIGFuZCBpdCdzIGEgc3RyaW5nLCBgLnRocm93YCBpbnZva2VzIHRoZVxuICAgKiB0YXJnZXQgZnVuY3Rpb24gYW5kIGFzc2VydHMgdGhhdCBhbiBlcnJvciBpcyB0aHJvd24gd2l0aCBhIG1lc3NhZ2UgdGhhdFxuICAgKiBjb250YWlucyB0aGF0IHN0cmluZy5cbiAgICpcbiAgICogICAgIHZhciBiYWRGbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBzYWxtb24hJyk7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KCdzYWxtb24nKTtcbiAgICpcbiAgICogV2hlbiBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQsIGFuZCBpdCdzIGEgcmVndWxhciBleHByZXNzaW9uLCBgLnRocm93YFxuICAgKiBpbnZva2VzIHRoZSB0YXJnZXQgZnVuY3Rpb24gYW5kIGFzc2VydHMgdGhhdCBhbiBlcnJvciBpcyB0aHJvd24gd2l0aCBhXG4gICAqIG1lc3NhZ2UgdGhhdCBtYXRjaGVzIHRoYXQgcmVndWxhciBleHByZXNzaW9uLlxuICAgKlxuICAgKiAgICAgdmFyIGJhZEZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIHNhbG1vbiEnKTsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coL3NhbG1vbi8pO1xuICAgKlxuICAgKiBXaGVuIHR3byBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCBhbmQgdGhlIGZpcnN0IGlzIGFuIGVycm9yIGluc3RhbmNlIG9yXG4gICAqIGNvbnN0cnVjdG9yLCBhbmQgdGhlIHNlY29uZCBpcyBhIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24sIGAudGhyb3dgXG4gICAqIGludm9rZXMgdGhlIGZ1bmN0aW9uIGFuZCBhc3NlcnRzIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duIHRoYXQgZnVsZmlsbHMgYm90aFxuICAgKiBjb25kaXRpb25zIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICpcbiAgICogICAgIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIHNhbG1vbiEnKTtcbiAgICogICAgIHZhciBiYWRGbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdyhUeXBlRXJyb3IsICdzYWxtb24nKTtcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coVHlwZUVycm9yLCAvc2FsbW9uLyk7XG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KGVyciwgJ3NhbG1vbicpO1xuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdyhlcnIsIC9zYWxtb24vKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC50aHJvd2AuXG4gICAqICAgICBcbiAgICogICAgIHZhciBnb29kRm4gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChnb29kRm4pLnRvLm5vdC50aHJvdygpO1xuICAgKiBcbiAgICogSG93ZXZlciwgaXQncyBkYW5nZXJvdXMgdG8gbmVnYXRlIGAudGhyb3dgIHdoZW4gcHJvdmlkaW5nIGFueSBhcmd1bWVudHMuXG4gICAqIFRoZSBwcm9ibGVtIGlzIHRoYXQgaXQgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zIGJ5IGFzc2VydGluZyB0aGF0IHRoZVxuICAgKiB0YXJnZXQgZWl0aGVyIGRvZXNuJ3QgdGhyb3cgYW4gZXJyb3IsIG9yIHRoYXQgaXQgdGhyb3dzIGFuIGVycm9yIGJ1dCBvZiBhXG4gICAqIGRpZmZlcmVudCB0eXBlIHRoYW4gdGhlIGdpdmVuIHR5cGUsIG9yIHRoYXQgaXQgdGhyb3dzIGFuIGVycm9yIG9mIHRoZSBnaXZlblxuICAgKiB0eXBlIGJ1dCB3aXRoIGEgbWVzc2FnZSB0aGF0IGRvZXNuJ3QgaW5jbHVkZSB0aGUgZ2l2ZW4gc3RyaW5nLiBJdCdzIG9mdGVuXG4gICAqIGJlc3QgdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3MgZXhwZWN0ZWQsIGFuZCB0aGVuIHdyaXRlIGFuXG4gICAqIGFzc2VydGlvbiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzbid0IGV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0XG4gICAqIGV4YWN0bHkgdGhhdC5cbiAgICpcbiAgICogICAgIHZhciBnb29kRm4gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChnb29kRm4pLnRvLm5vdC50aHJvdygpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGdvb2RGbikudG8ubm90LnRocm93KFJlZmVyZW5jZUVycm9yLCAneCcpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0XG4gICAqIHRoYXQgdGhlIGVycm9yIGlzIG9mIGl0cyBleHBlY3RlZCB0eXBlLCBhbmQgaGFzIGEgbWVzc2FnZSB0aGF0IGluY2x1ZGVzIGFuXG4gICAqIGV4cGVjdGVkIHN0cmluZywgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIHRoYXQgaXQgZG9lc24ndCBoYXZlIG9uZSBvZiBtYW55XG4gICAqIHVuZXhwZWN0ZWQgdHlwZXMsIGFuZCBkb2Vzbid0IGhhdmUgYSBtZXNzYWdlIHRoYXQgaW5jbHVkZXMgc29tZSBzdHJpbmcuXG4gICAqXG4gICAqICAgICB2YXIgYmFkRm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgc2FsbW9uIScpOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdyhUeXBlRXJyb3IsICdzYWxtb24nKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8ubm90LnRocm93KFJlZmVyZW5jZUVycm9yLCAneCcpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC50aHJvd2AgY2hhbmdlcyB0aGUgdGFyZ2V0IG9mIGFueSBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0b1xuICAgKiBiZSB0aGUgZXJyb3Igb2JqZWN0IHRoYXQncyB0aHJvd24uXG4gICAqXG4gICAqICAgICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcignSWxsZWdhbCBzYWxtb24hJyk7XG4gICAqICAgICBlcnIuY29kZSA9IDQyO1xuICAgKiAgICAgdmFyIGJhZEZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBlcnI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KFR5cGVFcnJvcikud2l0aC5wcm9wZXJ0eSgnY29kZScsIDQyKTtcbiAgICpcbiAgICogYC50aHJvd2AgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gICAqIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGVcbiAgICogc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLiBXaGVuIG5vdCBwcm92aWRpbmcgdHdvIGFyZ3VtZW50cywgYWx3YXlzIHVzZVxuICAgKiB0aGUgc2Vjb25kIGZvcm0uXG4gICAqXG4gICAqICAgICB2YXIgZ29vZEZuID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3QoZ29vZEZuKS50by50aHJvdyhUeXBlRXJyb3IsICd4JywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KGdvb2RGbiwgJ25vb28gd2h5IGZhaWw/PycpLnRvLnRocm93KCk7XG4gICAqXG4gICAqIER1ZSB0byBsaW1pdGF0aW9ucyBpbiBFUzUsIGAudGhyb3dgIG1heSBub3QgYWx3YXlzIHdvcmsgYXMgZXhwZWN0ZWQgd2hlblxuICAgKiB1c2luZyBhIHRyYW5zcGlsZXIgc3VjaCBhcyBCYWJlbCBvciBUeXBlU2NyaXB0LiBJbiBwYXJ0aWN1bGFyLCBpdCBtYXlcbiAgICogcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMgd2hlbiBzdWJjbGFzc2luZyB0aGUgYnVpbHQtaW4gYEVycm9yYCBvYmplY3QgYW5kXG4gICAqIHRoZW4gcGFzc2luZyB0aGUgc3ViY2xhc3NlZCBjb25zdHJ1Y3RvciB0byBgLnRocm93YC4gU2VlIHlvdXIgdHJhbnNwaWxlcidzXG4gICAqIGRvY3MgZm9yIGRldGFpbHM6XG4gICAqXG4gICAqIC0gKFtCYWJlbF0oaHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvdXNhZ2UvY2F2ZWF0cy8jY2xhc3NlcykpXG4gICAqIC0gKFtUeXBlU2NyaXB0XShodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvd2lraS9CcmVha2luZy1DaGFuZ2VzI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29yaykpXG4gICAqXG4gICAqIEJld2FyZSBvZiBzb21lIGNvbW1vbiBtaXN0YWtlcyB3aGVuIHVzaW5nIHRoZSBgdGhyb3dgIGFzc2VydGlvbi4gT25lIGNvbW1vblxuICAgKiBtaXN0YWtlIGlzIHRvIGFjY2lkZW50YWxseSBpbnZva2UgdGhlIGZ1bmN0aW9uIHlvdXJzZWxmIGluc3RlYWQgb2YgbGV0dGluZ1xuICAgKiB0aGUgYHRocm93YCBhc3NlcnRpb24gaW52b2tlIHRoZSBmdW5jdGlvbiBmb3IgeW91LiBGb3IgZXhhbXBsZSwgd2hlblxuICAgKiB0ZXN0aW5nIGlmIGEgZnVuY3Rpb24gbmFtZWQgYGZuYCB0aHJvd3MsIHByb3ZpZGUgYGZuYCBpbnN0ZWFkIG9mIGBmbigpYCBhc1xuICAgKiB0aGUgdGFyZ2V0IGZvciB0aGUgYXNzZXJ0aW9uLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdygpOyAgICAgLy8gR29vZCEgVGVzdHMgYGZuYCBhcyBkZXNpcmVkXG4gICAqICAgICBleHBlY3QoZm4oKSkudG8udGhyb3coKTsgICAvLyBCYWQhIFRlc3RzIHJlc3VsdCBvZiBgZm4oKWAsIG5vdCBgZm5gXG4gICAqXG4gICAqIElmIHlvdSBuZWVkIHRvIGFzc2VydCB0aGF0IHlvdXIgZnVuY3Rpb24gYGZuYCB0aHJvd3Mgd2hlbiBwYXNzZWQgY2VydGFpblxuICAgKiBhcmd1bWVudHMsIHRoZW4gd3JhcCBhIGNhbGwgdG8gYGZuYCBpbnNpZGUgb2YgYW5vdGhlciBmdW5jdGlvbi5cbiAgICpcbiAgICogICAgIGV4cGVjdChmdW5jdGlvbiAoKSB7IGZuKDQyKTsgfSkudG8udGhyb3coKTsgIC8vIEZ1bmN0aW9uIGV4cHJlc3Npb25cbiAgICogICAgIGV4cGVjdCgoKSA9PiBmbig0MikpLnRvLnRocm93KCk7ICAgICAgICAgICAgIC8vIEVTNiBhcnJvdyBmdW5jdGlvblxuICAgKlxuICAgKiBBbm90aGVyIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHByb3ZpZGUgYW4gb2JqZWN0IG1ldGhvZCAob3IgYW55IHN0YW5kLWFsb25lXG4gICAqIGZ1bmN0aW9uIHRoYXQgcmVsaWVzIG9uIGB0aGlzYCkgYXMgdGhlIHRhcmdldCBvZiB0aGUgYXNzZXJ0aW9uLiBEb2luZyBzbyBpc1xuICAgKiBwcm9ibGVtYXRpYyBiZWNhdXNlIHRoZSBgdGhpc2AgY29udGV4dCB3aWxsIGJlIGxvc3Qgd2hlbiB0aGUgZnVuY3Rpb24gaXNcbiAgICogaW52b2tlZCBieSBgLnRocm93YDsgdGhlcmUncyBubyB3YXkgZm9yIGl0IHRvIGtub3cgd2hhdCBgdGhpc2AgaXMgc3VwcG9zZWRcbiAgICogdG8gYmUuIFRoZXJlIGFyZSB0d28gd2F5cyBhcm91bmQgdGhpcyBwcm9ibGVtLiBPbmUgc29sdXRpb24gaXMgdG8gd3JhcCB0aGVcbiAgICogbWV0aG9kIG9yIGZ1bmN0aW9uIGNhbGwgaW5zaWRlIG9mIGFub3RoZXIgZnVuY3Rpb24uIEFub3RoZXIgc29sdXRpb24gaXMgdG9cbiAgICogdXNlIGBiaW5kYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChmdW5jdGlvbiAoKSB7IGNhdC5tZW93KCk7IH0pLnRvLnRocm93KCk7ICAvLyBGdW5jdGlvbiBleHByZXNzaW9uXG4gICAqICAgICBleHBlY3QoKCkgPT4gY2F0Lm1lb3coKSkudG8udGhyb3coKTsgICAgICAgICAgICAgLy8gRVM2IGFycm93IGZ1bmN0aW9uXG4gICAqICAgICBleHBlY3QoY2F0Lm1lb3cuYmluZChjYXQpKS50by50aHJvdygpOyAgICAgICAgICAgLy8gQmluZFxuICAgKlxuICAgKiBGaW5hbGx5LCBpdCdzIHdvcnRoIG1lbnRpb25pbmcgdGhhdCBpdCdzIGEgYmVzdCBwcmFjdGljZSBpbiBKYXZhU2NyaXB0IHRvXG4gICAqIG9ubHkgdGhyb3cgYEVycm9yYCBhbmQgZGVyaXZhdGl2ZXMgb2YgYEVycm9yYCBzdWNoIGFzIGBSZWZlcmVuY2VFcnJvcmAsXG4gICAqIGBUeXBlRXJyb3JgLCBhbmQgdXNlci1kZWZpbmVkIG9iamVjdHMgdGhhdCBleHRlbmQgYEVycm9yYC4gTm8gb3RoZXIgdHlwZSBvZlxuICAgKiB2YWx1ZSB3aWxsIGdlbmVyYXRlIGEgc3RhY2sgdHJhY2Ugd2hlbiBpbml0aWFsaXplZC4gV2l0aCB0aGF0IHNhaWQsIHRoZVxuICAgKiBgdGhyb3dgIGFzc2VydGlvbiBkb2VzIHRlY2huaWNhbGx5IHN1cHBvcnQgYW55IHR5cGUgb2YgdmFsdWUgYmVpbmcgdGhyb3duLFxuICAgKiBub3QganVzdCBgRXJyb3JgIGFuZCBpdHMgZGVyaXZhdGl2ZXMuXG4gICAqXG4gICAqIFRoZSBhbGlhc2VzIGAudGhyb3dzYCBhbmQgYC5UaHJvd2AgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGhcbiAgICogYC50aHJvd2AuXG4gICAqXG4gICAqIEBuYW1lIHRocm93XG4gICAqIEBhbGlhcyB0aHJvd3NcbiAgICogQGFsaWFzIFRocm93XG4gICAqIEBwYXJhbSB7RXJyb3J8RXJyb3JDb25zdHJ1Y3Rvcn0gZXJyb3JMaWtlXG4gICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXJyTXNnTWF0Y2hlciBlcnJvciBtZXNzYWdlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAqIEByZXR1cm5zIGVycm9yIGZvciBjaGFpbmluZyAobnVsbCBpZiBubyBlcnJvcilcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0VGhyb3dzIChlcnJvckxpa2UsIGVyck1zZ01hdGNoZXIsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgbmVnYXRlID0gZmxhZyh0aGlzLCAnbmVnYXRlJykgfHwgZmFsc2U7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ2Z1bmN0aW9uJyk7XG5cbiAgICBpZiAoZXJyb3JMaWtlIGluc3RhbmNlb2YgUmVnRXhwIHx8IHR5cGVvZiBlcnJvckxpa2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJNc2dNYXRjaGVyID0gZXJyb3JMaWtlO1xuICAgICAgZXJyb3JMaWtlID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY2F1Z2h0RXJyO1xuICAgIHRyeSB7XG4gICAgICBvYmooKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhdWdodEVyciA9IGVycjtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIHRoZSBuZWdhdGUgZmxhZyBlbmFibGVkIGFuZCBhdCBsZWFzdCBvbmUgdmFsaWQgYXJndW1lbnQgaXQgbWVhbnMgd2UgZG8gZXhwZWN0IGFuIGVycm9yXG4gICAgLy8gYnV0IHdlIHdhbnQgaXQgdG8gbWF0Y2ggYSBnaXZlbiBzZXQgb2YgY3JpdGVyaWFcbiAgICB2YXIgZXZlcnlBcmdJc1VuZGVmaW5lZCA9IGVycm9yTGlrZSA9PT0gdW5kZWZpbmVkICYmIGVyck1zZ01hdGNoZXIgPT09IHVuZGVmaW5lZDtcblxuICAgIC8vIElmIHdlJ3ZlIGdvdCB0aGUgbmVnYXRlIGZsYWcgZW5hYmxlZCBhbmQgYm90aCBhcmdzLCB3ZSBzaG91bGQgb25seSBmYWlsIGlmIGJvdGggYXJlbid0IGNvbXBhdGlibGVcbiAgICAvLyBTZWUgSXNzdWUgIzU1MSBhbmQgUFIgIzY4M0BHaXRIdWJcbiAgICB2YXIgZXZlcnlBcmdJc0RlZmluZWQgPSBCb29sZWFuKGVycm9yTGlrZSAmJiBlcnJNc2dNYXRjaGVyKTtcbiAgICB2YXIgZXJyb3JMaWtlRmFpbCA9IGZhbHNlO1xuICAgIHZhciBlcnJNc2dNYXRjaGVyRmFpbCA9IGZhbHNlO1xuXG4gICAgLy8gQ2hlY2tpbmcgaWYgZXJyb3Igd2FzIHRocm93blxuICAgIGlmIChldmVyeUFyZ0lzVW5kZWZpbmVkIHx8ICFldmVyeUFyZ0lzVW5kZWZpbmVkICYmICFuZWdhdGUpIHtcbiAgICAgIC8vIFdlIG5lZWQgdGhpcyB0byBkaXNwbGF5IHJlc3VsdHMgY29ycmVjdGx5IGFjY29yZGluZyB0byB0aGVpciB0eXBlc1xuICAgICAgdmFyIGVycm9yTGlrZVN0cmluZyA9ICdhbiBlcnJvcic7XG4gICAgICBpZiAoZXJyb3JMaWtlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgZXJyb3JMaWtlU3RyaW5nID0gJyN7ZXhwfSc7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yTGlrZSkge1xuICAgICAgICBlcnJvckxpa2VTdHJpbmcgPSBfLmNoZWNrRXJyb3IuZ2V0Q29uc3RydWN0b3JOYW1lKGVycm9yTGlrZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGNhdWdodEVyclxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93ICcgKyBlcnJvckxpa2VTdHJpbmdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgdGhyb3cgYW4gZXJyb3IgYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAsIGVycm9yTGlrZSAmJiBlcnJvckxpa2UudG9TdHJpbmcoKVxuICAgICAgICAsIChjYXVnaHRFcnIgaW5zdGFuY2VvZiBFcnJvciA/XG4gICAgICAgICAgICBjYXVnaHRFcnIudG9TdHJpbmcoKSA6ICh0eXBlb2YgY2F1Z2h0RXJyID09PSAnc3RyaW5nJyA/IGNhdWdodEVyciA6IGNhdWdodEVyciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5jaGVja0Vycm9yLmdldENvbnN0cnVjdG9yTmFtZShjYXVnaHRFcnIpKSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yTGlrZSAmJiBjYXVnaHRFcnIpIHtcbiAgICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIGluc3RhbmNlcyBvbmx5IGlmIGBlcnJvckxpa2VgIGlzIGFuIGluc3RhbmNlIG9mIGBFcnJvcmBcbiAgICAgIGlmIChlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB2YXIgaXNDb21wYXRpYmxlSW5zdGFuY2UgPSBfLmNoZWNrRXJyb3IuY29tcGF0aWJsZUluc3RhbmNlKGNhdWdodEVyciwgZXJyb3JMaWtlKTtcblxuICAgICAgICBpZiAoaXNDb21wYXRpYmxlSW5zdGFuY2UgPT09IG5lZ2F0ZSkge1xuICAgICAgICAgIC8vIFRoZXNlIGNoZWNrcyB3ZXJlIGNyZWF0ZWQgdG8gZW5zdXJlIHdlIHdvbid0IGZhaWwgdG9vIHNvb24gd2hlbiB3ZSd2ZSBnb3QgYm90aCBhcmdzIGFuZCBhIG5lZ2F0ZVxuICAgICAgICAgIC8vIFNlZSBJc3N1ZSAjNTUxIGFuZCBQUiAjNjgzQEdpdEh1YlxuICAgICAgICAgIGlmIChldmVyeUFyZ0lzRGVmaW5lZCAmJiBuZWdhdGUpIHtcbiAgICAgICAgICAgIGVycm9yTGlrZUZhaWwgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgICAgICBuZWdhdGVcbiAgICAgICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyAje2V4cH0gYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCB0aHJvdyAje2V4cH0nICsgKGNhdWdodEVyciAmJiAhbmVnYXRlID8gJyBidXQgI3thY3R9IHdhcyB0aHJvd24nIDogJycpXG4gICAgICAgICAgICAgICwgZXJyb3JMaWtlLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgLCBjYXVnaHRFcnIudG9TdHJpbmcoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGlzQ29tcGF0aWJsZUNvbnN0cnVjdG9yID0gXy5jaGVja0Vycm9yLmNvbXBhdGlibGVDb25zdHJ1Y3RvcihjYXVnaHRFcnIsIGVycm9yTGlrZSk7XG4gICAgICBpZiAoaXNDb21wYXRpYmxlQ29uc3RydWN0b3IgPT09IG5lZ2F0ZSkge1xuICAgICAgICBpZiAoZXZlcnlBcmdJc0RlZmluZWQgJiYgbmVnYXRlKSB7XG4gICAgICAgICAgICBlcnJvckxpa2VGYWlsID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgICAgbmVnYXRlXG4gICAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93ICN7ZXhwfSBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCB0aHJvdyAje2V4cH0nICsgKGNhdWdodEVyciA/ICcgYnV0ICN7YWN0fSB3YXMgdGhyb3duJyA6ICcnKVxuICAgICAgICAgICAgLCAoZXJyb3JMaWtlIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvckxpa2UudG9TdHJpbmcoKSA6IGVycm9yTGlrZSAmJiBfLmNoZWNrRXJyb3IuZ2V0Q29uc3RydWN0b3JOYW1lKGVycm9yTGlrZSkpXG4gICAgICAgICAgICAsIChjYXVnaHRFcnIgaW5zdGFuY2VvZiBFcnJvciA/IGNhdWdodEVyci50b1N0cmluZygpIDogY2F1Z2h0RXJyICYmIF8uY2hlY2tFcnJvci5nZXRDb25zdHJ1Y3Rvck5hbWUoY2F1Z2h0RXJyKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNhdWdodEVyciAmJiBlcnJNc2dNYXRjaGVyICE9PSB1bmRlZmluZWQgJiYgZXJyTXNnTWF0Y2hlciAhPT0gbnVsbCkge1xuICAgICAgLy8gSGVyZSB3ZSBjaGVjayBjb21wYXRpYmxlIG1lc3NhZ2VzXG4gICAgICB2YXIgcGxhY2Vob2xkZXIgPSAnaW5jbHVkaW5nJztcbiAgICAgIGlmIChlcnJNc2dNYXRjaGVyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHBsYWNlaG9sZGVyID0gJ21hdGNoaW5nJ1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNDb21wYXRpYmxlTWVzc2FnZSA9IF8uY2hlY2tFcnJvci5jb21wYXRpYmxlTWVzc2FnZShjYXVnaHRFcnIsIGVyck1zZ01hdGNoZXIpO1xuICAgICAgaWYgKGlzQ29tcGF0aWJsZU1lc3NhZ2UgPT09IG5lZ2F0ZSkge1xuICAgICAgICBpZiAoZXZlcnlBcmdJc0RlZmluZWQgJiYgbmVnYXRlKSB7XG4gICAgICAgICAgICBlcnJNc2dNYXRjaGVyRmFpbCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICBuZWdhdGVcbiAgICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgZXJyb3IgJyArIHBsYWNlaG9sZGVyICsgJyAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93IGVycm9yIG5vdCAnICsgcGxhY2Vob2xkZXIgKyAnICN7ZXhwfSdcbiAgICAgICAgICAgICwgIGVyck1zZ01hdGNoZXJcbiAgICAgICAgICAgICwgIF8uY2hlY2tFcnJvci5nZXRNZXNzYWdlKGNhdWdodEVycilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgYm90aCBhc3NlcnRpb25zIGZhaWxlZCBhbmQgYm90aCBzaG91bGQndmUgbWF0Y2hlZCB3ZSB0aHJvdyBhbiBlcnJvclxuICAgIGlmIChlcnJvckxpa2VGYWlsICYmIGVyck1zZ01hdGNoZXJGYWlsKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgbmVnYXRlXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgI3tleHB9IGJ1dCAje2FjdH0gd2FzIHRocm93bidcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgdGhyb3cgI3tleHB9JyArIChjYXVnaHRFcnIgPyAnIGJ1dCAje2FjdH0gd2FzIHRocm93bicgOiAnJylcbiAgICAgICAgLCAoZXJyb3JMaWtlIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvckxpa2UudG9TdHJpbmcoKSA6IGVycm9yTGlrZSAmJiBfLmNoZWNrRXJyb3IuZ2V0Q29uc3RydWN0b3JOYW1lKGVycm9yTGlrZSkpXG4gICAgICAgICwgKGNhdWdodEVyciBpbnN0YW5jZW9mIEVycm9yID8gY2F1Z2h0RXJyLnRvU3RyaW5nKCkgOiBjYXVnaHRFcnIgJiYgXy5jaGVja0Vycm9yLmdldENvbnN0cnVjdG9yTmFtZShjYXVnaHRFcnIpKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBjYXVnaHRFcnIpO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Rocm93JywgYXNzZXJ0VGhyb3dzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgndGhyb3dzJywgYXNzZXJ0VGhyb3dzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnVGhyb3cnLCBhc3NlcnRUaHJvd3MpO1xuXG4gIC8qKlxuICAgKiAjIyMgLnJlc3BvbmRUbyhtZXRob2RbLCBtc2ddKVxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBub24tZnVuY3Rpb24gb2JqZWN0LCBgLnJlc3BvbmRUb2AgYXNzZXJ0cyB0aGF0IHRoZVxuICAgKiB0YXJnZXQgaGFzIGEgbWV0aG9kIHdpdGggdGhlIGdpdmVuIG5hbWUgYG1ldGhvZGAuIFRoZSBtZXRob2QgY2FuIGJlIG93biBvclxuICAgKiBpbmhlcml0ZWQsIGFuZCBpdCBjYW4gYmUgZW51bWVyYWJsZSBvciBub24tZW51bWVyYWJsZS5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIENhdCAoKSB7fVxuICAgKiAgICAgQ2F0LnByb3RvdHlwZS5tZW93ID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3QobmV3IENhdCgpKS50by5yZXNwb25kVG8oJ21lb3cnKTtcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgZnVuY3Rpb24sIGAucmVzcG9uZFRvYCBhc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzXG4gICAqIGBwcm90b3R5cGVgIHByb3BlcnR5IGhhcyBhIG1ldGhvZCB3aXRoIHRoZSBnaXZlbiBuYW1lIGBtZXRob2RgLiBBZ2FpbiwgdGhlXG4gICAqIG1ldGhvZCBjYW4gYmUgb3duIG9yIGluaGVyaXRlZCwgYW5kIGl0IGNhbiBiZSBlbnVtZXJhYmxlIG9yIG5vbi1lbnVtZXJhYmxlLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gQ2F0ICgpIHt9XG4gICAqICAgICBDYXQucHJvdG90eXBlLm1lb3cgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChDYXQpLnRvLnJlc3BvbmRUbygnbWVvdycpO1xuICAgKlxuICAgKiBBZGQgYC5pdHNlbGZgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIGZvcmNlIGAucmVzcG9uZFRvYCB0byB0cmVhdCB0aGVcbiAgICogdGFyZ2V0IGFzIGEgbm9uLWZ1bmN0aW9uIG9iamVjdCwgZXZlbiBpZiBpdCdzIGEgZnVuY3Rpb24uIFRodXMsIGl0IGFzc2VydHNcbiAgICogdGhhdCB0aGUgdGFyZ2V0IGhhcyBhIG1ldGhvZCB3aXRoIHRoZSBnaXZlbiBuYW1lIGBtZXRob2RgLCByYXRoZXIgdGhhblxuICAgKiBhc3NlcnRpbmcgdGhhdCB0aGUgdGFyZ2V0J3MgYHByb3RvdHlwZWAgcHJvcGVydHkgaGFzIGEgbWV0aG9kIHdpdGggdGhlXG4gICAqIGdpdmVuIG5hbWUgYG1ldGhvZGAuXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBDYXQgKCkge31cbiAgICogICAgIENhdC5wcm90b3R5cGUubWVvdyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKiAgICAgQ2F0Lmhpc3MgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChDYXQpLml0c2VsZi50by5yZXNwb25kVG8oJ2hpc3MnKS5idXQubm90LnJlc3BvbmRUbygnbWVvdycpO1xuICAgKlxuICAgKiBXaGVuIG5vdCBhZGRpbmcgYC5pdHNlbGZgLCBpdCdzIGltcG9ydGFudCB0byBjaGVjayB0aGUgdGFyZ2V0J3MgdHlwZSBiZWZvcmVcbiAgICogdXNpbmcgYC5yZXNwb25kVG9gLiBTZWUgdGhlIGAuYWAgZG9jIGZvciBpbmZvIG9uIGNoZWNraW5nIGEgdGFyZ2V0J3MgdHlwZS5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIENhdCAoKSB7fVxuICAgKiAgICAgQ2F0LnByb3RvdHlwZS5tZW93ID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3QobmV3IENhdCgpKS50by5iZS5hbignb2JqZWN0JykudGhhdC5yZXNwb25kc1RvKCdtZW93Jyk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAucmVzcG9uZFRvYC5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIERvZyAoKSB7fVxuICAgKiAgICAgRG9nLnByb3RvdHlwZS5iYXJrID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3QobmV3IERvZygpKS50by5ub3QucmVzcG9uZFRvKCdtZW93Jyk7XG4gICAqXG4gICAqIGAucmVzcG9uZFRvYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe30pLnRvLnJlc3BvbmRUbygnbWVvdycsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCh7fSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLnJlc3BvbmRUbygnbWVvdycpO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5yZXNwb25kc1RvYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLnJlc3BvbmRUb2AuXG4gICAqXG4gICAqIEBuYW1lIHJlc3BvbmRUb1xuICAgKiBAYWxpYXMgcmVzcG9uZHNUb1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiByZXNwb25kVG8gKG1ldGhvZCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGl0c2VsZiA9IGZsYWcodGhpcywgJ2l0c2VsZicpXG4gICAgICAsIGNvbnRleHQgPSAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG9iaiAmJiAhaXRzZWxmKVxuICAgICAgICA/IG9iai5wcm90b3R5cGVbbWV0aG9kXVxuICAgICAgICA6IG9ialttZXRob2RdO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICdmdW5jdGlvbicgPT09IHR5cGVvZiBjb250ZXh0XG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHJlc3BvbmQgdG8gJyArIF8uaW5zcGVjdChtZXRob2QpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCByZXNwb25kIHRvICcgKyBfLmluc3BlY3QobWV0aG9kKVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdyZXNwb25kVG8nLCByZXNwb25kVG8pO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdyZXNwb25kc1RvJywgcmVzcG9uZFRvKTtcblxuICAvKipcbiAgICogIyMjIC5pdHNlbGZcbiAgICpcbiAgICogRm9yY2VzIGFsbCBgLnJlc3BvbmRUb2AgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4gdG8gYmVoYXZlIGFzIGlmXG4gICAqIHRoZSB0YXJnZXQgaXMgYSBub24tZnVuY3Rpb24gb2JqZWN0LCBldmVuIGlmIGl0J3MgYSBmdW5jdGlvbi4gVGh1cywgaXRcbiAgICogY2F1c2VzIGAucmVzcG9uZFRvYCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGhhcyBhIG1ldGhvZCB3aXRoIHRoZSBnaXZlblxuICAgKiBuYW1lLCByYXRoZXIgdGhhbiBhc3NlcnRpbmcgdGhhdCB0aGUgdGFyZ2V0J3MgYHByb3RvdHlwZWAgcHJvcGVydHkgaGFzIGFcbiAgICogbWV0aG9kIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBDYXQgKCkge31cbiAgICogICAgIENhdC5wcm90b3R5cGUubWVvdyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKiAgICAgQ2F0Lmhpc3MgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChDYXQpLml0c2VsZi50by5yZXNwb25kVG8oJ2hpc3MnKS5idXQubm90LnJlc3BvbmRUbygnbWVvdycpO1xuICAgKlxuICAgKiBAbmFtZSBpdHNlbGZcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdpdHNlbGYnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnaXRzZWxmJywgdHJ1ZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnNhdGlzZnkobWF0Y2hlclssIG1zZ10pXG4gICAqXG4gICAqIEludm9rZXMgdGhlIGdpdmVuIGBtYXRjaGVyYCBmdW5jdGlvbiB3aXRoIHRoZSB0YXJnZXQgYmVpbmcgcGFzc2VkIGFzIHRoZVxuICAgKiBmaXJzdCBhcmd1bWVudCwgYW5kIGFzc2VydHMgdGhhdCB0aGUgdmFsdWUgcmV0dXJuZWQgaXMgdHJ1dGh5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLnNhdGlzZnkoZnVuY3Rpb24obnVtKSB7XG4gICAqICAgICAgIHJldHVybiBudW0gPiAwOyBcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLnNhdGlzZnlgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5zYXRpc2Z5KGZ1bmN0aW9uKG51bSkge1xuICAgKiAgICAgICByZXR1cm4gbnVtID4gMjtcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBgLnNhdGlzZnlgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5zYXRpc2Z5KGZ1bmN0aW9uKG51bSkge1xuICAgKiAgICAgICByZXR1cm4gbnVtID4gMjtcbiAgICogICAgIH0sICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICpcbiAgICogICAgIGV4cGVjdCgxLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uc2F0aXNmeShmdW5jdGlvbihudW0pIHtcbiAgICogICAgICAgcmV0dXJuIG51bSA+IDI7XG4gICAqICAgICB9KTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuc2F0aXNmaWVzYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLnNhdGlzZnlgLlxuICAgKlxuICAgKiBAbmFtZSBzYXRpc2Z5XG4gICAqIEBhbGlhcyBzYXRpc2ZpZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWF0Y2hlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gc2F0aXNmeSAobWF0Y2hlciwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIHZhciByZXN1bHQgPSBtYXRjaGVyKG9iaik7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHJlc3VsdFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBzYXRpc2Z5ICcgKyBfLm9iakRpc3BsYXkobWF0Y2hlcilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHNhdGlzZnknICsgXy5vYmpEaXNwbGF5KG1hdGNoZXIpXG4gICAgICAsIGZsYWcodGhpcywgJ25lZ2F0ZScpID8gZmFsc2UgOiB0cnVlXG4gICAgICAsIHJlc3VsdFxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdzYXRpc2Z5Jywgc2F0aXNmeSk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3NhdGlzZmllcycsIHNhdGlzZnkpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmNsb3NlVG8oZXhwZWN0ZWQsIGRlbHRhWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYSBudW1iZXIgdGhhdCdzIHdpdGhpbiBhIGdpdmVuICsvLSBgZGVsdGFgIHJhbmdlXG4gICAqIG9mIHRoZSBnaXZlbiBudW1iZXIgYGV4cGVjdGVkYC4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZVxuICAgKiB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLmVxdWFsKDEuNSk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLmJlLmNsb3NlVG8oMSwgMC41KTtcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLmJlLmNsb3NlVG8oMiwgMC41KTtcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLmJlLmNsb3NlVG8oMSwgMSk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuY2xvc2VUb2AuXG4gICAqXG4gICAqICAgICBleHBlY3QoMS41KS50by5lcXVhbCgxLjUpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEuNSkudG8ubm90LmJlLmNsb3NlVG8oMywgMSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmNsb3NlVG9gIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLmJlLmNsb3NlVG8oMywgMSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDEuNSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmNsb3NlVG8oMywgMSk7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmFwcHJveGltYXRlbHlgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuY2xvc2VUb2AuXG4gICAqXG4gICAqIEBuYW1lIGNsb3NlVG9cbiAgICogQGFsaWFzIGFwcHJveGltYXRlbHlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gY2xvc2VUbyhleHBlY3RlZCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG5cbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGRlbHRhICE9PSAnbnVtYmVyJykge1xuICAgICAgZmxhZ01zZyA9IGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyA6ICcnO1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICAgIGZsYWdNc2cgKyAndGhlIGFyZ3VtZW50cyB0byBjbG9zZVRvIG9yIGFwcHJveGltYXRlbHkgbXVzdCBiZSBudW1iZXJzJyxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgc3NmaVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgTWF0aC5hYnMob2JqIC0gZXhwZWN0ZWQpIDw9IGRlbHRhXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGNsb3NlIHRvICcgKyBleHBlY3RlZCArICcgKy8tICcgKyBkZWx0YVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgY2xvc2UgdG8gJyArIGV4cGVjdGVkICsgJyArLy0gJyArIGRlbHRhXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2Nsb3NlVG8nLCBjbG9zZVRvKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYXBwcm94aW1hdGVseScsIGNsb3NlVG8pO1xuXG4gIC8vIE5vdGU6IER1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgaWYgdGVzdGluZyBmb3IgaW5jbHVzaW9uIGluc3RlYWQgb2Ygc2FtZW5lc3MuXG4gIGZ1bmN0aW9uIGlzU3Vic2V0T2Yoc3Vic2V0LCBzdXBlcnNldCwgY21wLCBjb250YWlucywgb3JkZXJlZCkge1xuICAgIGlmICghY29udGFpbnMpIHtcbiAgICAgIGlmIChzdWJzZXQubGVuZ3RoICE9PSBzdXBlcnNldC5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHN1cGVyc2V0ID0gc3VwZXJzZXQuc2xpY2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Vic2V0LmV2ZXJ5KGZ1bmN0aW9uKGVsZW0sIGlkeCkge1xuICAgICAgaWYgKG9yZGVyZWQpIHJldHVybiBjbXAgPyBjbXAoZWxlbSwgc3VwZXJzZXRbaWR4XSkgOiBlbGVtID09PSBzdXBlcnNldFtpZHhdO1xuXG4gICAgICBpZiAoIWNtcCkge1xuICAgICAgICB2YXIgbWF0Y2hJZHggPSBzdXBlcnNldC5pbmRleE9mKGVsZW0pO1xuICAgICAgICBpZiAobWF0Y2hJZHggPT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgLy8gUmVtb3ZlIG1hdGNoIGZyb20gc3VwZXJzZXQgc28gbm90IGNvdW50ZWQgdHdpY2UgaWYgZHVwbGljYXRlIGluIHN1YnNldC5cbiAgICAgICAgaWYgKCFjb250YWlucykgc3VwZXJzZXQuc3BsaWNlKG1hdGNoSWR4LCAxKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdXBlcnNldC5zb21lKGZ1bmN0aW9uKGVsZW0yLCBtYXRjaElkeCkge1xuICAgICAgICBpZiAoIWNtcChlbGVtLCBlbGVtMikpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBSZW1vdmUgbWF0Y2ggZnJvbSBzdXBlcnNldCBzbyBub3QgY291bnRlZCB0d2ljZSBpZiBkdXBsaWNhdGUgaW4gc3Vic2V0LlxuICAgICAgICBpZiAoIWNvbnRhaW5zKSBzdXBlcnNldC5zcGxpY2UobWF0Y2hJZHgsIDEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubWVtYmVycyhzZXRbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBhcnJheSBoYXMgdGhlIHNhbWUgbWVtYmVycyBhcyB0aGUgZ2l2ZW4gYXJyYXlcbiAgICogYHNldGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLm1lbWJlcnMoWzIsIDEsIDNdKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgMl0pLnRvLmhhdmUubWVtYmVycyhbMiwgMSwgMl0pO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBtZW1iZXJzIGFyZSBjb21wYXJlZCB1c2luZyBzdHJpY3QgKGA9PT1gKSBlcXVhbGl0eS4gQWRkIGAuZGVlcGBcbiAgICogZWFybGllciBpbiB0aGUgY2hhaW4gdG8gdXNlIGRlZXAgZXF1YWxpdHkgaW5zdGVhZC4gU2VlIHRoZSBgZGVlcC1lcWxgXG4gICAqIHByb2plY3QgcGFnZSBmb3IgaW5mbyBvbiB0aGUgZGVlcCBlcXVhbGl0eSBhbGdvcml0aG06XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWwuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgYXJyYXkgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBoYXMgbWVtYmVyIGB7YTogMX1gXG4gICAqICAgICBleHBlY3QoW3thOiAxfV0pLnRvLmhhdmUuZGVlcC5tZW1iZXJzKFt7YTogMX1dKTtcbiAgICogICAgIGV4cGVjdChbe2E6IDF9XSkudG8ubm90LmhhdmUubWVtYmVycyhbe2E6IDF9XSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIG9yZGVyIGRvZXNuJ3QgbWF0dGVyLiBBZGQgYC5vcmRlcmVkYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0b1xuICAgKiByZXF1aXJlIHRoYXQgbWVtYmVycyBhcHBlYXIgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLm9yZGVyZWQubWVtYmVycyhbMSwgMiwgM10pO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5tZW1iZXJzKFsyLCAxLCAzXSlcbiAgICogICAgICAgLmJ1dC5ub3Qub3JkZXJlZC5tZW1iZXJzKFsyLCAxLCAzXSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGJvdGggYXJyYXlzIG11c3QgYmUgdGhlIHNhbWUgc2l6ZS4gQWRkIGAuaW5jbHVkZWAgZWFybGllciBpblxuICAgKiB0aGUgY2hhaW4gdG8gcmVxdWlyZSB0aGF0IHRoZSB0YXJnZXQncyBtZW1iZXJzIGJlIGEgc3VwZXJzZXQgb2YgdGhlXG4gICAqIGV4cGVjdGVkIG1lbWJlcnMuIE5vdGUgdGhhdCBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGluIHRoZSBzdWJzZXQgd2hlblxuICAgKiBgLmluY2x1ZGVgIGlzIGFkZGVkLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IGFycmF5IGlzIGEgc3VwZXJzZXQgb2YgWzEsIDJdIGJ1dCBub3QgaWRlbnRpY2FsXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5pbmNsdWRlLm1lbWJlcnMoWzEsIDJdKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLm5vdC5oYXZlLm1lbWJlcnMoWzEsIDJdKTtcbiAgICpcbiAgICogICAgIC8vIER1cGxpY2F0ZXMgaW4gdGhlIHN1YnNldCBhcmUgaWdub3JlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaW5jbHVkZS5tZW1iZXJzKFsxLCAyLCAyLCAyXSk7XG4gICAqXG4gICAqIGAuZGVlcGAsIGAub3JkZXJlZGAsIGFuZCBgLmluY2x1ZGVgIGNhbiBhbGwgYmUgY29tYmluZWQuIEhvd2V2ZXIsIGlmXG4gICAqIGAuaW5jbHVkZWAgYW5kIGAub3JkZXJlZGAgYXJlIGNvbWJpbmVkLCB0aGUgb3JkZXJpbmcgYmVnaW5zIGF0IHRoZSBzdGFydCBvZlxuICAgKiBib3RoIGFycmF5cy5cbiAgICpcbiAgICogICAgIGV4cGVjdChbe2E6IDF9LCB7YjogMn0sIHtjOiAzfV0pXG4gICAqICAgICAgIC50by5pbmNsdWRlLmRlZXAub3JkZXJlZC5tZW1iZXJzKFt7YTogMX0sIHtiOiAyfV0pXG4gICAqICAgICAgIC5idXQubm90LmluY2x1ZGUuZGVlcC5vcmRlcmVkLm1lbWJlcnMoW3tiOiAyfSwge2M6IDN9XSk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAubWVtYmVyc2AuIEhvd2V2ZXIsIGl0J3NcbiAgICogZGFuZ2Vyb3VzIHRvIGRvIHNvLiBUaGUgcHJvYmxlbSBpcyB0aGF0IGl0IGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9uc1xuICAgKiBieSBhc3NlcnRpbmcgdGhhdCB0aGUgdGFyZ2V0IGFycmF5IGRvZXNuJ3QgaGF2ZSBhbGwgb2YgdGhlIHNhbWUgbWVtYmVycyBhc1xuICAgKiB0aGUgZ2l2ZW4gYXJyYXkgYHNldGAgYnV0IG1heSBvciBtYXkgbm90IGhhdmUgc29tZSBvZiB0aGVtLiBJdCdzIG9mdGVuIGJlc3RcbiAgICogdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3MgZXhwZWN0ZWQsIGFuZCB0aGVuIHdyaXRlIGFuIGFzc2VydGlvblxuICAgKiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLm5vdC5pbmNsdWRlKDMpLmFuZC5ub3QuaW5jbHVkZSg0KTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLm5vdC5oYXZlLm1lbWJlcnMoWzMsIDRdKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAubWVtYmVyc2AgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8uaGF2ZS5tZW1iZXJzKFsxLCAyLCAzXSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyXSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmhhdmUubWVtYmVycyhbMSwgMiwgM10pO1xuICAgKlxuICAgKiBAbmFtZSBtZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbWVtYmVycycsIGZ1bmN0aW9uIChzdWJzZXQsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG5cbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uYmUuYW4oJ2FycmF5Jyk7XG4gICAgbmV3IEFzc2VydGlvbihzdWJzZXQsIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmJlLmFuKCdhcnJheScpO1xuXG4gICAgdmFyIGNvbnRhaW5zID0gZmxhZyh0aGlzLCAnY29udGFpbnMnKTtcbiAgICB2YXIgb3JkZXJlZCA9IGZsYWcodGhpcywgJ29yZGVyZWQnKTtcblxuICAgIHZhciBzdWJqZWN0LCBmYWlsTXNnLCBmYWlsTmVnYXRlTXNnLCBsZW5ndGhDaGVjaztcblxuICAgIGlmIChjb250YWlucykge1xuICAgICAgc3ViamVjdCA9IG9yZGVyZWQgPyAnYW4gb3JkZXJlZCBzdXBlcnNldCcgOiAnYSBzdXBlcnNldCc7XG4gICAgICBmYWlsTXNnID0gJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgJyArIHN1YmplY3QgKyAnIG9mICN7ZXhwfSc7XG4gICAgICBmYWlsTmVnYXRlTXNnID0gJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlICcgKyBzdWJqZWN0ICsgJyBvZiAje2V4cH0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJqZWN0ID0gb3JkZXJlZCA/ICdvcmRlcmVkIG1lbWJlcnMnIDogJ21lbWJlcnMnO1xuICAgICAgZmFpbE1zZyA9ICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgdGhlIHNhbWUgJyArIHN1YmplY3QgKyAnIGFzICN7ZXhwfSc7XG4gICAgICBmYWlsTmVnYXRlTXNnID0gJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgdGhlIHNhbWUgJyArIHN1YmplY3QgKyAnIGFzICN7ZXhwfSc7XG4gICAgfVxuXG4gICAgdmFyIGNtcCA9IGZsYWcodGhpcywgJ2RlZXAnKSA/IF8uZXFsIDogdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGlzU3Vic2V0T2Yoc3Vic2V0LCBvYmosIGNtcCwgY29udGFpbnMsIG9yZGVyZWQpXG4gICAgICAsIGZhaWxNc2dcbiAgICAgICwgZmFpbE5lZ2F0ZU1zZ1xuICAgICAgLCBzdWJzZXRcbiAgICAgICwgb2JqXG4gICAgICAsIHRydWVcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5vbmVPZihsaXN0WywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYSBtZW1iZXIgb2YgdGhlIGdpdmVuIGFycmF5IGBsaXN0YC4gSG93ZXZlcixcbiAgICogaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLm9uZU9mKFsxLCAyLCAzXSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBDb21wYXJpc29ucyBhcmUgcGVyZm9ybWVkIHVzaW5nIHN0cmljdCAoYD09PWApIGVxdWFsaXR5LlxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLm9uZU9mYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUub25lT2YoWzIsIDMsIDRdKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAub25lT2ZgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5vbmVPZihbMiwgMywgNF0sICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgxLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUub25lT2YoWzIsIDMsIDRdKTtcbiAgICpcbiAgICogQG5hbWUgb25lT2ZcbiAgICogQHBhcmFtIHtBcnJheTwqPn0gbGlzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gb25lT2YgKGxpc3QsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBleHBlY3RlZCA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICBuZXcgQXNzZXJ0aW9uKGxpc3QsIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmJlLmFuKCdhcnJheScpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGxpc3QuaW5kZXhPZihleHBlY3RlZCkgPiAtMVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBvbmUgb2YgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgb25lIG9mICN7ZXhwfSdcbiAgICAgICwgbGlzdFxuICAgICAgLCBleHBlY3RlZFxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdvbmVPZicsIG9uZU9mKTtcblxuXG4gIC8qKlxuICAgKiAjIyMgLmNoYW5nZShzdWJqZWN0WywgcHJvcFssIG1zZ11dKVxuICAgKlxuICAgKiBXaGVuIG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCwgYC5jaGFuZ2VgIGFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gZnVuY3Rpb25cbiAgICogYHN1YmplY3RgIHJldHVybnMgYSBkaWZmZXJlbnQgdmFsdWUgd2hlbiBpdCdzIGludm9rZWQgYmVmb3JlIHRoZSB0YXJnZXRcbiAgICogZnVuY3Rpb24gY29tcGFyZWQgdG8gd2hlbiBpdCdzIGludm9rZWQgYWZ0ZXJ3YXJkLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3RcbiAgICogdG8gYXNzZXJ0IHRoYXQgYHN1YmplY3RgIGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIHZhciBkb3RzID0gJydcbiAgICogICAgICAgLCBhZGREb3QgPSBmdW5jdGlvbiAoKSB7IGRvdHMgKz0gJy4nOyB9XG4gICAqICAgICAgICwgZ2V0RG90cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvdHM7IH07XG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGdldERvdHMoKSkudG8uZXF1YWwoJycpO1xuICAgKiAgICAgYWRkRG90KCk7XG4gICAqICAgICBleHBlY3QoZ2V0RG90cygpKS50by5lcXVhbCgnLicpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkRG90KS50by5jaGFuZ2UoZ2V0RG90cyk7XG4gICAqXG4gICAqIFdoZW4gdHdvIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIGAuY2hhbmdlYCBhc3NlcnRzIHRoYXQgdGhlIHZhbHVlIG9mIHRoZVxuICAgKiBnaXZlbiBvYmplY3QgYHN1YmplY3RgJ3MgYHByb3BgIHByb3BlcnR5IGlzIGRpZmZlcmVudCBiZWZvcmUgaW52b2tpbmcgdGhlXG4gICAqIHRhcmdldCBmdW5jdGlvbiBjb21wYXJlZCB0byBhZnRlcndhcmQuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7ZG90czogJyd9XG4gICAqICAgICAgICwgYWRkRG90ID0gZnVuY3Rpb24gKCkgeyBteU9iai5kb3RzICs9ICcuJzsgfTtcbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QobXlPYmopLnRvLmhhdmUucHJvcGVydHkoJ2RvdHMnLCAnJyk7XG4gICAqICAgICBhZGREb3QoKTtcbiAgICogICAgIGV4cGVjdChteU9iaikudG8uaGF2ZS5wcm9wZXJ0eSgnZG90cycsICcuJyk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChhZGREb3QpLnRvLmNoYW5nZShteU9iaiwgJ2RvdHMnKTtcbiAgICpcbiAgICogU3RyaWN0IChgPT09YCkgZXF1YWxpdHkgaXMgdXNlZCB0byBjb21wYXJlIGJlZm9yZSBhbmQgYWZ0ZXIgdmFsdWVzLlxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmNoYW5nZWAuXG4gICAqXG4gICAqICAgICB2YXIgZG90cyA9ICcnXG4gICAqICAgICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG4gICAqICAgICAgICwgZ2V0RG90cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvdHM7IH07XG4gICAqXG4gICAqICAgICBleHBlY3Qobm9vcCkudG8ubm90LmNoYW5nZShnZXREb3RzKTtcbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHtkb3RzOiAnJ31cbiAgICogICAgICAgLCBub29wID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3Qobm9vcCkudG8ubm90LmNoYW5nZShteU9iaiwgJ2RvdHMnKTtcbiAgICpcbiAgICogYC5jaGFuZ2VgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC4gV2hlbiBub3QgcHJvdmlkaW5nIHR3byBhcmd1bWVudHMsIGFsd2F5c1xuICAgKiB1c2UgdGhlIHNlY29uZCBmb3JtLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge2RvdHM6ICcnfVxuICAgKiAgICAgICAsIGFkZERvdCA9IGZ1bmN0aW9uICgpIHsgbXlPYmouZG90cyArPSAnLic7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYWRkRG90KS50by5ub3QuY2hhbmdlKG15T2JqLCAnZG90cycsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICpcbiAgICogICAgIHZhciBkb3RzID0gJydcbiAgICogICAgICAgLCBhZGREb3QgPSBmdW5jdGlvbiAoKSB7IGRvdHMgKz0gJy4nOyB9XG4gICAqICAgICAgICwgZ2V0RG90cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvdHM7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYWRkRG90LCAnbm9vbyB3aHkgZmFpbD8/JykudG8ubm90LmNoYW5nZShnZXREb3RzKTtcbiAgICpcbiAgICogYC5jaGFuZ2VgIGFsc28gY2F1c2VzIGFsbCBgLmJ5YCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0b1xuICAgKiBhc3NlcnQgaG93IG11Y2ggYSBudW1lcmljIHN1YmplY3Qgd2FzIGluY3JlYXNlZCBvciBkZWNyZWFzZWQgYnkuIEhvd2V2ZXIsXG4gICAqIGl0J3MgZGFuZ2Vyb3VzIHRvIHVzZSBgLmNoYW5nZS5ieWAuIFRoZSBwcm9ibGVtIGlzIHRoYXQgaXQgY3JlYXRlc1xuICAgKiB1bmNlcnRhaW4gZXhwZWN0YXRpb25zIGJ5IGFzc2VydGluZyB0aGF0IHRoZSBzdWJqZWN0IGVpdGhlciBpbmNyZWFzZXMgYnlcbiAgICogdGhlIGdpdmVuIGRlbHRhLCBvciB0aGF0IGl0IGRlY3JlYXNlcyBieSB0aGUgZ2l2ZW4gZGVsdGEuIEl0J3Mgb2Z0ZW4gYmVzdFxuICAgKiB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQncyBleHBlY3RlZCwgYW5kIHRoZW4gd3JpdGUgYW4gYXNzZXJ0aW9uXG4gICAqIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBhZGRUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCArPSAyOyB9XG4gICAqICAgICAgICwgc3VidHJhY3RUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCAtPSAyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmNoYW5nZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uZGVjcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uY2hhbmdlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5jaGFuZ2VzYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmNoYW5nZWAuXG4gICAqXG4gICAqIEBuYW1lIGNoYW5nZVxuICAgKiBAYWxpYXMgY2hhbmdlc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ViamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydENoYW5nZXMgKHN1YmplY3QsIHByb3AsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBmbiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdmdW5jdGlvbicpO1xuXG4gICAgdmFyIGluaXRpYWw7XG4gICAgaWYgKCFwcm9wKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHN1YmplY3QsIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ2Z1bmN0aW9uJyk7XG4gICAgICBpbml0aWFsID0gc3ViamVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHN1YmplY3QsIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmhhdmUucHJvcGVydHkocHJvcCk7XG4gICAgICBpbml0aWFsID0gc3ViamVjdFtwcm9wXTtcbiAgICB9XG5cbiAgICBmbigpO1xuXG4gICAgdmFyIGZpbmFsID0gcHJvcCA9PT0gdW5kZWZpbmVkIHx8IHByb3AgPT09IG51bGwgPyBzdWJqZWN0KCkgOiBzdWJqZWN0W3Byb3BdO1xuICAgIHZhciBtc2dPYmogPSBwcm9wID09PSB1bmRlZmluZWQgfHwgcHJvcCA9PT0gbnVsbCA/IGluaXRpYWwgOiAnLicgKyBwcm9wO1xuXG4gICAgLy8gVGhpcyBnZXRzIGZsYWdnZWQgYmVjYXVzZSBvZiB0aGUgLmJ5KGRlbHRhKSBhc3NlcnRpb25cbiAgICBmbGFnKHRoaXMsICdkZWx0YU1zZ09iaicsIG1zZ09iaik7XG4gICAgZmxhZyh0aGlzLCAnaW5pdGlhbERlbHRhVmFsdWUnLCBpbml0aWFsKTtcbiAgICBmbGFnKHRoaXMsICdmaW5hbERlbHRhVmFsdWUnLCBmaW5hbCk7XG4gICAgZmxhZyh0aGlzLCAnZGVsdGFCZWhhdmlvcicsICdjaGFuZ2UnKTtcbiAgICBmbGFnKHRoaXMsICdyZWFsRGVsdGEnLCBmaW5hbCAhPT0gaW5pdGlhbCk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGluaXRpYWwgIT09IGZpbmFsXG4gICAgICAsICdleHBlY3RlZCAnICsgbXNnT2JqICsgJyB0byBjaGFuZ2UnXG4gICAgICAsICdleHBlY3RlZCAnICsgbXNnT2JqICsgJyB0byBub3QgY2hhbmdlJ1xuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdjaGFuZ2UnLCBhc3NlcnRDaGFuZ2VzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnY2hhbmdlcycsIGFzc2VydENoYW5nZXMpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmluY3JlYXNlKHN1YmplY3RbLCBwcm9wWywgbXNnXV0pXG4gICAqXG4gICAqIFdoZW4gb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBgLmluY3JlYXNlYCBhc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGZ1bmN0aW9uXG4gICAqIGBzdWJqZWN0YCByZXR1cm5zIGEgZ3JlYXRlciBudW1iZXIgd2hlbiBpdCdzIGludm9rZWQgYWZ0ZXIgaW52b2tpbmcgdGhlXG4gICAqIHRhcmdldCBmdW5jdGlvbiBjb21wYXJlZCB0byB3aGVuIGl0J3MgaW52b2tlZCBiZWZvcmVoYW5kLiBgLmluY3JlYXNlYCBhbHNvXG4gICAqIGNhdXNlcyBhbGwgYC5ieWAgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4gdG8gYXNzZXJ0IGhvdyBtdWNoXG4gICAqIGdyZWF0ZXIgb2YgYSBudW1iZXIgaXMgcmV0dXJuZWQuIEl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgcmV0dXJuXG4gICAqIHZhbHVlIGluY3JlYXNlZCBieSB0aGUgZXhwZWN0ZWQgYW1vdW50LCByYXRoZXIgdGhhbiBhc3NlcnRpbmcgaXQgaW5jcmVhc2VkXG4gICAqIGJ5IGFueSBhbW91bnQuXG4gICAqXG4gICAqICAgICB2YXIgdmFsID0gMVxuICAgKiAgICAgICAsIGFkZFR3byA9IGZ1bmN0aW9uICgpIHsgdmFsICs9IDI7IH1cbiAgICogICAgICAgLCBnZXRWYWwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWw7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShnZXRWYWwpLmJ5KDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UoZ2V0VmFsKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFdoZW4gdHdvIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIGAuaW5jcmVhc2VgIGFzc2VydHMgdGhhdCB0aGUgdmFsdWUgb2YgdGhlXG4gICAqIGdpdmVuIG9iamVjdCBgc3ViamVjdGAncyBgcHJvcGAgcHJvcGVydHkgaXMgZ3JlYXRlciBhZnRlciBpbnZva2luZyB0aGVcbiAgICogdGFyZ2V0IGZ1bmN0aW9uIGNvbXBhcmVkIHRvIGJlZm9yZWhhbmQuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIGFkZFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsICs9IDI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuaW5jcmVhc2VgLiBIb3dldmVyLCBpdCdzXG4gICAqIGRhbmdlcm91cyB0byBkbyBzby4gVGhlIHByb2JsZW0gaXMgdGhhdCBpdCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnNcbiAgICogYnkgYXNzZXJ0aW5nIHRoYXQgdGhlIHN1YmplY3QgZWl0aGVyIGRlY3JlYXNlcywgb3IgdGhhdCBpdCBzdGF5cyB0aGUgc2FtZS5cbiAgICogSXQncyBvZnRlbiBiZXN0IHRvIGlkZW50aWZ5IHRoZSBleGFjdCBvdXRwdXQgdGhhdCdzIGV4cGVjdGVkLCBhbmQgdGhlblxuICAgKiB3cml0ZSBhbiBhc3NlcnRpb24gdGhhdCBvbmx5IGFjY2VwdHMgdGhhdCBleGFjdCBvdXRwdXQuXG4gICAqXG4gICAqIFdoZW4gdGhlIHN1YmplY3QgaXMgZXhwZWN0ZWQgdG8gZGVjcmVhc2UsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCBpdFxuICAgKiBkZWNyZWFzZWQgYnkgdGhlIGV4cGVjdGVkIGFtb3VudC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgc3VidHJhY3RUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCAtPSAyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHN1YnRyYWN0VHdvKS50by5kZWNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHN1YnRyYWN0VHdvKS50by5ub3QuaW5jcmVhc2UobXlPYmosICd2YWwnKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqIFxuICAgKiBXaGVuIHRoZSBzdWJqZWN0IGlzIGV4cGVjdGVkIHRvIHN0YXkgdGhlIHNhbWUsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnRcbiAgICogZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBub29wID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3Qobm9vcCkudG8ubm90LmNoYW5nZShteU9iaiwgJ3ZhbCcpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KG5vb3ApLnRvLm5vdC5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5pbmNyZWFzZWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLiBXaGVuIG5vdCBwcm92aWRpbmcgdHdvIGFyZ3VtZW50cywgYWx3YXlzXG4gICAqIHVzZSB0aGUgc2Vjb25kIGZvcm0uXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChub29wKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICpcbiAgICogICAgIHZhciB2YWwgPSAxXG4gICAqICAgICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG4gICAqICAgICAgICwgZ2V0VmFsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5vb3AsICdub29vIHdoeSBmYWlsPz8nKS50by5pbmNyZWFzZShnZXRWYWwpO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5pbmNyZWFzZXNgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuaW5jcmVhc2VgLlxuICAgKlxuICAgKiBAbmFtZSBpbmNyZWFzZVxuICAgKiBAYWxpYXMgaW5jcmVhc2VzXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzdWJqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0SW5jcmVhc2VzIChzdWJqZWN0LCBwcm9wLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgZm4gPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG4gICAgbmV3IEFzc2VydGlvbihmbiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnZnVuY3Rpb24nKTtcblxuICAgIHZhciBpbml0aWFsO1xuICAgIGlmICghcHJvcCkge1xuICAgICAgbmV3IEFzc2VydGlvbihzdWJqZWN0LCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdmdW5jdGlvbicpO1xuICAgICAgaW5pdGlhbCA9IHN1YmplY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3IEFzc2VydGlvbihzdWJqZWN0LCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KHByb3ApO1xuICAgICAgaW5pdGlhbCA9IHN1YmplY3RbcHJvcF07XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHRhcmdldCBpcyBhIG51bWJlclxuICAgIG5ldyBBc3NlcnRpb24oaW5pdGlhbCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnbnVtYmVyJyk7XG5cbiAgICBmbigpO1xuXG4gICAgdmFyIGZpbmFsID0gcHJvcCA9PT0gdW5kZWZpbmVkIHx8IHByb3AgPT09IG51bGwgPyBzdWJqZWN0KCkgOiBzdWJqZWN0W3Byb3BdO1xuICAgIHZhciBtc2dPYmogPSBwcm9wID09PSB1bmRlZmluZWQgfHwgcHJvcCA9PT0gbnVsbCA/IGluaXRpYWwgOiAnLicgKyBwcm9wO1xuXG4gICAgZmxhZyh0aGlzLCAnZGVsdGFNc2dPYmonLCBtc2dPYmopO1xuICAgIGZsYWcodGhpcywgJ2luaXRpYWxEZWx0YVZhbHVlJywgaW5pdGlhbCk7XG4gICAgZmxhZyh0aGlzLCAnZmluYWxEZWx0YVZhbHVlJywgZmluYWwpO1xuICAgIGZsYWcodGhpcywgJ2RlbHRhQmVoYXZpb3InLCAnaW5jcmVhc2UnKTtcbiAgICBmbGFnKHRoaXMsICdyZWFsRGVsdGEnLCBmaW5hbCAtIGluaXRpYWwpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBmaW5hbCAtIGluaXRpYWwgPiAwXG4gICAgICAsICdleHBlY3RlZCAnICsgbXNnT2JqICsgJyB0byBpbmNyZWFzZSdcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBtc2dPYmogKyAnIHRvIG5vdCBpbmNyZWFzZSdcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnaW5jcmVhc2UnLCBhc3NlcnRJbmNyZWFzZXMpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdpbmNyZWFzZXMnLCBhc3NlcnRJbmNyZWFzZXMpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlY3JlYXNlKHN1YmplY3RbLCBwcm9wWywgbXNnXV0pXG4gICAqXG4gICAqIFdoZW4gb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBgLmRlY3JlYXNlYCBhc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGZ1bmN0aW9uXG4gICAqIGBzdWJqZWN0YCByZXR1cm5zIGEgbGVzc2VyIG51bWJlciB3aGVuIGl0J3MgaW52b2tlZCBhZnRlciBpbnZva2luZyB0aGVcbiAgICogdGFyZ2V0IGZ1bmN0aW9uIGNvbXBhcmVkIHRvIHdoZW4gaXQncyBpbnZva2VkIGJlZm9yZWhhbmQuIGAuZGVjcmVhc2VgIGFsc29cbiAgICogY2F1c2VzIGFsbCBgLmJ5YCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0byBhc3NlcnQgaG93IG11Y2hcbiAgICogbGVzc2VyIG9mIGEgbnVtYmVyIGlzIHJldHVybmVkLiBJdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHJldHVyblxuICAgKiB2YWx1ZSBkZWNyZWFzZWQgYnkgdGhlIGV4cGVjdGVkIGFtb3VudCwgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIGl0IGRlY3JlYXNlZFxuICAgKiBieSBhbnkgYW1vdW50LlxuICAgKlxuICAgKiAgICAgdmFyIHZhbCA9IDFcbiAgICogICAgICAgLCBzdWJ0cmFjdFR3byA9IGZ1bmN0aW9uICgpIHsgdmFsIC09IDI7IH1cbiAgICogICAgICAgLCBnZXRWYWwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWw7IH07XG4gICAqXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmRlY3JlYXNlKGdldFZhbCkuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmRlY3JlYXNlKGdldFZhbCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHR3byBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCBgLmRlY3JlYXNlYCBhc3NlcnRzIHRoYXQgdGhlIHZhbHVlIG9mIHRoZVxuICAgKiBnaXZlbiBvYmplY3QgYHN1YmplY3RgJ3MgYHByb3BgIHByb3BlcnR5IGlzIGxlc3NlciBhZnRlciBpbnZva2luZyB0aGVcbiAgICogdGFyZ2V0IGZ1bmN0aW9uIGNvbXBhcmVkIHRvIGJlZm9yZWhhbmQuIFxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBzdWJ0cmFjdFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsIC09IDI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmRlY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmRlY3JlYXNlKG15T2JqLCAndmFsJyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmRlY3JlYXNlYC4gSG93ZXZlciwgaXQnc1xuICAgKiBkYW5nZXJvdXMgdG8gZG8gc28uIFRoZSBwcm9ibGVtIGlzIHRoYXQgaXQgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zXG4gICAqIGJ5IGFzc2VydGluZyB0aGF0IHRoZSBzdWJqZWN0IGVpdGhlciBpbmNyZWFzZXMsIG9yIHRoYXQgaXQgc3RheXMgdGhlIHNhbWUuXG4gICAqIEl0J3Mgb2Z0ZW4gYmVzdCB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQncyBleHBlY3RlZCwgYW5kIHRoZW5cbiAgICogd3JpdGUgYW4gYXNzZXJ0aW9uIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiBXaGVuIHRoZSBzdWJqZWN0IGlzIGV4cGVjdGVkIHRvIGluY3JlYXNlLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgaXRcbiAgICogaW5jcmVhc2VkIGJ5IHRoZSBleHBlY3RlZCBhbW91bnQuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIGFkZFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsICs9IDI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8ubm90LmRlY3JlYXNlKG15T2JqLCAndmFsJyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiBcbiAgICogV2hlbiB0aGUgc3ViamVjdCBpcyBleHBlY3RlZCB0byBzdGF5IHRoZSBzYW1lLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0XG4gICAqIGV4YWN0bHkgdGhhdC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5vb3ApLnRvLm5vdC5jaGFuZ2UobXlPYmosICd2YWwnKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChub29wKS50by5ub3QuZGVjcmVhc2UobXlPYmosICd2YWwnKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAuZGVjcmVhc2VgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC4gV2hlbiBub3QgcHJvdmlkaW5nIHR3byBhcmd1bWVudHMsIGFsd2F5c1xuICAgKiB1c2UgdGhlIHNlY29uZCBmb3JtLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBub29wID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3Qobm9vcCkudG8uZGVjcmVhc2UobXlPYmosICd2YWwnLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqXG4gICAqICAgICB2YXIgdmFsID0gMVxuICAgKiAgICAgICAsIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxuICAgKiAgICAgICAsIGdldFZhbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbDsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChub29wLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uZGVjcmVhc2UoZ2V0VmFsKTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuZGVjcmVhc2VzYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmRlY3JlYXNlYC5cbiAgICpcbiAgICogQG5hbWUgZGVjcmVhc2VcbiAgICogQGFsaWFzIGRlY3JlYXNlc1xuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc3ViamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydERlY3JlYXNlcyAoc3ViamVjdCwgcHJvcCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIGZuID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgIG5ldyBBc3NlcnRpb24oZm4sIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ2Z1bmN0aW9uJyk7XG5cbiAgICB2YXIgaW5pdGlhbDtcbiAgICBpZiAoIXByb3ApIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oc3ViamVjdCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnZnVuY3Rpb24nKTtcbiAgICAgIGluaXRpYWwgPSBzdWJqZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oc3ViamVjdCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eShwcm9wKTtcbiAgICAgIGluaXRpYWwgPSBzdWJqZWN0W3Byb3BdO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSB0YXJnZXQgaXMgYSBudW1iZXJcbiAgICBuZXcgQXNzZXJ0aW9uKGluaXRpYWwsIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ251bWJlcicpO1xuXG4gICAgZm4oKTtcblxuICAgIHZhciBmaW5hbCA9IHByb3AgPT09IHVuZGVmaW5lZCB8fCBwcm9wID09PSBudWxsID8gc3ViamVjdCgpIDogc3ViamVjdFtwcm9wXTtcbiAgICB2YXIgbXNnT2JqID0gcHJvcCA9PT0gdW5kZWZpbmVkIHx8IHByb3AgPT09IG51bGwgPyBpbml0aWFsIDogJy4nICsgcHJvcDtcblxuICAgIGZsYWcodGhpcywgJ2RlbHRhTXNnT2JqJywgbXNnT2JqKTtcbiAgICBmbGFnKHRoaXMsICdpbml0aWFsRGVsdGFWYWx1ZScsIGluaXRpYWwpO1xuICAgIGZsYWcodGhpcywgJ2ZpbmFsRGVsdGFWYWx1ZScsIGZpbmFsKTtcbiAgICBmbGFnKHRoaXMsICdkZWx0YUJlaGF2aW9yJywgJ2RlY3JlYXNlJyk7XG4gICAgZmxhZyh0aGlzLCAncmVhbERlbHRhJywgaW5pdGlhbCAtIGZpbmFsKTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgZmluYWwgLSBpbml0aWFsIDwgMFxuICAgICAgLCAnZXhwZWN0ZWQgJyArIG1zZ09iaiArICcgdG8gZGVjcmVhc2UnXG4gICAgICAsICdleHBlY3RlZCAnICsgbXNnT2JqICsgJyB0byBub3QgZGVjcmVhc2UnXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2RlY3JlYXNlJywgYXNzZXJ0RGVjcmVhc2VzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZGVjcmVhc2VzJywgYXNzZXJ0RGVjcmVhc2VzKTtcblxuICAvKipcbiAgICogIyMjIC5ieShkZWx0YVssIG1zZ10pXG4gICAqXG4gICAqIFdoZW4gZm9sbG93aW5nIGFuIGAuaW5jcmVhc2VgIGFzc2VydGlvbiBpbiB0aGUgY2hhaW4sIGAuYnlgIGFzc2VydHMgdGhhdFxuICAgKiB0aGUgc3ViamVjdCBvZiB0aGUgYC5pbmNyZWFzZWAgYXNzZXJ0aW9uIGluY3JlYXNlZCBieSB0aGUgZ2l2ZW4gYGRlbHRhYC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgYWRkVHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgKz0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7XG4gICAqXG4gICAqIFdoZW4gZm9sbG93aW5nIGEgYC5kZWNyZWFzZWAgYXNzZXJ0aW9uIGluIHRoZSBjaGFpbiwgYC5ieWAgYXNzZXJ0cyB0aGF0IHRoZVxuICAgKiBzdWJqZWN0IG9mIHRoZSBgLmRlY3JlYXNlYCBhc3NlcnRpb24gZGVjcmVhc2VkIGJ5IHRoZSBnaXZlbiBgZGVsdGFgLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBzdWJ0cmFjdFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsIC09IDI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmRlY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7XG4gICAqXG4gICAqIFdoZW4gZm9sbG93aW5nIGEgYC5jaGFuZ2VgIGFzc2VydGlvbiBpbiB0aGUgY2hhaW4sIGAuYnlgIGFzc2VydHMgdGhhdCB0aGVcbiAgICogc3ViamVjdCBvZiB0aGUgYC5jaGFuZ2VgIGFzc2VydGlvbiBlaXRoZXIgaW5jcmVhc2VkIG9yIGRlY3JlYXNlZCBieSB0aGVcbiAgICogZ2l2ZW4gYGRlbHRhYC4gSG93ZXZlciwgaXQncyBkYW5nZXJvdXMgdG8gdXNlIGAuY2hhbmdlLmJ5YC4gVGhlIHByb2JsZW0gaXNcbiAgICogdGhhdCBpdCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnMuIEl0J3Mgb2Z0ZW4gYmVzdCB0byBpZGVudGlmeSB0aGVcbiAgICogZXhhY3Qgb3V0cHV0IHRoYXQncyBleHBlY3RlZCwgYW5kIHRoZW4gd3JpdGUgYW4gYXNzZXJ0aW9uIHRoYXQgb25seSBhY2NlcHRzXG4gICAqIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBhZGRUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCArPSAyOyB9XG4gICAqICAgICAgICwgc3VidHJhY3RUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCAtPSAyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmNoYW5nZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uZGVjcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uY2hhbmdlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmJ5YC4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0XG4gICAqIHRvIGFzc2VydCB0aGF0IHRoZSBzdWJqZWN0IGNoYW5nZWQgYnkgaXRzIGV4cGVjdGVkIGRlbHRhLCByYXRoZXIgdGhhblxuICAgKiBhc3NlcnRpbmcgdGhhdCBpdCBkaWRuJ3QgY2hhbmdlIGJ5IG9uZSBvZiBjb3VudGxlc3MgdW5leHBlY3RlZCBkZWx0YXMuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIGFkZFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsICs9IDI7IH07XG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKS5idXQubm90LmJ5KDMpO1xuICAgKlxuICAgKiBgLmJ5YCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgdG9cbiAgICogc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmRcbiAgICogYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIGFkZFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsICs9IDI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDMsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdChhZGRUd28sICdub29vIHdoeSBmYWlsPz8nKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDMpO1xuICAgKlxuICAgKiBAbmFtZSBieVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydERlbHRhKGRlbHRhLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcblxuICAgIHZhciBtc2dPYmogPSBmbGFnKHRoaXMsICdkZWx0YU1zZ09iaicpO1xuICAgIHZhciBpbml0aWFsID0gZmxhZyh0aGlzLCAnaW5pdGlhbERlbHRhVmFsdWUnKTtcbiAgICB2YXIgZmluYWwgPSBmbGFnKHRoaXMsICdmaW5hbERlbHRhVmFsdWUnKTtcbiAgICB2YXIgYmVoYXZpb3IgPSBmbGFnKHRoaXMsICdkZWx0YUJlaGF2aW9yJyk7XG4gICAgdmFyIHJlYWxEZWx0YSA9IGZsYWcodGhpcywgJ3JlYWxEZWx0YScpO1xuXG4gICAgdmFyIGV4cHJlc3Npb247XG4gICAgaWYgKGJlaGF2aW9yID09PSAnY2hhbmdlJykge1xuICAgICAgZXhwcmVzc2lvbiA9IE1hdGguYWJzKGZpbmFsIC0gaW5pdGlhbCkgPT09IE1hdGguYWJzKGRlbHRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwcmVzc2lvbiA9IHJlYWxEZWx0YSA9PT0gTWF0aC5hYnMoZGVsdGEpO1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgZXhwcmVzc2lvblxuICAgICAgLCAnZXhwZWN0ZWQgJyArIG1zZ09iaiArICcgdG8gJyArIGJlaGF2aW9yICsgJyBieSAnICsgZGVsdGFcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBtc2dPYmogKyAnIHRvIG5vdCAnICsgYmVoYXZpb3IgKyAnIGJ5ICcgKyBkZWx0YVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdieScsIGFzc2VydERlbHRhKTtcblxuICAvKipcbiAgICogIyMjIC5leHRlbnNpYmxlXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGV4dGVuc2libGUsIHdoaWNoIG1lYW5zIHRoYXQgbmV3IHByb3BlcnRpZXMgY2FuXG4gICAqIGJlIGFkZGVkIHRvIGl0LiBQcmltaXRpdmVzIGFyZSBuZXZlciBleHRlbnNpYmxlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uYmUuZXh0ZW5zaWJsZTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5leHRlbnNpYmxlYC5cbiAgICpcbiAgICogICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KVxuICAgKiAgICAgICAsIHNlYWxlZE9iamVjdCA9IE9iamVjdC5zZWFsKHt9KVxuICAgKiAgICAgICAsIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5vbkV4dGVuc2libGVPYmplY3QpLnRvLm5vdC5iZS5leHRlbnNpYmxlO1xuICAgKiAgICAgZXhwZWN0KHNlYWxlZE9iamVjdCkudG8ubm90LmJlLmV4dGVuc2libGU7XG4gICAqICAgICBleHBlY3QoZnJvemVuT2JqZWN0KS50by5ub3QuYmUuZXh0ZW5zaWJsZTtcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUuZXh0ZW5zaWJsZTtcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuZXh0ZW5zaWJsZTtcbiAgICpcbiAgICogQG5hbWUgZXh0ZW5zaWJsZVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2V4dGVuc2libGUnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG5cbiAgICAvLyBJbiBFUzUsIGlmIHRoZSBhcmd1bWVudCB0byB0aGlzIG1ldGhvZCBpcyBhIHByaW1pdGl2ZSwgdGhlbiBpdCB3aWxsIGNhdXNlIGEgVHlwZUVycm9yLlxuICAgIC8vIEluIEVTNiwgYSBub24tb2JqZWN0IGFyZ3VtZW50IHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3YXMgYSBub24tZXh0ZW5zaWJsZSBvcmRpbmFyeSBvYmplY3QsIHNpbXBseSByZXR1cm4gZmFsc2UuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzRXh0ZW5zaWJsZVxuICAgIC8vIFRoZSBmb2xsb3dpbmcgcHJvdmlkZXMgRVM2IGJlaGF2aW9yIGZvciBFUzUgZW52aXJvbm1lbnRzLlxuXG4gICAgdmFyIGlzRXh0ZW5zaWJsZSA9IG9iaiA9PT0gT2JqZWN0KG9iaikgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShvYmopO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBpc0V4dGVuc2libGVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZXh0ZW5zaWJsZSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGV4dGVuc2libGUnXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuc2VhbGVkXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHNlYWxlZCwgd2hpY2ggbWVhbnMgdGhhdCBuZXcgcHJvcGVydGllcyBjYW4ndCBiZVxuICAgKiBhZGRlZCB0byBpdCwgYW5kIGl0cyBleGlzdGluZyBwcm9wZXJ0aWVzIGNhbid0IGJlIHJlY29uZmlndXJlZCBvciBkZWxldGVkLlxuICAgKiBIb3dldmVyLCBpdCdzIHBvc3NpYmxlIHRoYXQgaXRzIGV4aXN0aW5nIHByb3BlcnRpZXMgY2FuIHN0aWxsIGJlIHJlYXNzaWduZWRcbiAgICogdG8gZGlmZmVyZW50IHZhbHVlcy4gUHJpbWl0aXZlcyBhcmUgYWx3YXlzIHNlYWxlZC5cbiAgICpcbiAgICogICAgIHZhciBzZWFsZWRPYmplY3QgPSBPYmplY3Quc2VhbCh7fSk7XG4gICAqICAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAqXG4gICAqICAgICBleHBlY3Qoc2VhbGVkT2JqZWN0KS50by5iZS5zZWFsZWQ7XG4gICAqICAgICBleHBlY3QoZnJvemVuT2JqZWN0KS50by5iZS5zZWFsZWQ7XG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuc2VhbGVkO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLnNlYWxlZGAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuYmUuc2VhbGVkO1xuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLnNlYWxlZDtcbiAgICpcbiAgICogQG5hbWUgc2VhbGVkXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnc2VhbGVkJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuXG4gICAgLy8gSW4gRVM1LCBpZiB0aGUgYXJndW1lbnQgdG8gdGhpcyBtZXRob2QgaXMgYSBwcmltaXRpdmUsIHRoZW4gaXQgd2lsbCBjYXVzZSBhIFR5cGVFcnJvci5cbiAgICAvLyBJbiBFUzYsIGEgbm9uLW9iamVjdCBhcmd1bWVudCB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2FzIGEgc2VhbGVkIG9yZGluYXJ5IG9iamVjdCwgc2ltcGx5IHJldHVybiB0cnVlLlxuICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNTZWFsZWRcbiAgICAvLyBUaGUgZm9sbG93aW5nIHByb3ZpZGVzIEVTNiBiZWhhdmlvciBmb3IgRVM1IGVudmlyb25tZW50cy5cblxuICAgIHZhciBpc1NlYWxlZCA9IG9iaiA9PT0gT2JqZWN0KG9iaikgPyBPYmplY3QuaXNTZWFsZWQob2JqKSA6IHRydWU7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGlzU2VhbGVkXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHNlYWxlZCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIHNlYWxlZCdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5mcm96ZW5cbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZnJvemVuLCB3aGljaCBtZWFucyB0aGF0IG5ldyBwcm9wZXJ0aWVzIGNhbid0IGJlXG4gICAqIGFkZGVkIHRvIGl0LCBhbmQgaXRzIGV4aXN0aW5nIHByb3BlcnRpZXMgY2FuJ3QgYmUgcmVhc3NpZ25lZCB0byBkaWZmZXJlbnRcbiAgICogdmFsdWVzLCByZWNvbmZpZ3VyZWQsIG9yIGRlbGV0ZWQuIFByaW1pdGl2ZXMgYXJlIGFsd2F5cyBmcm96ZW4uXG4gICAqXG4gICAqICAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAqXG4gICAqICAgICBleHBlY3QoZnJvemVuT2JqZWN0KS50by5iZS5mcm96ZW47XG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuZnJvemVuO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmZyb3plbmAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuYmUuZnJvemVuO1xuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmZyb3plbjtcbiAgICpcbiAgICogQG5hbWUgZnJvemVuXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZnJvemVuJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuXG4gICAgLy8gSW4gRVM1LCBpZiB0aGUgYXJndW1lbnQgdG8gdGhpcyBtZXRob2QgaXMgYSBwcmltaXRpdmUsIHRoZW4gaXQgd2lsbCBjYXVzZSBhIFR5cGVFcnJvci5cbiAgICAvLyBJbiBFUzYsIGEgbm9uLW9iamVjdCBhcmd1bWVudCB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2FzIGEgZnJvemVuIG9yZGluYXJ5IG9iamVjdCwgc2ltcGx5IHJldHVybiB0cnVlLlxuICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNGcm96ZW5cbiAgICAvLyBUaGUgZm9sbG93aW5nIHByb3ZpZGVzIEVTNiBiZWhhdmlvciBmb3IgRVM1IGVudmlyb25tZW50cy5cblxuICAgIHZhciBpc0Zyb3plbiA9IG9iaiA9PT0gT2JqZWN0KG9iaikgPyBPYmplY3QuaXNGcm96ZW4ob2JqKSA6IHRydWU7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGlzRnJvemVuXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZyb3plbidcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGZyb3plbidcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5maW5pdGVcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYSBudW1iZXIsIGFuZCBpc24ndCBgTmFOYCBvciBwb3NpdGl2ZS9uZWdhdGl2ZVxuICAgKiBgSW5maW5pdHlgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLmZpbml0ZTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5maW5pdGVgLiBIb3dldmVyLCBpdCdzXG4gICAqIGRhbmdlcm91cyB0byBkbyBzby4gVGhlIHByb2JsZW0gaXMgdGhhdCBpdCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnNcbiAgICogYnkgYXNzZXJ0aW5nIHRoYXQgdGhlIHN1YmplY3QgZWl0aGVyIGlzbid0IGEgbnVtYmVyLCBvciB0aGF0IGl0J3MgYE5hTmAsIG9yXG4gICAqIHRoYXQgaXQncyBwb3NpdGl2ZSBgSW5maW5pdHlgLCBvciB0aGF0IGl0J3MgbmVnYXRpdmUgYEluZmluaXR5YC4gSXQncyBvZnRlblxuICAgKiBiZXN0IHRvIGlkZW50aWZ5IHRoZSBleGFjdCBvdXRwdXQgdGhhdCdzIGV4cGVjdGVkLCBhbmQgdGhlbiB3cml0ZSBhblxuICAgKiBhc3NlcnRpb24gdGhhdCBvbmx5IGFjY2VwdHMgdGhhdCBleGFjdCBvdXRwdXQuXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpc24ndCBleHBlY3RlZCB0byBiZSBhIG51bWJlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydFxuICAgKiB0aGF0IGl0J3MgdGhlIGV4cGVjdGVkIHR5cGUsIHJhdGhlciB0aGFuIGFzc2VydGluZyB0aGF0IGl0IGlzbid0IG9uZSBvZlxuICAgKiBtYW55IHVuZXhwZWN0ZWQgdHlwZXMuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmJlLmEoJ3N0cmluZycpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5ub3QuYmUuZmluaXRlOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGV4cGVjdGVkIHRvIGJlIGBOYU5gLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IGV4YWN0bHlcbiAgICogdGhhdC5cbiAgICpcbiAgICogICAgIGV4cGVjdChOYU4pLnRvLmJlLk5hTjsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChOYU4pLnRvLm5vdC5iZS5maW5pdGU7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgZXhwZWN0ZWQgdG8gYmUgcG9zaXRpdmUgaW5maW5pdHksIGl0J3Mgb2Z0ZW4gYmVzdCB0b1xuICAgKiBhc3NlcnQgZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KEluZmluaXR5KS50by5lcXVhbChJbmZpbml0eSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoSW5maW5pdHkpLnRvLm5vdC5iZS5maW5pdGU7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgZXhwZWN0ZWQgdG8gYmUgbmVnYXRpdmUgaW5maW5pdHksIGl0J3Mgb2Z0ZW4gYmVzdCB0b1xuICAgKiBhc3NlcnQgZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KC1JbmZpbml0eSkudG8uZXF1YWwoLUluZmluaXR5KTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgtSW5maW5pdHkpLnRvLm5vdC5iZS5maW5pdGU7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuZmluaXRlO1xuICAgKlxuICAgKiBAbmFtZSBmaW5pdGVcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdmaW5pdGUnLCBmdW5jdGlvbihtc2cpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgdHlwZW9mIG9iaiA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZShvYmopXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGEgZmluaXRlIG51bWJlcidcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGEgZmluaXRlIG51bWJlcidcbiAgICApO1xuICB9KTtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCB1dGlsKSB7XG4gIGNoYWkuZXhwZWN0ID0gZnVuY3Rpb24gKHZhbCwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgY2hhaS5Bc3NlcnRpb24odmFsLCBtZXNzYWdlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5mYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSwgW29wZXJhdG9yXSlcbiAgICpcbiAgICogVGhyb3cgYSBmYWlsdXJlLlxuICAgKlxuICAgKiBAbmFtZSBmYWlsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0b3JcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgY2hhaS5leHBlY3QuZmFpbCA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvcikge1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdleHBlY3QuZmFpbCgpJztcbiAgICB0aHJvdyBuZXcgY2hhaS5Bc3NlcnRpb25FcnJvcihtZXNzYWdlLCB7XG4gICAgICAgIGFjdHVhbDogYWN0dWFsXG4gICAgICAsIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgLCBvcGVyYXRvcjogb3BlcmF0b3JcbiAgICB9LCBjaGFpLmV4cGVjdC5mYWlsKTtcbiAgfTtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCB1dGlsKSB7XG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvbjtcblxuICBmdW5jdGlvbiBsb2FkU2hvdWxkICgpIHtcbiAgICAvLyBleHBsaWNpdGx5IGRlZmluZSB0aGlzIG1ldGhvZCBhcyBmdW5jdGlvbiBhcyB0byBoYXZlIGl0J3MgbmFtZSB0byBpbmNsdWRlIGFzIGBzc2ZpYFxuICAgIGZ1bmN0aW9uIHNob3VsZEdldHRlcigpIHtcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU3RyaW5nXG4gICAgICAgICAgfHwgdGhpcyBpbnN0YW5jZW9mIE51bWJlclxuICAgICAgICAgIHx8IHRoaXMgaW5zdGFuY2VvZiBCb29sZWFuXG4gICAgICAgICAgfHwgdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGlzIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHRoaXMudmFsdWVPZigpLCBudWxsLCBzaG91bGRHZXR0ZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBc3NlcnRpb24odGhpcywgbnVsbCwgc2hvdWxkR2V0dGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkU2V0dGVyKHZhbHVlKSB7XG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9jaGFpL2lzc3Vlcy84NjogdGhpcyBtYWtlc1xuICAgICAgLy8gYHdoYXRldmVyLnNob3VsZCA9IHNvbWVWYWx1ZWAgYWN0dWFsbHkgc2V0IGBzb21lVmFsdWVgLCB3aGljaCBpc1xuICAgICAgLy8gZXNwZWNpYWxseSB1c2VmdWwgZm9yIGBnbG9iYWwuc2hvdWxkID0gcmVxdWlyZSgnY2hhaScpLnNob3VsZCgpYC5cbiAgICAgIC8vXG4gICAgICAvLyBOb3RlIHRoYXQgd2UgaGF2ZSB0byB1c2UgW1tEZWZpbmVQcm9wZXJ0eV1dIGluc3RlYWQgb2YgW1tQdXRdXVxuICAgICAgLy8gc2luY2Ugb3RoZXJ3aXNlIHdlIHdvdWxkIHRyaWdnZXIgdGhpcyB2ZXJ5IHNldHRlciFcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2hvdWxkJywge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBtb2RpZnkgT2JqZWN0LnByb3RvdHlwZSB0byBoYXZlIGBzaG91bGRgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdC5wcm90b3R5cGUsICdzaG91bGQnLCB7XG4gICAgICBzZXQ6IHNob3VsZFNldHRlclxuICAgICAgLCBnZXQ6IHNob3VsZEdldHRlclxuICAgICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIHZhciBzaG91bGQgPSB7fTtcblxuICAgIC8qKlxuICAgICAqICMjIyAuZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0sIFtvcGVyYXRvcl0pXG4gICAgICpcbiAgICAgKiBUaHJvdyBhIGZhaWx1cmUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBmYWlsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcGVyYXRvclxuICAgICAqIEBuYW1lc3BhY2UgQkREXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5mYWlsID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yKSB7XG4gICAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAnc2hvdWxkLmZhaWwoKSc7XG4gICAgICB0aHJvdyBuZXcgY2hhaS5Bc3NlcnRpb25FcnJvcihtZXNzYWdlLCB7XG4gICAgICAgICAgYWN0dWFsOiBhY3R1YWxcbiAgICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICAgLCBvcGVyYXRvcjogb3BlcmF0b3JcbiAgICAgIH0sIHNob3VsZC5mYWlsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIyMjIC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAgICpcbiAgICAgKiBBc3NlcnRzIG5vbi1zdHJpY3QgZXF1YWxpdHkgKGA9PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgICAqXG4gICAgICogICAgIHNob3VsZC5lcXVhbCgzLCAnMycsICc9PSBjb2VyY2VzIHZhbHVlcyB0byBzdHJpbmdzJyk7XG4gICAgICpcbiAgICAgKiBAbmFtZSBlcXVhbFxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAbmFtZXNwYWNlIFNob3VsZFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBzaG91bGQuZXF1YWwgPSBmdW5jdGlvbiAodmFsMSwgdmFsMiwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbDEsIG1zZykudG8uZXF1YWwodmFsMik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICMjIyAudGhyb3coZnVuY3Rpb24sIFtjb25zdHJ1Y3Rvci9zdHJpbmcvcmVnZXhwXSwgW3N0cmluZy9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAgICpcbiAgICAgKiBBc3NlcnRzIHRoYXQgYGZ1bmN0aW9uYCB3aWxsIHRocm93IGFuIGVycm9yIHRoYXQgaXMgYW4gaW5zdGFuY2Ugb2ZcbiAgICAgKiBgY29uc3RydWN0b3JgLCBvciBhbHRlcm5hdGVseSB0aGF0IGl0IHdpbGwgdGhyb3cgYW4gZXJyb3Igd2l0aCBtZXNzYWdlXG4gICAgICogbWF0Y2hpbmcgYHJlZ2V4cGAuXG4gICAgICpcbiAgICAgKiAgICAgc2hvdWxkLnRocm93KGZuLCAnZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yJyk7XG4gICAgICogICAgIHNob3VsZC50aHJvdyhmbiwgL2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvci8pO1xuICAgICAqICAgICBzaG91bGQudGhyb3coZm4sIFJlZmVyZW5jZUVycm9yKTtcbiAgICAgKiAgICAgc2hvdWxkLnRocm93KGZuLCBSZWZlcmVuY2VFcnJvciwgJ2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvcicpO1xuICAgICAqICAgICBzaG91bGQudGhyb3coZm4sIFJlZmVyZW5jZUVycm9yLCAvZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yLyk7XG4gICAgICpcbiAgICAgKiBAbmFtZSB0aHJvd1xuICAgICAqIEBhbGlhcyBUaHJvd1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtFcnJvckNvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICAgKiBAbmFtZXNwYWNlIFNob3VsZFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBzaG91bGQuVGhyb3cgPSBmdW5jdGlvbiAoZm4sIGVycnQsIGVycnMsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbihmbiwgbXNnKS50by5UaHJvdyhlcnJ0LCBlcnJzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIyMjIC5leGlzdFxuICAgICAqXG4gICAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgbmVpdGhlciBgbnVsbGAgbm9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogICAgIHZhciBmb28gPSAnaGknO1xuICAgICAqXG4gICAgICogICAgIHNob3VsZC5leGlzdChmb28sICdmb28gZXhpc3RzJyk7XG4gICAgICpcbiAgICAgKiBAbmFtZSBleGlzdFxuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5leGlzdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uZXhpc3Q7XG4gICAgfVxuXG4gICAgLy8gbmVnYXRpb25cbiAgICBzaG91bGQubm90ID0ge31cblxuICAgIC8qKlxuICAgICAqICMjIyAubm90LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICAgKlxuICAgICAqIEFzc2VydHMgbm9uLXN0cmljdCBpbmVxdWFsaXR5IChgIT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICAgKlxuICAgICAqICAgICBzaG91bGQubm90LmVxdWFsKDMsIDQsICd0aGVzZSBudW1iZXJzIGFyZSBub3QgZXF1YWwnKTtcbiAgICAgKlxuICAgICAqIEBuYW1lIG5vdC5lcXVhbFxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAbmFtZXNwYWNlIFNob3VsZFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBzaG91bGQubm90LmVxdWFsID0gZnVuY3Rpb24gKHZhbDEsIHZhbDIsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwxLCBtc2cpLnRvLm5vdC5lcXVhbCh2YWwyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIyMjIC50aHJvdyhmdW5jdGlvbiwgW2NvbnN0cnVjdG9yL3JlZ2V4cF0sIFttZXNzYWdlXSlcbiAgICAgKlxuICAgICAqIEFzc2VydHMgdGhhdCBgZnVuY3Rpb25gIHdpbGwgX25vdF8gdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgICAqIGBjb25zdHJ1Y3RvcmAsIG9yIGFsdGVybmF0ZWx5IHRoYXQgaXQgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3Igd2l0aCBtZXNzYWdlXG4gICAgICogbWF0Y2hpbmcgYHJlZ2V4cGAuXG4gICAgICpcbiAgICAgKiAgICAgc2hvdWxkLm5vdC50aHJvdyhmbiwgRXJyb3IsICdmdW5jdGlvbiBkb2VzIG5vdCB0aHJvdycpO1xuICAgICAqXG4gICAgICogQG5hbWUgbm90LnRocm93XG4gICAgICogQGFsaWFzIG5vdC5UaHJvd1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtFcnJvckNvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICAgKiBAbmFtZXNwYWNlIFNob3VsZFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBzaG91bGQubm90LlRocm93ID0gZnVuY3Rpb24gKGZuLCBlcnJ0LCBlcnJzLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZykudG8ubm90LlRocm93KGVycnQsIGVycnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAjIyMgLm5vdC5leGlzdFxuICAgICAqXG4gICAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgbmVpdGhlciBgbnVsbGAgbm9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogICAgIHZhciBiYXIgPSBudWxsO1xuICAgICAqXG4gICAgICogICAgIHNob3VsZC5ub3QuZXhpc3QoYmFyLCAnYmFyIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICpcbiAgICAgKiBAbmFtZSBub3QuZXhpc3RcbiAgICAgKiBAbmFtZXNwYWNlIFNob3VsZFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBzaG91bGQubm90LmV4aXN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuZXhpc3Q7XG4gICAgfVxuXG4gICAgc2hvdWxkWyd0aHJvdyddID0gc2hvdWxkWydUaHJvdyddO1xuICAgIHNob3VsZC5ub3RbJ3Rocm93J10gPSBzaG91bGQubm90WydUaHJvdyddO1xuXG4gICAgcmV0dXJuIHNob3VsZDtcbiAgfTtcblxuICBjaGFpLnNob3VsZCA9IGxvYWRTaG91bGQ7XG4gIGNoYWkuU2hvdWxkID0gbG9hZFNob3VsZDtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIHV0aWwpIHtcblxuICAvKiFcbiAgICogQ2hhaSBkZXBlbmRlbmNpZXMuXG4gICAqL1xuXG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvblxuICAgICwgZmxhZyA9IHV0aWwuZmxhZztcblxuICAvKiFcbiAgICogTW9kdWxlIGV4cG9ydC5cbiAgICovXG5cbiAgLyoqXG4gICAqICMjIyBhc3NlcnQoZXhwcmVzc2lvbiwgbWVzc2FnZSlcbiAgICpcbiAgICogV3JpdGUgeW91ciBvd24gdGVzdCBleHByZXNzaW9ucy5cbiAgICpcbiAgICogICAgIGFzc2VydCgnZm9vJyAhPT0gJ2JhcicsICdmb28gaXMgbm90IGJhcicpO1xuICAgKiAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoW10pLCAnZW1wdHkgYXJyYXlzIGFyZSBhcnJheXMnKTtcbiAgICpcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwcmVzc2lvbiB0byB0ZXN0IGZvciB0cnV0aGluZXNzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIHRvIGRpc3BsYXkgb24gZXJyb3JcbiAgICogQG5hbWUgYXNzZXJ0XG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHZhciBhc3NlcnQgPSBjaGFpLmFzc2VydCA9IGZ1bmN0aW9uIChleHByZXNzLCBlcnJtc2cpIHtcbiAgICB2YXIgdGVzdCA9IG5ldyBBc3NlcnRpb24obnVsbCwgbnVsbCwgY2hhaS5hc3NlcnQsIHRydWUpO1xuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICBleHByZXNzXG4gICAgICAsIGVycm1zZ1xuICAgICAgLCAnWyBuZWdhdGlvbiBtZXNzYWdlIHVuYXZhaWxhYmxlIF0nXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5mYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSwgW29wZXJhdG9yXSlcbiAgICpcbiAgICogVGhyb3cgYSBmYWlsdXJlLiBOb2RlLmpzIGBhc3NlcnRgIG1vZHVsZS1jb21wYXRpYmxlLlxuICAgKlxuICAgKiBAbmFtZSBmYWlsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0b3JcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmZhaWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IpIHtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAnYXNzZXJ0LmZhaWwoKSc7XG4gICAgdGhyb3cgbmV3IGNoYWkuQXNzZXJ0aW9uRXJyb3IobWVzc2FnZSwge1xuICAgICAgICBhY3R1YWw6IGFjdHVhbFxuICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICwgb3BlcmF0b3I6IG9wZXJhdG9yXG4gICAgfSwgYXNzZXJ0LmZhaWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzT2sob2JqZWN0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyB0cnV0aHkuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNPaygnZXZlcnl0aGluZycsICdldmVyeXRoaW5nIGlzIG9rJyk7XG4gICAqICAgICBhc3NlcnQuaXNPayhmYWxzZSwgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzT2tcbiAgICogQGFsaWFzIG9rXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCB0byB0ZXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc09rID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzT2ssIHRydWUpLmlzLm9rO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90T2sob2JqZWN0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBmYWxzeS5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdE9rKCdldmVyeXRoaW5nJywgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RPayhmYWxzZSwgJ3RoaXMgd2lsbCBwYXNzJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90T2tcbiAgICogQGFsaWFzIG5vdE9rXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCB0byB0ZXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE9rID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90T2ssIHRydWUpLmlzLm5vdC5vaztcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgbm9uLXN0cmljdCBlcXVhbGl0eSAoYD09YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZXF1YWwoMywgJzMnLCAnPT0gY29lcmNlcyB2YWx1ZXMgdG8gc3RyaW5ncycpO1xuICAgKlxuICAgKiBAbmFtZSBlcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICB2YXIgdGVzdCA9IG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5lcXVhbCwgdHJ1ZSk7XG5cbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgZXhwID09IGZsYWcodGVzdCwgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGVxdWFsICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGVxdWFsICN7YWN0fSdcbiAgICAgICwgZXhwXG4gICAgICAsIGFjdFxuICAgICAgLCB0cnVlXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgbm9uLXN0cmljdCBpbmVxdWFsaXR5IChgIT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RFcXVhbCgzLCA0LCAndGhlc2UgbnVtYmVycyBhcmUgbm90IGVxdWFsJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0Lm5vdEVxdWFsLCB0cnVlKTtcblxuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICBleHAgIT0gZmxhZyh0ZXN0LCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGVxdWFsICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXF1YWwgI3thY3R9J1xuICAgICAgLCBleHBcbiAgICAgICwgYWN0XG4gICAgICAsIHRydWVcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBzdHJpY3QgZXF1YWxpdHkgKGA9PT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCB0cnVlLCAndGhlc2UgYm9vbGVhbnMgYXJlIHN0cmljdGx5IGVxdWFsJyk7XG4gICAqXG4gICAqIEBuYW1lIHN0cmljdEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5zdHJpY3RFcXVhbCwgdHJ1ZSkudG8uZXF1YWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgc3RyaWN0IGluZXF1YWxpdHkgKGAhPT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RTdHJpY3RFcXVhbCgzLCAnMycsICdubyBjb2VyY2lvbiBmb3Igc3RyaWN0IGVxdWFsaXR5Jyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFN0cmljdEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5ub3RTdHJpY3RFcXVhbCwgdHJ1ZSkudG8ubm90LmVxdWFsKGV4cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBhY3R1YWxgIGlzIGRlZXBseSBlcXVhbCB0byBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBFcXVhbCh7IHRlYTogJ2dyZWVuJyB9LCB7IHRlYTogJ2dyZWVuJyB9KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYWxpYXMgZGVlcFN0cmljdEVxdWFsXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwRXF1YWwgPSBhc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQuZGVlcEVxdWFsLCB0cnVlKS50by5lcWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnQgdGhhdCBgYWN0dWFsYCBpcyBub3QgZGVlcGx5IGVxdWFsIHRvIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90RGVlcEVxdWFsKHsgdGVhOiAnZ3JlZW4nIH0sIHsgdGVhOiAnamFzbWluZScgfSk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0Lm5vdERlZXBFcXVhbCwgdHJ1ZSkudG8ubm90LmVxbChleHApO1xuICB9O1xuXG4gICAvKipcbiAgICogIyMjIC5pc0Fib3ZlKHZhbHVlVG9DaGVjaywgdmFsdWVUb0JlQWJvdmUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBgdmFsdWVUb0NoZWNrYCBpcyBzdHJpY3RseSBncmVhdGVyIHRoYW4gKD4pIGB2YWx1ZVRvQmVBYm92ZWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNBYm92ZSg1LCAyLCAnNSBpcyBzdHJpY3RseSBncmVhdGVyIHRoYW4gMicpO1xuICAgKlxuICAgKiBAbmFtZSBpc0Fib3ZlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9DaGVja1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQmVBYm92ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNBYm92ZSA9IGZ1bmN0aW9uICh2YWwsIGFidiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzQWJvdmUsIHRydWUpLnRvLmJlLmFib3ZlKGFidik7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzQXRMZWFzdCh2YWx1ZVRvQ2hlY2ssIHZhbHVlVG9CZUF0TGVhc3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBgdmFsdWVUb0NoZWNrYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gKD49KSBgdmFsdWVUb0JlQXRMZWFzdGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNBdExlYXN0KDUsIDIsICc1IGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMicpO1xuICAgKiAgICAgYXNzZXJ0LmlzQXRMZWFzdCgzLCAzLCAnMyBpcyBncmVhdGVyIG9yIGVxdWFsIHRvIDMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNBdExlYXN0XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9DaGVja1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQmVBdExlYXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0F0TGVhc3QgPSBmdW5jdGlvbiAodmFsLCBhdGxzdCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzQXRMZWFzdCwgdHJ1ZSkudG8uYmUubGVhc3QoYXRsc3QpO1xuICB9O1xuXG4gICAvKipcbiAgICogIyMjIC5pc0JlbG93KHZhbHVlVG9DaGVjaywgdmFsdWVUb0JlQmVsb3csIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBgdmFsdWVUb0NoZWNrYCBpcyBzdHJpY3RseSBsZXNzIHRoYW4gKDwpIGB2YWx1ZVRvQmVCZWxvd2AuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNCZWxvdygzLCA2LCAnMyBpcyBzdHJpY3RseSBsZXNzIHRoYW4gNicpO1xuICAgKlxuICAgKiBAbmFtZSBpc0JlbG93XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9DaGVja1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQmVCZWxvd1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNCZWxvdyA9IGZ1bmN0aW9uICh2YWwsIGJsdywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzQmVsb3csIHRydWUpLnRvLmJlLmJlbG93KGJsdyk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzQXRNb3N0KHZhbHVlVG9DaGVjaywgdmFsdWVUb0JlQXRNb3N0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgYHZhbHVlVG9DaGVja2AgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICg8PSkgYHZhbHVlVG9CZUF0TW9zdGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNBdE1vc3QoMywgNiwgJzMgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDYnKTtcbiAgICogICAgIGFzc2VydC5pc0F0TW9zdCg0LCA0LCAnNCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gNCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc0F0TW9zdFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQ2hlY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0JlQXRNb3N0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0F0TW9zdCA9IGZ1bmN0aW9uICh2YWwsIGF0bXN0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNBdE1vc3QsIHRydWUpLnRvLmJlLm1vc3QoYXRtc3QpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzVHJ1ZSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyB0cnVlLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVNlcnZlZCA9IHRydWU7XG4gICAqICAgICBhc3NlcnQuaXNUcnVlKHRlYVNlcnZlZCwgJ3RoZSB0ZWEgaGFzIGJlZW4gc2VydmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzVHJ1ZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNUcnVlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzVHJ1ZSwgdHJ1ZSkuaXNbJ3RydWUnXTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdFRydWUodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbm90IHRydWUuXG4gICAqXG4gICAqICAgICB2YXIgdGVhID0gJ3Rhc3R5IGNoYWknO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90VHJ1ZSh0ZWEsICdncmVhdCwgdGltZSBmb3IgdGVhIScpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdFRydWVcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90VHJ1ZSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdFRydWUsIHRydWUpLnRvLm5vdC5lcXVhbCh0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0ZhbHNlKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGZhbHNlLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVNlcnZlZCA9IGZhbHNlO1xuICAgKiAgICAgYXNzZXJ0LmlzRmFsc2UodGVhU2VydmVkLCAnbm8gdGVhIHlldD8gaG1tLi4uJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRmFsc2VcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRmFsc2UgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNGYWxzZSwgdHJ1ZSkuaXNbJ2ZhbHNlJ107XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RGYWxzZSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBub3QgZmFsc2UuXG4gICAqXG4gICAqICAgICB2YXIgdGVhID0gJ3Rhc3R5IGNoYWknO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90RmFsc2UodGVhLCAnZ3JlYXQsIHRpbWUgZm9yIHRlYSEnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RGYWxzZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RGYWxzZSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdEZhbHNlLCB0cnVlKS50by5ub3QuZXF1YWwoZmFsc2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTnVsbCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBudWxsLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTnVsbChlcnIsICd0aGVyZSB3YXMgbm8gZXJyb3InKTtcbiAgICpcbiAgICogQG5hbWUgaXNOdWxsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc051bGwgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOdWxsLCB0cnVlKS50by5lcXVhbChudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE51bGwodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbm90IG51bGwuXG4gICAqXG4gICAqICAgICB2YXIgdGVhID0gJ3Rhc3R5IGNoYWknO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90TnVsbCh0ZWEsICdncmVhdCwgdGltZSBmb3IgdGVhIScpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE51bGxcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90TnVsbCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdE51bGwsIHRydWUpLnRvLm5vdC5lcXVhbChudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05hTlxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdmFsdWUgaXMgTmFOLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTmFOKE5hTiwgJ05hTiBpcyBOYU4nKTtcbiAgICpcbiAgICogQG5hbWUgaXNOYU5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTmFOID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTmFOLCB0cnVlKS50by5iZS5OYU47XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3ROYU5cbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHZhbHVlIGlzIG5vdCBOYU4uXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOb3ROYU4oNCwgJzQgaXMgbm90IE5hTicpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE5hTlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgYXNzZXJ0LmlzTm90TmFOID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90TmFOLCB0cnVlKS5ub3QudG8uYmUuTmFOO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmV4aXN0c1xuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBuZWl0aGVyIGBudWxsYCBub3IgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgZm9vID0gJ2hpJztcbiAgICpcbiAgICogICAgIGFzc2VydC5leGlzdHMoZm9vLCAnZm9vIGlzIG5laXRoZXIgYG51bGxgIG5vciBgdW5kZWZpbmVkYCcpO1xuICAgKlxuICAgKiBAbmFtZSBleGlzdHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmV4aXN0cyA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5leGlzdHMsIHRydWUpLnRvLmV4aXN0O1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEV4aXN0c1xuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBlaXRoZXIgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgdmFyIGJhciA9IG51bGxcbiAgICogICAgICAgLCBiYXo7XG4gICAqXG4gICAqICAgICBhc3NlcnQubm90RXhpc3RzKGJhcik7XG4gICAqICAgICBhc3NlcnQubm90RXhpc3RzKGJheiwgJ2JheiBpcyBlaXRoZXIgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgbm90RXhpc3RzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RFeGlzdHMgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQubm90RXhpc3RzLCB0cnVlKS50by5ub3QuZXhpc3Q7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNVbmRlZmluZWQodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgdGVhO1xuICAgKiAgICAgYXNzZXJ0LmlzVW5kZWZpbmVkKHRlYSwgJ25vIHRlYSBkZWZpbmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzVW5kZWZpbmVkXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc1VuZGVmaW5lZCwgdHJ1ZSkudG8uZXF1YWwodW5kZWZpbmVkKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0RlZmluZWQodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbm90IGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYSA9ICdjdXAgb2YgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNEZWZpbmVkKHRlYSwgJ3RlYSBoYXMgYmVlbiBkZWZpbmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRGVmaW5lZFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNEZWZpbmVkID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzRGVmaW5lZCwgdHJ1ZSkudG8ubm90LmVxdWFsKHVuZGVmaW5lZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNGdW5jdGlvbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gc2VydmVUZWEoKSB7IHJldHVybiAnY3VwIG9mIHRlYSc7IH07XG4gICAqICAgICBhc3NlcnQuaXNGdW5jdGlvbihzZXJ2ZVRlYSwgJ2dyZWF0LCB3ZSBjYW4gaGF2ZSB0ZWEgbm93Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRnVuY3Rpb25cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNGdW5jdGlvbiwgdHJ1ZSkudG8uYmUuYSgnZnVuY3Rpb24nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEZ1bmN0aW9uKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGEgZnVuY3Rpb24uXG4gICAqXG4gICAqICAgICB2YXIgc2VydmVUZWEgPSBbICdoZWF0JywgJ3BvdXInLCAnc2lwJyBdO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90RnVuY3Rpb24oc2VydmVUZWEsICdncmVhdCwgd2UgaGF2ZSBsaXN0ZWQgdGhlIHN0ZXBzJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90RnVuY3Rpb25cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90RnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3RGdW5jdGlvbiwgdHJ1ZSkudG8ubm90LmJlLmEoJ2Z1bmN0aW9uJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNPYmplY3QodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYW4gb2JqZWN0IG9mIHR5cGUgJ09iamVjdCcgKGFzIHJldmVhbGVkIGJ5IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCkuXG4gICAqIF9UaGUgYXNzZXJ0aW9uIGRvZXMgbm90IG1hdGNoIHN1YmNsYXNzZWQgb2JqZWN0cy5fXG4gICAqXG4gICAqICAgICB2YXIgc2VsZWN0aW9uID0geyBuYW1lOiAnQ2hhaScsIHNlcnZlOiAnd2l0aCBzcGljZXMnIH07XG4gICAqICAgICBhc3NlcnQuaXNPYmplY3Qoc2VsZWN0aW9uLCAndGVhIHNlbGVjdGlvbiBpcyBhbiBvYmplY3QnKTtcbiAgICpcbiAgICogQG5hbWUgaXNPYmplY3RcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzT2JqZWN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzT2JqZWN0LCB0cnVlKS50by5iZS5hKCdvYmplY3QnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE9iamVjdCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhbiBvYmplY3Qgb2YgdHlwZSAnT2JqZWN0JyAoYXMgcmV2ZWFsZWQgYnkgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgKS5cbiAgICpcbiAgICogICAgIHZhciBzZWxlY3Rpb24gPSAnY2hhaSdcbiAgICogICAgIGFzc2VydC5pc05vdE9iamVjdChzZWxlY3Rpb24sICd0ZWEgc2VsZWN0aW9uIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICogICAgIGFzc2VydC5pc05vdE9iamVjdChudWxsLCAnbnVsbCBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90T2JqZWN0XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE9iamVjdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdE9iamVjdCwgdHJ1ZSkudG8ubm90LmJlLmEoJ29iamVjdCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzQXJyYXkodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYW4gYXJyYXkuXG4gICAqXG4gICAqICAgICB2YXIgbWVudSA9IFsgJ2dyZWVuJywgJ2NoYWknLCAnb29sb25nJyBdO1xuICAgKiAgICAgYXNzZXJ0LmlzQXJyYXkobWVudSwgJ3doYXQga2luZCBvZiB0ZWEgZG8gd2Ugd2FudD8nKTtcbiAgICpcbiAgICogQG5hbWUgaXNBcnJheVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNBcnJheSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0FycmF5LCB0cnVlKS50by5iZS5hbignYXJyYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEFycmF5KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGFuIGFycmF5LlxuICAgKlxuICAgKiAgICAgdmFyIG1lbnUgPSAnZ3JlZW58Y2hhaXxvb2xvbmcnO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90QXJyYXkobWVudSwgJ3doYXQga2luZCBvZiB0ZWEgZG8gd2Ugd2FudD8nKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RBcnJheVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RBcnJheSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdEFycmF5LCB0cnVlKS50by5ub3QuYmUuYW4oJ2FycmF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNTdHJpbmcodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBzdHJpbmcuXG4gICAqXG4gICAqICAgICB2YXIgdGVhT3JkZXIgPSAnY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNTdHJpbmcodGVhT3JkZXIsICdvcmRlciBwbGFjZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNTdHJpbmdcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzU3RyaW5nID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzU3RyaW5nLCB0cnVlKS50by5iZS5hKCdzdHJpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdFN0cmluZyh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIHN0cmluZy5cbiAgICpcbiAgICogICAgIHZhciB0ZWFPcmRlciA9IDQ7XG4gICAqICAgICBhc3NlcnQuaXNOb3RTdHJpbmcodGVhT3JkZXIsICdvcmRlciBwbGFjZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RTdHJpbmdcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90U3RyaW5nID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90U3RyaW5nLCB0cnVlKS50by5ub3QuYmUuYSgnc3RyaW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOdW1iZXIodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBudW1iZXIuXG4gICAqXG4gICAqICAgICB2YXIgY3VwcyA9IDI7XG4gICAqICAgICBhc3NlcnQuaXNOdW1iZXIoY3VwcywgJ2hvdyBtYW55IGN1cHMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOdW1iZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc051bWJlciA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc051bWJlciwgdHJ1ZSkudG8uYmUuYSgnbnVtYmVyJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3ROdW1iZXIodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBudW1iZXIuXG4gICAqXG4gICAqICAgICB2YXIgY3VwcyA9ICcyIGN1cHMgcGxlYXNlJztcbiAgICogICAgIGFzc2VydC5pc05vdE51bWJlcihjdXBzLCAnaG93IG1hbnkgY3VwcycpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE51bWJlclxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3ROdW1iZXIgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3ROdW1iZXIsIHRydWUpLnRvLm5vdC5iZS5hKCdudW1iZXInKTtcbiAgfTtcblxuICAgLyoqXG4gICAqICMjIyAuaXNGaW5pdGUodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLiBVbmxpa2UgYC5pc051bWJlcmAsIHRoaXMgd2lsbCBmYWlsIGZvciBgTmFOYCBhbmQgYEluZmluaXR5YC5cbiAgICpcbiAgICogICAgIHZhciBjdXBzID0gMjtcbiAgICogICAgIGFzc2VydC5pc0Zpbml0ZShjdXBzLCAnaG93IG1hbnkgY3VwcycpO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzRmluaXRlKE5hTik7IC8vIHRocm93c1xuICAgKlxuICAgKiBAbmFtZSBpc0Zpbml0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRmluaXRlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzRmluaXRlLCB0cnVlKS50by5iZS5maW5pdGU7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNCb29sZWFuKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgYm9vbGVhbi5cbiAgICpcbiAgICogICAgIHZhciB0ZWFSZWFkeSA9IHRydWVcbiAgICogICAgICAgLCB0ZWFTZXJ2ZWQgPSBmYWxzZTtcbiAgICpcbiAgICogICAgIGFzc2VydC5pc0Jvb2xlYW4odGVhUmVhZHksICdpcyB0aGUgdGVhIHJlYWR5Jyk7XG4gICAqICAgICBhc3NlcnQuaXNCb29sZWFuKHRlYVNlcnZlZCwgJ2hhcyB0ZWEgYmVlbiBzZXJ2ZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNCb29sZWFuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0Jvb2xlYW4gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNCb29sZWFuLCB0cnVlKS50by5iZS5hKCdib29sZWFuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RCb29sZWFuKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGEgYm9vbGVhbi5cbiAgICpcbiAgICogICAgIHZhciB0ZWFSZWFkeSA9ICd5ZXAnXG4gICAqICAgICAgICwgdGVhU2VydmVkID0gJ25vcGUnO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90Qm9vbGVhbih0ZWFSZWFkeSwgJ2lzIHRoZSB0ZWEgcmVhZHknKTtcbiAgICogICAgIGFzc2VydC5pc05vdEJvb2xlYW4odGVhU2VydmVkLCAnaGFzIHRlYSBiZWVuIHNlcnZlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEJvb2xlYW5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90Qm9vbGVhbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdEJvb2xlYW4sIHRydWUpLnRvLm5vdC5iZS5hKCdib29sZWFuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAudHlwZU9mKHZhbHVlLCBuYW1lLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgJ3MgdHlwZSBpcyBgbmFtZWAsIGFzIGRldGVybWluZWQgYnlcbiAgICogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnR5cGVPZih7IHRlYTogJ2NoYWknIH0sICdvYmplY3QnLCAnd2UgaGF2ZSBhbiBvYmplY3QnKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YoWydjaGFpJywgJ2phc21pbmUnXSwgJ2FycmF5JywgJ3dlIGhhdmUgYW4gYXJyYXknKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YoJ3RlYScsICdzdHJpbmcnLCAnd2UgaGF2ZSBhIHN0cmluZycpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZigvdGVhLywgJ3JlZ2V4cCcsICd3ZSBoYXZlIGEgcmVndWxhciBleHByZXNzaW9uJyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKG51bGwsICdudWxsJywgJ3dlIGhhdmUgYSBudWxsJyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKHVuZGVmaW5lZCwgJ3VuZGVmaW5lZCcsICd3ZSBoYXZlIGFuIHVuZGVmaW5lZCcpO1xuICAgKlxuICAgKiBAbmFtZSB0eXBlT2ZcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnR5cGVPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC50eXBlT2YsIHRydWUpLnRvLmJlLmEodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90VHlwZU9mKHZhbHVlLCBuYW1lLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgJ3MgdHlwZSBpcyBfbm90XyBgbmFtZWAsIGFzIGRldGVybWluZWQgYnlcbiAgICogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFR5cGVPZigndGVhJywgJ251bWJlcicsICdzdHJpbmdzIGFyZSBub3QgbnVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RUeXBlT2ZcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVvZiBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RUeXBlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQubm90VHlwZU9mLCB0cnVlKS50by5ub3QuYmUuYSh0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pbnN0YW5jZU9mKG9iamVjdCwgY29uc3RydWN0b3IsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYW4gaW5zdGFuY2Ugb2YgYGNvbnN0cnVjdG9yYC5cbiAgICpcbiAgICogICAgIHZhciBUZWEgPSBmdW5jdGlvbiAobmFtZSkgeyB0aGlzLm5hbWUgPSBuYW1lOyB9XG4gICAqICAgICAgICwgY2hhaSA9IG5ldyBUZWEoJ2NoYWknKTtcbiAgICpcbiAgICogICAgIGFzc2VydC5pbnN0YW5jZU9mKGNoYWksIFRlYSwgJ2NoYWkgaXMgYW4gaW5zdGFuY2Ugb2YgdGVhJyk7XG4gICAqXG4gICAqIEBuYW1lIGluc3RhbmNlT2ZcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5zdGFuY2VPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pbnN0YW5jZU9mLCB0cnVlKS50by5iZS5pbnN0YW5jZU9mKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEluc3RhbmNlT2Yob2JqZWN0LCBjb25zdHJ1Y3RvciwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZWAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGBjb25zdHJ1Y3RvcmAuXG4gICAqXG4gICAqICAgICB2YXIgVGVhID0gZnVuY3Rpb24gKG5hbWUpIHsgdGhpcy5uYW1lID0gbmFtZTsgfVxuICAgKiAgICAgICAsIGNoYWkgPSBuZXcgU3RyaW5nKCdjaGFpJyk7XG4gICAqXG4gICAqICAgICBhc3NlcnQubm90SW5zdGFuY2VPZihjaGFpLCBUZWEsICdjaGFpIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiB0ZWEnKTtcbiAgICpcbiAgICogQG5hbWUgbm90SW5zdGFuY2VPZlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RJbnN0YW5jZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0Lm5vdEluc3RhbmNlT2YsIHRydWUpXG4gICAgICAudG8ubm90LmJlLmluc3RhbmNlT2YodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgaGF5c3RhY2tgIGluY2x1ZGVzIGBuZWVkbGVgLiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlXG4gICAqIGluY2x1c2lvbiBvZiBhIHZhbHVlIGluIGFuIGFycmF5LCBhIHN1YnN0cmluZyBpbiBhIHN0cmluZywgb3IgYSBzdWJzZXQgb2ZcbiAgICogcHJvcGVydGllcyBpbiBhbiBvYmplY3QuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5jbHVkZShbMSwyLDNdLCAyLCAnYXJyYXkgY29udGFpbnMgdmFsdWUnKTtcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKCdmb29iYXInLCAnZm9vJywgJ3N0cmluZyBjb250YWlucyBzdWJzdHJpbmcnKTtcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKHsgZm9vOiAnYmFyJywgaGVsbG86ICd1bml2ZXJzZScgfSwgeyBmb286ICdiYXInIH0sICdvYmplY3QgY29udGFpbnMgcHJvcGVydHknKTtcbiAgICpcbiAgICogU3RyaWN0IGVxdWFsaXR5ICg9PT0pIGlzIHVzZWQuIFdoZW4gYXNzZXJ0aW5nIHRoZSBpbmNsdXNpb24gb2YgYSB2YWx1ZSBpblxuICAgKiBhbiBhcnJheSwgdGhlIGFycmF5IGlzIHNlYXJjaGVkIGZvciBhbiBlbGVtZW50IHRoYXQncyBzdHJpY3RseSBlcXVhbCB0byB0aGVcbiAgICogZ2l2ZW4gdmFsdWUuIFdoZW4gYXNzZXJ0aW5nIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW4gb2JqZWN0LCB0aGUgb2JqZWN0XG4gICAqIGlzIHNlYXJjaGVkIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkga2V5cywgY2hlY2tpbmcgdGhhdCBlYWNoIG9uZSBpcyBwcmVzZW50XG4gICAqIGFuZCBzdHJpY3R5IGVxdWFsIHRvIHRoZSBnaXZlbiBwcm9wZXJ0eSB2YWx1ZS4gRm9yIGluc3RhbmNlOlxuICAgKlxuICAgKiAgICAgdmFyIG9iajEgPSB7YTogMX1cbiAgICogICAgICAgLCBvYmoyID0ge2I6IDJ9O1xuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoW29iajEsIG9iajJdLCBvYmoxKTtcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKHtmb286IG9iajEsIGJhcjogb2JqMn0sIHtmb286IG9iajF9KTtcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKHtmb286IG9iajEsIGJhcjogb2JqMn0sIHtmb286IG9iajEsIGJhcjogb2JqMn0pO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge01peGVkfSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5pbmNsdWRlLCB0cnVlKS5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgaGF5c3RhY2tgIGRvZXMgbm90IGluY2x1ZGUgYG5lZWRsZWAuIENhbiBiZSB1c2VkIHRvIGFzc2VydFxuICAgKiB0aGUgYWJzZW5jZSBvZiBhIHZhbHVlIGluIGFuIGFycmF5LCBhIHN1YnN0cmluZyBpbiBhIHN0cmluZywgb3IgYSBzdWJzZXQgb2ZcbiAgICogcHJvcGVydGllcyBpbiBhbiBvYmplY3QuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZShbMSwyLDNdLCA0LCAnYXJyYXkgZG9lc24ndCBjb250YWluIHZhbHVlJyk7XG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZSgnZm9vYmFyJywgJ2JheicsICdzdHJpbmcgZG9lc24ndCBjb250YWluIHN1YnN0cmluZycpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGUoeyBmb286ICdiYXInLCBoZWxsbzogJ3VuaXZlcnNlJyB9LCB7IGZvbzogJ2JheicgfSwgJ29iamVjdCBkb2Vzbid0IGNvbnRhaW4gcHJvcGVydHknKTtcbiAgICpcbiAgICogU3RyaWN0IGVxdWFsaXR5ICg9PT0pIGlzIHVzZWQuIFdoZW4gYXNzZXJ0aW5nIHRoZSBhYnNlbmNlIG9mIGEgdmFsdWUgaW4gYW5cbiAgICogYXJyYXksIHRoZSBhcnJheSBpcyBzZWFyY2hlZCB0byBjb25maXJtIHRoZSBhYnNlbmNlIG9mIGFuIGVsZW1lbnQgdGhhdCdzXG4gICAqIHN0cmljdGx5IGVxdWFsIHRvIHRoZSBnaXZlbiB2YWx1ZS4gV2hlbiBhc3NlcnRpbmcgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpblxuICAgKiBhbiBvYmplY3QsIHRoZSBvYmplY3QgaXMgc2VhcmNoZWQgdG8gY29uZmlybSB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGUgZ2l2ZW5cbiAgICogcHJvcGVydHkga2V5cyBpcyBlaXRoZXIgbm90IHByZXNlbnQgb3Igbm90IHN0cmljdGx5IGVxdWFsIHRvIHRoZSBnaXZlblxuICAgKiBwcm9wZXJ0eSB2YWx1ZS4gRm9yIGluc3RhbmNlOlxuICAgKlxuICAgKiAgICAgdmFyIG9iajEgPSB7YTogMX1cbiAgICogICAgICAgLCBvYmoyID0ge2I6IDJ9O1xuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGUoW29iajEsIG9iajJdLCB7YTogMX0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGUoe2Zvbzogb2JqMSwgYmFyOiBvYmoyfSwge2Zvbzoge2E6IDF9fSk7XG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZSh7Zm9vOiBvYmoxLCBiYXI6IG9iajJ9LCB7Zm9vOiBvYmoxLCBiYXI6IHtiOiAyfX0pO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbmNsdWRlXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge01peGVkfSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5ub3RJbmNsdWRlLCB0cnVlKS5ub3QuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBJbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBoYXlzdGFja2AgaW5jbHVkZXMgYG5lZWRsZWAuIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGVcbiAgICogaW5jbHVzaW9uIG9mIGEgdmFsdWUgaW4gYW4gYXJyYXkgb3IgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhbiBvYmplY3QuXG4gICAqIERlZXAgZXF1YWxpdHkgaXMgdXNlZC5cbiAgICpcbiAgICogICAgIHZhciBvYmoxID0ge2E6IDF9XG4gICAqICAgICAgICwgb2JqMiA9IHtiOiAyfTtcbiAgICogICAgIGFzc2VydC5kZWVwSW5jbHVkZShbb2JqMSwgb2JqMl0sIHthOiAxfSk7XG4gICAqICAgICBhc3NlcnQuZGVlcEluY2x1ZGUoe2Zvbzogb2JqMSwgYmFyOiBvYmoyfSwge2Zvbzoge2E6IDF9fSk7XG4gICAqICAgICBhc3NlcnQuZGVlcEluY2x1ZGUoe2Zvbzogb2JqMSwgYmFyOiBvYmoyfSwge2Zvbzoge2E6IDF9LCBiYXI6IHtiOiAyfX0pO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwSW5jbHVkZVxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwSW5jbHVkZSA9IGZ1bmN0aW9uIChleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0LmRlZXBJbmNsdWRlLCB0cnVlKS5kZWVwLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgaGF5c3RhY2tgIGRvZXMgbm90IGluY2x1ZGUgYG5lZWRsZWAuIENhbiBiZSB1c2VkIHRvIGFzc2VydFxuICAgKiB0aGUgYWJzZW5jZSBvZiBhIHZhbHVlIGluIGFuIGFycmF5IG9yIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW4gb2JqZWN0LlxuICAgKiBEZWVwIGVxdWFsaXR5IGlzIHVzZWQuXG4gICAqXG4gICAqICAgICB2YXIgb2JqMSA9IHthOiAxfVxuICAgKiAgICAgICAsIG9iajIgPSB7YjogMn07XG4gICAqICAgICBhc3NlcnQubm90RGVlcEluY2x1ZGUoW29iajEsIG9iajJdLCB7YTogOX0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBJbmNsdWRlKHtmb286IG9iajEsIGJhcjogb2JqMn0sIHtmb286IHthOiA5fX0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBJbmNsdWRlKHtmb286IG9iajEsIGJhcjogb2JqMn0sIHtmb286IHthOiAxfSwgYmFyOiB7YjogOX19KTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcEluY2x1ZGVcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcEluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5ub3REZWVwSW5jbHVkZSwgdHJ1ZSkubm90LmRlZXAuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5lc3RlZEluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKiBcbiAgICogQXNzZXJ0cyB0aGF0ICdoYXlzdGFjaycgaW5jbHVkZXMgJ25lZWRsZScuIFxuICAgKiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIGluY2x1c2lvbiBvZiBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuIFxuICAgKiBvYmplY3QuXG4gICAqIEVuYWJsZXMgdGhlIHVzZSBvZiBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciByZWZlcmVuY2luZyBuZXN0ZWQgXG4gICAqIHByb3BlcnRpZXMuXG4gICAqICdbXScgYW5kICcuJyBpbiBwcm9wZXJ0eSBuYW1lcyBjYW4gYmUgZXNjYXBlZCB1c2luZyBkb3VibGUgYmFja3NsYXNoZXMuXG4gICAqIFxuICAgKiAgICAgYXNzZXJ0Lm5lc3RlZEluY2x1ZGUoeycuYSc6IHsnYic6ICd4J319LCB7J1xcXFwuYS5bYl0nOiAneCd9KTtcbiAgICogICAgIGFzc2VydC5uZXN0ZWRJbmNsdWRlKHsnYSc6IHsnW2JdJzogJ3gnfX0sIHsnYS5cXFxcW2JcXFxcXSc6ICd4J30pO1xuICAgKiBcbiAgICogQG5hbWUgbmVzdGVkSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpYyBcbiAgICovIFxuXG4gIGFzc2VydC5uZXN0ZWRJbmNsdWRlID0gZnVuY3Rpb24gKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubmVzdGVkSW5jbHVkZSwgdHJ1ZSkubmVzdGVkLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3ROZXN0ZWRJbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICogXG4gICAqIEFzc2VydHMgdGhhdCAnaGF5c3RhY2snIGRvZXMgbm90IGluY2x1ZGUgJ25lZWRsZScuIFxuICAgKiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIGFic2VuY2Ugb2YgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhbiBcbiAgICogb2JqZWN0LlxuICAgKiBFbmFibGVzIHRoZSB1c2Ugb2YgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgcmVmZXJlbmNpbmcgbmVzdGVkIFxuICAgKiBwcm9wZXJ0aWVzLiBcbiAgICogJ1tdJyBhbmQgJy4nIGluIHByb3BlcnR5IG5hbWVzIGNhbiBiZSBlc2NhcGVkIHVzaW5nIGRvdWJsZSBiYWNrc2xhc2hlcy5cbiAgICogXG4gICAqICAgICBhc3NlcnQubm90TmVzdGVkSW5jbHVkZSh7Jy5hJzogeydiJzogJ3gnfX0sIHsnXFxcXC5hLmInOiAneSd9KTtcbiAgICogICAgIGFzc2VydC5ub3ROZXN0ZWRJbmNsdWRlKHsnYSc6IHsnW2JdJzogJ3gnfX0sIHsnYS5cXFxcW2JcXFxcXSc6ICd5J30pO1xuICAgKiBcbiAgICogQG5hbWUgbm90TmVzdGVkSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpYyBcbiAgICovIFxuXG4gIGFzc2VydC5ub3ROZXN0ZWRJbmNsdWRlID0gZnVuY3Rpb24gKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubm90TmVzdGVkSW5jbHVkZSwgdHJ1ZSlcbiAgICAgIC5ub3QubmVzdGVkLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwTmVzdGVkSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqIFxuICAgKiBBc3NlcnRzIHRoYXQgJ2hheXN0YWNrJyBpbmNsdWRlcyAnbmVlZGxlJy5cbiAgICogQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSBpbmNsdXNpb24gb2YgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhbiBcbiAgICogb2JqZWN0IHdoaWxlIGNoZWNraW5nIGZvciBkZWVwIGVxdWFsaXR5LlxuICAgKiBFbmFibGVzIHRoZSB1c2Ugb2YgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgcmVmZXJlbmNpbmcgbmVzdGVkIFxuICAgKiBwcm9wZXJ0aWVzLlxuICAgKiAnW10nIGFuZCAnLicgaW4gcHJvcGVydHkgbmFtZXMgY2FuIGJlIGVzY2FwZWQgdXNpbmcgZG91YmxlIGJhY2tzbGFzaGVzLlxuICAgKiBcbiAgICogICAgIGFzc2VydC5kZWVwTmVzdGVkSW5jbHVkZSh7YToge2I6IFt7eDogMX1dfX0sIHsnYS5iWzBdJzoge3g6IDF9fSk7XG4gICAqICAgICBhc3NlcnQuZGVlcE5lc3RlZEluY2x1ZGUoeycuYSc6IHsnW2JdJzoge3g6IDF9fX0sIHsnXFxcXC5hLlxcXFxbYlxcXFxdJzoge3g6IDF9fSk7XG4gICAqICAgIFxuICAgKiBAbmFtZSBkZWVwTmVzdGVkSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpYyBcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBOZXN0ZWRJbmNsdWRlID0gZnVuY3Rpb24oZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5kZWVwTmVzdGVkSW5jbHVkZSwgdHJ1ZSlcbiAgICAgIC5kZWVwLm5lc3RlZC5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RGVlcE5lc3RlZEluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKiBcbiAgICogQXNzZXJ0cyB0aGF0ICdoYXlzdGFjaycgZG9lcyBub3QgaW5jbHVkZSAnbmVlZGxlJy5cbiAgICogQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSBhYnNlbmNlIG9mIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW4gXG4gICAqIG9iamVjdCB3aGlsZSBjaGVja2luZyBmb3IgZGVlcCBlcXVhbGl0eS5cbiAgICogRW5hYmxlcyB0aGUgdXNlIG9mIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIHJlZmVyZW5jaW5nIG5lc3RlZCBcbiAgICogcHJvcGVydGllcy5cbiAgICogJ1tdJyBhbmQgJy4nIGluIHByb3BlcnR5IG5hbWVzIGNhbiBiZSBlc2NhcGVkIHVzaW5nIGRvdWJsZSBiYWNrc2xhc2hlcy5cbiAgICogXG4gICAqICAgICBhc3NlcnQubm90RGVlcE5lc3RlZEluY2x1ZGUoe2E6IHtiOiBbe3g6IDF9XX19LCB7J2EuYlswXSc6IHt5OiAxfX0pXG4gICAqICAgICBhc3NlcnQubm90RGVlcE5lc3RlZEluY2x1ZGUoeycuYSc6IHsnW2JdJzoge3g6IDF9fX0sIHsnXFxcXC5hLlxcXFxbYlxcXFxdJzoge3k6IDJ9fSk7XG4gICAqICAgIFxuICAgKiBAbmFtZSBub3REZWVwTmVzdGVkSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpYyBcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdERlZXBOZXN0ZWRJbmNsdWRlID0gZnVuY3Rpb24oZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5ub3REZWVwTmVzdGVkSW5jbHVkZSwgdHJ1ZSlcbiAgICAgIC5ub3QuZGVlcC5uZXN0ZWQuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm93bkluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKiBcbiAgICogQXNzZXJ0cyB0aGF0ICdoYXlzdGFjaycgaW5jbHVkZXMgJ25lZWRsZScuXG4gICAqIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgaW5jbHVzaW9uIG9mIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW4gXG4gICAqIG9iamVjdCB3aGlsZSBpZ25vcmluZyBpbmhlcml0ZWQgcHJvcGVydGllcy5cbiAgICogXG4gICAqICAgICBhc3NlcnQub3duSW5jbHVkZSh7IGE6IDEgfSwgeyBhOiAxIH0pO1xuICAgKiBcbiAgICogQG5hbWUgb3duSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQub3duSW5jbHVkZSA9IGZ1bmN0aW9uKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQub3duSW5jbHVkZSwgdHJ1ZSkub3duLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RPd25JbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICogXG4gICAqIEFzc2VydHMgdGhhdCAnaGF5c3RhY2snIGluY2x1ZGVzICduZWVkbGUnLlxuICAgKiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIGFic2VuY2Ugb2YgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhbiBcbiAgICogb2JqZWN0IHdoaWxlIGlnbm9yaW5nIGluaGVyaXRlZCBwcm9wZXJ0aWVzLlxuICAgKiBcbiAgICogICAgIE9iamVjdC5wcm90b3R5cGUuYiA9IDI7XG4gICAqIFxuICAgKiAgICAgYXNzZXJ0Lm5vdE93bkluY2x1ZGUoeyBhOiAxIH0sIHsgYjogMiB9KTtcbiAgICogXG4gICAqIEBuYW1lIG5vdE93bkluY2x1ZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdE93bkluY2x1ZGUgPSBmdW5jdGlvbihleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm5vdE93bkluY2x1ZGUsIHRydWUpLm5vdC5vd24uaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBPd25JbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICogXG4gICAqIEFzc2VydHMgdGhhdCAnaGF5c3RhY2snIGluY2x1ZGVzICduZWVkbGUnLlxuICAgKiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIGluY2x1c2lvbiBvZiBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuIFxuICAgKiBvYmplY3Qgd2hpbGUgaWdub3JpbmcgaW5oZXJpdGVkIHByb3BlcnRpZXMgYW5kIGNoZWNraW5nIGZvciBkZWVwIGVxdWFsaXR5LlxuICAgKiBcbiAgICogICAgICBhc3NlcnQuZGVlcE93bkluY2x1ZGUoe2E6IHtiOiAyfX0sIHthOiB7YjogMn19KTtcbiAgICogICAgICBcbiAgICogQG5hbWUgZGVlcE93bkluY2x1ZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBPd25JbmNsdWRlID0gZnVuY3Rpb24oZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5kZWVwT3duSW5jbHVkZSwgdHJ1ZSlcbiAgICAgIC5kZWVwLm93bi5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLm5vdERlZXBPd25JbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICogXG4gICAqIEFzc2VydHMgdGhhdCAnaGF5c3RhY2snIGluY2x1ZGVzICduZWVkbGUnLlxuICAgKiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIGFic2VuY2Ugb2YgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhbiBcbiAgICogb2JqZWN0IHdoaWxlIGlnbm9yaW5nIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGFuZCBjaGVja2luZyBmb3IgZGVlcCBlcXVhbGl0eS5cbiAgICogXG4gICAqICAgICAgYXNzZXJ0Lm5vdERlZXBPd25JbmNsdWRlKHthOiB7YjogMn19LCB7YToge2M6IDN9fSk7XG4gICAqICAgICAgXG4gICAqIEBuYW1lIG5vdERlZXBPd25JbmNsdWRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3REZWVwT3duSW5jbHVkZSA9IGZ1bmN0aW9uKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubm90RGVlcE93bkluY2x1ZGUsIHRydWUpXG4gICAgICAubm90LmRlZXAub3duLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5tYXRjaCh2YWx1ZSwgcmVnZXhwLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIG1hdGNoZXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBgcmVnZXhwYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5tYXRjaCgnZm9vYmFyJywgL15mb28vLCAncmVnZXhwIG1hdGNoZXMnKTtcbiAgICpcbiAgICogQG5hbWUgbWF0Y2hcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubWF0Y2ggPSBmdW5jdGlvbiAoZXhwLCByZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm1hdGNoLCB0cnVlKS50by5tYXRjaChyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90TWF0Y2godmFsdWUsIHJlZ2V4cCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBkb2VzIG5vdCBtYXRjaCB0aGUgcmVndWxhciBleHByZXNzaW9uIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE1hdGNoKCdmb29iYXInLCAvXmZvby8sICdyZWdleHAgZG9lcyBub3QgbWF0Y2gnKTtcbiAgICpcbiAgICogQG5hbWUgbm90TWF0Y2hcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90TWF0Y2ggPSBmdW5jdGlvbiAoZXhwLCByZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm5vdE1hdGNoLCB0cnVlKS50by5ub3QubWF0Y2gocmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZWQgYnlcbiAgICogYHByb3BlcnR5YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5wcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEnKTtcbiAgICogICAgIGFzc2VydC5wcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0b1N0cmluZycpO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQucHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQucHJvcGVydHksIHRydWUpLnRvLmhhdmUucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90UHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lZFxuICAgKiBieSBgcHJvcGVydHlgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ2NvZmZlZScpO1xuICAgKlxuICAgKiBAbmFtZSBub3RQcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90UHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90UHJvcGVydHksIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAucHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZWQgYnlcbiAgICogYHByb3BlcnR5YCB3aXRoIGEgdmFsdWUgZ2l2ZW4gYnkgYHZhbHVlYC4gVXNlcyBhIHN0cmljdCBlcXVhbGl0eSBjaGVja1xuICAgKiAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5wcm9wZXJ0eVZhbCh7IHRlYTogJ2lzIGdvb2QnIH0sICd0ZWEnLCAnaXMgZ29vZCcpO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQucHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5wcm9wZXJ0eVZhbCwgdHJ1ZSlcbiAgICAgIC50by5oYXZlLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90UHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZWRcbiAgICogYnkgYHByb3BlcnR5YCB3aXRoIHZhbHVlIGdpdmVuIGJ5IGB2YWx1ZWAuIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHkgY2hlY2tcbiAgICogKD09PSkuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90UHJvcGVydHlWYWwoeyB0ZWE6ICdpcyBnb29kJyB9LCAndGVhJywgJ2lzIGJhZCcpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdFByb3BlcnR5VmFsKHsgdGVhOiAnaXMgZ29vZCcgfSwgJ2NvZmZlZScsICdpcyBnb29kJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RQcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm5vdFByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVkIGJ5XG4gICAqIGBwcm9wZXJ0eWAgd2l0aCBhIHZhbHVlIGdpdmVuIGJ5IGB2YWx1ZWAuIFVzZXMgYSBkZWVwIGVxdWFsaXR5IGNoZWNrLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfSB9LCAndGVhJywgeyBncmVlbjogJ21hdGNoYScgfSk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBQcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuZGVlcFByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lZFxuICAgKiBieSBgcHJvcGVydHlgIHdpdGggdmFsdWUgZ2l2ZW4gYnkgYHZhbHVlYC4gVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90RGVlcFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9IH0sICd0ZWEnLCB7IGJsYWNrOiAnbWF0Y2hhJyB9KTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH0gfSwgJ3RlYScsIHsgZ3JlZW46ICdvb2xvbmcnIH0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfSB9LCAnY29mZmVlJywgeyBncmVlbjogJ21hdGNoYScgfSk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBQcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90RGVlcFByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLmRlZXAucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5vd25Qcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBkaXJlY3QgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YC4gSW5oZXJpdGVkXG4gICAqIHByb3BlcnRpZXMgYXJlbid0IGNoZWNrZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQub3duUHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhJyk7XG4gICAqXG4gICAqIEBuYW1lIG93blByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5vd25Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5vd25Qcm9wZXJ0eSwgdHJ1ZSlcbiAgICAgIC50by5oYXZlLm93bi5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RPd25Qcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBkaXJlY3QgcHJvcGVydHkgbmFtZWQgYnlcbiAgICogYHByb3BlcnR5YC4gSW5oZXJpdGVkIHByb3BlcnRpZXMgYXJlbid0IGNoZWNrZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90T3duUHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAnY29mZmVlJyk7XG4gICAqICAgICBhc3NlcnQubm90T3duUHJvcGVydHkoe30sICd0b1N0cmluZycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RPd25Qcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90T3duUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90T3duUHJvcGVydHksIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUub3duLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm93blByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBkaXJlY3QgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCBhbmQgYSB2YWx1ZVxuICAgKiBlcXVhbCB0byB0aGUgcHJvdmlkZWQgYHZhbHVlYC4gVXNlcyBhIHN0cmljdCBlcXVhbGl0eSBjaGVjayAoPT09KS5cbiAgICogSW5oZXJpdGVkIHByb3BlcnRpZXMgYXJlbid0IGNoZWNrZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQub3duUHJvcGVydHlWYWwoeyBjb2ZmZWU6ICdpcyBnb29kJ30sICdjb2ZmZWUnLCAnaXMgZ29vZCcpO1xuICAgKlxuICAgKiBAbmFtZSBvd25Qcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQub3duUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWx1ZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm93blByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLmhhdmUub3duLnByb3BlcnR5KHByb3AsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RPd25Qcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgZGlyZWN0IHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWBcbiAgICogd2l0aCBhIHZhbHVlIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBgdmFsdWVgLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrXG4gICAqICg9PT0pLiBJbmhlcml0ZWQgcHJvcGVydGllcyBhcmVuJ3QgY2hlY2tlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RPd25Qcm9wZXJ0eVZhbCh7IHRlYTogJ2lzIGJldHRlcid9LCAndGVhJywgJ2lzIHdvcnNlJyk7XG4gICAqICAgICBhc3NlcnQubm90T3duUHJvcGVydHlWYWwoe30sICd0b1N0cmluZycsIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuICAgKlxuICAgKiBAbmFtZSBub3RPd25Qcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90T3duUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWx1ZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm5vdE93blByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLm93bi5wcm9wZXJ0eShwcm9wLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcE93blByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBkaXJlY3QgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCBhbmQgYSB2YWx1ZVxuICAgKiBlcXVhbCB0byB0aGUgcHJvdmlkZWQgYHZhbHVlYC4gVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suIEluaGVyaXRlZFxuICAgKiBwcm9wZXJ0aWVzIGFyZW4ndCBjaGVja2VkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBPd25Qcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfSB9LCAndGVhJywgeyBncmVlbjogJ21hdGNoYScgfSk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBPd25Qcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcE93blByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsdWUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5kZWVwT3duUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8uaGF2ZS5kZWVwLm93bi5wcm9wZXJ0eShwcm9wLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RGVlcE93blByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBkaXJlY3QgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YFxuICAgKiB3aXRoIGEgdmFsdWUgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIGB2YWx1ZWAuIFVzZXMgYSBkZWVwIGVxdWFsaXR5IGNoZWNrLlxuICAgKiBJbmhlcml0ZWQgcHJvcGVydGllcyBhcmVuJ3QgY2hlY2tlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3REZWVwT3duUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH0gfSwgJ3RlYScsIHsgYmxhY2s6ICdtYXRjaGEnIH0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBPd25Qcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfSB9LCAndGVhJywgeyBncmVlbjogJ29vbG9uZycgfSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcE93blByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9IH0sICdjb2ZmZWUnLCB7IGdyZWVuOiAnbWF0Y2hhJyB9KTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwT3duUHJvcGVydHlWYWwoe30sICd0b1N0cmluZycsIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuICAgKlxuICAgKiBAbmFtZSBub3REZWVwT3duUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdERlZXBPd25Qcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbHVlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90RGVlcE93blByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLmRlZXAub3duLnByb3BlcnR5KHByb3AsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5uZXN0ZWRQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVkIGJ5XG4gICAqIGBwcm9wZXJ0eWAsIHdoaWNoIGNhbiBiZSBhIHN0cmluZyB1c2luZyBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvclxuICAgKiBuZXN0ZWQgcmVmZXJlbmNlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5lc3RlZFByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5ncmVlbicpO1xuICAgKlxuICAgKiBAbmFtZSBuZXN0ZWRQcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubmVzdGVkUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubmVzdGVkUHJvcGVydHksIHRydWUpXG4gICAgICAudG8uaGF2ZS5uZXN0ZWQucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90TmVzdGVkUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCwgd2hpY2hcbiAgICogY2FuIGJlIGEgc3RyaW5nIHVzaW5nIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIG5lc3RlZCByZWZlcmVuY2UuIFRoZVxuICAgKiBwcm9wZXJ0eSBjYW5ub3QgZXhpc3Qgb24gdGhlIG9iamVjdCBub3IgYW55d2hlcmUgaW4gaXRzIHByb3RvdHlwZSBjaGFpbi5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3ROZXN0ZWRQcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEub29sb25nJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdE5lc3RlZFByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3ROZXN0ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3ROZXN0ZWRQcm9wZXJ0eSwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5uZXN0ZWQucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubmVzdGVkUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAgd2l0aCB2YWx1ZSBnaXZlblxuICAgKiBieSBgdmFsdWVgLiBgcHJvcGVydHlgIGNhbiB1c2UgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgbmVzdGVkXG4gICAqIHJlZmVyZW5jZS4gVXNlcyBhIHN0cmljdCBlcXVhbGl0eSBjaGVjayAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5uZXN0ZWRQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEuZ3JlZW4nLCAnbWF0Y2hhJyk7XG4gICAqXG4gICAqIEBuYW1lIG5lc3RlZFByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5uZXN0ZWRQcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm5lc3RlZFByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLmhhdmUubmVzdGVkLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90TmVzdGVkUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAgd2l0aFxuICAgKiB2YWx1ZSBnaXZlbiBieSBgdmFsdWVgLiBgcHJvcGVydHlgIGNhbiB1c2UgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3JcbiAgICogbmVzdGVkIHJlZmVyZW5jZS4gVXNlcyBhIHN0cmljdCBlcXVhbGl0eSBjaGVjayAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3ROZXN0ZWRQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEuZ3JlZW4nLCAna29uYWNoYScpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdE5lc3RlZFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ2NvZmZlZS5ncmVlbicsICdtYXRjaGEnKTtcbiAgICpcbiAgICogQG5hbWUgbm90TmVzdGVkUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdE5lc3RlZFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90TmVzdGVkUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUubmVzdGVkLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcE5lc3RlZFByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgIHdpdGggYSB2YWx1ZSBnaXZlblxuICAgKiBieSBgdmFsdWVgLiBgcHJvcGVydHlgIGNhbiB1c2UgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgbmVzdGVkXG4gICAqIHJlZmVyZW5jZS4gVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcE5lc3RlZFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiB7IG1hdGNoYTogJ3l1bScgfSB9IH0sICd0ZWEuZ3JlZW4nLCB7IG1hdGNoYTogJ3l1bScgfSk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBOZXN0ZWRQcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcE5lc3RlZFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuZGVlcE5lc3RlZFByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLmhhdmUuZGVlcC5uZXN0ZWQucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwTmVzdGVkUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAgd2l0aFxuICAgKiB2YWx1ZSBnaXZlbiBieSBgdmFsdWVgLiBgcHJvcGVydHlgIGNhbiB1c2UgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3JcbiAgICogbmVzdGVkIHJlZmVyZW5jZS4gVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90RGVlcE5lc3RlZFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiB7IG1hdGNoYTogJ3l1bScgfSB9IH0sICd0ZWEuZ3JlZW4nLCB7IG9vbG9uZzogJ3l1bScgfSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcE5lc3RlZFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiB7IG1hdGNoYTogJ3l1bScgfSB9IH0sICd0ZWEuZ3JlZW4nLCB7IG1hdGNoYTogJ3l1Y2snIH0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBOZXN0ZWRQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogeyBtYXRjaGE6ICd5dW0nIH0gfSB9LCAndGVhLmJsYWNrJywgeyBtYXRjaGE6ICd5dW0nIH0pO1xuICAgKlxuICAgKiBAbmFtZSBub3REZWVwTmVzdGVkUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdERlZXBOZXN0ZWRQcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm5vdERlZXBOZXN0ZWRQcm9wZXJ0eVZhbCwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5kZWVwLm5lc3RlZC5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubGVuZ3RoT2Yob2JqZWN0LCBsZW5ndGgsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGBsZW5ndGhgIHByb3BlcnR5IHdpdGggdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmxlbmd0aE9mKFsxLDIsM10sIDMsICdhcnJheSBoYXMgbGVuZ3RoIG9mIDMnKTtcbiAgICogICAgIGFzc2VydC5sZW5ndGhPZignZm9vYmFyJywgNiwgJ3N0cmluZyBoYXMgbGVuZ3RoIG9mIDYnKTtcbiAgICpcbiAgICogQG5hbWUgbGVuZ3RoT2ZcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lmxlbmd0aE9mID0gZnVuY3Rpb24gKGV4cCwgbGVuLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubGVuZ3RoT2YsIHRydWUpLnRvLmhhdmUubGVuZ3RoT2YobGVuKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5oYXNBbnlLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYXQgbGVhc3Qgb25lIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmhhc0FueUtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCBbJ2ZvbycsICdpRG9udEV4aXN0JywgJ2JheiddKTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwge2ZvbzogMzAsIGlEb250RXhpc3Q6IDk5LCBiYXo6IDEzMzd9KTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlLZXlzKG5ldyBNYXAoW1t7Zm9vOiAxfSwgJ2JhciddLCBbJ2tleScsICd2YWx1ZSddXSksIFt7Zm9vOiAxfSwgJ2tleSddKTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlLZXlzKG5ldyBTZXQoW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSksIFt7Zm9vOiAnYmFyJ30sICdhbm90aGVyS2V5J10pO1xuICAgKlxuICAgKiBAbmFtZSBoYXNBbnlLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaGFzQW55S2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5oYXNBbnlLZXlzLCB0cnVlKS50by5oYXZlLmFueS5rZXlzKGtleXMpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaGFzQWxsS2V5cyhvYmplY3QsIFtrZXlzXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGFsbCBhbmQgb25seSBhbGwgb2YgdGhlIGBrZXlzYCBwcm92aWRlZC5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaGFzQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIFsnZm9vJywgJ2JhcicsICdiYXonXSk7XG4gICAqICAgICBhc3NlcnQuaGFzQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIHtmb286IDMwLCBiYXI6IDk5LCBiYXo6IDEzMzddKTtcbiAgICogICAgIGFzc2VydC5oYXNBbGxLZXlzKG5ldyBNYXAoW1t7Zm9vOiAxfSwgJ2JhciddLCBbJ2tleScsICd2YWx1ZSddXSksIFt7Zm9vOiAxfSwgJ2tleSddKTtcbiAgICogICAgIGFzc2VydC5oYXNBbGxLZXlzKG5ldyBTZXQoW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSwgW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSk7XG4gICAqXG4gICAqIEBuYW1lIGhhc0FsbEtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGtleXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lmhhc0FsbEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaGFzQWxsS2V5cywgdHJ1ZSkudG8uaGF2ZS5hbGwua2V5cyhrZXlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmNvbnRhaW5zQWxsS2V5cyhvYmplY3QsIFtrZXlzXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGFsbCBvZiB0aGUgYGtleXNgIHByb3ZpZGVkIGJ1dCBtYXkgaGF2ZSBtb3JlIGtleXMgbm90IGxpc3RlZC5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwgWydmb28nLCAnYmF6J10pO1xuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIFsnZm9vJywgJ2JhcicsICdiYXonXSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwge2ZvbzogMzAsIGJhejogMTMzN30pO1xuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIHtmb286IDMwLCBiYXI6IDk5LCBiYXo6IDEzMzd9KTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbEtleXMobmV3IE1hcChbW3tmb286IDF9LCAnYmFyJ10sIFsna2V5JywgJ3ZhbHVlJ11dKSwgW3tmb286IDF9XSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxLZXlzKG5ldyBNYXAoW1t7Zm9vOiAxfSwgJ2JhciddLCBbJ2tleScsICd2YWx1ZSddXSksIFt7Zm9vOiAxfSwgJ2tleSddKTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbEtleXMobmV3IFNldChbe2ZvbzogJ2Jhcid9LCAnYW5vdGhlcktleSddLCBbe2ZvbzogJ2Jhcid9XSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxLZXlzKG5ldyBTZXQoW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSwgW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSk7XG4gICAqXG4gICAqIEBuYW1lIGNvbnRhaW5zQWxsS2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuY29udGFpbnNBbGxLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmNvbnRhaW5zQWxsS2V5cywgdHJ1ZSlcbiAgICAgIC50by5jb250YWluLmFsbC5rZXlzKGtleXMpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuZG9lc05vdEhhdmVBbnlLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgbm9uZSBvZiB0aGUgYGtleXNgIHByb3ZpZGVkLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFueUtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCBbJ29uZScsICd0d28nLCAnZXhhbXBsZSddKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFueUtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCB7b25lOiAxLCB0d286IDIsIGV4YW1wbGU6ICdmb28nfSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbnlLZXlzKG5ldyBNYXAoW1t7Zm9vOiAxfSwgJ2JhciddLCBbJ2tleScsICd2YWx1ZSddXSksIFt7b25lOiAndHdvJ30sICdleGFtcGxlJ10pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55S2V5cyhuZXcgU2V0KFt7Zm9vOiAnYmFyJ30sICdhbm90aGVyS2V5J10sIFt7b25lOiAndHdvJ30sICdleGFtcGxlJ10pO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90SGF2ZUFueUtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGtleXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55S2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5kb2VzTm90SGF2ZUFueUtleXMsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuYW55LmtleXMoa2V5cyk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90SGF2ZUFsbEtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgbm90IGhhdmUgYXQgbGVhc3Qgb25lIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIFsnb25lJywgJ3R3bycsICdleGFtcGxlJ10pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIHtvbmU6IDEsIHR3bzogMiwgZXhhbXBsZTogJ2Zvbyd9KTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFsbEtleXMobmV3IE1hcChbW3tmb286IDF9LCAnYmFyJ10sIFsna2V5JywgJ3ZhbHVlJ11dKSwgW3tvbmU6ICd0d28nfSwgJ2V4YW1wbGUnXSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbGxLZXlzKG5ldyBTZXQoW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSwgW3tvbmU6ICd0d28nfSwgJ2V4YW1wbGUnXSk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RIYXZlQWxsS2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdEhhdmVBbGxLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsS2V5cywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5hbGwua2V5cyhrZXlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmhhc0FueURlZXBLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYXQgbGVhc3Qgb25lIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFNpbmNlIFNldHMgYW5kIE1hcHMgY2FuIGhhdmUgb2JqZWN0cyBhcyBrZXlzIHlvdSBjYW4gdXNlIHRoaXMgYXNzZXJ0aW9uIHRvIHBlcmZvcm1cbiAgICogYSBkZWVwIGNvbXBhcmlzb24uXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmhhc0FueURlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbMSwgMl1dKSwge29uZTogJ29uZSd9KTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXSwgWzEsIDJdXSksIFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FueURlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbe3R3bzogJ3R3byd9LCAndmFsdWVUd28nXV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCB7b25lOiAnb25lJ30pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FueURlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIFt7b25lOiAnb25lJ30sIHt0aHJlZTogJ3RocmVlJ31dKTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdEhhdmVBbGxLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaGFzQW55RGVlcEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaGFzQW55RGVlcEtleXMsIHRydWUpXG4gICAgICAudG8uaGF2ZS5hbnkuZGVlcC5rZXlzKGtleXMpO1xuICB9XG5cbiAvKipcbiAgICogIyMjIC5oYXNBbGxEZWVwS2V5cyhvYmplY3QsIFtrZXlzXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGFsbCBhbmQgb25seSBhbGwgb2YgdGhlIGBrZXlzYCBwcm92aWRlZC5cbiAgICogU2luY2UgU2V0cyBhbmQgTWFwcyBjYW4gaGF2ZSBvYmplY3RzIGFzIGtleXMgeW91IGNhbiB1c2UgdGhpcyBhc3NlcnRpb24gdG8gcGVyZm9ybVxuICAgKiBhIGRlZXAgY29tcGFyaXNvbi5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaGFzQWxsRGVlcEtleXMobmV3IE1hcChbW3tvbmU6ICdvbmUnfSwgJ3ZhbHVlT25lJ11dKSwge29uZTogJ29uZSd9KTtcbiAgICogICAgIGFzc2VydC5oYXNBbGxEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXSwgW3t0d286ICd0d28nfSwgJ3ZhbHVlVHdvJ11dKSwgW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSk7XG4gICAqICAgICBhc3NlcnQuaGFzQWxsRGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9XSksIHtvbmU6ICdvbmUnfSk7XG4gICAqICAgICBhc3NlcnQuaGFzQWxsRGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKSwgW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSk7XG4gICAqXG4gICAqIEBuYW1lIGhhc0FsbERlZXBLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaGFzQWxsRGVlcEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaGFzQWxsRGVlcEtleXMsIHRydWUpXG4gICAgICAudG8uaGF2ZS5hbGwuZGVlcC5rZXlzKGtleXMpO1xuICB9XG5cbiAvKipcbiAgICogIyMjIC5jb250YWluc0FsbERlZXBLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBjb250YWlucyBhbGwgb2YgdGhlIGBrZXlzYCBwcm92aWRlZC5cbiAgICogU2luY2UgU2V0cyBhbmQgTWFwcyBjYW4gaGF2ZSBvYmplY3RzIGFzIGtleXMgeW91IGNhbiB1c2UgdGhpcyBhc3NlcnRpb24gdG8gcGVyZm9ybVxuICAgKiBhIGRlZXAgY29tcGFyaXNvbi5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXSwgWzEsIDJdXSksIHtvbmU6ICdvbmUnfSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXSwgW3t0d286ICd0d28nfSwgJ3ZhbHVlVHdvJ11dKSwgW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCB7b25lOiAnb25lJ30pO1xuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsRGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKSwgW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSk7XG4gICAqXG4gICAqIEBuYW1lIGNvbnRhaW5zQWxsRGVlcEtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5jb250YWluc0FsbERlZXBLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmNvbnRhaW5zQWxsRGVlcEtleXMsIHRydWUpXG4gICAgICAudG8uY29udGFpbi5hbGwuZGVlcC5rZXlzKGtleXMpO1xuICB9XG5cbiAvKipcbiAgICogIyMjIC5kb2VzTm90SGF2ZUFueURlZXBLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgbm9uZSBvZiB0aGUgYGtleXNgIHByb3ZpZGVkLlxuICAgKiBTaW5jZSBTZXRzIGFuZCBNYXBzIGNhbiBoYXZlIG9iamVjdHMgYXMga2V5cyB5b3UgY2FuIHVzZSB0aGlzIGFzc2VydGlvbiB0byBwZXJmb3JtXG4gICAqIGEgZGVlcCBjb21wYXJpc29uLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFueURlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbMSwgMl1dKSwge3RoaXNEb2VzTm90OiAnZXhpc3QnfSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbnlEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXSwgW3t0d286ICd0d28nfSwgJ3ZhbHVlVHdvJ11dKSwgW3t0d2VudHk6ICd0d2VudHknfSwge2ZpZnR5OiAnZmlmdHknfV0pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55RGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKSwge3R3ZW50eTogJ3R3ZW50eSd9KTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFueURlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIFt7dHdlbnR5OiAndHdlbnR5J30sIHtmaWZ0eTogJ2ZpZnR5J31dKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdEhhdmVBbnlEZWVwS2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGtleXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55RGVlcEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuZG9lc05vdEhhdmVBbnlEZWVwS2V5cywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5hbnkuZGVlcC5rZXlzKGtleXMpO1xuICB9XG5cbiAvKipcbiAgICogIyMjIC5kb2VzTm90SGF2ZUFsbERlZXBLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIG5vdCBoYXZlIGF0IGxlYXN0IG9uZSBvZiB0aGUgYGtleXNgIHByb3ZpZGVkLlxuICAgKiBTaW5jZSBTZXRzIGFuZCBNYXBzIGNhbiBoYXZlIG9iamVjdHMgYXMga2V5cyB5b3UgY2FuIHVzZSB0aGlzIGFzc2VydGlvbiB0byBwZXJmb3JtXG4gICAqIGEgZGVlcCBjb21wYXJpc29uLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFsbERlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbMSwgMl1dKSwge3RoaXNEb2VzTm90OiAnZXhpc3QnfSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbGxEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXSwgW3t0d286ICd0d28nfSwgJ3ZhbHVlVHdvJ11dKSwgW3t0d2VudHk6ICd0d2VudHknfSwge29uZTogJ29uZSd9XSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbGxEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCB7dHdlbnR5OiAndHdlbnR5J30pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsRGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKSwgW3tvbmU6ICdvbmUnfSwge2ZpZnR5OiAnZmlmdHknfV0pO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90SGF2ZUFsbERlZXBLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdEhhdmVBbGxEZWVwS2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5kb2VzTm90SGF2ZUFsbERlZXBLZXlzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLmFsbC5kZWVwLmtleXMoa2V5cyk7XG4gIH1cblxuIC8qKlxuICAgKiAjIyMgLnRocm93cyhmbiwgW2Vycm9yTGlrZS9zdHJpbmcvcmVnZXhwXSwgW3N0cmluZy9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIElmIGBlcnJvckxpa2VgIGlzIGFuIGBFcnJvcmAgY29uc3RydWN0b3IsIGFzc2VydHMgdGhhdCBgZm5gIHdpbGwgdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhblxuICAgKiBpbnN0YW5jZSBvZiBgZXJyb3JMaWtlYC5cbiAgICogSWYgYGVycm9yTGlrZWAgaXMgYW4gYEVycm9yYCBpbnN0YW5jZSwgYXNzZXJ0cyB0aGF0IHRoZSBlcnJvciB0aHJvd24gaXMgdGhlIHNhbWVcbiAgICogaW5zdGFuY2UgYXMgYGVycm9yTGlrZWAuXG4gICAqIElmIGBlcnJNc2dNYXRjaGVyYCBpcyBwcm92aWRlZCwgaXQgYWxzbyBhc3NlcnRzIHRoYXQgdGhlIGVycm9yIHRocm93biB3aWxsIGhhdmUgYVxuICAgKiBtZXNzYWdlIG1hdGNoaW5nIGBlcnJNc2dNYXRjaGVyYC5cbiAgICpcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sICdmdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3InKTtcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sIC9mdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3IvKTtcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sIFJlZmVyZW5jZUVycm9yKTtcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sIGVycm9ySW5zdGFuY2UpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgUmVmZXJlbmNlRXJyb3IsICdFcnJvciB0aHJvd24gbXVzdCBiZSBhIFJlZmVyZW5jZUVycm9yIGFuZCBoYXZlIHRoaXMgbXNnJyk7XG4gICAqICAgICBhc3NlcnQudGhyb3dzKGZuLCBlcnJvckluc3RhbmNlLCAnRXJyb3IgdGhyb3duIG11c3QgYmUgdGhlIHNhbWUgZXJyb3JJbnN0YW5jZSBhbmQgaGF2ZSB0aGlzIG1zZycpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgUmVmZXJlbmNlRXJyb3IsIC9FcnJvciB0aHJvd24gbXVzdCBiZSBhIFJlZmVyZW5jZUVycm9yIGFuZCBtYXRjaCB0aGlzLyk7XG4gICAqICAgICBhc3NlcnQudGhyb3dzKGZuLCBlcnJvckluc3RhbmNlLCAvRXJyb3IgdGhyb3duIG11c3QgYmUgdGhlIHNhbWUgZXJyb3JJbnN0YW5jZSBhbmQgbWF0Y2ggdGhpcy8pO1xuICAgKlxuICAgKiBAbmFtZSB0aHJvd3NcbiAgICogQGFsaWFzIHRocm93XG4gICAqIEBhbGlhcyBUaHJvd1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge0Vycm9yQ29uc3RydWN0b3J8RXJyb3J9IGVycm9yTGlrZVxuICAgKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IGVyck1zZ01hdGNoZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQudGhyb3dzID0gZnVuY3Rpb24gKGZuLCBlcnJvckxpa2UsIGVyck1zZ01hdGNoZXIsIG1zZykge1xuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGVycm9yTGlrZSB8fCBlcnJvckxpa2UgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIGVyck1zZ01hdGNoZXIgPSBlcnJvckxpa2U7XG4gICAgICBlcnJvckxpa2UgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBhc3NlcnRFcnIgPSBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC50aHJvd3MsIHRydWUpXG4gICAgICAudG8udGhyb3coZXJyb3JMaWtlLCBlcnJNc2dNYXRjaGVyKTtcbiAgICByZXR1cm4gZmxhZyhhc3NlcnRFcnIsICdvYmplY3QnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90VGhyb3coZm4sIFtlcnJvckxpa2Uvc3RyaW5nL3JlZ2V4cF0sIFtzdHJpbmcvcmVnZXhwXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBJZiBgZXJyb3JMaWtlYCBpcyBhbiBgRXJyb3JgIGNvbnN0cnVjdG9yLCBhc3NlcnRzIHRoYXQgYGZuYCB3aWxsIF9ub3RfIHRocm93IGFuIGVycm9yIHRoYXQgaXMgYW5cbiAgICogaW5zdGFuY2Ugb2YgYGVycm9yTGlrZWAuXG4gICAqIElmIGBlcnJvckxpa2VgIGlzIGFuIGBFcnJvcmAgaW5zdGFuY2UsIGFzc2VydHMgdGhhdCB0aGUgZXJyb3IgdGhyb3duIGlzIF9ub3RfIHRoZSBzYW1lXG4gICAqIGluc3RhbmNlIGFzIGBlcnJvckxpa2VgLlxuICAgKiBJZiBgZXJyTXNnTWF0Y2hlcmAgaXMgcHJvdmlkZWQsIGl0IGFsc28gYXNzZXJ0cyB0aGF0IHRoZSBlcnJvciB0aHJvd24gd2lsbCBfbm90XyBoYXZlIGFcbiAgICogbWVzc2FnZSBtYXRjaGluZyBgZXJyTXNnTWF0Y2hlcmAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZG9lc05vdFRocm93KGZuLCAnQW55IEVycm9yIHRocm93biBtdXN0IG5vdCBoYXZlIHRoaXMgbWVzc2FnZScpO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgL0FueSBFcnJvciB0aHJvd24gbXVzdCBub3QgbWF0Y2ggdGhpcy8pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgRXJyb3IpO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgZXJyb3JJbnN0YW5jZSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdFRocm93KGZuLCBFcnJvciwgJ0Vycm9yIG11c3Qgbm90IGhhdmUgdGhpcyBtZXNzYWdlJyk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdFRocm93KGZuLCBlcnJvckluc3RhbmNlLCAnRXJyb3IgbXVzdCBub3QgaGF2ZSB0aGlzIG1lc3NhZ2UnKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIEVycm9yLCAvRXJyb3IgbXVzdCBub3QgbWF0Y2ggdGhpcy8pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgZXJyb3JJbnN0YW5jZSwgL0Vycm9yIG11c3Qgbm90IG1hdGNoIHRoaXMvKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdFRocm93XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gZXJyb3JMaWtlXG4gICAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gZXJyTXNnTWF0Y2hlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbiAoZm4sIGVycm9yTGlrZSwgZXJyTXNnTWF0Y2hlciwgbXNnKSB7XG4gICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgZXJyb3JMaWtlIHx8IGVycm9yTGlrZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgZXJyTXNnTWF0Y2hlciA9IGVycm9yTGlrZTtcbiAgICAgIGVycm9yTGlrZSA9IG51bGw7XG4gICAgfVxuXG4gICAgbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuZG9lc05vdFRocm93LCB0cnVlKVxuICAgICAgLnRvLm5vdC50aHJvdyhlcnJvckxpa2UsIGVyck1zZ01hdGNoZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm9wZXJhdG9yKHZhbDEsIG9wZXJhdG9yLCB2YWwyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIENvbXBhcmVzIHR3byB2YWx1ZXMgdXNpbmcgYG9wZXJhdG9yYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5vcGVyYXRvcigxLCAnPCcsIDIsICdldmVyeXRoaW5nIGlzIG9rJyk7XG4gICAqICAgICBhc3NlcnQub3BlcmF0b3IoMSwgJz4nLCAyLCAndGhpcyB3aWxsIGZhaWwnKTtcbiAgICpcbiAgICogQG5hbWUgb3BlcmF0b3JcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsMVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0b3JcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsMlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQub3BlcmF0b3IgPSBmdW5jdGlvbiAodmFsLCBvcGVyYXRvciwgdmFsMiwgbXNnKSB7XG4gICAgdmFyIG9rO1xuICAgIHN3aXRjaChvcGVyYXRvcikge1xuICAgICAgY2FzZSAnPT0nOlxuICAgICAgICBvayA9IHZhbCA9PSB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgIG9rID0gdmFsID09PSB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJz4nOlxuICAgICAgICBvayA9IHZhbCA+IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnPj0nOlxuICAgICAgICBvayA9IHZhbCA+PSB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzwnOlxuICAgICAgICBvayA9IHZhbCA8IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnPD0nOlxuICAgICAgICBvayA9IHZhbCA8PSB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgb2sgPSB2YWwgIT0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICchPT0nOlxuICAgICAgICBvayA9IHZhbCAhPT0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBtc2cgPSBtc2cgPyBtc2cgKyAnOiAnIDogbXNnO1xuICAgICAgICB0aHJvdyBuZXcgY2hhaS5Bc3NlcnRpb25FcnJvcihcbiAgICAgICAgICBtc2cgKyAnSW52YWxpZCBvcGVyYXRvciBcIicgKyBvcGVyYXRvciArICdcIicsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIGFzc2VydC5vcGVyYXRvclxuICAgICAgICApO1xuICAgIH1cbiAgICB2YXIgdGVzdCA9IG5ldyBBc3NlcnRpb24ob2ssIG1zZywgYXNzZXJ0Lm9wZXJhdG9yLCB0cnVlKTtcbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgdHJ1ZSA9PT0gZmxhZyh0ZXN0LCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICcgKyB1dGlsLmluc3BlY3QodmFsKSArICcgdG8gYmUgJyArIG9wZXJhdG9yICsgJyAnICsgdXRpbC5pbnNwZWN0KHZhbDIpXG4gICAgICAsICdleHBlY3RlZCAnICsgdXRpbC5pbnNwZWN0KHZhbCkgKyAnIHRvIG5vdCBiZSAnICsgb3BlcmF0b3IgKyAnICcgKyB1dGlsLmluc3BlY3QodmFsMikgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5jbG9zZVRvKGFjdHVhbCwgZXhwZWN0ZWQsIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIGBleHBlY3RlZGAsIHRvIHdpdGhpbiBhICsvLSBgZGVsdGFgIHJhbmdlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmNsb3NlVG8oMS41LCAxLCAwLjUsICdudW1iZXJzIGFyZSBjbG9zZScpO1xuICAgKlxuICAgKiBAbmFtZSBjbG9zZVRvXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhY3R1YWxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuY2xvc2VUbyA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgZGVsdGEsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5jbG9zZVRvLCB0cnVlKS50by5iZS5jbG9zZVRvKGV4cCwgZGVsdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmFwcHJveGltYXRlbHkoYWN0dWFsLCBleHBlY3RlZCwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgYGV4cGVjdGVkYCwgdG8gd2l0aGluIGEgKy8tIGBkZWx0YWAgcmFuZ2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQuYXBwcm94aW1hdGVseSgxLjUsIDEsIDAuNSwgJ251bWJlcnMgYXJlIGNsb3NlJyk7XG4gICAqXG4gICAqIEBuYW1lIGFwcHJveGltYXRlbHlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFjdHVhbFxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5hcHByb3hpbWF0ZWx5ID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBkZWx0YSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0LmFwcHJveGltYXRlbHksIHRydWUpXG4gICAgICAudG8uYmUuYXBwcm94aW1hdGVseShleHAsIGRlbHRhKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5zYW1lTWVtYmVycyhzZXQxLCBzZXQyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc2V0MWAgYW5kIGBzZXQyYCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgaW4gYW55IG9yZGVyLiBVc2VzIGFcbiAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnNhbWVNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDIsIDEsIDMgXSwgJ3NhbWUgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBzYW1lTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQxXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnNhbWVNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnLCBhc3NlcnQuc2FtZU1lbWJlcnMsIHRydWUpXG4gICAgICAudG8uaGF2ZS5zYW1lLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5ub3RTYW1lTWVtYmVycyhzZXQxLCBzZXQyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc2V0MWAgYW5kIGBzZXQyYCBkb24ndCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgaW4gYW55IG9yZGVyLlxuICAgKiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFNhbWVNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDUsIDEsIDMgXSwgJ25vdCBzYW1lIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90U2FtZU1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RTYW1lTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZywgYXNzZXJ0Lm5vdFNhbWVNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLnNhbWUubWVtYmVycyhzZXQyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLnNhbWVEZWVwTWVtYmVycyhzZXQxLCBzZXQyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc2V0MWAgYW5kIGBzZXQyYCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgaW4gYW55IG9yZGVyLiBVc2VzIGFcbiAgICogZGVlcCBlcXVhbGl0eSBjaGVjay5cbiAgICpcbiAgICogICAgIGFzc2VydC5zYW1lRGVlcE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFt7IGI6IDIgfSwgeyBhOiAxIH0sIHsgYzogMyB9XSwgJ3NhbWUgZGVlcCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIHNhbWVEZWVwTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQxXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnNhbWVEZWVwTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZywgYXNzZXJ0LnNhbWVEZWVwTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5oYXZlLnNhbWUuZGVlcC5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubm90U2FtZURlZXBNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGRvbid0IGhhdmUgdGhlIHNhbWUgbWVtYmVycyBpbiBhbnkgb3JkZXIuXG4gICAqIFVzZXMgYSBkZWVwIGVxdWFsaXR5IGNoZWNrLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFNhbWVEZWVwTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgW3sgYjogMiB9LCB7IGE6IDEgfSwgeyBmOiA1IH1dLCAnbm90IHNhbWUgZGVlcCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFNhbWVEZWVwTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQxXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFNhbWVEZWVwTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZywgYXNzZXJ0Lm5vdFNhbWVEZWVwTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5zYW1lLmRlZXAubWVtYmVycyhzZXQyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLnNhbWVPcmRlcmVkTWVtYmVycyhzZXQxLCBzZXQyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc2V0MWAgYW5kIGBzZXQyYCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAqIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgKD09PSkuXG4gICAqXG4gICAqICAgICBhc3NlcnQuc2FtZU9yZGVyZWRNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDEsIDIsIDMgXSwgJ3NhbWUgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIHNhbWVPcmRlcmVkTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQxXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnNhbWVPcmRlcmVkTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZywgYXNzZXJ0LnNhbWVPcmRlcmVkTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5oYXZlLnNhbWUub3JkZXJlZC5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubm90U2FtZU9yZGVyZWRNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGRvbid0IGhhdmUgdGhlIHNhbWUgbWVtYmVycyBpbiB0aGUgc2FtZVxuICAgKiBvcmRlci4gVXNlcyBhIHN0cmljdCBlcXVhbGl0eSBjaGVjayAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RTYW1lT3JkZXJlZE1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgMiwgMSwgMyBdLCAnbm90IHNhbWUgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFNhbWVPcmRlcmVkTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQxXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFNhbWVPcmRlcmVkTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZywgYXNzZXJ0Lm5vdFNhbWVPcmRlcmVkTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5zYW1lLm9yZGVyZWQubWVtYmVycyhzZXQyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLnNhbWVEZWVwT3JkZXJlZE1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgKiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay5cbiAgICpcbiAgICogYXNzZXJ0LnNhbWVEZWVwT3JkZXJlZE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCAnc2FtZSBkZWVwIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBzYW1lRGVlcE9yZGVyZWRNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuc2FtZURlZXBPcmRlcmVkTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZywgYXNzZXJ0LnNhbWVEZWVwT3JkZXJlZE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8uaGF2ZS5zYW1lLmRlZXAub3JkZXJlZC5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubm90U2FtZURlZXBPcmRlcmVkTWVtYmVycyhzZXQxLCBzZXQyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc2V0MWAgYW5kIGBzZXQyYCBkb24ndCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgaW4gdGhlIHNhbWVcbiAgICogb3JkZXIuIFVzZXMgYSBkZWVwIGVxdWFsaXR5IGNoZWNrLlxuICAgKlxuICAgKiBhc3NlcnQubm90U2FtZURlZXBPcmRlcmVkTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgejogNSB9IF0sICdub3Qgc2FtZSBkZWVwIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKiBhc3NlcnQubm90U2FtZURlZXBPcmRlcmVkTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGI6IDIgfSwgeyBhOiAxIH0sIHsgYzogMyB9IF0sICdub3Qgc2FtZSBkZWVwIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RTYW1lRGVlcE9yZGVyZWRNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90U2FtZURlZXBPcmRlcmVkTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZywgYXNzZXJ0Lm5vdFNhbWVEZWVwT3JkZXJlZE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuc2FtZS5kZWVwLm9yZGVyZWQubWVtYmVycyhzZXQyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGVNZW1iZXJzKHN1cGVyc2V0LCBzdWJzZXQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzdWJzZXRgIGlzIGluY2x1ZGVkIGluIGBzdXBlcnNldGAgaW4gYW55IG9yZGVyLiBVc2VzIGFcbiAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLiBEdXBsaWNhdGVzIGFyZSBpZ25vcmVkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGVNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDIsIDEsIDIgXSwgJ2luY2x1ZGUgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGVNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZywgYXNzZXJ0LmluY2x1ZGVNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLmluY2x1ZGUubWVtYmVycyhzdWJzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5jbHVkZU1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXNuJ3QgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YCBpbiBhbnkgb3JkZXIuIFVzZXMgYVxuICAgKiBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgKD09PSkuIER1cGxpY2F0ZXMgYXJlIGlnbm9yZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZU1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgNSwgMSBdLCAnbm90IGluY2x1ZGUgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbmNsdWRlTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluY2x1ZGVNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZywgYXNzZXJ0Lm5vdEluY2x1ZGVNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5pbmNsdWRlLm1lbWJlcnMoc3Vic2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGVEZWVwTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpcyBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgIGluIGFueSBvcmRlci4gVXNlcyBhIGRlZXBcbiAgICogZXF1YWxpdHkgY2hlY2suIER1cGxpY2F0ZXMgYXJlIGlnbm9yZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5jbHVkZURlZXBNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbIHsgYjogMiB9LCB7IGE6IDEgfSwgeyBiOiAyIH0gXSwgJ2luY2x1ZGUgZGVlcCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVEZWVwTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGVEZWVwTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2csIGFzc2VydC5pbmNsdWRlRGVlcE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8uaW5jbHVkZS5kZWVwLm1lbWJlcnMoc3Vic2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEluY2x1ZGVEZWVwTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpc24ndCBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgIGluIGFueSBvcmRlci4gVXNlcyBhXG4gICAqIGRlZXAgZXF1YWxpdHkgY2hlY2suIER1cGxpY2F0ZXMgYXJlIGlnbm9yZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZURlZXBNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbIHsgYjogMiB9LCB7IGY6IDUgfSBdLCAnbm90IGluY2x1ZGUgZGVlcCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEluY2x1ZGVEZWVwTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluY2x1ZGVEZWVwTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2csIGFzc2VydC5ub3RJbmNsdWRlRGVlcE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8ubm90LmluY2x1ZGUuZGVlcC5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlT3JkZXJlZE1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXMgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YCBpbiB0aGUgc2FtZSBvcmRlclxuICAgKiBiZWdpbm5pbmcgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBpbiBgc3VwZXJzZXRgLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNoZWNrICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGVPcmRlcmVkTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAxLCAyIF0sICdpbmNsdWRlIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlT3JkZXJlZE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNsdWRlT3JkZXJlZE1lbWJlcnMgPSBmdW5jdGlvbiAoc3VwZXJzZXQsIHN1YnNldCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzdXBlcnNldCwgbXNnLCBhc3NlcnQuaW5jbHVkZU9yZGVyZWRNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLmluY2x1ZGUub3JkZXJlZC5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5ub3RJbmNsdWRlT3JkZXJlZE1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXNuJ3QgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YCBpbiB0aGUgc2FtZSBvcmRlclxuICAgKiBiZWdpbm5pbmcgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBpbiBgc3VwZXJzZXRgLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNoZWNrICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGVPcmRlcmVkTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAyLCAxIF0sICdub3QgaW5jbHVkZSBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlT3JkZXJlZE1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgMiwgMyBdLCAnbm90IGluY2x1ZGUgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEluY2x1ZGVPcmRlcmVkTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluY2x1ZGVPcmRlcmVkTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2csIGFzc2VydC5ub3RJbmNsdWRlT3JkZXJlZE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8ubm90LmluY2x1ZGUub3JkZXJlZC5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzKHN1cGVyc2V0LCBzdWJzZXQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzdWJzZXRgIGlzIGluY2x1ZGVkIGluIGBzdXBlcnNldGAgaW4gdGhlIHNhbWUgb3JkZXJcbiAgICogYmVnaW5uaW5nIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgaW4gYHN1cGVyc2V0YC4gVXNlcyBhIGRlZXAgZXF1YWxpdHlcbiAgICogY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGE6IDEgfSwgeyBiOiAyIH0gXSwgJ2luY2x1ZGUgZGVlcCBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZURlZXBPcmRlcmVkTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMgPSBmdW5jdGlvbiAoc3VwZXJzZXQsIHN1YnNldCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzdXBlcnNldCwgbXNnLCBhc3NlcnQuaW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5pbmNsdWRlLmRlZXAub3JkZXJlZC5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5ub3RJbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzKHN1cGVyc2V0LCBzdWJzZXQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzdWJzZXRgIGlzbid0IGluY2x1ZGVkIGluIGBzdXBlcnNldGAgaW4gdGhlIHNhbWUgb3JkZXJcbiAgICogYmVnaW5uaW5nIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgaW4gYHN1cGVyc2V0YC4gVXNlcyBhIGRlZXAgZXF1YWxpdHlcbiAgICogY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGE6IDEgfSwgeyBmOiA1IH0gXSwgJ25vdCBpbmNsdWRlIGRlZXAgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGI6IDIgfSwgeyBhOiAxIH0gXSwgJ25vdCBpbmNsdWRlIGRlZXAgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgJ25vdCBpbmNsdWRlIGRlZXAgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RJbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZywgYXNzZXJ0Lm5vdEluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8ubm90LmluY2x1ZGUuZGVlcC5vcmRlcmVkLm1lbWJlcnMoc3Vic2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm9uZU9mKGluTGlzdCwgbGlzdCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgbm9uLW9iamVjdCwgbm9uLWFycmF5IHZhbHVlIGBpbkxpc3RgIGFwcGVhcnMgaW4gdGhlIGZsYXQgYXJyYXkgYGxpc3RgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm9uZU9mKDEsIFsgMiwgMSBdLCAnTm90IGZvdW5kIGluIGxpc3QnKTtcbiAgICpcbiAgICogQG5hbWUgb25lT2ZcbiAgICogQHBhcmFtIHsqfSBpbkxpc3RcbiAgICogQHBhcmFtIHtBcnJheTwqPn0gbGlzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQub25lT2YgPSBmdW5jdGlvbiAoaW5MaXN0LCBsaXN0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGluTGlzdCwgbXNnLCBhc3NlcnQub25lT2YsIHRydWUpLnRvLmJlLm9uZU9mKGxpc3QpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuY2hhbmdlcyhmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBjaGFuZ2VzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSAyMiB9O1xuICAgKiAgICAgYXNzZXJ0LmNoYW5nZXMoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuY2hhbmdlcyA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtc2cgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuY2hhbmdlcywgdHJ1ZSkudG8uY2hhbmdlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAgLyoqXG4gICAqICMjIyAuY2hhbmdlc0J5KGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBjaGFuZ2VzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGJ5IGFuIGFtb3VudCAoZGVsdGEpLlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgKz0gMiB9O1xuICAgKiAgICAgYXNzZXJ0LmNoYW5nZXNCeShmbiwgb2JqLCAndmFsJywgMik7XG4gICAqXG4gICAqIEBuYW1lIGNoYW5nZXNCeVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFuZ2UgYW1vdW50IChkZWx0YSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuY2hhbmdlc0J5ID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdG1wTXNnID0gZGVsdGE7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBtc2cgPSB0bXBNc2c7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5jaGFuZ2VzQnksIHRydWUpXG4gICAgICAudG8uY2hhbmdlKG9iaiwgcHJvcCkuYnkoZGVsdGEpO1xuICB9XG5cbiAgIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RDaGFuZ2UoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZG9lcyBub3QgY2hhbmdlIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKCdmb28nKTsgfTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90Q2hhbmdlKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdENoYW5nZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RDaGFuZ2UgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbXNnID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5kb2VzTm90Q2hhbmdlLCB0cnVlKVxuICAgICAgLnRvLm5vdC5jaGFuZ2Uob2JqLCBwcm9wKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmNoYW5nZXNCdXROb3RCeShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZG9lcyBub3QgY2hhbmdlIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IG9yIG9mIGEgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWUgYnkgYW4gYW1vdW50IChkZWx0YSlcbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsICs9IDEwIH07XG4gICAqICAgICBhc3NlcnQuY2hhbmdlc0J1dE5vdEJ5KGZuLCBvYmosICd2YWwnLCA1KTtcbiAgICpcbiAgICogQG5hbWUgY2hhbmdlc0J1dE5vdEJ5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZSBhbW91bnQgKGRlbHRhKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5jaGFuZ2VzQnV0Tm90QnkgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0ICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0bXBNc2cgPSBkZWx0YTtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIG1zZyA9IHRtcE1zZztcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmNoYW5nZXNCdXROb3RCeSwgdHJ1ZSlcbiAgICAgIC50by5jaGFuZ2Uob2JqLCBwcm9wKS5idXQubm90LmJ5KGRlbHRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmluY3JlYXNlcyhmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBpbmNyZWFzZXMgYSBudW1lcmljIG9iamVjdCBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gMTMgfTtcbiAgICogICAgIGFzc2VydC5pbmNyZWFzZXMoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNyZWFzZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNyZWFzZXMgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbXNnID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5pbmNyZWFzZXMsIHRydWUpXG4gICAgICAudG8uaW5jcmVhc2Uob2JqLCBwcm9wKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmluY3JlYXNlc0J5KGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBpbmNyZWFzZXMgYSBudW1lcmljIG9iamVjdCBwcm9wZXJ0eSBvciBhIGZ1bmN0aW9uJ3MgcmV0dXJuIHZhbHVlIGJ5IGFuIGFtb3VudCAoZGVsdGEpLlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgKz0gMTAgfTtcbiAgICogICAgIGFzc2VydC5pbmNyZWFzZXNCeShmbiwgb2JqLCAndmFsJywgMTApO1xuICAgKlxuICAgKiBAbmFtZSBpbmNyZWFzZXNCeVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFuZ2UgYW1vdW50IChkZWx0YSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jcmVhc2VzQnkgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0ICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0bXBNc2cgPSBkZWx0YTtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIG1zZyA9IHRtcE1zZztcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmluY3JlYXNlc0J5LCB0cnVlKVxuICAgICAgLnRvLmluY3JlYXNlKG9iaiwgcHJvcCkuYnkoZGVsdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuZG9lc05vdEluY3JlYXNlKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRvZXMgbm90IGluY3JlYXNlIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkuXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDggfTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SW5jcmVhc2UoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90SW5jcmVhc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90SW5jcmVhc2UgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbXNnID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5kb2VzTm90SW5jcmVhc2UsIHRydWUpXG4gICAgICAudG8ubm90LmluY3JlYXNlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNyZWFzZXNCdXROb3RCeShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkb2VzIG5vdCBpbmNyZWFzZSBhIG51bWVyaWMgb2JqZWN0IHByb3BlcnR5IG9yIGZ1bmN0aW9uJ3MgcmV0dXJuIHZhbHVlIGJ5IGFuIGFtb3VudCAoZGVsdGEpLlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSAxNSB9O1xuICAgKiAgICAgYXNzZXJ0LmluY3JlYXNlc0J1dE5vdEJ5KGZuLCBvYmosICd2YWwnLCAxMCk7XG4gICAqXG4gICAqIEBuYW1lIGluY3JlYXNlc0J1dE5vdEJ5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZSBhbW91bnQgKGRlbHRhKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNyZWFzZXNCdXROb3RCeSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRtcE1zZyA9IGRlbHRhO1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgbXNnID0gdG1wTXNnO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuaW5jcmVhc2VzQnV0Tm90QnksIHRydWUpXG4gICAgICAudG8uaW5jcmVhc2Uob2JqLCBwcm9wKS5idXQubm90LmJ5KGRlbHRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmRlY3JlYXNlcyhmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkZWNyZWFzZXMgYSBudW1lcmljIG9iamVjdCBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gNSB9O1xuICAgKiAgICAgYXNzZXJ0LmRlY3JlYXNlcyhmbiwgb2JqLCAndmFsJyk7XG4gICAqXG4gICAqIEBuYW1lIGRlY3JlYXNlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlY3JlYXNlcyA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtc2cgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmRlY3JlYXNlcywgdHJ1ZSlcbiAgICAgIC50by5kZWNyZWFzZShvYmosIHByb3ApO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuZGVjcmVhc2VzQnkoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRlY3JlYXNlcyBhIG51bWVyaWMgb2JqZWN0IHByb3BlcnR5IG9yIGEgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWUgYnkgYW4gYW1vdW50IChkZWx0YSlcbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsIC09IDUgfTtcbiAgICogICAgIGFzc2VydC5kZWNyZWFzZXNCeShmbiwgb2JqLCAndmFsJywgNSk7XG4gICAqXG4gICAqIEBuYW1lIGRlY3JlYXNlc0J5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZSBhbW91bnQgKGRlbHRhKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWNyZWFzZXNCeSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRtcE1zZyA9IGRlbHRhO1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgbXNnID0gdG1wTXNnO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuZGVjcmVhc2VzQnksIHRydWUpXG4gICAgICAudG8uZGVjcmVhc2Uob2JqLCBwcm9wKS5ieShkZWx0YSk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90RGVjcmVhc2UoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZG9lcyBub3QgZGVjcmVhc2VzIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkuXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDE1IH07XG4gICAqICAgICBhc3NlcnQuZG9lc05vdERlY3JlYXNlKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdERlY3JlYXNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdERlY3JlYXNlID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1zZyA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuZG9lc05vdERlY3JlYXNlLCB0cnVlKVxuICAgICAgLnRvLm5vdC5kZWNyZWFzZShvYmosIHByb3ApO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuZG9lc05vdERlY3JlYXNlQnkoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRvZXMgbm90IGRlY3JlYXNlcyBhIG51bWVyaWMgb2JqZWN0IHByb3BlcnR5IG9yIGEgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWUgYnkgYW4gYW1vdW50IChkZWx0YSlcbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gNSB9O1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3REZWNyZWFzZUJ5KGZuLCBvYmosICd2YWwnLCAxKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdERlY3JlYXNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZSBhbW91bnQgKGRlbHRhKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90RGVjcmVhc2VCeSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRtcE1zZyA9IGRlbHRhO1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgbXNnID0gdG1wTXNnO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmRvZXNOb3REZWNyZWFzZUJ5LCB0cnVlKVxuICAgICAgLnRvLm5vdC5kZWNyZWFzZShvYmosIHByb3ApLmJ5KGRlbHRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmRlY3JlYXNlc0J1dE5vdEJ5KGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkb2VzIG5vdCBkZWNyZWFzZXMgYSBudW1lcmljIG9iamVjdCBwcm9wZXJ0eSBvciBhIGZ1bmN0aW9uJ3MgcmV0dXJuIHZhbHVlIGJ5IGFuIGFtb3VudCAoZGVsdGEpXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDUgfTtcbiAgICogICAgIGFzc2VydC5kZWNyZWFzZXNCdXROb3RCeShmbiwgb2JqLCAndmFsJywgMSk7XG4gICAqXG4gICAqIEBuYW1lIGRlY3JlYXNlc0J1dE5vdEJ5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZSBhbW91bnQgKGRlbHRhKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWNyZWFzZXNCdXROb3RCeSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRtcE1zZyA9IGRlbHRhO1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgbXNnID0gdG1wTXNnO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuZGVjcmVhc2VzQnV0Tm90QnksIHRydWUpXG4gICAgICAudG8uZGVjcmVhc2Uob2JqLCBwcm9wKS5idXQubm90LmJ5KGRlbHRhKTtcbiAgfVxuXG4gIC8qIVxuICAgKiAjIyMgLmlmRXJyb3Iob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIGlmIHZhbHVlIGlzIG5vdCBhIGZhbHNlIHZhbHVlLCBhbmQgdGhyb3dzIGlmIGl0IGlzIGEgdHJ1ZSB2YWx1ZS5cbiAgICogVGhpcyBpcyBhZGRlZCB0byBhbGxvdyBmb3IgY2hhaSB0byBiZSBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIE5vZGUnc1xuICAgKiBhc3NlcnQgY2xhc3MuXG4gICAqXG4gICAqICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdJIGFtIGEgY3VzdG9tIGVycm9yJyk7XG4gICAqICAgICBhc3NlcnQuaWZFcnJvcihlcnIpOyAvLyBSZXRocm93cyBlcnIhXG4gICAqXG4gICAqIEBuYW1lIGlmRXJyb3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAodmFsKSB7XG4gICAgICB0aHJvdyh2YWwpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0V4dGVuc2libGUob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgZXh0ZW5zaWJsZSAoY2FuIGhhdmUgbmV3IHByb3BlcnRpZXMgYWRkZWQgdG8gaXQpLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzRXh0ZW5zaWJsZSh7fSk7XG4gICAqXG4gICAqIEBuYW1lIGlzRXh0ZW5zaWJsZVxuICAgKiBAYWxpYXMgZXh0ZW5zaWJsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRXh0ZW5zaWJsZSA9IGZ1bmN0aW9uIChvYmosIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5pc0V4dGVuc2libGUsIHRydWUpLnRvLmJlLmV4dGVuc2libGU7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RFeHRlbnNpYmxlKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIF9ub3RfIGV4dGVuc2libGUuXG4gICAqXG4gICAqICAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAqICAgICB2YXIgc2VhbGVkT2JqZWN0ID0gT2JqZWN0LnNlYWwoe30pO1xuICAgKiAgICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90RXh0ZW5zaWJsZShub25FeHRlbnNpYmxlT2JqZWN0KTtcbiAgICogICAgIGFzc2VydC5pc05vdEV4dGVuc2libGUoc2VhbGVkT2JqZWN0KTtcbiAgICogICAgIGFzc2VydC5pc05vdEV4dGVuc2libGUoZnJvemVuT2JqZWN0KTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RFeHRlbnNpYmxlXG4gICAqIEBhbGlhcyBub3RFeHRlbnNpYmxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RFeHRlbnNpYmxlID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmlzTm90RXh0ZW5zaWJsZSwgdHJ1ZSkudG8ubm90LmJlLmV4dGVuc2libGU7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNTZWFsZWQob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgc2VhbGVkIChjYW5ub3QgaGF2ZSBuZXcgcHJvcGVydGllcyBhZGRlZCB0byBpdFxuICAgKiBhbmQgaXRzIGV4aXN0aW5nIHByb3BlcnRpZXMgY2Fubm90IGJlIHJlbW92ZWQpLlxuICAgKlxuICAgKiAgICAgdmFyIHNlYWxlZE9iamVjdCA9IE9iamVjdC5zZWFsKHt9KTtcbiAgICogICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3Quc2VhbCh7fSk7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNTZWFsZWQoc2VhbGVkT2JqZWN0KTtcbiAgICogICAgIGFzc2VydC5pc1NlYWxlZChmcm96ZW5PYmplY3QpO1xuICAgKlxuICAgKiBAbmFtZSBpc1NlYWxlZFxuICAgKiBAYWxpYXMgc2VhbGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNTZWFsZWQgPSBmdW5jdGlvbiAob2JqLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaXNTZWFsZWQsIHRydWUpLnRvLmJlLnNlYWxlZDtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdFNlYWxlZChvYmplY3QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBfbm90XyBzZWFsZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOb3RTZWFsZWQoe30pO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdFNlYWxlZFxuICAgKiBAYWxpYXMgbm90U2VhbGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RTZWFsZWQgPSBmdW5jdGlvbiAob2JqLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaXNOb3RTZWFsZWQsIHRydWUpLnRvLm5vdC5iZS5zZWFsZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNGcm96ZW4ob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgZnJvemVuIChjYW5ub3QgaGF2ZSBuZXcgcHJvcGVydGllcyBhZGRlZCB0byBpdFxuICAgKiBhbmQgaXRzIGV4aXN0aW5nIHByb3BlcnRpZXMgY2Fubm90IGJlIG1vZGlmaWVkKS5cbiAgICpcbiAgICogICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICogICAgIGFzc2VydC5mcm96ZW4oZnJvemVuT2JqZWN0KTtcbiAgICpcbiAgICogQG5hbWUgaXNGcm96ZW5cbiAgICogQGFsaWFzIGZyb3plblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRnJvemVuID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmlzRnJvemVuLCB0cnVlKS50by5iZS5mcm96ZW47XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RGcm96ZW4ob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgX25vdF8gZnJvemVuLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90RnJvemVuKHt9KTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RGcm96ZW5cbiAgICogQGFsaWFzIG5vdEZyb3plblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90RnJvemVuID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmlzTm90RnJvemVuLCB0cnVlKS50by5ub3QuYmUuZnJvemVuO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRW1wdHkodGFyZ2V0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBkb2VzIG5vdCBjb250YWluIGFueSB2YWx1ZXMuXG4gICAqIEZvciBhcnJheXMgYW5kIHN0cmluZ3MsIGl0IGNoZWNrcyB0aGUgYGxlbmd0aGAgcHJvcGVydHkuXG4gICAqIEZvciBgTWFwYCBhbmQgYFNldGAgaW5zdGFuY2VzLCBpdCBjaGVja3MgdGhlIGBzaXplYCBwcm9wZXJ0eS5cbiAgICogRm9yIG5vbi1mdW5jdGlvbiBvYmplY3RzLCBpdCBnZXRzIHRoZSBjb3VudCBvZiBvd25cbiAgICogZW51bWVyYWJsZSBzdHJpbmcga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc0VtcHR5KFtdKTtcbiAgICogICAgIGFzc2VydC5pc0VtcHR5KCcnKTtcbiAgICogICAgIGFzc2VydC5pc0VtcHR5KG5ldyBNYXApO1xuICAgKiAgICAgYXNzZXJ0LmlzRW1wdHkoe30pO1xuICAgKlxuICAgKiBAbmFtZSBpc0VtcHR5XG4gICAqIEBhbGlhcyBlbXB0eVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheXxTdHJpbmd8TWFwfFNldH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRW1wdHkgPSBmdW5jdGlvbih2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0VtcHR5LCB0cnVlKS50by5iZS5lbXB0eTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEVtcHR5KHRhcmdldClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgY29udGFpbnMgdmFsdWVzLlxuICAgKiBGb3IgYXJyYXlzIGFuZCBzdHJpbmdzLCBpdCBjaGVja3MgdGhlIGBsZW5ndGhgIHByb3BlcnR5LlxuICAgKiBGb3IgYE1hcGAgYW5kIGBTZXRgIGluc3RhbmNlcywgaXQgY2hlY2tzIHRoZSBgc2l6ZWAgcHJvcGVydHkuXG4gICAqIEZvciBub24tZnVuY3Rpb24gb2JqZWN0cywgaXQgZ2V0cyB0aGUgY291bnQgb2Ygb3duXG4gICAqIGVudW1lcmFibGUgc3RyaW5nIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOb3RFbXB0eShbMSwgMl0pO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90RW1wdHkoJzM0Jyk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RFbXB0eShuZXcgU2V0KFs1LCA2XSkpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90RW1wdHkoeyBrZXk6IDcgfSk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90RW1wdHlcbiAgICogQGFsaWFzIG5vdEVtcHR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fFN0cmluZ3xNYXB8U2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RFbXB0eSA9IGZ1bmN0aW9uKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90RW1wdHksIHRydWUpLnRvLm5vdC5iZS5lbXB0eTtcbiAgfTtcblxuICAvKiFcbiAgICogQWxpYXNlcy5cbiAgICovXG5cbiAgKGZ1bmN0aW9uIGFsaWFzKG5hbWUsIGFzKXtcbiAgICBhc3NlcnRbYXNdID0gYXNzZXJ0W25hbWVdO1xuICAgIHJldHVybiBhbGlhcztcbiAgfSlcbiAgKCdpc09rJywgJ29rJylcbiAgKCdpc05vdE9rJywgJ25vdE9rJylcbiAgKCd0aHJvd3MnLCAndGhyb3cnKVxuICAoJ3Rocm93cycsICdUaHJvdycpXG4gICgnaXNFeHRlbnNpYmxlJywgJ2V4dGVuc2libGUnKVxuICAoJ2lzTm90RXh0ZW5zaWJsZScsICdub3RFeHRlbnNpYmxlJylcbiAgKCdpc1NlYWxlZCcsICdzZWFsZWQnKVxuICAoJ2lzTm90U2VhbGVkJywgJ25vdFNlYWxlZCcpXG4gICgnaXNGcm96ZW4nLCAnZnJvemVuJylcbiAgKCdpc05vdEZyb3plbicsICdub3RGcm96ZW4nKVxuICAoJ2lzRW1wdHknLCAnZW1wdHknKVxuICAoJ2lzTm90RW1wdHknLCAnbm90RW1wdHknKTtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgdXNlZCA9IFtdO1xuXG4vKiFcbiAqIENoYWkgdmVyc2lvblxuICovXG5cbmV4cG9ydHMudmVyc2lvbiA9ICc0LjEuMic7XG5cbi8qIVxuICogQXNzZXJ0aW9uIEVycm9yXG4gKi9cblxuZXhwb3J0cy5Bc3NlcnRpb25FcnJvciA9IHJlcXVpcmUoJ2Fzc2VydGlvbi1lcnJvcicpO1xuXG4vKiFcbiAqIFV0aWxzIGZvciBwbHVnaW5zIChub3QgZXhwb3J0ZWQpXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL2NoYWkvdXRpbHMnKTtcblxuLyoqXG4gKiAjIC51c2UoZnVuY3Rpb24pXG4gKlxuICogUHJvdmlkZXMgYSB3YXkgdG8gZXh0ZW5kIHRoZSBpbnRlcm5hbHMgb2YgQ2hhaS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQHJldHVybnMge3RoaXN9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnVzZSA9IGZ1bmN0aW9uIChmbikge1xuICBpZiAoIX51c2VkLmluZGV4T2YoZm4pKSB7XG4gICAgZm4oZXhwb3J0cywgdXRpbCk7XG4gICAgdXNlZC5wdXNoKGZuKTtcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzO1xufTtcblxuLyohXG4gKiBVdGlsaXR5IEZ1bmN0aW9uc1xuICovXG5cbmV4cG9ydHMudXRpbCA9IHV0aWw7XG5cbi8qIVxuICogQ29uZmlndXJhdGlvblxuICovXG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NoYWkvY29uZmlnJyk7XG5leHBvcnRzLmNvbmZpZyA9IGNvbmZpZztcblxuLyohXG4gKiBQcmltYXJ5IGBBc3NlcnRpb25gIHByb3RvdHlwZVxuICovXG5cbnZhciBhc3NlcnRpb24gPSByZXF1aXJlKCcuL2NoYWkvYXNzZXJ0aW9uJyk7XG5leHBvcnRzLnVzZShhc3NlcnRpb24pO1xuXG4vKiFcbiAqIENvcmUgQXNzZXJ0aW9uc1xuICovXG5cbnZhciBjb3JlID0gcmVxdWlyZSgnLi9jaGFpL2NvcmUvYXNzZXJ0aW9ucycpO1xuZXhwb3J0cy51c2UoY29yZSk7XG5cbi8qIVxuICogRXhwZWN0IGludGVyZmFjZVxuICovXG5cbnZhciBleHBlY3QgPSByZXF1aXJlKCcuL2NoYWkvaW50ZXJmYWNlL2V4cGVjdCcpO1xuZXhwb3J0cy51c2UoZXhwZWN0KTtcblxuLyohXG4gKiBTaG91bGQgaW50ZXJmYWNlXG4gKi9cblxudmFyIHNob3VsZCA9IHJlcXVpcmUoJy4vY2hhaS9pbnRlcmZhY2Uvc2hvdWxkJyk7XG5leHBvcnRzLnVzZShzaG91bGQpO1xuXG4vKiFcbiAqIEFzc2VydCBpbnRlcmZhY2VcbiAqL1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9jaGFpL2ludGVyZmFjZS9hc3NlcnQnKTtcbmV4cG9ydHMudXNlKGFzc2VydCk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2NoYWknKTtcbiIsIihmdW5jdGlvbihjaGFpRG9tKSB7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNoYWlEb21cbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY2hhaURvbVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgY2hhaS51c2UoY2hhaURvbSlcbiAgfVxufShmdW5jdGlvbihjaGFpLCB1dGlscykge1xuICB2YXIgZmxhZyA9IHV0aWxzLmZsYWcsXG5cbiAgZWxUb1N0cmluZyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgdmFyIGRlc2NcbiAgICBpZiAoZWwgaW5zdGFuY2VvZiB3aW5kb3cuTm9kZUxpc3QpIHtcbiAgICAgIGlmIChlbC5sZW5ndGggPT09IDApIHJldHVybiAnZW1wdHkgTm9kZUxpc3QnXG4gICAgICBkZXNjID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWwsIDAsIDUpLm1hcChlbFRvU3RyaW5nKS5qb2luKCcsICcpXG4gICAgICByZXR1cm4gZWwubGVuZ3RoID4gNSA/IGRlc2MgKyAnLi4uICgrJyArIChlbC5sZW5ndGggLSA1KSArICcgbW9yZSknIDogZGVzY1xuICAgIH1cbiAgICBpZiAoIShlbCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoZWwpXG4gICAgfVxuXG4gICAgZGVzYyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbC5pZCkge1xuICAgICAgZGVzYyArPSAnIycgKyBlbC5pZFxuICAgIH1cbiAgICBpZiAoZWwuY2xhc3NOYW1lKSB7XG4gICAgICBkZXNjICs9ICcuJyArIFN0cmluZyhlbC5jbGFzc05hbWUpLnJlcGxhY2UoL1xccysvZywgJy4nKVxuICAgIH1cbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGVsLmF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIGlmIChhdHRyLm5hbWUgIT09ICdjbGFzcycgJiYgYXR0ci5uYW1lICE9PSAnaWQnKSB7XG4gICAgICAgIGRlc2MgKz0gJ1snICsgYXR0ci5uYW1lICsgKGF0dHIudmFsdWUgPyAnPVwiJyArIGF0dHIudmFsdWUgKyAnXCJdJyA6ICddJylcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBkZXNjXG4gIH0sXG5cbiAgYXR0ckFzc2VydCA9IGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAgIHZhciBlbCA9IGZsYWcodGhpcywgJ29iamVjdCcpLCBhY3R1YWwgPSBlbC5nZXRBdHRyaWJ1dGUobmFtZSlcblxuICAgIGlmICghZmxhZyh0aGlzLCAnbmVnYXRlJykgfHwgdW5kZWZpbmVkID09PSB2YWwpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAhIWVsLmF0dHJpYnV0ZXNbbmFtZV1cbiAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyB0byBoYXZlIGFuIGF0dHJpYnV0ZSAje2V4cH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgbm90IHRvIGhhdmUgYW4gYXR0cmlidXRlICN7ZXhwfSdcbiAgICAgICAgLCBuYW1lXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHVuZGVmaW5lZCAhPT0gdmFsKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgdmFsID09PSBhY3R1YWxcbiAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyB0byBoYXZlIGFuIGF0dHJpYnV0ZSAnICsgdXRpbHMuaW5zcGVjdChuYW1lKSArICcgd2l0aCB0aGUgdmFsdWUgI3tleHB9LCBidXQgdGhlIHZhbHVlIHdhcyAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgbm90IHRvIGhhdmUgYW4gYXR0cmlidXRlICcgKyB1dGlscy5pbnNwZWN0KG5hbWUpICsgJyB3aXRoIHRoZSB2YWx1ZSAje2FjdH0nXG4gICAgICAgICwgdmFsXG4gICAgICAgICwgYWN0dWFsXG4gICAgICApXG4gICAgfVxuXG4gICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgYWN0dWFsKVxuICB9XG5cbiAgdXRpbHMuZWxUb1N0cmluZyA9IGVsVG9TdHJpbmdcbiAgY2hhaS5Bc3NlcnRpb24uYWRkTWV0aG9kKCdhdHRyJywgYXR0ckFzc2VydClcbiAgY2hhaS5Bc3NlcnRpb24uYWRkTWV0aG9kKCdhdHRyaWJ1dGUnLCBhdHRyQXNzZXJ0KVxuXG4gIGNoYWkuQXNzZXJ0aW9uLmFkZE1ldGhvZCgnY2xhc3MnLCBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICB2YXIgZWwgPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgdG8gaGF2ZSBjbGFzcyAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIG5vdCB0byBoYXZlIGNsYXNzICN7ZXhwfSdcbiAgICAgICwgY2xhc3NOYW1lXG4gICAgKVxuICB9KVxuXG4gIGNoYWkuQXNzZXJ0aW9uLmFkZE1ldGhvZCgnaWQnLCBmdW5jdGlvbihpZCkge1xuICAgIHZhciBlbCA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBlbC5pZCA9PSBpZFxuICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyB0byBoYXZlIGlkICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgbm90IHRvIGhhdmUgaWQgI3tleHB9J1xuICAgICAgLCBpZFxuICAgIClcbiAgfSlcblxuICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ2h0bWwnLCBmdW5jdGlvbihodG1sKSB7XG4gICAgdmFyIGVsID0gZmxhZyh0aGlzLCAnb2JqZWN0JyksIGFjdHVhbCA9IGZsYWcodGhpcywgJ29iamVjdCcpLmlubmVySFRNTFxuXG4gICAgaWYgKGZsYWcodGhpcywgJ2NvbnRhaW5zJykpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBhY3R1YWwuaW5kZXhPZihodG1sKSA+PSAwXG4gICAgICAgICwgJ2V4cGVjdGVkICN7YWN0fSB0byBjb250YWluIEhUTUwgI3tleHB9J1xuICAgICAgICAsICdleHBlY3RlZCAje2FjdH0gbm90IHRvIGNvbnRhaW4gSFRNTCAje2V4cH0nXG4gICAgICAgICwgaHRtbFxuICAgICAgICAsIGFjdHVhbFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgYWN0dWFsID09PSBodG1sXG4gICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgdG8gaGF2ZSBIVE1MICN7ZXhwfSwgYnV0IHRoZSBIVE1MIHdhcyAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgbm90IHRvIGhhdmUgSFRNTCAje2V4cH0nXG4gICAgICAgICwgaHRtbFxuICAgICAgICAsIGFjdHVhbFxuICAgICAgKVxuICAgIH1cbiAgfSlcblxuICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ3RleHQnLCBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpLCBjb250YWlucyA9IGZsYWcodGhpcywgJ2NvbnRhaW5zJyksIGFjdHVhbCwgcmVzdWx0XG5cbiAgICBpZiAob2JqIGluc3RhbmNlb2Ygd2luZG93Lk5vZGVMaXN0KSB7XG4gICAgICBhY3R1YWwgPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwob2JqLCBmdW5jdGlvbihlbCkgeyByZXR1cm4gZWwudGV4dENvbnRlbnQgfSlcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRleHQpKSB7XG4gICAgICAgIHJlc3VsdCA9IGNvbnRhaW5zID9cbiAgICAgICAgICB0ZXh0W2ZsYWcodGhpcywgJ25lZ2F0ZScpID8gJ3NvbWUnIDogJ2V2ZXJ5J10oZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zb21lLmNhbGwob2JqLCBmdW5jdGlvbihlbCkgeyByZXR1cm4gZWwudGV4dENvbnRlbnQgPT09IHQgfSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIDpcbiAgICAgICAgICB1dGlscy5lcWwoYWN0dWFsLCB0ZXh0KVxuXG4gICAgICAgIGFjdHVhbCA9IGFjdHVhbC5qb2luKClcbiAgICAgICAgdGV4dCA9IHRleHQuam9pbigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3R1YWwgPSBhY3R1YWwuam9pbignJylcbiAgICAgICAgcmVzdWx0ID0gY29udGFpbnMgPyBhY3R1YWwuaW5kZXhPZih0ZXh0KSA+PSAwIDogYWN0dWFsID09PSB0ZXh0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdHVhbCA9IGZsYWcodGhpcywgJ29iamVjdCcpLnRleHRDb250ZW50XG4gICAgICByZXN1bHQgPSBjb250YWlucyA/IGFjdHVhbC5pbmRleE9mKHRleHQpID49IDAgOiBhY3R1YWwgPT09IHRleHRcbiAgICB9XG5cbiAgICB2YXIgb2JqRGVzYyA9IGVsVG9TdHJpbmcob2JqKVxuICAgIGlmIChjb250YWlucykge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHJlc3VsdFxuICAgICAgICAsICdleHBlY3RlZCAnICsgb2JqRGVzYyArICcgdG8gY29udGFpbiAje2V4cH0sIGJ1dCB0aGUgdGV4dCB3YXMgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAnICsgb2JqRGVzYyArICcgbm90IHRvIGNvbnRhaW4gI3tleHB9LCBidXQgdGhlIHRleHQgd2FzICN7YWN0fSdcbiAgICAgICAgLCB0ZXh0XG4gICAgICAgICwgYWN0dWFsXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICByZXN1bHRcbiAgICAgICAgLCAnZXhwZWN0ZWQgJyArIG9iakRlc2MgKyAnIHRvIGhhdmUgdGV4dCAje2V4cH0sIGJ1dCB0aGUgdGV4dCB3YXMgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAnICsgb2JqRGVzYyArICcgbm90IHRvIGhhdmUgdGV4dCAje2V4cH0nXG4gICAgICAgICwgdGV4dFxuICAgICAgICAsIGFjdHVhbFxuICAgICAgKVxuICAgIH1cbiAgfSlcblxuICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ3ZhbHVlJywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgZWwgPSBmbGFnKHRoaXMsICdvYmplY3QnKSwgYWN0dWFsID0gZmxhZyh0aGlzLCAnb2JqZWN0JykudmFsdWVcbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGZsYWcodGhpcywgJ29iamVjdCcpLnZhbHVlID09PSB2YWx1ZVxuICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyB0byBoYXZlIHZhbHVlICN7ZXhwfSwgYnV0IHRoZSB2YWx1ZSB3YXMgI3thY3R9J1xuICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyBub3QgdG8gaGF2ZSB2YWx1ZSAje2V4cH0nXG4gICAgICAsIHZhbHVlXG4gICAgICAsIGFjdHVhbFxuICAgIClcbiAgfSlcblxuICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVQcm9wZXJ0eSgnZXhpc3QnLCBmdW5jdGlvbihfc3VwZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiB3aW5kb3cuTm9kZUxpc3QpIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqLmxlbmd0aCA+IDBcbiAgICAgICAgICAsICdleHBlY3RlZCBhbiBlbXB0eSBOb2RlTGlzdCB0byBoYXZlIG5vZGVzJ1xuICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIG5vdCBleGlzdCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVQcm9wZXJ0eSgnZW1wdHknLCBmdW5jdGlvbihfc3VwZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiB3aW5kb3cuSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqLmNoaWxkcmVuLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIGJlIGVtcHR5J1xuICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIG5vdCBiZSBlbXB0eScpXG4gICAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIHdpbmRvdy5Ob2RlTGlzdCkge1xuICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmoubGVuZ3RoID09PSAwXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gYmUgZW1wdHknXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCgnbGVuZ3RoJyxcbiAgICBmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICAgICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiB3aW5kb3cuTm9kZUxpc3QgfHwgb2JqIGluc3RhbmNlb2Ygd2luZG93LkhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgdmFyIGFjdHVhbExlbmd0aCA9IG9iai5jaGlsZHJlbiA/IG9iai5jaGlsZHJlbi5sZW5ndGggOiBvYmoubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgICBhY3R1YWxMZW5ndGggPT09IGxlbmd0aFxuICAgICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gaGF2ZSAje2V4cH0gY2hpbGRyZW4gYnV0IGl0IGhhZCAje2FjdH0gY2hpbGRyZW4nXG4gICAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBub3QgaGF2ZSAje2V4cH0gY2hpbGRyZW4nXG4gICAgICAgICAgICAsIGxlbmd0aFxuICAgICAgICAgICAgLCBhY3R1YWxMZW5ndGhcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpXG4gICAgICB9XG4gICAgfVxuICApXG5cblxuICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QoJ21hdGNoJywgZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiB3aW5kb3cuSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqLm1hdGNoZXMoc2VsZWN0b3IpXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gbWF0Y2ggI3tleHB9J1xuICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIG5vdCBtYXRjaCAje2V4cH0nXG4gICAgICAgICAgLCBzZWxlY3RvclxuICAgICAgICApXG4gICAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIHdpbmRvdy5Ob2RlTGlzdCkge1xuICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAoISFvYmoubGVuZ3RoICYmIEFycmF5LnByb3RvdHlwZS5ldmVyeS5jYWxsKG9iaiwgZnVuY3Rpb24oZWwpIHsgcmV0dXJuIGVsLm1hdGNoZXMoc2VsZWN0b3IpIH0pKVxuICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIG1hdGNoICN7ZXhwfSdcbiAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBub3QgbWF0Y2ggI3tleHB9J1xuICAgICAgICAgICwgc2VsZWN0b3JcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKCdjb250YWluJyxcbiAgICBmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdWJpdGVtKSB7XG4gICAgICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2Ygd2luZG93LkhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzdWJpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICAgICEhb2JqLnF1ZXJ5U2VsZWN0b3Ioc3ViaXRlbSlcbiAgICAgICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gY29udGFpbiAje2V4cH0nXG4gICAgICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIG5vdCBjb250YWluICN7ZXhwfSdcbiAgICAgICAgICAgICAgLCBzdWJpdGVtKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgICAgb2JqLmNvbnRhaW5zKHN1Yml0ZW0pXG4gICAgICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIGNvbnRhaW4gJyArIGVsVG9TdHJpbmcoc3ViaXRlbSlcbiAgICAgICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gbm90IGNvbnRhaW4gJyArIGVsVG9TdHJpbmcoc3ViaXRlbSkpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKVxuICAgICAgfVxuICAgIH1cbiAgKVxuXG4gIGNoYWkuQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdkaXNwbGF5ZWQnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgZWwgPSBmbGFnKHRoaXMsICdvYmplY3QnKSxcbiAgICAgICAgYWN0dWFsID0gZG9jdW1lbnQuYm9keS5jb250YWlucyhlbCkgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZGlzcGxheSA6IGVsLnN0eWxlLmRpc3BsYXlcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgYWN0dWFsICE9PSAnbm9uZSdcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgdG8gYmUgZGlzcGxheWVkLCBidXQgaXQgd2FzIG5vdCdcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgdG8gbm90IGJlIGRpc3BsYXllZCwgYnV0IGl0IHdhcyBhcyAnICsgYWN0dWFsXG4gICAgICAsIGFjdHVhbFxuICAgIClcbiAgfSlcbn0pKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gY2hhaVN0eWxlXG5cbmZ1bmN0aW9uIGNoYWlTdHlsZShjaGFpLCB1dGlscykge1xuICBjb25zdCB7QXNzZXJ0aW9ufSA9IGNoYWlcbiAgY29uc3Qge2ZsYWd9ID0gdXRpbHNcblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdzdHlsZScsIGZ1bmN0aW9uKHByb3BlcnR5LCB2YWx1ZSA9ICcnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVxuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpXG5cbiAgICBjb25zdCBpc05vbkNvbG9ycyA9IHN0eWxlW3Byb3BlcnR5XSA9PT0gJ3JnYmEoMCwgMCwgMCwgMCknIC8vIHdlYmtpdFxuICAgICAgfHwgc3R5bGVbcHJvcGVydHldID09PSAndHJhbnNwYXJlbnQnIC8vIGZpcmVmb3hcblxuICAgIGNvbnN0IHByb3BlcnR5VmFsdWUgPSBpc05vbkNvbG9yc1xuICAgICAgPyAnJ1xuICAgICAgOiBzdHlsZVtwcm9wZXJ0eV1cblxuICAgIGNvbnN0IGFzc2VydGlvbiA9IHZhbHVlXG4gICAgICA/IGNvbXBhcmVDU1NWYWx1ZShwcm9wZXJ0eVZhbHVlLCB2YWx1ZSlcbiAgICAgIDogQm9vbGVhbihwcm9wZXJ0eVZhbHVlKVxuXG4gICAgY29uc3QgZWxlbWVudFRhZyA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICBjb25zdCB0aHJvd01lc3NhZ2UgPSBgZXhwZWN0ICR7ZWxlbWVudFRhZ30gdG8gaGF2ZSB7JHtwcm9wZXJ0eX06ICR7dmFsdWV9fSwgaXMgcmVjZWl2aW5nIHske3Byb3BlcnR5fTogJHtwcm9wZXJ0eVZhbHVlfX1gXG4gICAgY29uc3QgdGhyb3dNZXNzYWdlTmVnYXRpdmUgPSBgZXhwZWN0ICR7ZWxlbWVudFRhZ30gdG8gbm90IGhhdmUgeyR7cHJvcGVydHl9OiAke3ZhbHVlfX0sIGlzIHJlY2VpdmluZyB7JHtwcm9wZXJ0eX06ICR7cHJvcGVydHlWYWx1ZX19YFxuXG4gICAgdGhpcy5hc3NlcnQoYXNzZXJ0aW9uLCB0aHJvd01lc3NhZ2UsIHRocm93TWVzc2FnZU5lZ2F0aXZlLCB2YWx1ZSlcblxuICAgIGZ1bmN0aW9uIGNvbXBhcmVDU1NWYWx1ZShjb21wdXRlZCwgZXhwZWN0ZWQpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5SGlmZW5DYXNlID0gcHJvcGVydHkucmVwbGFjZSgvW0EtWl0vZywgKG1hdGNoKSA9PiAnLScgKyBtYXRjaC50b0xvd2VyQ2FzZSgpKVxuICAgICAgY29uc3QgZmFrZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICBmYWtlLnN0eWxlLmZvbnRTaXplID0gc3R5bGUuZm9udFNpemVcbiAgICAgIGZha2Uuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHlIaWZlbkNhc2UsIGV4cGVjdGVkLCAnaW1wb3J0YW50JylcbiAgICAgIGNvbnN0IGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpXG4gICAgICBpZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSlcbiAgICAgIGlmcmFtZS5hcHBlbmRDaGlsZChmYWtlKVxuICAgICAgY29uc3QgZmFrZVN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZmFrZSlcbiAgICAgIGNvbnN0IHZhbHVlID0gZmFrZVN0eWxlW3Byb3BlcnR5XVxuXG4gICAgICBjb25zdCBoYXNBdXRvVmFsdWUgPSB2YWx1ZS5pbmNsdWRlcygnYXV0bycpXG4gICAgICBjb25zdCByZWcgPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cCh2YWx1ZSkucmVwbGFjZSgvYXV0by9nLCAnKFxcXFxkKyguXFxcXGQrKT9weHxhdXRvKScpKVxuXG4gICAgICByZXR1cm4gaGFzQXV0b1ZhbHVlXG4gICAgICAgID8gcmVnLnRlc3QoY29tcHV0ZWQpXG4gICAgICAgIDogY29tcHV0ZWQgPT09IHZhbHVlXG4gICAgfVxuICB9KVxufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtaW5nci9SZWdFeHAuZXNjYXBlL2Jsb2IvbWFzdGVyL3BvbHlmaWxsLmpzXG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAodmFsdWUpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlKS5yZXBsYWNlKC9bXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpXG59XG4iLCIndXNlIHN0cmljdCc7XG4vKiAhXG4gKiB0eXBlLWRldGVjdFxuICogQ29weXJpZ2h0KGMpIDIwMTMgamFrZSBsdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xudmFyIGdldFByb3RvdHlwZU9mRXhpc3RzID0gdHlwZW9mIE9iamVjdC5nZXRQcm90b3R5cGVPZiA9PT0gJ2Z1bmN0aW9uJztcbnZhciBwcm9taXNlRXhpc3RzID0gdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbic7XG52YXIgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHNlbGY7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbnZhciBpc0RvbSA9ICdsb2NhdGlvbicgaW4gZ2xvYmFsT2JqZWN0ICYmICdkb2N1bWVudCcgaW4gZ2xvYmFsT2JqZWN0O1xudmFyIGh0bWxFbGVtZW50RXhpc3RzID0gdHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBpc0FycmF5RXhpc3RzID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbic7XG52YXIgc3ltYm9sRXhpc3RzID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgbWFwRXhpc3RzID0gdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgc2V0RXhpc3RzID0gdHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgd2Vha01hcEV4aXN0cyA9IHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJztcbnZhciB3ZWFrU2V0RXhpc3RzID0gdHlwZW9mIFdlYWtTZXQgIT09ICd1bmRlZmluZWQnO1xudmFyIGRhdGFWaWV3RXhpc3RzID0gdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJztcbnZhciBzeW1ib2xJdGVyYXRvckV4aXN0cyA9IHN5bWJvbEV4aXN0cyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yICE9PSAndW5kZWZpbmVkJztcbnZhciBzeW1ib2xUb1N0cmluZ1RhZ0V4aXN0cyA9IHN5bWJvbEV4aXN0cyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnICE9PSAndW5kZWZpbmVkJztcbnZhciBzZXRFbnRyaWVzRXhpc3RzID0gc2V0RXhpc3RzICYmIHR5cGVvZiBTZXQucHJvdG90eXBlLmVudHJpZXMgPT09ICdmdW5jdGlvbic7XG52YXIgbWFwRW50cmllc0V4aXN0cyA9IG1hcEV4aXN0cyAmJiB0eXBlb2YgTWFwLnByb3RvdHlwZS5lbnRyaWVzID09PSAnZnVuY3Rpb24nO1xudmFyIHNldEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2ZFeGlzdHMgJiYgc2V0RW50cmllc0V4aXN0cyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IFNldCgpLmVudHJpZXMoKSk7XG52YXIgbWFwSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZkV4aXN0cyAmJiBtYXBFbnRyaWVzRXhpc3RzICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgTWFwKCkuZW50cmllcygpKTtcbnZhciBhcnJheUl0ZXJhdG9yRXhpc3RzID0gc3ltYm9sSXRlcmF0b3JFeGlzdHMgJiYgdHlwZW9mIEFycmF5LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xudmFyIGFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBhcnJheUl0ZXJhdG9yRXhpc3RzICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihbXVtTeW1ib2wuaXRlcmF0b3JdKCkpO1xudmFyIHN0cmluZ0l0ZXJhdG9yRXhpc3RzID0gc3ltYm9sSXRlcmF0b3JFeGlzdHMgJiYgdHlwZW9mIEFycmF5LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xudmFyIHN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlID0gc3RyaW5nSXRlcmF0b3JFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSk7XG52YXIgdG9TdHJpbmdMZWZ0U2xpY2VMZW5ndGggPSA4O1xudmFyIHRvU3RyaW5nUmlnaHRTbGljZUxlbmd0aCA9IC0xO1xuLyoqXG4gKiAjIyMgdHlwZU9mIChvYmopXG4gKlxuICogVXNlcyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGFuIG9iamVjdCxcbiAqIG5vcm1hbGlzaW5nIGJlaGF2aW91ciBhY3Jvc3MgZW5naW5lIHZlcnNpb25zICYgd2VsbCBvcHRpbWlzZWQuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IG9iamVjdCB0eXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHR5cGVEZXRlY3Qob2JqKSB7XG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAqIFByZTpcbiAgICogICBzdHJpbmcgbGl0ZXJhbCAgICAgeCAzLDAzOSwwMzUgb3BzL3NlYyDCsTEuNjIlICg3OCBydW5zIHNhbXBsZWQpXG4gICAqICAgYm9vbGVhbiBsaXRlcmFsICAgIHggMSw0MjQsMTM4IG9wcy9zZWMgwrE0LjU0JSAoNzUgcnVucyBzYW1wbGVkKVxuICAgKiAgIG51bWJlciBsaXRlcmFsICAgICB4IDEsNjUzLDE1MyBvcHMvc2VjIMKxMS45MSUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICogICB1bmRlZmluZWQgICAgICAgICAgeCA5LDk3OCw2NjAgb3BzL3NlYyDCsTEuOTIlICg3NSBydW5zIHNhbXBsZWQpXG4gICAqICAgZnVuY3Rpb24gICAgICAgICAgIHggMiw1NTYsNzY5IG9wcy9zZWMgwrExLjczJSAoNzcgcnVucyBzYW1wbGVkKVxuICAgKiBQb3N0OlxuICAgKiAgIHN0cmluZyBsaXRlcmFsICAgICB4IDM4LDU2NCw3OTYgb3BzL3NlYyDCsTEuMTUlICg3OSBydW5zIHNhbXBsZWQpXG4gICAqICAgYm9vbGVhbiBsaXRlcmFsICAgIHggMzEsMTQ4LDk0MCBvcHMvc2VjIMKxMS4xMCUgKDc5IHJ1bnMgc2FtcGxlZClcbiAgICogICBudW1iZXIgbGl0ZXJhbCAgICAgeCAzMiw2NzksMzMwIG9wcy9zZWMgwrExLjkwJSAoNzggcnVucyBzYW1wbGVkKVxuICAgKiAgIHVuZGVmaW5lZCAgICAgICAgICB4IDMyLDM2MywzNjggb3BzL3NlYyDCsTEuMDclICg4MiBydW5zIHNhbXBsZWQpXG4gICAqICAgZnVuY3Rpb24gICAgICAgICAgIHggMzEsMjk2LDg3MCBvcHMvc2VjIMKxMC45NiUgKDgzIHJ1bnMgc2FtcGxlZClcbiAgICovXG4gIHZhciB0eXBlb2ZPYmogPSB0eXBlb2Ygb2JqO1xuICBpZiAodHlwZW9mT2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0eXBlb2ZPYmo7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgKiBQcmU6XG4gICAqICAgbnVsbCAgICAgICAgICAgICAgIHggMjgsNjQ1LDc2NSBvcHMvc2VjIMKxMS4xNyUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICogUG9zdDpcbiAgICogICBudWxsICAgICAgICAgICAgICAgeCAzNiw0MjgsOTYyIG9wcy9zZWMgwrExLjM3JSAoODQgcnVucyBzYW1wbGVkKVxuICAgKi9cbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH1cblxuICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cpYGBcbiAgICogIC0gTm9kZSA9PT0gXCJbb2JqZWN0IGdsb2JhbF1cIlxuICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBnbG9iYWxdXCJcbiAgICogIC0gRmlyZWZveCA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiAgLSBQaGFudG9tSlMgPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogIC0gU2FmYXJpID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqICAtIElFIDExID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqICAtIElFIEVkZ2UgPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzKWBgXG4gICAqICAtIENocm9tZSBXb3JrZXIgPT09IFwiW29iamVjdCBnbG9iYWxdXCJcbiAgICogIC0gRmlyZWZveCBXb3JrZXIgPT09IFwiW29iamVjdCBEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZV1cIlxuICAgKiAgLSBTYWZhcmkgV29ya2VyID09PSBcIltvYmplY3QgRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVdXCJcbiAgICogIC0gSUUgMTEgV29ya2VyID09PSBcIltvYmplY3QgV29ya2VyR2xvYmFsU2NvcGVdXCJcbiAgICogIC0gSUUgRWRnZSBXb3JrZXIgPT09IFwiW29iamVjdCBXb3JrZXJHbG9iYWxTY29wZV1cIlxuICAgKi9cbiAgaWYgKG9iaiA9PT0gZ2xvYmFsT2JqZWN0KSB7XG4gICAgcmV0dXJuICdnbG9iYWwnO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICogUHJlOlxuICAgKiAgIGFycmF5IGxpdGVyYWwgICAgICB4IDIsODg4LDM1MiBvcHMvc2VjIMKxMC42NyUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICogUG9zdDpcbiAgICogICBhcnJheSBsaXRlcmFsICAgICAgeCAyMiw0NzksNjUwIG9wcy9zZWMgwrEwLjk2JSAoODEgcnVucyBzYW1wbGVkKVxuICAgKi9cbiAgaWYgKGlzQXJyYXlFeGlzdHMgJiYgQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuICdBcnJheSc7XG4gIH1cblxuICBpZiAoaXNEb20pIHtcbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvYnJvd3NlcnMuaHRtbCNsb2NhdGlvbilcbiAgICAgKiBXaGF0V0cgSFRNTCQ3LjcuMyAtIFRoZSBgTG9jYXRpb25gIGludGVyZmFjZVxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93LmxvY2F0aW9uKWBgXG4gICAgICogIC0gSUUgPD0xMSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqICAtIElFIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqL1xuICAgIGlmIChvYmogPT09IGdsb2JhbE9iamVjdC5sb2NhdGlvbikge1xuICAgICAgcmV0dXJuICdMb2NhdGlvbic7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2RvY3VtZW50KVxuICAgICAqIFdoYXRXRyBIVE1MJDMuMS4xIC0gVGhlIGBEb2N1bWVudGAgb2JqZWN0XG4gICAgICogTm90ZTogTW9zdCBicm93c2VycyBjdXJyZW50bHkgYWRoZXIgdG8gdGhlIFczQyBET00gTGV2ZWwgMiBzcGVjXG4gICAgICogICAgICAgKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1IVE1ML2h0bWwuaHRtbCNJRC0yNjgwOTI2OClcbiAgICAgKiAgICAgICB3aGljaCBzdWdnZXN0cyB0aGF0IGJyb3dzZXJzIHNob3VsZCB1c2UgSFRNTFRhYmxlQ2VsbEVsZW1lbnQgZm9yXG4gICAgICogICAgICAgYm90aCBURCBhbmQgVEggZWxlbWVudHMuIFdoYXRXRyBzZXBhcmF0ZXMgdGhlc2UuXG4gICAgICogICAgICAgV2hhdFdHIEhUTUwgc3RhdGVzOlxuICAgICAqICAgICAgICAgPiBGb3IgaGlzdG9yaWNhbCByZWFzb25zLCBXaW5kb3cgb2JqZWN0cyBtdXN0IGFsc28gaGF2ZSBhXG4gICAgICogICAgICAgICA+IHdyaXRhYmxlLCBjb25maWd1cmFibGUsIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVkXG4gICAgICogICAgICAgICA+IEhUTUxEb2N1bWVudCB3aG9zZSB2YWx1ZSBpcyB0aGUgRG9jdW1lbnQgaW50ZXJmYWNlIG9iamVjdC5cbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvY3VtZW50KWBgXG4gICAgICogIC0gQ2hyb21lID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICogIC0gRmlyZWZveCA9PT0gXCJbb2JqZWN0IEhUTUxEb2N1bWVudF1cIlxuICAgICAqICAtIFNhZmFyaSA9PT0gXCJbb2JqZWN0IEhUTUxEb2N1bWVudF1cIlxuICAgICAqICAtIElFIDw9MTAgPT09IFwiW29iamVjdCBEb2N1bWVudF1cIlxuICAgICAqICAtIElFIDExID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICogIC0gSUUgRWRnZSA8PTEzID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICovXG4gICAgaWYgKG9iaiA9PT0gZ2xvYmFsT2JqZWN0LmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gJ0RvY3VtZW50JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI21pbWV0eXBlYXJyYXkpXG4gICAgICogV2hhdFdHIEhUTUwkOC42LjEuNSAtIFBsdWdpbnMgLSBJbnRlcmZhY2UgTWltZVR5cGVBcnJheVxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmF2aWdhdG9yLm1pbWVUeXBlcylgYFxuICAgICAqICAtIElFIDw9MTAgPT09IFwiW29iamVjdCBNU01pbWVUeXBlc0NvbGxlY3Rpb25dXCJcbiAgICAgKi9cbiAgICBpZiAob2JqID09PSAoZ2xvYmFsT2JqZWN0Lm5hdmlnYXRvciB8fCB7fSkubWltZVR5cGVzKSB7XG4gICAgICByZXR1cm4gJ01pbWVUeXBlQXJyYXknO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjcGx1Z2luYXJyYXkpXG4gICAgICogV2hhdFdHIEhUTUwkOC42LjEuNSAtIFBsdWdpbnMgLSBJbnRlcmZhY2UgUGx1Z2luQXJyYXlcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5hdmlnYXRvci5wbHVnaW5zKWBgXG4gICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IE1TUGx1Z2luc0NvbGxlY3Rpb25dXCJcbiAgICAgKi9cbiAgICBpZiAob2JqID09PSAoZ2xvYmFsT2JqZWN0Lm5hdmlnYXRvciB8fCB7fSkucGx1Z2lucykge1xuICAgICAgcmV0dXJuICdQbHVnaW5BcnJheSc7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCNwbHVnaW5hcnJheSlcbiAgICAgKiBXaGF0V0cgSFRNTCQ0LjQuNCAtIFRoZSBgYmxvY2txdW90ZWAgZWxlbWVudCAtIEludGVyZmFjZSBgSFRNTFF1b3RlRWxlbWVudGBcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Jsb2NrcXVvdGUnKSlgYFxuICAgICAqICAtIElFIDw9MTAgPT09IFwiW29iamVjdCBIVE1MQmxvY2tFbGVtZW50XVwiXG4gICAgICovXG4gICAgaWYgKGh0bWxFbGVtZW50RXhpc3RzICYmIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIG9iai50YWdOYW1lID09PSAnQkxPQ0tRVU9URScpIHtcbiAgICAgIHJldHVybiAnSFRNTFF1b3RlRWxlbWVudCc7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2h0bWx0YWJsZWRhdGFjZWxsZWxlbWVudClcbiAgICAgKiBXaGF0V0cgSFRNTCQ0LjkuOSAtIFRoZSBgdGRgIGVsZW1lbnQgLSBJbnRlcmZhY2UgYEhUTUxUYWJsZURhdGFDZWxsRWxlbWVudGBcbiAgICAgKiBOb3RlOiBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBhZGhlciB0byB0aGUgVzNDIERPTSBMZXZlbCAyIHNwZWNcbiAgICAgKiAgICAgICAoaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUhUTUwvaHRtbC5odG1sI0lELTgyOTE1MDc1KVxuICAgICAqICAgICAgIHdoaWNoIHN1Z2dlc3RzIHRoYXQgYnJvd3NlcnMgc2hvdWxkIHVzZSBIVE1MVGFibGVDZWxsRWxlbWVudCBmb3JcbiAgICAgKiAgICAgICBib3RoIFREIGFuZCBUSCBlbGVtZW50cy4gV2hhdFdHIHNlcGFyYXRlcyB0aGVzZS5cbiAgICAgKiBUZXN0OiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKSlcbiAgICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAqICAtIEZpcmVmb3ggPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAqICAtIFNhZmFyaSA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICovXG4gICAgaWYgKGh0bWxFbGVtZW50RXhpc3RzICYmIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIG9iai50YWdOYW1lID09PSAnVEQnKSB7XG4gICAgICByZXR1cm4gJ0hUTUxUYWJsZURhdGFDZWxsRWxlbWVudCc7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2h0bWx0YWJsZWhlYWRlcmNlbGxlbGVtZW50KVxuICAgICAqIFdoYXRXRyBIVE1MJDQuOS45IC0gVGhlIGB0ZGAgZWxlbWVudCAtIEludGVyZmFjZSBgSFRNTFRhYmxlSGVhZGVyQ2VsbEVsZW1lbnRgXG4gICAgICogTm90ZTogTW9zdCBicm93c2VycyBjdXJyZW50bHkgYWRoZXIgdG8gdGhlIFczQyBET00gTGV2ZWwgMiBzcGVjXG4gICAgICogICAgICAgKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1IVE1ML2h0bWwuaHRtbCNJRC04MjkxNTA3NSlcbiAgICAgKiAgICAgICB3aGljaCBzdWdnZXN0cyB0aGF0IGJyb3dzZXJzIHNob3VsZCB1c2UgSFRNTFRhYmxlQ2VsbEVsZW1lbnQgZm9yXG4gICAgICogICAgICAgYm90aCBURCBhbmQgVEggZWxlbWVudHMuIFdoYXRXRyBzZXBhcmF0ZXMgdGhlc2UuXG4gICAgICogVGVzdDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJykpXG4gICAgICogIC0gQ2hyb21lID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgKiAgLSBGaXJlZm94ID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgKiAgLSBTYWZhcmkgPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAqL1xuICAgIGlmIChodG1sRWxlbWVudEV4aXN0cyAmJiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBvYmoudGFnTmFtZSA9PT0gJ1RIJykge1xuICAgICAgcmV0dXJuICdIVE1MVGFibGVIZWFkZXJDZWxsRWxlbWVudCc7XG4gICAgfVxuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICBGbG9hdDY0QXJyYXkgICAgICAgeCA2MjUsNjQ0IG9wcy9zZWMgwrExLjU4JSAoODAgcnVucyBzYW1wbGVkKVxuICAqICAgRmxvYXQzMkFycmF5ICAgICAgIHggMSwyNzksODUyIG9wcy9zZWMgwrEyLjkxJSAoNzcgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDMyQXJyYXkgICAgICAgIHggMSwxNzgsMTg1IG9wcy9zZWMgwrExLjk1JSAoODMgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDE2QXJyYXkgICAgICAgIHggMSwwMDgsMzgwIG9wcy9zZWMgwrEyLjI1JSAoODAgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDhBcnJheSAgICAgICAgIHggMSwxMjgsMDQwIG9wcy9zZWMgwrEyLjExJSAoODEgcnVucyBzYW1wbGVkKVxuICAqICAgSW50MzJBcnJheSAgICAgICAgIHggMSwxNzAsMTE5IG9wcy9zZWMgwrEyLjg4JSAoODAgcnVucyBzYW1wbGVkKVxuICAqICAgSW50MTZBcnJheSAgICAgICAgIHggMSwxNzYsMzQ4IG9wcy9zZWMgwrE1Ljc5JSAoODYgcnVucyBzYW1wbGVkKVxuICAqICAgSW50OEFycmF5ICAgICAgICAgIHggMSwwNTgsNzA3IG9wcy9zZWMgwrE0Ljk0JSAoNzcgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDhDbGFtcGVkQXJyYXkgIHggMSwxMTAsNjMzIG9wcy9zZWMgwrE0LjIwJSAoODAgcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICBGbG9hdDY0QXJyYXkgICAgICAgeCA3LDEwNSw2NzEgb3BzL3NlYyDCsTEzLjQ3JSAoNjQgcnVucyBzYW1wbGVkKVxuICAqICAgRmxvYXQzMkFycmF5ICAgICAgIHggNSw4ODcsOTEyIG9wcy9zZWMgwrExLjQ2JSAoODIgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDMyQXJyYXkgICAgICAgIHggNiw0OTEsNjYxIG9wcy9zZWMgwrExLjc2JSAoNzkgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDE2QXJyYXkgICAgICAgIHggNiw1NTksNzk1IG9wcy9zZWMgwrExLjY3JSAoODIgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDhBcnJheSAgICAgICAgIHggNiw0NjMsOTY2IG9wcy9zZWMgwrExLjQzJSAoODUgcnVucyBzYW1wbGVkKVxuICAqICAgSW50MzJBcnJheSAgICAgICAgIHggNSw2NDEsODQxIG9wcy9zZWMgwrEzLjQ5JSAoODEgcnVucyBzYW1wbGVkKVxuICAqICAgSW50MTZBcnJheSAgICAgICAgIHggNiw1ODMsNTExIG9wcy9zZWMgwrExLjk4JSAoODAgcnVucyBzYW1wbGVkKVxuICAqICAgSW50OEFycmF5ICAgICAgICAgIHggNiw2MDYsMDc4IG9wcy9zZWMgwrExLjc0JSAoODEgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDhDbGFtcGVkQXJyYXkgIHggNiw2MDIsMjI0IG9wcy9zZWMgwrExLjc3JSAoODMgcnVucyBzYW1wbGVkKVxuICAqL1xuICB2YXIgc3RyaW5nVGFnID0gKHN5bWJvbFRvU3RyaW5nVGFnRXhpc3RzICYmIG9ialtTeW1ib2wudG9TdHJpbmdUYWddKTtcbiAgaWYgKHR5cGVvZiBzdHJpbmdUYWcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0cmluZ1RhZztcbiAgfVxuXG4gIGlmIChnZXRQcm90b3R5cGVPZkV4aXN0cykge1xuICAgIHZhciBvYmpQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgICogUHJlOlxuICAgICogICByZWdleCBsaXRlcmFsICAgICAgeCAxLDc3MiwzODUgb3BzL3NlYyDCsTEuODUlICg3NyBydW5zIHNhbXBsZWQpXG4gICAgKiAgIHJlZ2V4IGNvbnN0cnVjdG9yICB4IDIsMTQzLDYzNCBvcHMvc2VjIMKxMi40NiUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgICAqIFBvc3Q6XG4gICAgKiAgIHJlZ2V4IGxpdGVyYWwgICAgICB4IDMsOTI4LDAwOSBvcHMvc2VjIMKxMC42NSUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgICAqICAgcmVnZXggY29uc3RydWN0b3IgIHggMyw5MzEsMTA4IG9wcy9zZWMgwrEwLjU4JSAoODQgcnVucyBzYW1wbGVkKVxuICAgICovXG4gICAgaWYgKG9ialByb3RvdHlwZSA9PT0gUmVnRXhwLnByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdSZWdFeHAnO1xuICAgIH1cblxuICAgIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAgKiBQcmU6XG4gICAgKiAgIGRhdGUgICAgICAgICAgICAgICB4IDIsMTMwLDA3NCBvcHMvc2VjIMKxNC40MiUgKDY4IHJ1bnMgc2FtcGxlZClcbiAgICAqIFBvc3Q6XG4gICAgKiAgIGRhdGUgICAgICAgICAgICAgICB4IDMsOTUzLDc3OSBvcHMvc2VjIMKxMS4zNSUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgICAqL1xuICAgIGlmIChvYmpQcm90b3R5cGUgPT09IERhdGUucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ0RhdGUnO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLXByb21pc2UucHJvdG90eXBlLUBAdG9zdHJpbmd0YWcpXG4gICAgICogRVM2JDI1LjQuNS40IC0gUHJvbWlzZS5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiUHJvbWlzZVwiOlxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUHJvbWlzZS5yZXNvbHZlKCkpYGBcbiAgICAgKiAgLSBDaHJvbWUgPD00NyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqICAtIEVkZ2UgPD0yMCA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqICAtIEZpcmVmb3ggMjktTGF0ZXN0ID09PSBcIltvYmplY3QgUHJvbWlzZV1cIlxuICAgICAqICAtIFNhZmFyaSA3LjEtTGF0ZXN0ID09PSBcIltvYmplY3QgUHJvbWlzZV1cIlxuICAgICAqL1xuICAgIGlmIChwcm9taXNlRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gUHJvbWlzZS5wcm90b3R5cGUpIHtcbiAgICAgIHJldHVybiAnUHJvbWlzZSc7XG4gICAgfVxuXG4gICAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICAqIFByZTpcbiAgICAqICAgc2V0ICAgICAgICAgICAgICAgIHggMiwyMjIsMTg2IG9wcy9zZWMgwrExLjMxJSAoODIgcnVucyBzYW1wbGVkKVxuICAgICogUG9zdDpcbiAgICAqICAgc2V0ICAgICAgICAgICAgICAgIHggNCw1NDUsODc5IG9wcy9zZWMgwrExLjEzJSAoODMgcnVucyBzYW1wbGVkKVxuICAgICovXG4gICAgaWYgKHNldEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IFNldC5wcm90b3R5cGUpIHtcbiAgICAgIHJldHVybiAnU2V0JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgICogUHJlOlxuICAgICogICBtYXAgICAgICAgICAgICAgICAgeCAyLDM5Niw4NDIgb3BzL3NlYyDCsTEuNTklICg4MSBydW5zIHNhbXBsZWQpXG4gICAgKiBQb3N0OlxuICAgICogICBtYXAgICAgICAgICAgICAgICAgeCA0LDE4Myw5NDUgb3BzL3NlYyDCsTYuNTklICg4MiBydW5zIHNhbXBsZWQpXG4gICAgKi9cbiAgICBpZiAobWFwRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gTWFwLnByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdNYXAnO1xuICAgIH1cblxuICAgIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAgKiBQcmU6XG4gICAgKiAgIHdlYWtzZXQgICAgICAgICAgICB4IDEsMzIzLDIyMCBvcHMvc2VjIMKxMi4xNyUgKDc2IHJ1bnMgc2FtcGxlZClcbiAgICAqIFBvc3Q6XG4gICAgKiAgIHdlYWtzZXQgICAgICAgICAgICB4IDQsMjM3LDUxMCBvcHMvc2VjIMKxMi4wMSUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgICAqL1xuICAgIGlmICh3ZWFrU2V0RXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gV2Vha1NldC5wcm90b3R5cGUpIHtcbiAgICAgIHJldHVybiAnV2Vha1NldCc7XG4gICAgfVxuXG4gICAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICAqIFByZTpcbiAgICAqICAgd2Vha21hcCAgICAgICAgICAgIHggMSw1MDAsMjYwIG9wcy9zZWMgwrEyLjAyJSAoNzggcnVucyBzYW1wbGVkKVxuICAgICogUG9zdDpcbiAgICAqICAgd2Vha21hcCAgICAgICAgICAgIHggMyw4ODEsMzg0IG9wcy9zZWMgwrExLjQ1JSAoODIgcnVucyBzYW1wbGVkKVxuICAgICovXG4gICAgaWYgKHdlYWtNYXBFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBXZWFrTWFwLnByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdXZWFrTWFwJztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy1kYXRhdmlldy5wcm90b3R5cGUtQEB0b3N0cmluZ3RhZylcbiAgICAgKiBFUzYkMjQuMi40LjIxIC0gRGF0YVZpZXcucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIkRhdGFWaWV3XCI6XG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSlgYFxuICAgICAqICAtIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqL1xuICAgIGlmIChkYXRhVmlld0V4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IERhdGFWaWV3LnByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdEYXRhVmlldyc7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtJW1hcGl0ZXJhdG9ycHJvdG90eXBlJS1AQHRvc3RyaW5ndGFnKVxuICAgICAqIEVTNiQyMy4xLjUuMi4yIC0gJU1hcEl0ZXJhdG9yUHJvdG90eXBlJVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJNYXAgSXRlcmF0b3JcIjpcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ldyBNYXAoKS5lbnRyaWVzKCkpYGBcbiAgICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICAgKi9cbiAgICBpZiAobWFwRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gbWFwSXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICAgIHJldHVybiAnTWFwIEl0ZXJhdG9yJztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy0lc2V0aXRlcmF0b3Jwcm90b3R5cGUlLUBAdG9zdHJpbmd0YWcpXG4gICAgICogRVM2JDIzLjIuNS4yLjIgLSAlU2V0SXRlcmF0b3JQcm90b3R5cGUlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIlNldCBJdGVyYXRvclwiOlxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3IFNldCgpLmVudHJpZXMoKSlgYFxuICAgICAqICAtIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqL1xuICAgIGlmIChzZXRFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBzZXRJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdTZXQgSXRlcmF0b3InO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS1AQHRvc3RyaW5ndGFnKVxuICAgICAqIEVTNiQyMi4xLjUuMi4yIC0gJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIkFycmF5IEl0ZXJhdG9yXCI6XG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChbXVtTeW1ib2wuaXRlcmF0b3JdKCkpYGBcbiAgICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICAgKi9cbiAgICBpZiAoYXJyYXlJdGVyYXRvckV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IGFycmF5SXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICAgIHJldHVybiAnQXJyYXkgSXRlcmF0b3InO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUtQEB0b3N0cmluZ3RhZylcbiAgICAgKiBFUzYkMjEuMS41LjIuMiAtICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiU3RyaW5nIEl0ZXJhdG9yXCI6XG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCgnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpYGBcbiAgICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICAgKi9cbiAgICBpZiAoc3RyaW5nSXRlcmF0b3JFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBzdHJpbmdJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdTdHJpbmcgSXRlcmF0b3InO1xuICAgIH1cblxuICAgIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAgKiBQcmU6XG4gICAgKiAgIG9iamVjdCBmcm9tIG51bGwgICB4IDIsNDI0LDMyMCBvcHMvc2VjIMKxMS42NyUgKDc2IHJ1bnMgc2FtcGxlZClcbiAgICAqIFBvc3Q6XG4gICAgKiAgIG9iamVjdCBmcm9tIG51bGwgICB4IDUsODM4LDAwMCBvcHMvc2VjIMKxMC45OSUgKDg0IHJ1bnMgc2FtcGxlZClcbiAgICAqL1xuICAgIGlmIChvYmpQcm90b3R5cGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnT2JqZWN0JztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gT2JqZWN0XG4gICAgLnByb3RvdHlwZVxuICAgIC50b1N0cmluZ1xuICAgIC5jYWxsKG9iailcbiAgICAuc2xpY2UodG9TdHJpbmdMZWZ0U2xpY2VMZW5ndGgsIHRvU3RyaW5nUmlnaHRTbGljZUxlbmd0aCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy50eXBlRGV0ZWN0ID0gbW9kdWxlLmV4cG9ydHM7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWxzIFN5bWJvbDogdHJ1ZSwgVWludDhBcnJheTogdHJ1ZSwgV2Vha01hcDogdHJ1ZSAqL1xuLyohXG4gKiBkZWVwLWVxbFxuICogQ29weXJpZ2h0KGMpIDIwMTMgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgdHlwZSA9IHJlcXVpcmUoJ3R5cGUtZGV0ZWN0Jyk7XG5mdW5jdGlvbiBGYWtlTWFwKCkge1xuICB0aGlzLmNsZWFyKCk7XG59XG5GYWtlTWFwLnByb3RvdHlwZSA9IHtcbiAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyTWFwKCkge1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0TWFwKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmtleXMuaW5kZXhPZihrZXkpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLnZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgICAgIHRoaXMudmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXRNYXAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzW3RoaXMua2V5cy5pbmRleE9mKGtleSldO1xuICB9LFxuICBkZWxldGU6IGZ1bmN0aW9uIGRlbGV0ZU1hcChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmtleXMuaW5kZXhPZihrZXkpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLnZhbHVlcyA9IHRoaXMudmFsdWVzLnNsaWNlKDAsIGluZGV4KS5jb25jYXQodGhpcy52YWx1ZXMuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgICB0aGlzLmtleXMgPSB0aGlzLmtleXMuc2xpY2UoMCwgaW5kZXgpLmNvbmNhdCh0aGlzLmtleXMuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxufTtcblxudmFyIE1lbW9pemVNYXAgPSBudWxsO1xuaWYgKHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nKSB7XG4gIE1lbW9pemVNYXAgPSBXZWFrTWFwO1xufSBlbHNlIHtcbiAgTWVtb2l6ZU1hcCA9IEZha2VNYXA7XG59XG5cbi8qIVxuICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBNZW1vaXplTWFwIGhhcyByZWNvcmRlZCBhIHJlc3VsdCBvZiB0aGUgdHdvIG9wZXJhbmRzXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01lbW9pemVNYXB9IG1lbW9pemVNYXBcbiAqIEByZXR1cm5zIHtCb29sZWFufG51bGx9IHJlc3VsdFxuKi9cbmZ1bmN0aW9uIG1lbW9pemVDb21wYXJlKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgbWVtb2l6ZU1hcCkge1xuICAvLyBUZWNobmljYWxseSwgV2Vha01hcCBrZXlzIGNhbiAqb25seSogYmUgb2JqZWN0cywgbm90IHByaW1pdGl2ZXMuXG4gIGlmICghbWVtb2l6ZU1hcCB8fCBpc1ByaW1pdGl2ZShsZWZ0SGFuZE9wZXJhbmQpIHx8IGlzUHJpbWl0aXZlKHJpZ2h0SGFuZE9wZXJhbmQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGxlZnRIYW5kTWFwID0gbWVtb2l6ZU1hcC5nZXQobGVmdEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kTWFwKSB7XG4gICAgdmFyIHJlc3VsdCA9IGxlZnRIYW5kTWFwLmdldChyaWdodEhhbmRPcGVyYW5kKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyohXG4gKiBTZXQgdGhlIHJlc3VsdCBvZiB0aGUgZXF1YWxpdHkgaW50byB0aGUgTWVtb2l6ZU1hcFxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNZW1vaXplTWFwfSBtZW1vaXplTWFwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJlc3VsdFxuKi9cbmZ1bmN0aW9uIG1lbW9pemVTZXQobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBtZW1vaXplTWFwLCByZXN1bHQpIHtcbiAgLy8gVGVjaG5pY2FsbHksIFdlYWtNYXAga2V5cyBjYW4gKm9ubHkqIGJlIG9iamVjdHMsIG5vdCBwcmltaXRpdmVzLlxuICBpZiAoIW1lbW9pemVNYXAgfHwgaXNQcmltaXRpdmUobGVmdEhhbmRPcGVyYW5kKSB8fCBpc1ByaW1pdGl2ZShyaWdodEhhbmRPcGVyYW5kKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbGVmdEhhbmRNYXAgPSBtZW1vaXplTWFwLmdldChsZWZ0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRNYXApIHtcbiAgICBsZWZ0SGFuZE1hcC5zZXQocmlnaHRIYW5kT3BlcmFuZCwgcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBsZWZ0SGFuZE1hcCA9IG5ldyBNZW1vaXplTWFwKCk7XG4gICAgbGVmdEhhbmRNYXAuc2V0KHJpZ2h0SGFuZE9wZXJhbmQsIHJlc3VsdCk7XG4gICAgbWVtb2l6ZU1hcC5zZXQobGVmdEhhbmRPcGVyYW5kLCBsZWZ0SGFuZE1hcCk7XG4gIH1cbn1cblxuLyohXG4gKiBQcmltYXJ5IEV4cG9ydFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVlcEVxdWFsO1xubW9kdWxlLmV4cG9ydHMuTWVtb2l6ZU1hcCA9IE1lbW9pemVNYXA7XG5cbi8qKlxuICogQXNzZXJ0IGRlZXBseSBuZXN0ZWQgc2FtZVZhbHVlIGVxdWFsaXR5IGJldHdlZW4gdHdvIG9iamVjdHMgb2YgYW55IHR5cGUuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChvcHRpb25hbCkgQWRkaXRpb25hbCBvcHRpb25zXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5jb21wYXJhdG9yXSAob3B0aW9uYWwpIE92ZXJyaWRlIGRlZmF1bHQgYWxnb3JpdGhtLCBkZXRlcm1pbmluZyBjdXN0b20gZXF1YWxpdHkuXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5tZW1vaXplXSAob3B0aW9uYWwpIFByb3ZpZGUgYSBjdXN0b20gbWVtb2l6YXRpb24gb2JqZWN0IHdoaWNoIHdpbGwgY2FjaGUgdGhlIHJlc3VsdHMgb2ZcbiAgICBjb21wbGV4IG9iamVjdHMgZm9yIGEgc3BlZWQgYm9vc3QuIEJ5IHBhc3NpbmcgYGZhbHNlYCB5b3UgY2FuIGRpc2FibGUgbWVtb2l6YXRpb24sIGJ1dCB0aGlzIHdpbGwgY2F1c2UgY2lyY3VsYXJcbiAgICByZWZlcmVuY2VzIHRvIGJsb3cgdGhlIHN0YWNrLlxuICogQHJldHVybiB7Qm9vbGVhbn0gZXF1YWwgbWF0Y2hcbiAqL1xuZnVuY3Rpb24gZGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICAvLyBJZiB3ZSBoYXZlIGEgY29tcGFyYXRvciwgd2UgY2FuJ3QgYXNzdW1lIGFueXRoaW5nOyBzbyBiYWlsIHRvIGl0cyBjaGVjayBmaXJzdC5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIGV4dGVuc2l2ZURlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHNpbXBsZVJlc3VsdCA9IHNpbXBsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCk7XG4gIGlmIChzaW1wbGVSZXN1bHQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc2ltcGxlUmVzdWx0O1xuICB9XG5cbiAgLy8gRGVlcGVyIGNvbXBhcmlzb25zIGFyZSBwdXNoZWQgdGhyb3VnaCB0byBhIGxhcmdlciBmdW5jdGlvblxuICByZXR1cm4gZXh0ZW5zaXZlRGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogTWFueSBjb21wYXJpc29ucyBjYW4gYmUgY2FuY2VsZWQgb3V0IGVhcmx5IHZpYSBzaW1wbGUgZXF1YWxpdHkgb3IgcHJpbWl0aXZlIGNoZWNrcy5cbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHJldHVybiB7Qm9vbGVhbnxudWxsfSBlcXVhbCBtYXRjaFxuICovXG5mdW5jdGlvbiBzaW1wbGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpIHtcbiAgLy8gRXF1YWwgcmVmZXJlbmNlcyAoZXhjZXB0IGZvciBOdW1iZXJzKSBjYW4gYmUgcmV0dXJuZWQgZWFybHlcbiAgaWYgKGxlZnRIYW5kT3BlcmFuZCA9PT0gcmlnaHRIYW5kT3BlcmFuZCkge1xuICAgIC8vIEhhbmRsZSArLTAgY2FzZXNcbiAgICByZXR1cm4gbGVmdEhhbmRPcGVyYW5kICE9PSAwIHx8IDEgLyBsZWZ0SGFuZE9wZXJhbmQgPT09IDEgLyByaWdodEhhbmRPcGVyYW5kO1xuICB9XG5cbiAgLy8gaGFuZGxlIE5hTiBjYXNlc1xuICBpZiAoXG4gICAgbGVmdEhhbmRPcGVyYW5kICE9PSBsZWZ0SGFuZE9wZXJhbmQgJiYgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByaWdodEhhbmRPcGVyYW5kICE9PSByaWdodEhhbmRPcGVyYW5kIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gQW55dGhpbmcgdGhhdCBpcyBub3QgYW4gJ29iamVjdCcsIGkuZS4gc3ltYm9scywgZnVuY3Rpb25zLCBib29sZWFucywgbnVtYmVycyxcbiAgLy8gc3RyaW5ncywgYW5kIHVuZGVmaW5lZCwgY2FuIGJlIGNvbXBhcmVkIGJ5IHJlZmVyZW5jZS5cbiAgaWYgKGlzUHJpbWl0aXZlKGxlZnRIYW5kT3BlcmFuZCkgfHwgaXNQcmltaXRpdmUocmlnaHRIYW5kT3BlcmFuZCkpIHtcbiAgICAvLyBFYXN5IG91dCBiL2MgaXQgd291bGQgaGF2ZSBwYXNzZWQgdGhlIGZpcnN0IGVxdWFsaXR5IGNoZWNrXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKiFcbiAqIFRoZSBtYWluIGxvZ2ljIG9mIHRoZSBgZGVlcEVxdWFsYCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKG9wdGlvbmFsKSBBZGRpdGlvbmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmNvbXBhcmF0b3JdIChvcHRpb25hbCkgT3ZlcnJpZGUgZGVmYXVsdCBhbGdvcml0aG0sIGRldGVybWluaW5nIGN1c3RvbSBlcXVhbGl0eS5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm1lbW9pemVdIChvcHRpb25hbCkgUHJvdmlkZSBhIGN1c3RvbSBtZW1vaXphdGlvbiBvYmplY3Qgd2hpY2ggd2lsbCBjYWNoZSB0aGUgcmVzdWx0cyBvZlxuICAgIGNvbXBsZXggb2JqZWN0cyBmb3IgYSBzcGVlZCBib29zdC4gQnkgcGFzc2luZyBgZmFsc2VgIHlvdSBjYW4gZGlzYWJsZSBtZW1vaXphdGlvbiwgYnV0IHRoaXMgd2lsbCBjYXVzZSBjaXJjdWxhclxuICAgIHJlZmVyZW5jZXMgdG8gYmxvdyB0aGUgc3RhY2suXG4gKiBAcmV0dXJuIHtCb29sZWFufSBlcXVhbCBtYXRjaFxuKi9cbmZ1bmN0aW9uIGV4dGVuc2l2ZURlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMubWVtb2l6ZSA9IG9wdGlvbnMubWVtb2l6ZSA9PT0gZmFsc2UgPyBmYWxzZSA6IG9wdGlvbnMubWVtb2l6ZSB8fCBuZXcgTWVtb2l6ZU1hcCgpO1xuICB2YXIgY29tcGFyYXRvciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wYXJhdG9yO1xuXG4gIC8vIENoZWNrIGlmIGEgbWVtb2l6ZWQgcmVzdWx0IGV4aXN0cy5cbiAgdmFyIG1lbW9pemVSZXN1bHRMZWZ0ID0gbWVtb2l6ZUNvbXBhcmUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUpO1xuICBpZiAobWVtb2l6ZVJlc3VsdExlZnQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gbWVtb2l6ZVJlc3VsdExlZnQ7XG4gIH1cbiAgdmFyIG1lbW9pemVSZXN1bHRSaWdodCA9IG1lbW9pemVDb21wYXJlKHJpZ2h0SGFuZE9wZXJhbmQsIGxlZnRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplKTtcbiAgaWYgKG1lbW9pemVSZXN1bHRSaWdodCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBtZW1vaXplUmVzdWx0UmlnaHQ7XG4gIH1cblxuICAvLyBJZiBhIGNvbXBhcmF0b3IgaXMgcHJlc2VudCwgdXNlIGl0LlxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIHZhciBjb21wYXJhdG9yUmVzdWx0ID0gY29tcGFyYXRvcihsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIC8vIENvbXBhcmF0b3JzIG1heSByZXR1cm4gbnVsbCwgaW4gd2hpY2ggY2FzZSB3ZSB3YW50IHRvIGdvIGJhY2sgdG8gZGVmYXVsdCBiZWhhdmlvci5cbiAgICBpZiAoY29tcGFyYXRvclJlc3VsdCA9PT0gZmFsc2UgfHwgY29tcGFyYXRvclJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgbWVtb2l6ZVNldChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSwgY29tcGFyYXRvclJlc3VsdCk7XG4gICAgICByZXR1cm4gY29tcGFyYXRvclJlc3VsdDtcbiAgICB9XG4gICAgLy8gVG8gYWxsb3cgY29tcGFyYXRvcnMgdG8gb3ZlcnJpZGUgKmFueSogYmVoYXZpb3IsIHdlIHJhbiB0aGVtIGZpcnN0LiBTaW5jZSBpdCBkaWRuJ3QgZGVjaWRlXG4gICAgLy8gd2hhdCB0byBkbywgd2UgbmVlZCB0byBtYWtlIHN1cmUgdG8gcmV0dXJuIHRoZSBiYXNpYyB0ZXN0cyBmaXJzdCBiZWZvcmUgd2UgbW92ZSBvbi5cbiAgICB2YXIgc2ltcGxlUmVzdWx0ID0gc2ltcGxlRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKTtcbiAgICBpZiAoc2ltcGxlUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAvLyBEb24ndCBtZW1vaXplIHRoaXMsIGl0IHRha2VzIGxvbmdlciB0byBzZXQvcmV0cmlldmUgdGhhbiB0byBqdXN0IGNvbXBhcmUuXG4gICAgICByZXR1cm4gc2ltcGxlUmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIHZhciBsZWZ0SGFuZFR5cGUgPSB0eXBlKGxlZnRIYW5kT3BlcmFuZCk7XG4gIGlmIChsZWZ0SGFuZFR5cGUgIT09IHR5cGUocmlnaHRIYW5kT3BlcmFuZCkpIHtcbiAgICBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplLCBmYWxzZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVtcG9yYXJpbHkgc2V0IHRoZSBvcGVyYW5kcyBpbiB0aGUgbWVtb2l6ZSBvYmplY3QgdG8gcHJldmVudCBibG93aW5nIHRoZSBzdGFja1xuICBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplLCB0cnVlKTtcblxuICB2YXIgcmVzdWx0ID0gZXh0ZW5zaXZlRGVlcEVxdWFsQnlUeXBlKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgbGVmdEhhbmRUeXBlLCBvcHRpb25zKTtcbiAgbWVtb2l6ZVNldChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5zaXZlRGVlcEVxdWFsQnlUeXBlKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgbGVmdEhhbmRUeXBlLCBvcHRpb25zKSB7XG4gIHN3aXRjaCAobGVmdEhhbmRUeXBlKSB7XG4gICAgY2FzZSAnU3RyaW5nJzpcbiAgICBjYXNlICdOdW1iZXInOlxuICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgLy8gSWYgdGhlc2UgdHlwZXMgYXJlIHRoZWlyIGluc3RhbmNlIHR5cGVzIChlLmcuIGBuZXcgTnVtYmVyYCkgdGhlbiByZS1kZWVwRXF1YWwgYWdhaW5zdCB0aGVpciB2YWx1ZXNcbiAgICAgIHJldHVybiBkZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kLnZhbHVlT2YoKSwgcmlnaHRIYW5kT3BlcmFuZC52YWx1ZU9mKCkpO1xuICAgIGNhc2UgJ1Byb21pc2UnOlxuICAgIGNhc2UgJ1N5bWJvbCc6XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgIGNhc2UgJ1dlYWtNYXAnOlxuICAgIGNhc2UgJ1dlYWtTZXQnOlxuICAgIGNhc2UgJ0Vycm9yJzpcbiAgICAgIHJldHVybiBsZWZ0SGFuZE9wZXJhbmQgPT09IHJpZ2h0SGFuZE9wZXJhbmQ7XG4gICAgY2FzZSAnQXJndW1lbnRzJzpcbiAgICBjYXNlICdJbnQ4QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQ4QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQ4Q2xhbXBlZEFycmF5JzpcbiAgICBjYXNlICdJbnQxNkFycmF5JzpcbiAgICBjYXNlICdVaW50MTZBcnJheSc6XG4gICAgY2FzZSAnSW50MzJBcnJheSc6XG4gICAgY2FzZSAnVWludDMyQXJyYXknOlxuICAgIGNhc2UgJ0Zsb2F0MzJBcnJheSc6XG4gICAgY2FzZSAnRmxvYXQ2NEFycmF5JzpcbiAgICBjYXNlICdBcnJheSc6XG4gICAgICByZXR1cm4gaXRlcmFibGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICByZXR1cm4gcmVnZXhwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKTtcbiAgICBjYXNlICdHZW5lcmF0b3InOlxuICAgICAgcmV0dXJuIGdlbmVyYXRvckVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gICAgY2FzZSAnRGF0YVZpZXcnOlxuICAgICAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobmV3IFVpbnQ4QXJyYXkobGVmdEhhbmRPcGVyYW5kLmJ1ZmZlciksIG5ldyBVaW50OEFycmF5KHJpZ2h0SGFuZE9wZXJhbmQuYnVmZmVyKSwgb3B0aW9ucyk7XG4gICAgY2FzZSAnQXJyYXlCdWZmZXInOlxuICAgICAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobmV3IFVpbnQ4QXJyYXkobGVmdEhhbmRPcGVyYW5kKSwgbmV3IFVpbnQ4QXJyYXkocmlnaHRIYW5kT3BlcmFuZCksIG9wdGlvbnMpO1xuICAgIGNhc2UgJ1NldCc6XG4gICAgICByZXR1cm4gZW50cmllc0VxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gICAgY2FzZSAnTWFwJzpcbiAgICAgIHJldHVybiBlbnRyaWVzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG9iamVjdEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuLyohXG4gKiBDb21wYXJlIHR3byBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gcmVnZXhwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKSB7XG4gIHJldHVybiBsZWZ0SGFuZE9wZXJhbmQudG9TdHJpbmcoKSA9PT0gcmlnaHRIYW5kT3BlcmFuZC50b1N0cmluZygpO1xufVxuXG4vKiFcbiAqIENvbXBhcmUgdHdvIFNldHMvTWFwcyBmb3IgZXF1YWxpdHkuIEZhc3RlciB0aGFuIG90aGVyIGVxdWFsaXR5IGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge1NldH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge1NldH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAoT3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBlbnRyaWVzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIC8vIElFMTEgZG9lc24ndCBzdXBwb3J0IFNldCNlbnRyaWVzIG9yIFNldCNAQGl0ZXJhdG9yLCBzbyB3ZSBuZWVkIG1hbnVhbGx5IHBvcHVsYXRlIHVzaW5nIFNldCNmb3JFYWNoXG4gIGlmIChsZWZ0SGFuZE9wZXJhbmQuc2l6ZSAhPT0gcmlnaHRIYW5kT3BlcmFuZC5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChsZWZ0SGFuZE9wZXJhbmQuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBsZWZ0SGFuZEl0ZW1zID0gW107XG4gIHZhciByaWdodEhhbmRJdGVtcyA9IFtdO1xuICBsZWZ0SGFuZE9wZXJhbmQuZm9yRWFjaChmdW5jdGlvbiBnYXRoZXJFbnRyaWVzKGtleSwgdmFsdWUpIHtcbiAgICBsZWZ0SGFuZEl0ZW1zLnB1c2goWyBrZXksIHZhbHVlIF0pO1xuICB9KTtcbiAgcmlnaHRIYW5kT3BlcmFuZC5mb3JFYWNoKGZ1bmN0aW9uIGdhdGhlckVudHJpZXMoa2V5LCB2YWx1ZSkge1xuICAgIHJpZ2h0SGFuZEl0ZW1zLnB1c2goWyBrZXksIHZhbHVlIF0pO1xuICB9KTtcbiAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobGVmdEhhbmRJdGVtcy5zb3J0KCksIHJpZ2h0SGFuZEl0ZW1zLnNvcnQoKSwgb3B0aW9ucyk7XG59XG5cbi8qIVxuICogU2ltcGxlIGVxdWFsaXR5IGZvciBmbGF0IGl0ZXJhYmxlIG9iamVjdHMgc3VjaCBhcyBBcnJheXMsIFR5cGVkQXJyYXlzIG9yIE5vZGUuanMgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7SXRlcmFibGV9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gaXRlcmFibGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlbmd0aCA9IGxlZnRIYW5kT3BlcmFuZC5sZW5ndGg7XG4gIGlmIChsZW5ndGggIT09IHJpZ2h0SGFuZE9wZXJhbmQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaW5kZXggPSAtMTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoZGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZFtpbmRleF0sIHJpZ2h0SGFuZE9wZXJhbmRbaW5kZXhdLCBvcHRpb25zKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qIVxuICogU2ltcGxlIGVxdWFsaXR5IGZvciBnZW5lcmF0b3Igb2JqZWN0cyBzdWNoIGFzIHRob3NlIHJldHVybmVkIGJ5IGdlbmVyYXRvciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtJdGVyYWJsZX0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChPcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGdlbmVyYXRvckVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICByZXR1cm4gaXRlcmFibGVFcXVhbChnZXRHZW5lcmF0b3JFbnRyaWVzKGxlZnRIYW5kT3BlcmFuZCksIGdldEdlbmVyYXRvckVudHJpZXMocmlnaHRIYW5kT3BlcmFuZCksIG9wdGlvbnMpO1xufVxuXG4vKiFcbiAqIERldGVybWluZSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBhbiBAQGl0ZXJhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgb2JqZWN0IGhhcyBhbiBAQGl0ZXJhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBoYXNJdGVyYXRvckZ1bmN0aW9uKHRhcmdldCkge1xuICByZXR1cm4gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHRhcmdldFtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKiFcbiAqIEdldHMgYWxsIGl0ZXJhdG9yIGVudHJpZXMgZnJvbSB0aGUgZ2l2ZW4gT2JqZWN0LiBJZiB0aGUgT2JqZWN0IGhhcyBubyBAQGl0ZXJhdG9yIGZ1bmN0aW9uLCByZXR1cm5zIGFuIGVtcHR5IGFycmF5LlxuICogVGhpcyB3aWxsIGNvbnN1bWUgdGhlIGl0ZXJhdG9yIC0gd2hpY2ggY291bGQgaGF2ZSBzaWRlIGVmZmVjdHMgZGVwZW5kaW5nIG9uIHRoZSBAQGl0ZXJhdG9yIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2YgZW50cmllcyBmcm9tIHRoZSBAQGl0ZXJhdG9yIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRW50cmllcyh0YXJnZXQpIHtcbiAgaWYgKGhhc0l0ZXJhdG9yRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZ2V0R2VuZXJhdG9yRW50cmllcyh0YXJnZXRbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbiAgICB9IGNhdGNoIChpdGVyYXRvckVycm9yKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTtcbn1cblxuLyohXG4gKiBHZXRzIGFsbCBlbnRyaWVzIGZyb20gYSBHZW5lcmF0b3IuIFRoaXMgd2lsbCBjb25zdW1lIHRoZSBnZW5lcmF0b3IgLSB3aGljaCBjb3VsZCBoYXZlIHNpZGUgZWZmZWN0cy5cbiAqXG4gKiBAcGFyYW0ge0dlbmVyYXRvcn0gdGFyZ2V0XG4gKiBAcmV0dXJucyB7QXJyYXl9IGFuIGFycmF5IG9mIGVudHJpZXMgZnJvbSB0aGUgR2VuZXJhdG9yLlxuICovXG5mdW5jdGlvbiBnZXRHZW5lcmF0b3JFbnRyaWVzKGdlbmVyYXRvcikge1xuICB2YXIgZ2VuZXJhdG9yUmVzdWx0ID0gZ2VuZXJhdG9yLm5leHQoKTtcbiAgdmFyIGFjY3VtdWxhdG9yID0gWyBnZW5lcmF0b3JSZXN1bHQudmFsdWUgXTtcbiAgd2hpbGUgKGdlbmVyYXRvclJlc3VsdC5kb25lID09PSBmYWxzZSkge1xuICAgIGdlbmVyYXRvclJlc3VsdCA9IGdlbmVyYXRvci5uZXh0KCk7XG4gICAgYWNjdW11bGF0b3IucHVzaChnZW5lcmF0b3JSZXN1bHQudmFsdWUpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxuLyohXG4gKiBHZXRzIGFsbCBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIGtleXMgZnJvbSBhIHRhcmdldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcmV0dXJucyB7QXJyYXl9IGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUga2V5cyBmcm9tIHRoZSB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVLZXlzKHRhcmdldCkge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbi8qIVxuICogRGV0ZXJtaW5lcyBpZiB0d28gb2JqZWN0cyBoYXZlIG1hdGNoaW5nIHZhbHVlcywgZ2l2ZW4gYSBzZXQgb2Yga2V5cy4gRGVmZXJzIHRvIGRlZXBFcXVhbCBmb3IgdGhlIGVxdWFsaXR5IGNoZWNrIG9mXG4gKiBlYWNoIGtleS4gSWYgYW55IHZhbHVlIG9mIHRoZSBnaXZlbiBrZXkgaXMgbm90IGVxdWFsLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gZmFsc2UgKGVhcmx5KS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7QXJyYXl9IGtleXMgQW4gYXJyYXkgb2Yga2V5cyB0byBjb21wYXJlIHRoZSB2YWx1ZXMgb2YgbGVmdEhhbmRPcGVyYW5kIGFuZCByaWdodEhhbmRPcGVyYW5kIGFnYWluc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGtleXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChkZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kW2tleXNbaV1dLCByaWdodEhhbmRPcGVyYW5kW2tleXNbaV1dLCBvcHRpb25zKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qIVxuICogUmVjdXJzaXZlbHkgY2hlY2sgdGhlIGVxdWFsaXR5IG9mIHR3byBPYmplY3RzLiBPbmNlIGJhc2ljIHNhbWVuZXNzIGhhcyBiZWVuIGVzdGFibGlzaGVkIGl0IHdpbGwgZGVmZXIgdG8gYGRlZXBFcXVhbGBcbiAqIGZvciBlYWNoIGVudW1lcmFibGUga2V5IGluIHRoZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChPcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIG9iamVjdEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICB2YXIgbGVmdEhhbmRLZXlzID0gZ2V0RW51bWVyYWJsZUtleXMobGVmdEhhbmRPcGVyYW5kKTtcbiAgdmFyIHJpZ2h0SGFuZEtleXMgPSBnZXRFbnVtZXJhYmxlS2V5cyhyaWdodEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kS2V5cy5sZW5ndGggJiYgbGVmdEhhbmRLZXlzLmxlbmd0aCA9PT0gcmlnaHRIYW5kS2V5cy5sZW5ndGgpIHtcbiAgICBsZWZ0SGFuZEtleXMuc29ydCgpO1xuICAgIHJpZ2h0SGFuZEtleXMuc29ydCgpO1xuICAgIGlmIChpdGVyYWJsZUVxdWFsKGxlZnRIYW5kS2V5cywgcmlnaHRIYW5kS2V5cykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBrZXlzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBsZWZ0SGFuZEtleXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIGxlZnRIYW5kRW50cmllcyA9IGdldEl0ZXJhdG9yRW50cmllcyhsZWZ0SGFuZE9wZXJhbmQpO1xuICB2YXIgcmlnaHRIYW5kRW50cmllcyA9IGdldEl0ZXJhdG9yRW50cmllcyhyaWdodEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kRW50cmllcy5sZW5ndGggJiYgbGVmdEhhbmRFbnRyaWVzLmxlbmd0aCA9PT0gcmlnaHRIYW5kRW50cmllcy5sZW5ndGgpIHtcbiAgICBsZWZ0SGFuZEVudHJpZXMuc29ydCgpO1xuICAgIHJpZ2h0SGFuZEVudHJpZXMuc29ydCgpO1xuICAgIHJldHVybiBpdGVyYWJsZUVxdWFsKGxlZnRIYW5kRW50cmllcywgcmlnaHRIYW5kRW50cmllcywgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAobGVmdEhhbmRLZXlzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgbGVmdEhhbmRFbnRyaWVzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgcmlnaHRIYW5kS2V5cy5sZW5ndGggPT09IDAgJiZcbiAgICAgIHJpZ2h0SGFuZEVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qIVxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhIHByaW1pdGl2ZS5cbiAqXG4gKiBUaGlzIGludGVudGlvbmFsbHkgcmV0dXJucyB0cnVlIGZvciBhbGwgb2JqZWN0cyB0aGF0IGNhbiBiZSBjb21wYXJlZCBieSByZWZlcmVuY2UsXG4gKiBpbmNsdWRpbmcgZnVuY3Rpb25zIGFuZCBzeW1ib2xzLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCc7XG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGRlZXBFcXVhbCA9IHJlcXVpcmUoJ2RlZXAtZXFsJylcbnZhciB0eXBlID0gcmVxdWlyZSgndHlwZS1kZXRlY3QnKVxuXG52YXIgREVGQVVMVF9UT0xFUkFOQ0UgPSAxZS02XG5cbi8qKlxuICogc21hbGwgdXRpbGl0eSBmdW5jdGlvbnNcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIgKHZhbCkge1xuICByZXR1cm4gdHlwZSh2YWwpID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiBib3RoTnVtYmVycyAobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIGlzTnVtYmVyKHJpZ2h0KSAmJiBpc051bWJlcihsZWZ0KVxufVxuXG5mdW5jdGlvbiBhbG1vc3RFcXVhbCAobGVmdCwgcmlnaHQsIHRvbCkge1xuICByZXR1cm4gTWF0aC5hYnMobGVmdCAtIHJpZ2h0KSA8PSB0b2xcbn1cblxuLyoqXG4gKiBNYWtlcyBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gYmUgcGFzc2VkIHRvIGRlZXBFcXVhbC5cbiAqIFRoZSByZXR1cm5lZCBmdW5jdGlvbiB3aWxsIHJldHVybiBudWxsIGlmIGJvdGggYXJndW1lbnRzIGFyZSBub3QgbnVtYmVycyxcbiAqIGluZGljYXRpbmcgdGhhdCBkZWVwRXF1YWwgc2hvdWxkIHByb2NlZWQgd2l0aCBvdGhlciBlcXVhbGl0eSBjaGVja3NcbiAqL1xuZnVuY3Rpb24gY29tcGFyYXRvciAodG9sZXJhbmNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAoYm90aE51bWJlcnMobGVmdCwgcmlnaHQpKSB7XG4gICAgICByZXR1cm4gYWxtb3N0RXF1YWwobGVmdCwgcmlnaHQsIHRvbGVyYW5jZSlcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgZ2xvYmFsIHRvbGVyYW5jZSBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHBhc3NlZCB0byBjaGFpLnVzZVxuICogQHNlZSBodHRwOi8vY2hhaWpzLmNvbS9ndWlkZS9wbHVnaW5zL1xuICovXG5mdW5jdGlvbiBjaGFpQWxtb3N0IChjdXN0b21Ub2xlcmFuY2UpIHtcbiAgdmFyIHN0YW5kYXJkVG9sZXJhbmNlID0gY3VzdG9tVG9sZXJhbmNlIHx8IERFRkFVTFRfVE9MRVJBTkNFXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjaGFpLCB1dGlscykge1xuICAgIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvblxuICAgIHZhciBmbGFnID0gdXRpbHMuZmxhZ1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBzaGFsbG93IGVxdWFsaXR5IGZ1bmN0aW9uIHRvIG92ZXJyaWRlXG4gICAgICogLmVxdWFsLCAuZXF1YWxzLCAuZXEgdGhhdCB0ZXN0cyAnYWxtb3N0JyBlcXVhbGl0eVxuICAgICAqIGlmIGJvdGggdmFsdWVzIGFyZSBudW1iZXJzIGFuZCBhICd0b2xlcmFuY2UnIGZsYWcgaXMgc2V0LlxuICAgICAqIFNlbmRzIHRvIGRlZXAgZXF1YWxpdHkgY2hlY2sgaWYgZGVlcCBmbGFnIGlzIHNldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG92ZXJyaWRlQXNzZXJ0RXF1YWwgKF9zdXBlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFzc2VydEVxdWFsICh2YWwsIG1zZykge1xuICAgICAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKVxuXG4gICAgICAgIHZhciBkZWVwID0gZmxhZyh0aGlzLCAnZGVlcCcpXG4gICAgICAgIHZhciB0b2xlcmFuY2UgPSBmbGFnKHRoaXMsICd0b2xlcmFuY2UnKVxuXG4gICAgICAgIGlmIChkZWVwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXFsKHZhbClcbiAgICAgICAgfSBlbHNlIGlmICh0b2xlcmFuY2UgJiYgYm90aE51bWJlcnModmFsLCB0aGlzLl9vYmopKSB7XG4gICAgICAgICAgdGhpcy5hc3NlcnQoYWxtb3N0RXF1YWwodmFsLCB0aGlzLl9vYmosIHRvbGVyYW5jZSksXG4gICAgICAgICAgICAnZXhwZWN0ZWQgI3t0aGlzfSB0byBhbG1vc3QgZXF1YWwgI3tleHB9JyxcbiAgICAgICAgICAgICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBhbG1vc3QgZXF1YWwgI3tleHB9JyxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIHRoaXMuX29iaixcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGRlZXAgZXF1YWxpdHkgZnVuY3Rpb24gdG8gb3ZlcnJpZGVcbiAgICAgKiAuZXFsLCAuZXFscyB0aGF0IHRlc3RzICdhbG1vc3QnIGVxdWFsaXR5IGlmIGJvdGggY29ycmVzcG9uZGluZ1xuICAgICAqIHZhbHVlcyBhcmUgbnVtYmVycyBhbmQgdG9sZXJhbmNlIGZsYWcgaXMgc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlcnJpZGVBc3NlcnRFcWwgKF9zdXBlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFzc2VydEVxbCAodmFsLCBtc2cpIHtcbiAgICAgICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZylcblxuICAgICAgICB2YXIgdG9sZXJhbmNlID0gZmxhZyh0aGlzLCAndG9sZXJhbmNlJylcblxuICAgICAgICBpZiAodG9sZXJhbmNlKSB7XG4gICAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICBkZWVwRXF1YWwodmFsLCB0aGlzLl9vYmosIHsgY29tcGFyYXRvcjogY29tcGFyYXRvcih0b2xlcmFuY2UpIH0pLFxuICAgICAgICAgICAgJ2V4cGVjdGVkICN7dGhpc30gdG8gZGVlcGx5IGFsbW9zdCBlcXVhbCAje2V4cH0nLFxuICAgICAgICAgICAgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGRlZXBseSBhbG1vc3QgZXF1YWwgI3tleHB9JyxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIHRoaXMuX29iaixcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAuYWxtb3N0KCkgbWV0aG9kLiBUbyBiZSB1c2VkIGF0IHRoZSBlbmQgb2YgdGhlIGNoYWluIGxpa2U6XG4gICAgICogZXhwZWN0KDQpLnRvLm5vdC5iZS5hbG1vc3QoNSwgMS41KS4gU2ltcGx5IGFkZHMgdG9sZXJhbmNlIGZsYWcgdGhlbiBjYWxsc1xuICAgICAqIC5lcXVhbC4gVGhpcyB3aWxsIHJlZGlyZWN0IHRvIC5lcWwgaWYgZGVlcCBmbGFnIHNldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ldGhvZCAodmFsLCB0b2xlcmFuY2VPdmVycmlkZSkge1xuICAgICAgdmFyIHRvbGVyYW5jZSA9IHRvbGVyYW5jZU92ZXJyaWRlIHx8IHN0YW5kYXJkVG9sZXJhbmNlXG5cbiAgICAgIGZsYWcodGhpcywgJ3RvbGVyYW5jZScsIHRvbGVyYW5jZSlcblxuICAgICAgcmV0dXJuIHRoaXMuZXF1YWwodmFsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIC5hbG1vc3QgY2hhaW5hYmxlIHByb3BlcnR5IHRvIGJlIHVzZWQgbGlrZTpcbiAgICAgKiBleHBlY3QoMy45OTk5OTk5OSkudG8uYWxtb3N0LmVxdWFsKDQpLiBTaW1wbHkgYWRkc1xuICAgICAqIHRvbGVyYW5jZSBmbGFnIHRvIGJlIHJlYWQgYnkgZXF1YWxpdHkgY2hlY2tpbmcgbWV0aG9kc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYWluaW5nQmVoYXZpb3IgKCkge1xuICAgICAgZmxhZyh0aGlzLCAndG9sZXJhbmNlJywgc3RhbmRhcmRUb2xlcmFuY2UpXG4gICAgfVxuXG4gICAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnYWxtb3N0JywgbWV0aG9kLCBjaGFpbmluZ0JlaGF2aW9yKVxuXG4gICAgQXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCgnZXF1YWwnLCBvdmVycmlkZUFzc2VydEVxdWFsKVxuICAgIEFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QoJ2VxdWFscycsIG92ZXJyaWRlQXNzZXJ0RXF1YWwpXG4gICAgQXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCgnZXEnLCBvdmVycmlkZUFzc2VydEVxdWFsKVxuXG4gICAgQXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCgnZXFsJywgb3ZlcnJpZGVBc3NlcnRFcWwpXG4gICAgQXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCgnZXFscycsIG92ZXJyaWRlQXNzZXJ0RXFsKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hhaUFsbW9zdFxuIiwiLypnbG9iYWxzIGRlZmluZSwgbW9kdWxlLCBTeW1ib2wgKi9cbi8qanNoaW50IC1XMDU2ICovXG5cbihmdW5jdGlvbiAoZ2xvYmFscykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHN0cmluZ3MsIG1lc3NhZ2VzLCBwcmVkaWNhdGVzLCBmdW5jdGlvbnMsIGFzc2VydCwgbm90LCBtYXliZSxcbiAgICAgIGNvbGxlY3Rpb25zLCBzbGljZSwgbmVnaW5mLCBwb3NpbmYsIGlzQXJyYXksIGhhdmVTeW1ib2xzO1xuXG4gIHN0cmluZ3MgPSB7XG4gICAgdjogJ3ZhbHVlJyxcbiAgICBuOiAnbnVtYmVyJyxcbiAgICBzOiAnc3RyaW5nJyxcbiAgICBiOiAnYm9vbGVhbicsXG4gICAgbzogJ29iamVjdCcsXG4gICAgdDogJ3R5cGUnLFxuICAgIGE6ICdhcnJheScsXG4gICAgYWw6ICdhcnJheS1saWtlJyxcbiAgICBpOiAnaXRlcmFibGUnLFxuICAgIGQ6ICdkYXRlJyxcbiAgICBmOiAnZnVuY3Rpb24nLFxuICAgIGw6ICdsZW5ndGgnXG4gIH07XG5cbiAgbWVzc2FnZXMgPSB7fTtcbiAgcHJlZGljYXRlcyA9IHt9O1xuXG4gIFtcbiAgICB7IG46ICdlcXVhbCcsIGY6IGVxdWFsLCBzOiAndicgfSxcbiAgICB7IG46ICd1bmRlZmluZWQnLCBmOiBpc1VuZGVmaW5lZCwgczogJ3YnIH0sXG4gICAgeyBuOiAnbnVsbCcsIGY6IGlzTnVsbCwgczogJ3YnIH0sXG4gICAgeyBuOiAnYXNzaWduZWQnLCBmOiBhc3NpZ25lZCwgczogJ3YnIH0sXG4gICAgeyBuOiAncHJpbWl0aXZlJywgZjogcHJpbWl0aXZlLCBzOiAndicgfSxcbiAgICB7IG46ICdpbmNsdWRlcycsIGY6IGluY2x1ZGVzLCBzOiAndicgfSxcbiAgICB7IG46ICd6ZXJvJywgZjogemVybyB9LFxuICAgIHsgbjogJ2luZmluaXR5JywgZjogaW5maW5pdHkgfSxcbiAgICB7IG46ICdudW1iZXInLCBmOiBudW1iZXIgfSxcbiAgICB7IG46ICdpbnRlZ2VyJywgZjogaW50ZWdlciB9LFxuICAgIHsgbjogJ2V2ZW4nLCBmOiBldmVuIH0sXG4gICAgeyBuOiAnb2RkJywgZjogb2RkIH0sXG4gICAgeyBuOiAnZ3JlYXRlcicsIGY6IGdyZWF0ZXIgfSxcbiAgICB7IG46ICdsZXNzJywgZjogbGVzcyB9LFxuICAgIHsgbjogJ2JldHdlZW4nLCBmOiBiZXR3ZWVuIH0sXG4gICAgeyBuOiAnZ3JlYXRlck9yRXF1YWwnLCBmOiBncmVhdGVyT3JFcXVhbCB9LFxuICAgIHsgbjogJ2xlc3NPckVxdWFsJywgZjogbGVzc09yRXF1YWwgfSxcbiAgICB7IG46ICdpblJhbmdlJywgZjogaW5SYW5nZSB9LFxuICAgIHsgbjogJ3Bvc2l0aXZlJywgZjogcG9zaXRpdmUgfSxcbiAgICB7IG46ICduZWdhdGl2ZScsIGY6IG5lZ2F0aXZlIH0sXG4gICAgeyBuOiAnc3RyaW5nJywgZjogc3RyaW5nLCBzOiAncycgfSxcbiAgICB7IG46ICdlbXB0eVN0cmluZycsIGY6IGVtcHR5U3RyaW5nLCBzOiAncycgfSxcbiAgICB7IG46ICdub25FbXB0eVN0cmluZycsIGY6IG5vbkVtcHR5U3RyaW5nLCBzOiAncycgfSxcbiAgICB7IG46ICdjb250YWlucycsIGY6IGNvbnRhaW5zLCBzOiAncycgfSxcbiAgICB7IG46ICdtYXRjaCcsIGY6IG1hdGNoLCBzOiAncycgfSxcbiAgICB7IG46ICdib29sZWFuJywgZjogYm9vbGVhbiwgczogJ2InIH0sXG4gICAgeyBuOiAnb2JqZWN0JywgZjogb2JqZWN0LCBzOiAnbycgfSxcbiAgICB7IG46ICdlbXB0eU9iamVjdCcsIGY6IGVtcHR5T2JqZWN0LCBzOiAnbycgfSxcbiAgICB7IG46ICdub25FbXB0eU9iamVjdCcsIGY6IG5vbkVtcHR5T2JqZWN0LCBzOiAnbycgfSxcbiAgICB7IG46ICdpbnN0YW5jZVN0cmljdCcsIGY6IGluc3RhbmNlU3RyaWN0LCBzOiAndCcgfSxcbiAgICB7IG46ICdpbnN0YW5jZScsIGY6IGluc3RhbmNlLCBzOiAndCcgfSxcbiAgICB7IG46ICdsaWtlJywgZjogbGlrZSwgczogJ3QnIH0sXG4gICAgeyBuOiAnYXJyYXknLCBmOiBhcnJheSwgczogJ2EnIH0sXG4gICAgeyBuOiAnZW1wdHlBcnJheScsIGY6IGVtcHR5QXJyYXksIHM6ICdhJyB9LFxuICAgIHsgbjogJ25vbkVtcHR5QXJyYXknLCBmOiBub25FbXB0eUFycmF5LCBzOiAnYScgfSxcbiAgICB7IG46ICdhcnJheUxpa2UnLCBmOiBhcnJheUxpa2UsIHM6ICdhbCcgfSxcbiAgICB7IG46ICdpdGVyYWJsZScsIGY6IGl0ZXJhYmxlLCBzOiAnaScgfSxcbiAgICB7IG46ICdkYXRlJywgZjogZGF0ZSwgczogJ2QnIH0sXG4gICAgeyBuOiAnZnVuY3Rpb24nLCBmOiBpc0Z1bmN0aW9uLCBzOiAnZicgfSxcbiAgICB7IG46ICdoYXNMZW5ndGgnLCBmOiBoYXNMZW5ndGgsIHM6ICdsJyB9LFxuICBdLm1hcChmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBuID0gZGF0YS5uO1xuICAgIG1lc3NhZ2VzW25dID0gJ0ludmFsaWQgJyArIHN0cmluZ3NbZGF0YS5zIHx8ICduJ107XG4gICAgcHJlZGljYXRlc1tuXSA9IGRhdGEuZjtcbiAgfSk7XG5cbiAgZnVuY3Rpb25zID0ge1xuICAgIGFwcGx5OiBhcHBseSxcbiAgICBtYXA6IG1hcCxcbiAgICBhbGw6IGFsbCxcbiAgICBhbnk6IGFueVxuICB9O1xuXG4gIGNvbGxlY3Rpb25zID0gWyAnYXJyYXknLCAnYXJyYXlMaWtlJywgJ2l0ZXJhYmxlJywgJ29iamVjdCcgXTtcbiAgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gIG5lZ2luZiA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgcG9zaW5mID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgaGF2ZVN5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nO1xuXG4gIGZ1bmN0aW9ucyA9IG1peGluKGZ1bmN0aW9ucywgcHJlZGljYXRlcyk7XG4gIGFzc2VydCA9IGNyZWF0ZU1vZGlmaWVkUHJlZGljYXRlcyhhc3NlcnRNb2RpZmllciwgYXNzZXJ0SW1wbCk7XG4gIG5vdCA9IGNyZWF0ZU1vZGlmaWVkUHJlZGljYXRlcyhub3RNb2RpZmllciwgbm90SW1wbCk7XG4gIG1heWJlID0gY3JlYXRlTW9kaWZpZWRQcmVkaWNhdGVzKG1heWJlTW9kaWZpZXIsIG1heWJlSW1wbCk7XG4gIGFzc2VydC5ub3QgPSBjcmVhdGVNb2RpZmllZE1vZGlmaWVyKGFzc2VydE1vZGlmaWVyLCBub3QpO1xuICBhc3NlcnQubWF5YmUgPSBjcmVhdGVNb2RpZmllZE1vZGlmaWVyKGFzc2VydE1vZGlmaWVyLCBtYXliZSk7XG5cbiAgY29sbGVjdGlvbnMuZm9yRWFjaChjcmVhdGVPZlByZWRpY2F0ZXMpO1xuICBjcmVhdGVPZk1vZGlmaWVycyhhc3NlcnQsIGFzc2VydE1vZGlmaWVyKTtcbiAgY3JlYXRlT2ZNb2RpZmllcnMobm90LCBub3RNb2RpZmllcik7XG4gIGNvbGxlY3Rpb25zLmZvckVhY2goY3JlYXRlTWF5YmVPZk1vZGlmaWVycyk7XG5cbiAgZXhwb3J0RnVuY3Rpb25zKG1peGluKGZ1bmN0aW9ucywge1xuICAgIGFzc2VydDogYXNzZXJ0LFxuICAgIG5vdDogbm90LFxuICAgIG1heWJlOiBtYXliZVxuICB9KSk7XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgZXF1YWxgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGxoc2AgYW5kIGByaHNgIGFyZSBzdHJpY3RseSBlcXVhbCwgd2l0aG91dCBjb2VyY2lvbi5cbiAgICogUmV0dXJucyBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBlcXVhbCAobGhzLCByaHMpIHtcbiAgICByZXR1cm4gbGhzID09PSByaHM7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIHVuZGVmaW5lZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNVbmRlZmluZWQgKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbnVsbGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgbnVsbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNOdWxsIChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgPT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBhc3NpZ25lZGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBhc3NpZ25lZCAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YSAhPT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYHByaW1pdGl2ZWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSBwcmltaXRpdmUgdHlwZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gcHJpbWl0aXZlIChkYXRhKSB7XG4gICAgdmFyIHR5cGU7XG5cbiAgICBzd2l0Y2ggKGRhdGEpIHtcbiAgICAgIGNhc2UgbnVsbDpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgY2FzZSBmYWxzZTpcbiAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdHlwZSA9IHR5cGVvZiBkYXRhO1xuICAgIHJldHVybiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCAoaGF2ZVN5bWJvbHMgJiYgdHlwZSA9PT0gJ3N5bWJvbCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgemVyb2AuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgemVybywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gemVybyAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgaW5maW5pdHlgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGluZmluaXR5LCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBpbmZpbml0eSAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhID09PSBuZWdpbmYgfHwgZGF0YSA9PT0gcG9zaW5mO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbnVtYmVyYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhIG51bWJlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbnVtYmVyIChkYXRhKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJyAmJiBkYXRhID4gbmVnaW5mICYmIGRhdGEgPCBwb3NpbmY7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBpbnRlZ2VyYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhbiBpbnRlZ2VyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBpbnRlZ2VyIChkYXRhKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJyAmJiBkYXRhICUgMSA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGV2ZW5gLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGFuIGV2ZW4gbnVtYmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBldmVuIChkYXRhKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJyAmJiBkYXRhICUgMiA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYG9kZGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gb2RkIG51bWJlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gb2RkIChkYXRhKSB7XG4gICAgcmV0dXJuIGludGVnZXIoZGF0YSkgJiYgZGF0YSAlIDIgIT09IDA7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBncmVhdGVyYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBsaHNgIGlzIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiBgcmhzYCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gZ3JlYXRlciAobGhzLCByaHMpIHtcbiAgICByZXR1cm4gbnVtYmVyKGxocykgJiYgbGhzID4gcmhzO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbGVzc2AuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgbGhzYCBpcyBhIG51bWJlciBsZXNzIHRoYW4gYHJoc2AsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGxlc3MgKGxocywgcmhzKSB7XG4gICAgcmV0dXJuIG51bWJlcihsaHMpICYmIGxocyA8IHJocztcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGJldHdlZW5gLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgbnVtYmVyIGJldHdlZW4gYHhgIGFuZCBgeWAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGJldHdlZW4gKGRhdGEsIHgsIHkpIHtcbiAgICBpZiAoeCA8IHkpIHtcbiAgICAgIHJldHVybiBncmVhdGVyKGRhdGEsIHgpICYmIGRhdGEgPCB5O1xuICAgIH1cblxuICAgIHJldHVybiBsZXNzKGRhdGEsIHgpICYmIGRhdGEgPiB5O1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgZ3JlYXRlck9yRXF1YWxgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGxoc2AgaXMgYSBudW1iZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGByaHNgLCBmYWxzZVxuICAgKiBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBncmVhdGVyT3JFcXVhbCAobGhzLCByaHMpIHtcbiAgICByZXR1cm4gbnVtYmVyKGxocykgJiYgbGhzID49IHJocztcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGxlc3NPckVxdWFsYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBsaHNgIGlzIGEgbnVtYmVyIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgcmhzYCwgZmFsc2VcbiAgICogb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbGVzc09yRXF1YWwgKGxocywgcmhzKSB7XG4gICAgcmV0dXJuIG51bWJlcihsaHMpICYmIGxocyA8PSByaHM7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBpblJhbmdlYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhIG51bWJlciBpbiB0aGUgcmFuZ2UgYHguLnlgLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBpblJhbmdlIChkYXRhLCB4LCB5KSB7XG4gICAgaWYgKHggPCB5KSB7XG4gICAgICByZXR1cm4gZ3JlYXRlck9yRXF1YWwoZGF0YSwgeCkgJiYgZGF0YSA8PSB5O1xuICAgIH1cblxuICAgIHJldHVybiBsZXNzT3JFcXVhbChkYXRhLCB4KSAmJiBkYXRhID49IHk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBwb3NpdGl2ZWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSBwb3NpdGl2ZSBudW1iZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIHBvc2l0aXZlIChkYXRhKSB7XG4gICAgcmV0dXJuIGdyZWF0ZXIoZGF0YSwgMCk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBuZWdhdGl2ZWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSBuZWdhdGl2ZSBudW1iZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIG5lZ2F0aXZlIChkYXRhKSB7XG4gICAgcmV0dXJuIGxlc3MoZGF0YSwgMCk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBzdHJpbmdgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgc3RyaW5nLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmcgKGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgZW1wdHlTdHJpbmdgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIHRoZSBlbXB0eSBzdHJpbmcsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGVtcHR5U3RyaW5nIChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgPT09ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbm9uRW1wdHlTdHJpbmdgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgbm9uLWVtcHR5IHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbm9uRW1wdHlTdHJpbmcgKGRhdGEpIHtcbiAgICByZXR1cm4gc3RyaW5nKGRhdGEpICYmIGRhdGEgIT09ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgY29udGFpbnNgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgc3RyaW5nIHRoYXQgY29udGFpbnMgYHN1YnN0cmluZ2AsIGZhbHNlXG4gICAqIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbnRhaW5zIChkYXRhLCBzdWJzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nKGRhdGEpICYmIGRhdGEuaW5kZXhPZihzdWJzdHJpbmcpICE9PSAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYG1hdGNoYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhIHN0cmluZyB0aGF0IG1hdGNoZXMgYHJlZ2V4YCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbWF0Y2ggKGRhdGEsIHJlZ2V4KSB7XG4gICAgcmV0dXJuIHN0cmluZyhkYXRhKSAmJiAhISBkYXRhLm1hdGNoKHJlZ2V4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGJvb2xlYW5gLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgYm9vbGVhbiB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gYm9vbGVhbiAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhID09PSBmYWxzZSB8fCBkYXRhID09PSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgb2JqZWN0YC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhIHBsYWluLW9sZCBKUyBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIG9iamVjdCAoZGF0YSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgZW1wdHlPYmplY3RgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGFuIGVtcHR5IG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gZW1wdHlPYmplY3QgKGRhdGEpIHtcbiAgICByZXR1cm4gb2JqZWN0KGRhdGEpICYmIE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYG5vbkVtcHR5T2JqZWN0YC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhIG5vbi1lbXB0eSBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIG5vbkVtcHR5T2JqZWN0IChkYXRhKSB7XG4gICAgcmV0dXJuIG9iamVjdChkYXRhKSAmJiBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgaW5zdGFuY2VTdHJpY3RgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGFuIGluc3RhbmNlIG9mIGBwcm90b3R5cGVgLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBpbnN0YW5jZVN0cmljdCAoZGF0YSwgcHJvdG90eXBlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgcHJvdG90eXBlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgaW5zdGFuY2VgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGFuIGluc3RhbmNlIG9mIGBwcm90b3R5cGVgLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEZhbGxzIGJhY2sgdG8gdGVzdGluZyBjb25zdHJ1Y3Rvci5uYW1lIGFuZCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAqIGlmIHRoZSBpbml0aWFsIGluc3RhbmNlb2YgdGVzdCBmYWlscy5cbiAgICovXG4gIGZ1bmN0aW9uIGluc3RhbmNlIChkYXRhLCBwcm90b3R5cGUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlU3RyaWN0KGRhdGEsIHByb3RvdHlwZSkgfHxcbiAgICAgICAgZGF0YS5jb25zdHJ1Y3Rvci5uYW1lID09PSBwcm90b3R5cGUubmFtZSB8fFxuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0ICcgKyBwcm90b3R5cGUubmFtZSArICddJztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGxpa2VgLlxuICAgKlxuICAgKiBUZXN0cyB3aGV0aGVyIGBkYXRhYCAncXVhY2tzIGxpa2UgYSBkdWNrJy4gUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBoYXMgYWxsXG4gICAqIG9mIHRoZSBwcm9wZXJ0aWVzIG9mIGBhcmNoZXR5cGVgICh0aGUgJ2R1Y2snKSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbGlrZSAoZGF0YSwgYXJjaGV0eXBlKSB7XG4gICAgdmFyIG5hbWU7XG5cbiAgICBmb3IgKG5hbWUgaW4gYXJjaGV0eXBlKSB7XG4gICAgICBpZiAoYXJjaGV0eXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KG5hbWUpID09PSBmYWxzZSB8fCB0eXBlb2YgZGF0YVtuYW1lXSAhPT0gdHlwZW9mIGFyY2hldHlwZVtuYW1lXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmplY3QoZGF0YVtuYW1lXSkgJiYgbGlrZShkYXRhW25hbWVdLCBhcmNoZXR5cGVbbmFtZV0pID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgYXJyYXlgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGFuIGFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheSAoZGF0YSkge1xuICAgIHJldHVybiBpc0FycmF5KGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgZW1wdHlBcnJheWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gZW1wdHkgYXJyYXksIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGVtcHR5QXJyYXkgKGRhdGEpIHtcbiAgICByZXR1cm4gYXJyYXkoZGF0YSkgJiYgZGF0YS5sZW5ndGggPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBub25FbXB0eUFycmF5YC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhIG5vbi1lbXB0eSBhcnJheSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbm9uRW1wdHlBcnJheSAoZGF0YSkge1xuICAgIHJldHVybiBhcnJheShkYXRhKSAmJiBncmVhdGVyKGRhdGEubGVuZ3RoLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGFycmF5TGlrZWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5TGlrZSAoZGF0YSkge1xuICAgIHJldHVybiBhc3NpZ25lZChkYXRhKSAmJiBncmVhdGVyT3JFcXVhbChkYXRhLmxlbmd0aCwgMCk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBpdGVyYWJsZWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gaXRlcmFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGl0ZXJhYmxlIChkYXRhKSB7XG4gICAgaWYgKCEgaGF2ZVN5bWJvbHMpIHtcbiAgICAgIC8vIEZhbGwgYmFjayB0byBgYXJyYXlMaWtlYCBwcmVkaWNhdGUgaW4gcHJlLUVTNiBlbnZpcm9ubWVudHMuXG4gICAgICByZXR1cm4gYXJyYXlMaWtlKGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBhc3NpZ25lZChkYXRhKSAmJiBpc0Z1bmN0aW9uKGRhdGFbU3ltYm9sLml0ZXJhdG9yXSk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBpbmNsdWRlc2AuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgY29udGFpbnMgYHZhbHVlYCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gaW5jbHVkZXMgKGRhdGEsIHZhbHVlKSB7XG4gICAgdmFyIGl0ZXJhdG9yLCBpdGVyYXRpb24sIGtleXMsIGxlbmd0aCwgaTtcblxuICAgIGlmICghIGFzc2lnbmVkKGRhdGEpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGhhdmVTeW1ib2xzICYmIGRhdGFbU3ltYm9sLml0ZXJhdG9yXSAmJiBpc0Z1bmN0aW9uKGRhdGEudmFsdWVzKSkge1xuICAgICAgaXRlcmF0b3IgPSBkYXRhLnZhbHVlcygpO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGl0ZXJhdGlvbiA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgICBpZiAoaXRlcmF0aW9uLnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICghIGl0ZXJhdGlvbi5kb25lKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChkYXRhW2tleXNbaV1dID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBoYXNMZW5ndGhgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGhhcyBhIGxlbmd0aCBwcm9wZXJ0eSB0aGF0IGVxdWFscyBgbGVuZ3RoYCwgZmFsc2VcbiAgICogb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzTGVuZ3RoIChkYXRhLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gYXNzaWduZWQoZGF0YSkgJiYgZGF0YS5sZW5ndGggPT09IGxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGRhdGVgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgdmFsaWQgZGF0ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gZGF0ZSAoZGF0YSkge1xuICAgIHJldHVybiBpbnN0YW5jZVN0cmljdChkYXRhLCBEYXRlKSAmJiBpbnRlZ2VyKGRhdGEuZ2V0VGltZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGZ1bmN0aW9uYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhIGZ1bmN0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBpc0Z1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgYXBwbHlgLlxuICAgKlxuICAgKiBNYXBzIGVhY2ggdmFsdWUgZnJvbSB0aGUgYGRhdGFgIHRvIHRoZSBjb3JyZXNwb25kaW5nIHByZWRpY2F0ZSBhbmQgcmV0dXJuc1xuICAgKiB0aGUgcmVzdWx0IGFycmF5LiBJZiB0aGUgc2FtZSBmdW5jdGlvbiBpcyB0byBiZSBhcHBsaWVkIGFjcm9zcyBhbGwgb2YgdGhlXG4gICAqIGRhdGEsIGEgc2luZ2xlIHByZWRpY2F0ZSBmdW5jdGlvbiBtYXkgYmUgcGFzc2VkIGluLlxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gYXBwbHkgKGRhdGEsIHByZWRpY2F0ZXMpIHtcbiAgICBhc3NlcnQuYXJyYXkoZGF0YSk7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihwcmVkaWNhdGVzKSkge1xuICAgICAgcmV0dXJuIGRhdGEubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlcyh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3NlcnQuYXJyYXkocHJlZGljYXRlcyk7XG4gICAgYXNzZXJ0Lmhhc0xlbmd0aChkYXRhLCBwcmVkaWNhdGVzLmxlbmd0aCk7XG5cbiAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHByZWRpY2F0ZXNbaW5kZXhdKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYG1hcGAuXG4gICAqXG4gICAqIE1hcHMgZWFjaCB2YWx1ZSBmcm9tIHRoZSBgZGF0YWAgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcHJlZGljYXRlIGFuZCByZXR1cm5zXG4gICAqIHRoZSByZXN1bHQgb2JqZWN0LiBTdXBwb3J0cyBuZXN0ZWQgb2JqZWN0cy4gSWYgdGhlIGBkYXRhYCBpcyBub3QgbmVzdGVkIGFuZFxuICAgKiB0aGUgc2FtZSBmdW5jdGlvbiBpcyB0byBiZSBhcHBsaWVkIGFjcm9zcyBhbGwgb2YgaXQsIGEgc2luZ2xlIHByZWRpY2F0ZVxuICAgKiBmdW5jdGlvbiBtYXkgYmUgcGFzc2VkIGluLlxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gbWFwIChkYXRhLCBwcmVkaWNhdGVzKSB7XG4gICAgYXNzZXJ0Lm9iamVjdChkYXRhKTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKHByZWRpY2F0ZXMpKSB7XG4gICAgICByZXR1cm4gbWFwU2ltcGxlKGRhdGEsIHByZWRpY2F0ZXMpO1xuICAgIH1cblxuICAgIGFzc2VydC5vYmplY3QocHJlZGljYXRlcyk7XG5cbiAgICByZXR1cm4gbWFwQ29tcGxleChkYXRhLCBwcmVkaWNhdGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcFNpbXBsZSAoZGF0YSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXN1bHRba2V5XSA9IHByZWRpY2F0ZShkYXRhW2tleV0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcENvbXBsZXggKGRhdGEsIHByZWRpY2F0ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICBPYmplY3Qua2V5cyhwcmVkaWNhdGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBwcmVkaWNhdGUgPSBwcmVkaWNhdGVzW2tleV07XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHByZWRpY2F0ZSkpIHtcbiAgICAgICAgaWYgKG5vdC5hc3NpZ25lZChkYXRhKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gISFwcmVkaWNhdGUubTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHByZWRpY2F0ZShkYXRhW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdChwcmVkaWNhdGUpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gbWFwQ29tcGxleChkYXRhW2tleV0sIHByZWRpY2F0ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgYWxsYFxuICAgKlxuICAgKiBDaGVjayB0aGF0IGFsbCBib29sZWFuIHZhbHVlcyBhcmUgdHJ1ZVxuICAgKiBpbiBhbiBhcnJheSAocmV0dXJuZWQgZnJvbSBgYXBwbHlgKVxuICAgKiBvciBvYmplY3QgKHJldHVybmVkIGZyb20gYG1hcGApLlxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gYWxsIChkYXRhKSB7XG4gICAgaWYgKGFycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm4gdGVzdEFycmF5KGRhdGEsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBhc3NlcnQub2JqZWN0KGRhdGEpO1xuXG4gICAgcmV0dXJuIHRlc3RPYmplY3QoZGF0YSwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGVzdEFycmF5IChkYXRhLCByZXN1bHQpIHtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoZGF0YVtpXSA9PT0gcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICFyZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiB0ZXN0T2JqZWN0IChkYXRhLCByZXN1bHQpIHtcbiAgICB2YXIga2V5LCB2YWx1ZTtcblxuICAgIGZvciAoa2V5IGluIGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFsdWUgPSBkYXRhW2tleV07XG5cbiAgICAgICAgaWYgKG9iamVjdCh2YWx1ZSkgJiYgdGVzdE9iamVjdCh2YWx1ZSwgcmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAhcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgYW55YFxuICAgKlxuICAgKiBDaGVjayB0aGF0IGF0IGxlYXN0IG9uZSBib29sZWFuIHZhbHVlIGlzIHRydWVcbiAgICogaW4gYW4gYXJyYXkgKHJldHVybmVkIGZyb20gYGFwcGx5YClcbiAgICogb3Igb2JqZWN0IChyZXR1cm5lZCBmcm9tIGBtYXBgKS5cbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIGFueSAoZGF0YSkge1xuICAgIGlmIChhcnJheShkYXRhKSkge1xuICAgICAgcmV0dXJuIHRlc3RBcnJheShkYXRhLCB0cnVlKTtcbiAgICB9XG5cbiAgICBhc3NlcnQub2JqZWN0KGRhdGEpO1xuXG4gICAgcmV0dXJuIHRlc3RPYmplY3QoZGF0YSwgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBtaXhpbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIG1vZGlmaWVyIGBhc3NlcnRgLlxuICAgKlxuICAgKiBUaHJvd3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFzc2VydE1vZGlmaWVyIChwcmVkaWNhdGUsIGRlZmF1bHRNZXNzYWdlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhc3NlcnRQcmVkaWNhdGUocHJlZGljYXRlLCBhcmd1bWVudHMsIGRlZmF1bHRNZXNzYWdlKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0UHJlZGljYXRlIChwcmVkaWNhdGUsIGFyZ3MsIGRlZmF1bHRNZXNzYWdlKSB7XG4gICAgdmFyIGFyZ0NvdW50ID0gcHJlZGljYXRlLmwgfHwgcHJlZGljYXRlLmxlbmd0aDtcbiAgICB2YXIgbWVzc2FnZSA9IGFyZ3NbYXJnQ291bnRdO1xuICAgIHZhciBFcnJvclR5cGUgPSBhcmdzW2FyZ0NvdW50ICsgMV07XG4gICAgYXNzZXJ0SW1wbChcbiAgICAgIHByZWRpY2F0ZS5hcHBseShudWxsLCBhcmdzKSxcbiAgICAgIG5vbkVtcHR5U3RyaW5nKG1lc3NhZ2UpID8gbWVzc2FnZSA6IGRlZmF1bHRNZXNzYWdlLFxuICAgICAgaXNGdW5jdGlvbihFcnJvclR5cGUpID8gRXJyb3JUeXBlIDogVHlwZUVycm9yXG4gICAgKTtcbiAgICByZXR1cm4gYXJnc1swXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydEltcGwgKHZhbHVlLCBtZXNzYWdlLCBFcnJvclR5cGUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IChFcnJvclR5cGUgfHwgRXJyb3IpKG1lc3NhZ2UgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgbW9kaWZpZXIgYG5vdGAuXG4gICAqXG4gICAqIE5lZ2F0ZXMgYHByZWRpY2F0ZWAuXG4gICAqL1xuICBmdW5jdGlvbiBub3RNb2RpZmllciAocHJlZGljYXRlKSB7XG4gICAgdmFyIG1vZGlmaWVkUHJlZGljYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5vdEltcGwocHJlZGljYXRlLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgbW9kaWZpZWRQcmVkaWNhdGUubCA9IHByZWRpY2F0ZS5sZW5ndGg7XG4gICAgcmV0dXJuIG1vZGlmaWVkUHJlZGljYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90SW1wbCAodmFsdWUpIHtcbiAgICByZXR1cm4gIXZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtb2RpZmllciBgbWF5YmVgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgcHJlZGljYXRlIGFyZ3VtZW50IGlzICBudWxsIG9yIHVuZGVmaW5lZCxcbiAgICogb3RoZXJ3aXNlIHByb3BhZ2F0ZXMgdGhlIHJldHVybiB2YWx1ZSBmcm9tIGBwcmVkaWNhdGVgLlxuICAgKi9cbiAgZnVuY3Rpb24gbWF5YmVNb2RpZmllciAocHJlZGljYXRlKSB7XG4gICAgdmFyIG1vZGlmaWVkUHJlZGljYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG5vdC5hc3NpZ25lZChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJlZGljYXRlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBtb2RpZmllZFByZWRpY2F0ZS5sID0gcHJlZGljYXRlLmxlbmd0aDtcblxuICAgIC8vIEhhY2tpc2hseSBpbmRpY2F0ZSB0aGF0IHRoaXMgaXMgYSBtYXliZS54eHggcHJlZGljYXRlLlxuICAgIC8vIFdpdGhvdXQgdGhpcyBmbGFnLCB0aGUgYWx0ZXJuYXRpdmUgd291bGQgYmUgdG8gaXRlcmF0ZVxuICAgIC8vIHRocm91Z2ggdGhlIG1heWJlIHByZWRpY2F0ZXMgb3IgdXNlIGluZGV4T2YgdG8gY2hlY2ssXG4gICAgLy8gd2hpY2ggd291bGQgYmUgdGltZS1jb25zdW1pbmcuXG4gICAgbW9kaWZpZWRQcmVkaWNhdGUubSA9IHRydWU7XG5cbiAgICByZXR1cm4gbW9kaWZpZWRQcmVkaWNhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZUltcGwgKHZhbHVlKSB7XG4gICAgaWYgKGFzc2lnbmVkKHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgbW9kaWZpZXIgYG9mYC5cbiAgICpcbiAgICogQXBwbGllcyB0aGUgY2hhaW5lZCBwcmVkaWNhdGUgdG8gbWVtYmVycyBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIG9mTW9kaWZpZXIgKHRhcmdldCwgdHlwZSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIG1vZGlmaWVkUHJlZGljYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbGxlY3Rpb24sIGFyZ3M7XG5cbiAgICAgIGNvbGxlY3Rpb24gPSBhcmd1bWVudHNbMF07XG5cbiAgICAgIGlmICh0YXJnZXQgPT09ICdtYXliZScgJiYgbm90LmFzc2lnbmVkKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXR5cGUoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb2xsZWN0aW9uID0gY29lcmNlQ29sbGVjdGlvbih0eXBlLCBjb2xsZWN0aW9uKTtcbiAgICAgIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbGxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICh0YXJnZXQgIT09ICdtYXliZScgfHwgYXNzaWduZWQoaXRlbSkpICYmXG4gICAgICAgICAgICAhcHJlZGljYXRlLmFwcGx5KG51bGwsIFsgaXRlbSBdLmNvbmNhdChhcmdzKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2Ugd2l0aCBmb3IuLi5vZiB3aGVuIEVTNiBpcyByZXF1aXJlZC5cbiAgICAgICAgICAgIHRocm93IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgbW9kaWZpZWRQcmVkaWNhdGUubCA9IHByZWRpY2F0ZS5sZW5ndGg7XG4gICAgcmV0dXJuIG1vZGlmaWVkUHJlZGljYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gY29lcmNlQ29sbGVjdGlvbiAodHlwZSwgY29sbGVjdGlvbikge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBhcnJheUxpa2U6XG4gICAgICAgIHJldHVybiBzbGljZS5jYWxsKGNvbGxlY3Rpb24pO1xuICAgICAgY2FzZSBvYmplY3Q6XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhjb2xsZWN0aW9uKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTW9kaWZpZWRQcmVkaWNhdGVzIChtb2RpZmllciwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZU1vZGlmaWVkRnVuY3Rpb25zKFsgbW9kaWZpZXIsIHByZWRpY2F0ZXMsIG9iamVjdCBdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU1vZGlmaWVkRnVuY3Rpb25zIChhcmdzKSB7XG4gICAgdmFyIG1vZGlmaWVyLCBvYmplY3QsIGZ1bmN0aW9ucywgcmVzdWx0O1xuXG4gICAgbW9kaWZpZXIgPSBhcmdzLnNoaWZ0KCk7XG4gICAgb2JqZWN0ID0gYXJncy5wb3AoKTtcbiAgICBmdW5jdGlvbnMgPSBhcmdzLnBvcCgpO1xuXG4gICAgcmVzdWx0ID0gb2JqZWN0IHx8IHt9O1xuXG4gICAgT2JqZWN0LmtleXMoZnVuY3Rpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBtb2RpZmllci5hcHBseShudWxsLCBhcmdzLmNvbmNhdChmdW5jdGlvbnNba2V5XSwgbWVzc2FnZXNba2V5XSkpXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVNb2RpZmllZE1vZGlmaWVyIChtb2RpZmllciwgbW9kaWZpZWQpIHtcbiAgICByZXR1cm4gY3JlYXRlTW9kaWZpZWRGdW5jdGlvbnMoWyBtb2RpZmllciwgbW9kaWZpZWQsIG51bGwgXSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPZlByZWRpY2F0ZXMgKGtleSkge1xuICAgIHByZWRpY2F0ZXNba2V5XS5vZiA9IGNyZWF0ZU1vZGlmaWVkRnVuY3Rpb25zKFxuICAgICAgWyBvZk1vZGlmaWVyLmJpbmQobnVsbCwgbnVsbCksIHByZWRpY2F0ZXNba2V5XSwgcHJlZGljYXRlcywgbnVsbCBdXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9mTW9kaWZpZXJzIChiYXNlLCBtb2RpZmllcikge1xuICAgIGNvbGxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgYmFzZVtrZXldLm9mID0gY3JlYXRlTW9kaWZpZWRNb2RpZmllcihtb2RpZmllciwgcHJlZGljYXRlc1trZXldLm9mKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU1heWJlT2ZNb2RpZmllcnMgKGtleSkge1xuICAgIG1heWJlW2tleV0ub2YgPSBjcmVhdGVNb2RpZmllZEZ1bmN0aW9ucyhcbiAgICAgIFsgb2ZNb2RpZmllci5iaW5kKG51bGwsICdtYXliZScpLCBwcmVkaWNhdGVzW2tleV0sIHByZWRpY2F0ZXMsIG51bGwgXVxuICAgICk7XG4gICAgYXNzZXJ0Lm1heWJlW2tleV0ub2YgPSBjcmVhdGVNb2RpZmllZE1vZGlmaWVyKGFzc2VydE1vZGlmaWVyLCBtYXliZVtrZXldLm9mKTtcbiAgICBhc3NlcnQubm90W2tleV0ub2YgPSBjcmVhdGVNb2RpZmllZE1vZGlmaWVyKGFzc2VydE1vZGlmaWVyLCBub3Rba2V5XS5vZik7XG4gIH1cblxuICBmdW5jdGlvbiBleHBvcnRGdW5jdGlvbnMgKGZ1bmN0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbnM7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZSAhPT0gbnVsbCAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsb2JhbHMuY2hlY2sgPSBmdW5jdGlvbnM7XG4gICAgfVxuICB9XG59KHRoaXMpKTtcbiIsImNvbnN0IGNoZWNrID0gcmVxdWlyZSgnY2hlY2stdHlwZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoY2hhaSkgPT4ge1xuXG4gIGNvbnN0IHR5cGVzID0gWydudW1iZXInLCAnc3RyaW5nJywgJ2Jvb2xlYW4nLCAnb2JqZWN0JywgJ2FycmF5JywgJ2RhdGUnLCAnZnVuY3Rpb24nXTtcblxuICB0eXBlcy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgY2hhaS5Bc3NlcnRpb24uYWRkTWV0aG9kKHR5cGUsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGNoZWNrW3R5cGVdKHRoaXMuX29iaiksXG4gICAgICAgIGBleHBlY3RlZCAje3RoaXN9IHRvIGJlICR7dHlwZX1gLFxuICAgICAgICBgZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgJHt0eXBlfWBcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG59OyIsImZ1bmN0aW9uIHBsdWdpbihjaGFpLCB1dGlscykge1xuXG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvbjtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gZW50cnkgaXMgYW4gZXZlbnQgZW1pdHRlci5cbiAgICogVXNlcyBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQgaWYgYXZhaWxhYmxlIHRvIHF1aWNrbHkgY2hlY2sgYGluc3RhbmNlb2ZgLiAgT3RoZXJ3aXNlLCBjaGVja3MgdGhhdCBjb21tb24gbWV0aG9kc1xuICAgKiB0byBldmVudCBlbWl0dGVycyBhcmUgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBHcmFjZWZ1bGx5IGhhbmRsZXMgY3VzdG9tIGltcGxlbWVudGF0aW9ucyBvZiBldmVudCBlbWl0dGVycyBldmVuIGlmIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCBhcmUgYXZhaWxhYmxlLFxuICAgKiBjaGVja2luZyBtZXRob2RzIGlmIHRoZSBlbWl0dGVyIGRvZXNuJ3QgaW5oZXJpdCBmcm9tIHRoZSBnbG9iYWwgZW1pdHRlci5cbiAgKi9cbiAgZnVuY3Rpb24gaXNFbWl0dGVyKCkge1xuICAgIC8vIEVhc3kgY2hlY2s6IGlmIE5vZGUncyBFdmVudEVtaXR0ZXIgb3Igd2luZG93LkV2ZW50RW1pdHRlciBleGlzdCwgY2hlY2sgaWYgdGhpcyBpcyBhbiBpbnN0YW5jZSBvZiBpdC5cbiAgICBpZih0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlciAhPT0gbnVsbCAmJiB0aGlzLl9vYmogaW5zdGFuY2VvZiBFdmVudEVtaXR0ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzc2VydCh0cnVlLCBcIlwiLCBcImV4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGFuIEV2ZW50RW1pdHRlclwiKTtcbiAgICB9XG5cbiAgICAvLyBFYXN5IGNoZWNrOiBpZiB0aGUgYnJvd3NlcidzIEV2ZW50VGFyZ2V0IGV4aXN0cywgY2hlY2sgaWYgdGhpcyBpcyBhbiBpbnN0YW5jZSBvZiBpdC5cbiAgICBpZih0eXBlb2YgRXZlbnRUYXJnZXQgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRUYXJnZXQgIT09IG51bGwgJiYgdGhpcy5fb2JqIGluc3RhbmNlb2YgRXZlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzc2VydCh0cnVlLCBcIlwiLCBcImV4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGFuIEV2ZW50VGFyZ2V0XCIpO1xuICAgIH1cblxuICAgIHZhciBvYmogPSB0aGlzLl9vYmo7XG5cbiAgICAvLyBDaGVjayBmb3IgTm9kZS5qcyBzdHlsZSBldmVudCBlbWl0dGVycyB3aXRoIFwib25cIiwgXCJlbWl0XCIsIGV0Yy5cbiAgICB2YXIgbm9kZSA9IFtcIm9uXCIsIFwiZW1pdFwiXS5ldmVyeShmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqW21ldGhvZF0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9KTtcblxuICAgIGlmKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzc2VydCh0cnVlLCBcIlwiLCBcImV4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGFuIEV2ZW50RW1pdHRlclwiKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgQnJvd3Nlci1iYXNlZCBldmVudCBlbWl0dGVycyB3aXRoIFwiYWRkRXZlbnRMaXN0ZW5lclwiLCBldGMuXG4gICAgdmFyIGJyb3dzZXIgPSBbXCJhZGRFdmVudExpc3RlbmVyXCIsIFwiZGlzcGF0Y2hFdmVudFwiLCBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIl0uZXZlcnkoZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9ialttZXRob2RdID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfSk7XG5cbiAgICBpZihicm93c2VyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hc3NlcnQodHJ1ZSwgXCJcIiwgXCJleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBhbiBFdmVudEVtaXR0ZXJcIik7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoZmFsc2UsIFwiZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhbiBFdmVudEVtaXR0ZXJcIiwgXCJcIik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KFwiZW1pdHRlclwiLCBpc0VtaXR0ZXIpO1xuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoXCJ0YXJnZXRcIiwgaXNFbWl0dGVyKTtcblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKFwiZW1pdFwiLCBmdW5jdGlvbihuYW1lLCBhcmdzKSB7XG4gICAgbmV3IEFzc2VydGlvbih0aGlzLl9vYmopLnRvLmJlLmFuLmVtaXR0ZXI7XG5cbiAgICBuZXcgQXNzZXJ0aW9uKG5hbWUpLnRvLmJlLmEoXCJzdHJpbmdcIik7XG4gICAgdmFyIG9iaiA9IHRoaXMuX29iajtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBhc3NlcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIF90aGlzLmFzc2VydC5hcHBseShfdGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSB1dGlscy5mbGFnKHRoaXMsICd0aW1lb3V0JykgfHwgMTUwMDtcblxuICAgIGlmKHV0aWxzLmZsYWcodGhpcywgJ25lZ2F0ZScpKSB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgZXZlbnQgZG9lc24ndCBmaXJlIGJlZm9yZSB0aW1lb3V0XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgIG9iai5vbihuYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZihkb25lKSB7IHJldHVybjsgfVxuICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBlbWl0IFwiK25hbWUrXCIuXCIpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYoZG9uZSkgeyByZXR1cm47IH1cbiAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGV2ZW50IGZpcmVzXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgIG9iai5vbihuYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZihkb25lKSB7IHJldHVybjsgfVxuICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYoZG9uZSkgeyByZXR1cm47IH1cbiAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwiZXhwZWN0ZWQgI3t0aGlzfSB0byBlbWl0IFwiK25hbWUrXCIuXCIpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG59XG5cbmlmICh0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwbHVnaW47XG59XG5lbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwbHVnaW47XG4gIH0pO1xufVxuZWxzZSB7XG4gIC8vIE90aGVyIGVudmlyb25tZW50ICh1c3VhbGx5IDxzY3JpcHQ+IHRhZyk6IHBsdWcgaW4gdG8gZ2xvYmFsIGNoYWkgaW5zdGFuY2UgZGlyZWN0bHkuXG4gIGNoYWkudXNlKHBsdWdpbik7XG59XG4iLCJpbXBvcnQgQ1NTIGZyb20ncXVpY2tjc3MnO3ZhciByZWdpc3RlcmVkO1xucmVnaXN0ZXJlZCA9IGZhbHNlO1xuZnVuY3Rpb24gcmVnaXN0ZXJBbmltYXRpb25zICgpIHtcbiAgaWYgKHJlZ2lzdGVyZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZWdpc3RlcmVkID0gdHJ1ZTtcbiAgQ1NTLmFuaW1hdGlvbignY2hlY2ttYXJrQW5pbWF0ZVN1Y2Nlc3NUaXAnLCB7XG4gICAgJzAlLCA1NCUnOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDNcbiAgICB9LFxuICAgICc3MCUnOiB7XG4gICAgICB3aWR0aDogMTQsXG4gICAgICBsZWZ0OiAtMixcbiAgICAgIHRvcDogOFxuICAgIH0sXG4gICAgJzg0JSc6IHtcbiAgICAgIHdpZHRoOiA1LFxuICAgICAgbGVmdDogNSxcbiAgICAgIHRvcDogMTBcbiAgICB9LFxuICAgICcxMDAlJzoge1xuICAgICAgd2lkdGg6IDgsXG4gICAgICBsZWZ0OiAzLFxuICAgICAgdG9wOiAxMFxuICAgIH1cbiAgfSk7XG4gIENTUy5hbmltYXRpb24oJ2NoZWNrbWFya0FuaW1hdGVTdWNjZXNzTG9uZycsIHtcbiAgICAnMCUsIDY1JSc6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgcmlnaHQ6IDEyLFxuICAgICAgdG9wOiAxMlxuICAgIH0sXG4gICAgJzg0JSc6IHtcbiAgICAgIHdpZHRoOiAxNCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiA3XG4gICAgfSxcbiAgICAnMTAwJSc6IHtcbiAgICAgIHdpZHRoOiAxMixcbiAgICAgIHJpZ2h0OiAyLFxuICAgICAgdG9wOiA4XG4gICAgfVxuICB9KTtcbiAgQ1NTLmFuaW1hdGlvbignY2hlY2ttYXJrQW5pbWF0ZUVycm9yJywge1xuICAgICcwJSwgNjUlJzoge1xuICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMC40KScsXG4gICAgICBvcGFjaXR5OiAwXG4gICAgfSxcbiAgICAnODQlJzoge1xuICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMS4xNSknXG4gICAgfSxcbiAgICAnMTAwJSc6IHtcbiAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDEpJ1xuICAgIH1cbiAgfSk7XG4gIENTUy5hbmltYXRpb24oJ2NoZWNrbWFya1JvdGF0ZVBsYWNlaG9sZGVyJywge1xuICAgICcwJSwgNSUnOiB7XG4gICAgICB0cmFuc2Zvcm06ICdyb3RhdGUoLTQ1ZGVnKSdcbiAgICB9LFxuICAgICcxMiUsIDEwMCUnOiB7XG4gICAgICB0cmFuc2Zvcm06ICdyb3RhdGUoLTQwNWRlZyknXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIENTUy5hbmltYXRpb24oJ2ZpZWxkRXJyb3JTaGFrZScsIHtcbiAgICAnMCUsIDUwJSc6IHtcbiAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTEwcHgpJ1xuICAgIH0sXG4gICAgJzI1JSwgNzUlJzoge1xuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgxMHB4KSdcbiAgICB9LFxuICAgICcxMDAlJzoge1xuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwcHgpJ1xuICAgIH1cbiAgfSk7XG59ZXhwb3J0IGRlZmF1bHQgcmVnaXN0ZXJBbmltYXRpb25zOyIsImltcG9ydCBJU18gZnJvbSdAZGFuaWVsa2FsZW4vaXMnO3ZhciBJUztcblxuSVMgPSBJU18uY3JlYXRlKCduYXRpdmVzJywgJ2RvbScpO1xuSVMubG9hZCh7XG4gIC8vIGZpZWxkOiAodGFyZ2V0KS0+IHRhcmdldCBhbmQgdGFyZ2V0IGluc3RhbmNlb2YgRmllbGRcbiAgcmVnZXg6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgUmVnRXhwO1xuICB9LFxuICBvYmplY3RhYmxlOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIElTLm9iamVjdCh0YXJnZXQpIHx8IElTLmZ1bmN0aW9uKHRhcmdldCk7XG4gIH1cbn0pO1xudmFyIElTJDEgPSBJUztleHBvcnQgZGVmYXVsdCBJUyQxOyIsIi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAod2luZG93LmNvbnNvbGUgPT0gbnVsbCkge1xuICB3aW5kb3cuY29uc29sZSA9IHt9O1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuXG5pZiAoY29uc29sZS5sb2cgPT0gbnVsbCkge1xuICBjb25zb2xlLmxvZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuXG5pZiAoY29uc29sZS53YXJuID09IG51bGwpIHtcbiAgY29uc29sZS53YXJuID0gY29uc29sZS5sb2c7XG59IiwiKGZ1bmN0aW9uKHQpe2lmKHQ9ZnVuY3Rpb24oZSxpLHMpe3JldHVybiBmdW5jdGlvbihuKXtpZighaVtuXSl0aHJvdyBFcnJvcihuK1wiIGlzIG5vdCBhIG1vZHVsZVwiKTtyZXR1cm4gZVtuXT9lW25dLmV4cG9ydHM6KGVbbl09e2V4cG9ydHM6e319LGVbbl0uZXhwb3J0cz1pW25dLmNhbGwocyx0LGVbbl0sZVtuXS5leHBvcnRzKSl9fSh7fSx7MDpmdW5jdGlvbih0LGUsaSl7dmFyIHM9MCxuPVwicHVzaCBwb3Agc2hpZnQgdW5zaGlmdCBzcGxpY2UgcmV2ZXJzZSBzb3J0XCIuc3BsaXQoXCIgXCIpLHI9e30saD17fSxvPVtcInt7XCIsXCJ9fVwiXSx1PU9iamVjdC5jcmVhdGUoe3NpbGVudDohMX0se3BsYWNlaG9sZGVyOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gb30sc2V0OmZ1bmN0aW9uKHQpe08uaUEodCkmJjI9PT10Lmxlbmd0aCYmKG89dCxDKCkpfX19KSxjPXtkZWxheTohMSx0aHJvdHRsZTohMSxzaW1wbGVTZWxlY3RvcjohMSxwcm9taXNlVHJhbnNmb3JtczohMSxkaXNwYXRjaEV2ZW50czohMSxzZW5kQXJyYXlDb3BpZXM6ITEsdXBkYXRlRXZlbklmU2FtZTohMSx1cGRhdGVPbkJpbmQ6ITB9LGE9T2JqZWN0LmRlZmluZVByb3BlcnR5LGY9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixsPW51bGwscD1mdW5jdGlvbigpe2lmKCFsKXt2YXIgdD1sPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7dC5pbml0RXZlbnQoXCJjaGFuZ2VcIiwhMCwhMSksdC5fc2I9ITB9cmV0dXJuIGx9LGQ9IShcImNsYXNzTmFtZVwiaW4gRWxlbWVudC5wcm90b3R5cGUmJmYoRWxlbWVudC5wcm90b3R5cGUsXCJjbGFzc05hbWVcIikuZ2V0KSx2PVwiaW5uZXJXaWR0aCBpbm5lckhlaWdodCBvdXRlcldpZHRoIG91dGVySGVpZ2h0IHNjcm9sbFggc2Nyb2xsWSBwYWdlWE9mZnNldCBwYWdlWU9mZnNldCBzY3JlZW5YIHNjcmVlblkgc2NyZWVuTGVmdCBzY3JlZW5Ub3BcIi5zcGxpdChcIiBcIiksYj1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnVBUyhlfHx0aGlzKX0sZz1mdW5jdGlvbigpe3JldHVyblwiXCIrICsrc30seT1mdW5jdGlvbigpe3JldHVybiBPYmplY3QuY3JlYXRlKG51bGwpfSxfPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKGkscyxuKXtyZXR1cm4gSChpLHMsbix0LGUpfX0sbT1mdW5jdGlvbih0LGUpe3JldHVybiB0LnNVfHwodC5zVT1uZXcgUihmdW5jdGlvbigpe3JldHVybiBlP3Quc1YodC5mRFYoKSx0LCEwKTp0LnVBUyh0KX0sXCJGdW5jXCIse30pKX0sRD1mdW5jdGlvbih0LGUpe3JldHVybiB0JiYtMSE9PXQuaW5kZXhPZihlKX0sTz17aUQ6ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXR9LGlBOmZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgQXJyYXl9LGlPOmZ1bmN0aW9uKHQpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0fSxpUzpmdW5jdGlvbih0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdH0saU46ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHR9LGlGOmZ1bmN0aW9uKHQpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHR9LGlCSTpmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFh9LGlCOmZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgUn0saXNJOmZ1bmN0aW9uKHQpe3JldHVybiBPLmlPKHQpJiZPLmlOKHQubGVuZ3RoKX0sRE06ZnVuY3Rpb24odCl7cmV0dXJuIHQubm9kZU5hbWUmJjE9PT10Lm5vZGVUeXBlfSxkSTpmdW5jdGlvbih0KXtyZXR1cm5cIklOUFVUXCI9PT0odD10Lm5vZGVOYW1lKXx8XCJURVhUQVJFQVwiPT09dHx8XCJTRUxFQ1RcIj09PXR9LGRSOmZ1bmN0aW9uKHQpe3JldHVyblwicmFkaW9cIj09PXQudHlwZX0sZEM6ZnVuY3Rpb24odCl7cmV0dXJuXCJjaGVja2JveFwiPT09dC50eXBlfSxlQzpmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIE5vZGVMaXN0fHx0IGluc3RhbmNlb2YgSFRNTENvbGxlY3Rpb258fHdpbmRvdy5qUXVlcnkmJnQgaW5zdGFuY2VvZiBqUXVlcnl9LGVBUzpmdW5jdGlvbih0KXt2YXIgZT10WzBdLnR5cGU7cmV0dXJuW10uZmlsdGVyLmNhbGwodCxmdW5jdGlvbih0KXtyZXR1cm4gdC50eXBlPT09ZX0pLmxlbmd0aD09PXQubGVuZ3RofSxkTjpmdW5jdGlvbih0KXtyZXR1cm4gTy5ETSh0KXx8dD09PXdpbmRvd3x8dD09PWRvY3VtZW50fX0sTT1mdW5jdGlvbih0LGUsaSl7dmFyIHM7cmV0dXJuKHM9Zih0LGUpKT8oaSYmKHMuY29uZmlndXJhYmxlPSEwKSxzKToodD1PYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpP00odCxlLCEwKTp2b2lkIDB9LEk9ZnVuY3Rpb24odCxlLGkpe3ZhciBzO2lmKHQuT0R8fCh0Lk9EPU0oZSx0LnByKSksaSluLmZvckVhY2goZnVuY3Rpb24oaSl7cmV0dXJuIGEoZSxpLHtjb25maWd1cmFibGU6ITAsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgcz1BcnJheS5wcm90b3R5cGVbaV0uYXBwbHkoZSxhcmd1bWVudHMpO3JldHVybiB0LnVBUyh0KSxzfX0pfSk7ZWxzZSBpZihcIlByb3h5XCI9PT10LnR5cGUpe3ZhciBoPXQub1I9dC52YWx1ZTtpZih0LnZhbHVlPXtyZXN1bHQ6bnVsbCxhcmdzOm51bGx9LE8uaUYoaCkpe3ZhciBvPVtdLnNsaWNlLHU9cz1mdW5jdGlvbigpe3ZhciBpPW8uY2FsbChhcmd1bWVudHMpO3JldHVybiB0LnZhbHVlLmFyZ3M9aT10LnRmUz90LnRmUyhpKTppLHQudmFsdWUucmVzdWx0PWk9aC5hcHBseShlLGkpLHQudUFTKHQpLGl9O2EoZSx0LnByLHtjb25maWd1cmFibGU6dC5pc0w9ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHV9LHNldDpmdW5jdGlvbihlKXtPLmlGKGUpP2UhPT1oJiYoZSE9PXMmJihoPXQub1I9ZSksdSE9PXMmJih1PXMpKTp1PWV9fSl9fWVsc2UgaWYoIShEKHQudHlwZSxcIkRPTVwiKXx8dC5vYmplY3Q9PT13aW5kb3cmJkQodix0LnByKSkpeyhpPXQuT0R8fHIpLmdldCYmKHQuT0c9aS5nZXQuYmluZChlKSksaS5zZXQmJih0Lk9TPWkuc2V0LmJpbmQoZSkpO3ZhciBjPShjPWkuY29uZmlndXJhYmxlKSYmZS5jb25zdHJ1Y3RvciE9PUNTU1N0eWxlRGVjbGFyYXRpb247aWYoZCYmdC5ETSYmdC5wciBpbiBlLmNsb25lTm9kZSghMSkmJih0Lk9EPWM9ITEsdC5pc0w9ITAsdC5PRz1mdW5jdGlvbigpe3JldHVybiB0Lm9iamVjdFt0LnByXX0sdC5PUz1mdW5jdGlvbihlKXtyZXR1cm4gdC5vYmplY3RbdC5wcl09ZX0pLGMpe2M9XCJBcnJheVwiPT09dC50eXBlO3ZhciBmPSF0Lk9TJiYhYzthKGUsdC5wcix7Y29uZmlndXJhYmxlOnQuaXNMPSEwLGVudW1lcmFibGU6aS5lbnVtZXJhYmxlLGdldDp0Lk9HfHxmdW5jdGlvbigpe3JldHVybiB0LnZhbHVlfSxzZXQ6ZnVuY3Rpb24oZSl7dC5zVihlLHQsZil9fSksYyYmSSh0LGVbdC5wcl0sITApfX19LGo9ZnVuY3Rpb24odCxlLGkpe2lmKGkpe3ZhciBzPVtdO2Zvcih0PTAsaT1uLmxlbmd0aDt0PGk7dCsrKXt2YXIgcj1uW3RdO3MucHVzaChkZWxldGUgZVtyXSl9cmV0dXJuIHN9cmV0dXJuKGk9dC5PRCkuc2V0fHxpLmdldHx8KGkudmFsdWU9dC5vUnx8dC52YWx1ZSksYShlLHQucHIsaSl9LFM9ZnVuY3Rpb24odCl7dmFyIGUsaT15KCk7Zm9yKGUgaW4gdClpW2VdPXRbZV07cmV0dXJuIGl9LEU9ZnVuY3Rpb24odCxlKXt2YXIgaSxzPU9iamVjdC5rZXlzKGUpLG49MDtmb3IoaT1zLmxlbmd0aDtuPGk7bisrKXt2YXIgcj1zW25dO3Rbcl09ZVtyXX19LFA9e2dldDpmdW5jdGlvbih0LGUsaSxzKXtyZXR1cm4gZT9oW3QuX3NiX0lEXTpzJiZ0WzBdLl9zYl9tYXAmJihlPWhbdFswXS5fc2JfbWFwW2ldXSkuZ0I/ZS5nQjp0Ll9zYl9tYXAmJnQuX3NiX21hcFtpXT9oW3QuX3NiX21hcFtpXV06dm9pZCAwfSxzZXQ6ZnVuY3Rpb24odCxlKXtpZihlKWEodC5vYmplY3QsXCJfc2JfSURcIix7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnQuSUR9KTtlbHNle3ZhciBpPXQuc2U7dC5vYmplY3QuX3NiX21hcD90Lm9iamVjdC5fc2JfbWFwW2ldPXQuSUQ6KGU9e30sZVtpXT10LklELGEodC5vYmplY3QsXCJfc2JfbWFwXCIse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTplfSkpfX19LFYsTj0vWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csQT1WPW51bGwsQz1mdW5jdGlvbigpe3ZhciB0PXUucGxhY2Vob2xkZXJbMF0ucmVwbGFjZShOLFwiXFxcXCQmXCIpLGU9dS5wbGFjZWhvbGRlclsxXS5yZXBsYWNlKE4sXCJcXFxcJCZcIiksaT1cIlteXCIrZStcIl0rXCI7QT1uZXcgUmVnRXhwKHQrXCIoXCIraStcIilcIitlLFwiZ1wiKSxWPW5ldyBSZWdFeHAoXCJcIit0K2krZSxcImdcIil9O0MoKTt2YXIgeD1mdW5jdGlvbih0LGUsaSl7dmFyIHMsbixyPVwiXCIsaD1zPTA7Zm9yKG49dC5sZW5ndGg7czxuO2g9KytzKXIrPXRbaF0saVtoXSYmKHIrPWVbaVtoXV0pO3JldHVybiByfSxrPWZ1bmN0aW9uKHQsZSxpKXtudWxsPT10W2ldJiYodFtpXT1bXSksdFtpXS5wdXNoKGUpfSxCPWZ1bmN0aW9uKHQsZSl7dmFyIGkscyxuLHI9MDtmb3Iocz0odD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LmNoaWxkTm9kZXMpKS5sZW5ndGg7cjxzO3IrKyl7dmFyIGg9dFtyXTtpZigzIT09aC5ub2RlVHlwZSlCKGgsZSk7ZWxzZSBpZihoLnRleHRDb250ZW50Lm1hdGNoKFYpKXt2YXIgbz1oLnRleHRDb250ZW50LnNwbGl0KEEpO2lmKDM9PT1vLmxlbmd0aCYmXCJcIj09PW9bMF0rb1syXSlrKGUsaCxvWzFdKTtlbHNle3ZhciB1PWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxjPWk9MDtmb3Iobj1vLmxlbmd0aDtpPG47Yz0rK2kpe3ZhciBhPW9bY10sZj11LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGEpKTtjJTImJmsoZSxmLGEpfWgucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodSxoKX19fX0sRj1mdW5jdGlvbih0KXt0aHJvdyBFcnJvcihcIlNpbXBseUJpbmQ6IFwiKyhUW3RdfHx0KSl9LEc9ZnVuY3Rpb24odCxlKXt1LnNpbGVudHx8KGU9TChlKSx0PVRbdF0sY29uc29sZS53YXJuKFwiU2ltcGx5QmluZDogXCIrdCtcIlxcblxcblwiK2UpKX0sdz1mdW5jdGlvbih0KXtGKFwiSW52YWxpZCBhcmd1bWVudC9zIChcIit0K1wiKVwiLCEwKX0sTD1mdW5jdGlvbih0KXtyZXR1cm4oRXJyb3IoKS5zdGFja3x8XCJcIikuc3BsaXQoXCJcXG5cIikuc2xpY2UodCszKS5qb2luKFwiXFxuXCIpfSxUPXtlcklQOlwiU2ltcGx5QmluZCgpIGFuZCAudG8oKSBvbmx5IGFjY2VwdCBhIGZ1bmN0aW9uLCBhbiBhcnJheSwgYSBib3VuZCBvYmplY3QsIGEgc3RyaW5nLCBvciBhIG51bWJlci5cIixlckZOOlwiT25seSBmdW5jdGlvbnMgYXJlIGFsbG93ZWQgZm9yIC50cmFuc2Zvcm0vLmNvbmRpdGlvbi9BbGwoKVwiLGVyRVY6XCJJbnZhbGlkIGFyZ3VtZW50IG51bWJlciBpbiAub2ZFdmVudCgpXCIsZW1wdHlMaXN0OlwiRW1wdHkgY29sbGVjdGlvbiBwcm92aWRlZFwiLGVyT0Q6XCJZb3UgY2FuIG9ubHkgcGFzcyBhIHNpbmdsZSBET00gZWxlbWVudCB0byBhIGJpbmRpbmdcIixlck1YOlwiJ2NoZWNrZWQnIG9mIE1peGVkIGxpc3Qgb2YgZWxlbWVudCBjYW5ub3QgYmUgYm91bmRcIn0sSD1mdW5jdGlvbih0LGUsaSxzLG4pe3JldHVybih0fHwwPT09dCkmJihPLmlTKHQpfHxPLmlOKHQpfHxPLmlGKHQpfHx0IGluc3RhbmNlb2YgQXJyYXkpfHxPLmlCSSh0KXx8RihcImVySVBcIiksIU8uaU8odCl8fHQgaW5zdGFuY2VvZiBBcnJheT8oZT1uZXcgWChlKSxlLnNvPWksZS5JUz1zLGUuY0M9bix0PU8uaUYodCk/ZS5zUyh0LCEwKTplLnNQKHQpKTp0PW4/bih0KTp0LnNDKCksdH07SC52ZXJzaW9uPVwiMS4xNS44XCIsSC5zZXR0aW5ncz11LEguZGVmYXVsdE9wdGlvbnM9YyxILnVuQmluZEFsbD1mdW5jdGlvbih0LGUpe3ZhciBpO2lmKHQmJihPLmlPKHQpfHxPLmlGKHQpKSl7Ty5pc0kodCkmJiF0Ll9zYl9JRCYmdFswXSYmTy5ETSh0WzBdKSYmKHQ9dFswXSk7dmFyIHM9dC5fc2JfbWFwO2lmKHQuX3NiX0lEJiZoW3QuX3NiX0lEXS5yQVMoZSkscylmb3IoaSBpbiBzKXQ9c1tpXSxoW3RdLnJBUyhlKX19O3ZhciBSPWZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gRSh0aGlzLGkpLHRoaXMub0Q9dGhpcy5zbz90aGlzLm9wdGlvbnM6Yyx0aGlzLnR5cGU9ZSx0aGlzLm9iamVjdD10LHRoaXMuSUQ9ZygpLHRoaXMuc3Vicz1bXSx0aGlzLnNNPXkoKSx0aGlzLnBNPXkoKSx0aGlzLmF0RVY9W10sXCJQcm94eVwiPT09dGhpcy50eXBlJiYodGhpcy5zVj1iKSx0aGlzLm1DJiYodGhpcy5jSD15KCksdGhpcy5vYmplY3QuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIGk9dC5jSFtlLnZhbHVlXT1IKFwiY2hlY2tlZFwiKS5vZihlKS5fO2kuYVModCksaS5zTVt0LklEXS50Rj1mdW5jdGlvbigpe3JldHVybiBpfSxpLmdCPXR9fSh0aGlzKSkpLFwiRXZlbnRcIj09PXRoaXMudHlwZXx8XCJGdW5jXCI9PT10aGlzLnR5cGUmJnRoaXMuSVN8fChcIlBob2xkZXJcIj09PXRoaXMudHlwZT8oZT10aGlzLmRlJiYhRCh0aGlzLmRlLFwibXVsdGlcIik/dGhpcy5kZStcIjpcIit0aGlzLnByOnRoaXMucHIsKHQ9dGhpcy5wQj1IKGUpLm9mKHQpLl8pLnNQSCgpLHRoaXMudmFsdWU9dC5wVkxbdGhpcy5QaF0sdC50eE4mJih0aGlzLnR4Tj10LnR4Tlt0aGlzLlBoXSkpOih0aGlzLnZhbHVlPXQ9dGhpcy5mRFYoKSxcIk9iamVjdFByb3BcIiE9PXRoaXMudHlwZXx8Ty5pRCh0KXx8Zih0aGlzLm9iamVjdCx0aGlzLnByKXx8KHRoaXMub2JqZWN0W3RoaXMucHJdPXQpLEkodGhpcyx0aGlzLm9iamVjdCkpKSx0aGlzLmFFVigpLGhbdGhpcy5JRF09dGhpc307Ui5wcm90b3R5cGU9e2FTOmZ1bmN0aW9uKHQsZSxpLHMpe3ZhciBuO2lmKHQuaXNNdWx0aSl7dmFyIHI9dC5iaW5kaW5ncztmb3IodD0wLG49ci5sZW5ndGg7dDxuO3QrKyl7dmFyIGg9clt0XTt0aGlzLmFTKGgsZSxpLHMpfX1lbHNlIGlmKHRoaXMuc01bdC5JRF0pdmFyIG89ITA7ZWxzZSB0LnBNW3RoaXMuSURdPXRoaXMsdGhpcy5zdWJzLnVuc2hpZnQodCksKG49dGhpcy5zTVt0LklEXT15KCkpLnVPPWksbi5vcHRzPVMoZSksKHN8fFwiRXZlbnRcIj09PXRoaXMudHlwZXx8XCJQcm94eVwiPT09dGhpcy50eXBlfHxcIkFycmF5XCI9PT10aGlzLnR5cGUpJiYobi5vcHRzLnVwZGF0ZUV2ZW5JZlNhbWU9ITApLG4uVlI9XCJGdW5jXCI9PT10LnR5cGU/XCJwc1wiOlwidmFsdWVcIjtyZXR1cm4gb30sclM6ZnVuY3Rpb24odCxlKXt2YXIgaTtpZih0LmlzTXVsdGkpe3ZhciBzPXQuYmluZGluZ3M7Zm9yKHQ9MCxpPXMubGVuZ3RoO3Q8aTt0Kyspe3ZhciBuPXNbdF07dGhpcy5yUyhuLGUpfX1lbHNlIHRoaXMuc01bdC5JRF0mJih0aGlzLnN1YnMuc3BsaWNlKHRoaXMuc3Vicy5pbmRleE9mKHQpLDEpLGRlbGV0ZSB0aGlzLnNNW3QuSURdLGRlbGV0ZSB0LnBNW3RoaXMuSURdKSxlJiYodC5yUyh0aGlzKSxkZWxldGUgdGhpcy5wTVt0LklEXSk7MD09PXRoaXMuc3Vicy5sZW5ndGgmJjA9PT1PYmplY3Qua2V5cyh0aGlzLnBNKS5sZW5ndGgmJnRoaXMuREVTKCl9LHJBUzpmdW5jdGlvbih0KXt2YXIgZSxpPXRoaXMuc3Vicy5zbGljZSgpLHM9MDtmb3IoZT1pLmxlbmd0aDtzPGU7cysrKXt2YXIgbj1pW3NdO3RoaXMuclMobix0KX19LERFUzpmdW5jdGlvbigpe3ZhciB0O2lmKGRlbGV0ZSBoW3RoaXMuSURdLHRoaXMuclBJKCksXCJFdmVudFwiPT09dGhpcy50eXBlKXt2YXIgZT10aGlzLmF0RVYsaT0wO2Zvcih0PWUubGVuZ3RoO2k8dDtpKyspe3ZhciBzPWVbaV07dGhpcy51ckVWRShzKX19ZWxzZVwiRnVuY1wiPT09dGhpcy50eXBlJiZkZWxldGUgdGhpcy5vYmplY3QuX3NiX0lEO3RoaXMuaXNMJiZ0aGlzLk9EJiZqKHRoaXMsdGhpcy5vYmplY3QpLFwiQXJyYXlcIj09PXRoaXMudHlwZSYmaih0aGlzLHRoaXMudmFsdWUsITApLHRoaXMub2JqZWN0Ll9zYl9tYXAmJihkZWxldGUgdGhpcy5vYmplY3QuX3NiX21hcFt0aGlzLnNlXSwwPT09T2JqZWN0LmtleXModGhpcy5vYmplY3QuX3NiX21hcCkubGVuZ3RoJiZkZWxldGUgdGhpcy5vYmplY3QuX3NiX21hcCl9LGZEVjpmdW5jdGlvbigpe3ZhciB0LGU9dGhpcy50eXBlO3N3aXRjaCghMSl7Y2FzZVwiRnVuY1wiIT09ZTpyZXR1cm4gdGhpcy5vYmplY3QoKTtjYXNlXCJET01BdHRyXCIhPT1lOnJldHVybiB0aGlzLm9iamVjdC5nZXRBdHRyaWJ1dGUodGhpcy5wcil8fFwiXCI7Y2FzZSF0aGlzLm1DOnZhciBpPVtdLHM9dGhpcy5jSDtmb3IodCBpbiBzKWlmKHNbdF0ub2JqZWN0LmNoZWNrZWQpe2lmKFwiRE9NUmFkaW9cIj09PWUpcmV0dXJuIHQ7aS5wdXNoKHQpfXJldHVybiBpO2RlZmF1bHQ6cmV0dXJuIHRoaXMub2JqZWN0W3RoaXMucHJdfX0sc1Y6ZnVuY3Rpb24odCxlLGkscyl7aWYoZXx8KGU9dGhpcyksdGhpcy50ZlMmJih0PXRoaXMudGZTKHQpKSwhaSlzd2l0Y2godGhpcy50eXBlKXtjYXNlXCJPYmplY3RQcm9wXCI6aWYodGhpcy5pc0wpaWYodGhpcy5kSSlpZihzKXtpZih0IT09dGhpcy5PRygpKXt2YXIgbj10aGlzLm9iamVjdC5zZWxlY3Rpb25TdGFydDt0aGlzLk9TKHQpLG4mJnRoaXMub2JqZWN0LnNldFNlbGVjdGlvblJhbmdlKG4sbil9fWVsc2UgdGhpcy5PUyh0KSx1LmRpc3BhdGNoRXZlbnRzJiZ0aGlzLm9iamVjdC5kaXNwYXRjaEV2ZW50KHAoKSk7ZWxzZSB0aGlzLk9TJiZ0aGlzLk9TKHQpO2Vsc2UgdCE9PXRoaXMudmFsdWUmJih0aGlzLm9iamVjdFt0aGlzLnByXT10KTticmVhaztjYXNlXCJQaG9sZGVyXCI6aWYocz10aGlzLnBCLHMucFZMW3RoaXMuUGhdPXQsbj14KHMucENULHMucFZMLHMucElNKSx0aGlzLnR4TiYmdCE9PXRoaXMudmFsdWUpe3ZhciByPXRoaXMudHhOLGg9MDtmb3IoaT1yLmxlbmd0aDtoPGk7aCsrKXt2YXIgbz1yW2hdO28udGV4dENvbnRlbnQ9dH19XCJ0ZXh0Q29udGVudFwiIT09dGhpcy5wciYmcy5zVihuLGUpO2JyZWFrO2Nhc2VcIkFycmF5XCI6dCE9PXRoaXMudmFsdWUmJihPLmlBKHQpfHwodD1BcnJheS5wcm90b3R5cGUuY29uY2F0KHQpKSxqKHRoaXMsdGhpcy52YWx1ZSwhMCksSSh0aGlzLHQ9dC5zbGljZSgpLCEwKSx0aGlzLk9TJiZ0aGlzLk9TKHQpKTticmVhaztjYXNlXCJGdW5jXCI6bj10aGlzLnBzLHRoaXMucHM9dCx0PXRoaXMub2JqZWN0KHQsbik7YnJlYWs7Y2FzZVwiRXZlbnRcIjp0aGlzLmlFPSEwLHRoaXMuZUUodCksdGhpcy5pRT0hMTticmVhaztjYXNlXCJET01SYWRpb1wiOmlmKHRoaXMubUMpaWYocz1PLmlCKHQpP3Q6dGhpcy5jSFt0XSlmb3IoaCBpbiB0PXMub2JqZWN0LnZhbHVlLG49dGhpcy5jSCkoaT1uW2hdKS5zVihpLklEPT09cy5JRCxlKTtlbHNlIHQ9dGhpcy52YWx1ZTtlbHNle2lmKCh0PSEhdCk9PT10aGlzLnZhbHVlKXJldHVybjt0aGlzLm9iamVjdC5jaGVja2VkIT09dCYmKHRoaXMub2JqZWN0LmNoZWNrZWQ9dCksdCYmdS5kaXNwYXRjaEV2ZW50cyYmdGhpcy5vYmplY3QuZGlzcGF0Y2hFdmVudChwKCkpfWJyZWFrO2Nhc2VcIkRPTUNoZWNrYm94XCI6aWYodGhpcy5tQyl7Zm9yKGg9IU8uaUIodCksaT1zPTAscj0odD1bXS5jb25jYXQodCkpLmxlbmd0aDtzPHI7aT0rK3Mpbz10W2ldLHRbaV09Ty5pQihvKT9vOnRoaXMuY0hbb107cj1bXSxvPXRoaXMuY0g7Zm9yKG4gaW4gbylpPW9bbl0scz1oP0QodCxpKTppLnZhbHVlLGkuc1YocyxlKSxzJiZyLnB1c2gobik7dD1yfWVsc2V7aWYoKHQ9ISF0KT09PXRoaXMudmFsdWUpcmV0dXJuO3RoaXMub2JqZWN0LmNoZWNrZWQhPT10JiYodGhpcy5vYmplY3QuY2hlY2tlZD10LHUuZGlzcGF0Y2hFdmVudHMmJnRoaXMub2JqZWN0LmRpc3BhdGNoRXZlbnQocCgpKSl9YnJlYWs7Y2FzZVwiRE9NQXR0clwiOnRoaXMub2JqZWN0LnNldEF0dHJpYnV0ZSh0aGlzLnByLHQpfXRoaXMudmFsdWU9dCx0aGlzLnVBUyhlKX0sdUFTOmZ1bmN0aW9uKHQpe3ZhciBlLGk7aWYoaT0oZT10aGlzLnN1YnMpLmxlbmd0aClmb3IoO2ktLTspdGhpcy51UyhlW2ldLHQpfSx1UzpmdW5jdGlvbih0LGUsaSl7dmFyIHM7aWYoIShlPT09dHx8ZSE9PXRoaXMmJmUuc01bdC5JRF0pKXt2YXIgbj10aGlzLnNNW3QuSURdO2lmKCFuLmRMfHwhbi5kTFtlLklEXSl7aWYobi5vcHRzLnRocm90dGxlKXt2YXIgcj0oaT0rbmV3IERhdGUpLW4ubFU7aWYocjxuLm9wdHMudGhyb3R0bGUpcmV0dXJuIGNsZWFyVGltZW91dChuLnVUKSxuLnVUPXNldFRpbWVvdXQoZnVuY3Rpb24oaSl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoaS5zTVt0LklEXSlyZXR1cm4gaS51Uyh0LGUpfX0odGhpcyksbi5vcHRzLnRocm90dGxlLXIpO24ubFU9aX1lbHNlIGlmKG4ub3B0cy5kZWxheSYmIWkpcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oaSl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoaS5zTVt0LklEXSlyZXR1cm4gaS51Uyh0LGUsITApfX0odGhpcyksbi5vcHRzLmRlbGF5KTtpPVwiQXJyYXlcIj09PXRoaXMudHlwZSYmbi5vcHRzLnNlbmRBcnJheUNvcGllcz90aGlzLnZhbHVlLnNsaWNlKCk6dGhpcy52YWx1ZSxyPXRbbi5WUl0sKGk9KHM9bi50Rik/cyhpLHIsdC5vYmplY3QpOmkpPT09ciYmIW4ub3B0cy51cGRhdGVFdmVuSWZTYW1lfHxuLmNOJiYhbi5jTihpLHIsdC5vYmplY3QpfHwobi5vcHRzLnByb21pc2VUcmFuc2Zvcm1zJiZpJiZPLmlGKGkudGhlbik/aS50aGVuKGZ1bmN0aW9uKGkpe3Quc1YoaSxlKX0pOnQuc1YoaSxlKSxuLnVPJiZ0aGlzLnJTKHQpKX19fSxhTTpmdW5jdGlvbih0LGUsaSxzKXt2YXIgbixyO2lmKE8uaUYoaSkpe3ZhciBoPTA7Zm9yKHI9ZS5sZW5ndGg7aDxyO2grKyl7dmFyIG89ZVtoXSx1PW8uX3x8bzt1LmlzTXVsdGk/dGhpcy5hTSh0LHUuYmluZGluZ3MsaSxzKToobz10aGlzLnNNW3UuSURdLG9bdF09aSxzPXMmJiFvLnVPLHRoaXMucE1bdS5JRF0mJigobj11LnNNW3RoaXMuSURdKVt0XXx8KG5bdF09aSkpLCFzJiZcIkZ1bmNcIiE9PXRoaXMudHlwZXx8XCJ0RlwiIT09dHx8dGhpcy51Uyh1LHRoaXMpKX1yZXR1cm4hMH1yZXR1cm4gRyhcImVyRk5cIiwyKX0sc3M6ZnVuY3Rpb24odCxlKXt0aGlzLnRmUz10LGUmJnRoaXMuc1YodGhpcy52YWx1ZSl9LGFEOmZ1bmN0aW9uKHQsZSl7dmFyIGk7KG51bGwhPShpPXRoaXMuc01bdC5JRF0pLmRMP2kuZEw6aS5kTD15KCkpW2UuSURdPTF9LHNQSDpmdW5jdGlvbigpe2lmKCF0aGlzLnBWTCl7aWYodGhpcy5wVkw9eSgpLHRoaXMucElNPXkoKSx0aGlzLnBDVD1bXSxPLmlTKHRoaXMudmFsdWUpKXt0aGlzLnBDVD10aGlzLnZhbHVlLnNwbGl0KFYpO3ZhciB0PTA7dGhpcy52YWx1ZT10aGlzLnZhbHVlLnJlcGxhY2UoQSxmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oaSxzKXtyZXR1cm4gZS5wSU1bdCsrXT1zLGUucFZMW3NdPXN9fSh0aGlzKSl9dGhpcy5ETSYmXCJ0ZXh0Q29udGVudFwiPT09dGhpcy5wciYmQih0aGlzLm9iamVjdCx0aGlzLnR4Tj15KCkpfX0sYVBJOmZ1bmN0aW9uKHQpe2lmKFwiRXZlbnRcIiE9PXRoaXMudHlwZSlyZXR1cm4gdGhpcy5yUEkoKSx0aGlzLlBJPXNldEludGVydmFsKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBlPXQuZkRWKCk7cmV0dXJuIHQuc1YoZSx0LCEwKX19KHRoaXMpLHQpfSxyUEk6ZnVuY3Rpb24oKXtyZXR1cm4gY2xlYXJJbnRlcnZhbCh0aGlzLlBJKSx0aGlzLlBJPW51bGx9LGFVVjpmdW5jdGlvbih0LGUpe3RoaXMub2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIodCxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oaSl7aS5fc2J8fChpPXQudGZTJiZ0LmRJLHQuc1YodC5vYmplY3RbZV0sbnVsbCwhaSwhMCkpfX0odGhpcyksITEpfSxhRVY6ZnVuY3Rpb24oKXt0aGlzLmV2Tj90aGlzLnJFVkUodGhpcy5ldk4pOnRoaXMuZEk/KHRoaXMuYVVWKFwiaW5wdXRcIixcInZhbHVlXCIpLHRoaXMuYVVWKFwiY2hhbmdlXCIsXCJ2YWx1ZVwiKSk6dGhpcy5tQ3x8XCJET01SYWRpb1wiIT09dGhpcy50eXBlJiZcIkRPTUNoZWNrYm94XCIhPT10aGlzLnR5cGV8fHRoaXMuYVVWKFwiY2hhbmdlXCIsXCJjaGVja2VkXCIpfSxyRVZFOmZ1bmN0aW9uKHQpe3RoaXMuYXRFVi5wdXNoKHQpLHRoaXMuZXZIfHwodGhpcy5ldkg9VS5iaW5kKHRoaXMpKSx0aGlzLm9iamVjdFt0aGlzLmVNLmxpc3Rlbl0odCx0aGlzLmV2SCl9LHVyRVZFOmZ1bmN0aW9uKHQpe3RoaXMuYXRFVi5zcGxpY2UodGhpcy5hdEVWLmluZGV4T2YodCksMSksdGhpcy5vYmplY3RbdGhpcy5lTS5yZW1vdmVdKHQsdGhpcy5ldkgpfSxlRTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmV2TjtcImRpc3BhdGNoRXZlbnRcIj09PXRoaXMuZU0uZW1pdCYmKHRoaXMuZXZPfHwodGhpcy5ldk89ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSx0aGlzLmV2Ty5pbml0RXZlbnQodGhpcy5ldk4sITAsITApKSx0aGlzLmV2Ty5iaW5kaW5nRGF0YT10LGU9dGhpcy5ldk8pLHRoaXMub2JqZWN0W3RoaXMuZU0uZW1pdF0oZSx0KX19O3ZhciBVPWZ1bmN0aW9uKCl7dGhpcy5pRXx8dGhpcy5zVihhcmd1bWVudHNbdGhpcy5wcl0sbnVsbCwhMCl9LFg9ZnVuY3Rpb24odCxlKXt2YXIgaTtpZihlKUUodGhpcyxlKSx0aGlzLnNHPTE7ZWxzZSBmb3IoaSBpbiB0aGlzLnNHPTAsdGhpcy5zdWJzPVtdLHRoaXMub1A9dHx8KHQ9e30pLHRoaXMub3B0aW9ucz17fSxjKXRoaXMub3B0aW9uc1tpXT1udWxsIT10W2ldP3RbaV06Y1tpXTtyZXR1cm4gdGhpc307dD17c0M6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFgobnVsbCx0aGlzKX0sZE06ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuXz10LE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMse3ZhbHVlOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdC52YWx1ZX19LG9yaWdpbmFsOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdC5vYmplY3RzfHx0Lm9iamVjdH19LHN1YnNjcmliZXJzOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdC5zdWJzLnNsaWNlKCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm9iamVjdH0pfX19KX0sY3JlYXRlQlA6ZnVuY3Rpb24odCxlLGkscyl7dmFyIG47cmV0dXJuIHRoaXMub2JqZWN0PXQsKG49UC5nZXQodCxzLHRoaXMuc2UsdGhpcy5tQykpP3RoaXMucGF0Y2hDYWNoZWRCUChuKToodD1uZXcgUih0LGUsaSksUC5zZXQodCxzKSx0KX0scGF0Y2hDYWNoZWRCUDpmdW5jdGlvbih0KXt2YXIgZTtpZihcIk9iamVjdFByb3BcIiE9PXQudHlwZXx8dGhpcy5wciBpbiB0aGlzLm9iamVjdHx8SSh0LHRoaXMub2JqZWN0KSx0aGlzLnNvKXt2YXIgaT10aGlzLm9QO2ZvcihuIGluIGkpe3ZhciBzPWlbbl07dC5vRFtuXT1zfX12YXIgbj10Lm9EO2ZvcihlIGluIG4pcz1uW2VdLHRoaXMub3B0aW9uc1tlXT1PLmlEKHRoaXMub1BbZV0pP3RoaXMub1BbZV06cztyZXR1cm4gdH0sc1A6ZnVuY3Rpb24odCl7aWYoTy5pTih0KSYmKHQ9dC50b1N0cmluZygpKSx0aGlzLnNlPXRoaXMucHI9dCwhdGhpcy5vcHRpb25zLnNpbXBsZVNlbGVjdG9yKXtpZihEKHQsXCI6XCIpKXt2YXIgZT10LnNwbGl0KFwiOlwiKTt0aGlzLmRlPWUuc2xpY2UoMCwtMSkuam9pbihcIjpcIiksdGhpcy5wcj1lW2UubGVuZ3RoLTFdfUQodCxcIi5cIikmJihlPXRoaXMucHIuc3BsaXQoXCIuXCIpLHRoaXMucHI9ZVswXSx0aGlzLlBoPWUuc2xpY2UoMSkuam9pbihcIi5cIikpLEQodGhpcy5kZSxcImV2ZW50XCIpJiYoRCh0LFwiI1wiKT8oZT10aGlzLnByLnNwbGl0KFwiI1wiKSx0aGlzLmV2Tj1lWzBdLHRoaXMucHI9ZVsxXSk6KHRoaXMuZXZOPXRoaXMucHIsdGhpcy5wcj0wKSxpc05hTihwYXJzZUludCh0aGlzLnByKSkmJkcoXCJlckVWXCIsMSkpfXJldHVybiB0aGlzfSxzUzpmdW5jdGlvbih0LGUpe3RoaXMuc0c9MTt2YXIgaSxzPShpPXQhPT13aW5kb3cmJk8uaXNJKHQpJiYhdC5ub2RlVHlwZSk/dFswXTp0O2lmKHMpe2lmKHRoaXMuRE09Ty5ETShzKSl7aWYoXCJjaGVja2VkXCI9PT10aGlzLnByKXZhciBuPXMmJk8uZFIocykscj0hbiYmcyYmTy5kQyhzKTtlbHNlXCJ2YWx1ZVwiPT09dGhpcy5wciYmKHRoaXMuZEk9Ty5kSShzKSk7aWYoaSYmIUQodGhpcy5kZSxcIm11bHRpXCIpKWlmKDE9PT10Lmxlbmd0aCl0PXRbMF07ZWxzZXtpZigobnx8cikmJiFPLmVBUyh0KSlyZXR1cm4gRyhcImVyTVhcIiwzKTtufHxyPyh0aGlzLm1DPSEwLHQ9W10uc2xpY2UuY2FsbCh0KSk6KHQ9dFswXSxHKFwiZXJPRFwiLDMpKX19fWVsc2UgaSYmTy5lQyh0KSYmRihcImVtcHR5TGlzdFwiKTtzd2l0Y2goITEpe2Nhc2UhZTpyPVwiRnVuY1wiO2JyZWFrO2Nhc2UhdGhpcy5QaDpyPVwiUGhvbGRlclwiO2JyZWFrO2Nhc2UhKEQodGhpcy5kZSxcImFycmF5XCIpJiZPLmlBKHRbdGhpcy5wcl0pKTpyPVwiQXJyYXlcIjticmVhaztjYXNlIUQodGhpcy5kZSxcImV2ZW50XCIpOnI9XCJFdmVudFwiLHRoaXMuZU09e2xpc3Rlbjp0aGlzLm9QLmxpc3Rlbk1ldGhvZCxyZW1vdmU6dGhpcy5vUC5yZW1vdmVNZXRob2QsZW1pdDp0aGlzLm9QLmVtaXRNZXRob2R9LHRbdGhpcy5lTS5saXN0ZW5dfHwodGhpcy5lTS5saXN0ZW49Ty5kTih0KT9cImFkZEV2ZW50TGlzdGVuZXJcIjpcIm9uXCIpLHRbdGhpcy5lTS5yZW1vdmVdfHwodGhpcy5lTS5yZW1vdmU9Ty5kTih0KT9cInJlbW92ZUV2ZW50TGlzdGVuZXJcIjpcInJlbW92ZUxpc3RlbmVyXCIpLHRbdGhpcy5lTS5lbWl0XXx8KHRoaXMuZU0uZW1pdD1PLmROKHQpP1wiZGlzcGF0Y2hFdmVudFwiOlwiZW1pdFwiKTticmVhaztjYXNlIUQodGhpcy5kZSxcImZ1bmNcIik6cj1cIlByb3h5XCI7YnJlYWs7Y2FzZSFuOnI9XCJET01SYWRpb1wiO2JyZWFrO2Nhc2UhcjpyPVwiRE9NQ2hlY2tib3hcIjticmVhaztjYXNlIUQodGhpcy5kZSxcImF0dHJcIik6cj1cIkRPTUF0dHJcIjticmVhaztkZWZhdWx0OnI9XCJPYmplY3RQcm9wXCJ9cmV0dXJuIEQodGhpcy5kZSxcIm11bHRpXCIpPyh0Lmxlbmd0aHx8RihcImVtcHR5TGlzdFwiKSx0aGlzLmRNKG5ldyBudCh0aGlzLHQscikpKTp0aGlzLmRNKHRoaXMuY3JlYXRlQlAodCxyLHRoaXMsZSkpLEQodGhpcy5fLnR5cGUsXCJFdmVudFwiKXx8RCh0aGlzLl8udHlwZSxcIlByb3h5XCIpP3RoaXMub3B0aW9ucy51cGRhdGVPbkJpbmQ9ITE6RCh0aGlzLl8udHlwZSxcIkZ1bmNcIikmJih0aGlzLm9wdGlvbnMudXBkYXRlT25CaW5kPSEwKSx0aGlzLmNDP3RoaXMuY0ModGhpcyk6dGhpc30sYVA6ZnVuY3Rpb24odCl7dmFyIGU7dC5zRz0yLHQuc3Vicy5wdXNoKHRoaXMpO3ZhciBpPXQuXy5hUyh0aGlzLl8sdC5vcHRpb25zLHQudU8pO2lmKHQudU8pZGVsZXRlIHQudU87ZWxzZSBpZih0Lm9wdGlvbnMudXBkYXRlT25CaW5kJiYhaSlpZih0aGlzLl8uaXNNdWx0aSl7dmFyIHM9dGhpcy5fLmJpbmRpbmdzLG49MDtmb3IoZT1zLmxlbmd0aDtuPGU7bisrKWk9c1tuXSx0Ll8udVMoaSx0Ll8pfWVsc2UgdC5fLnVTKHRoaXMuXyx0Ll8pfX0sWC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0LHtvZjp7Z2V0OmZ1bmN0aW9uKCl7aWYoIXRoaXMuc0cpcmV0dXJuIFd9fSxzZXQ6e2dldDpmdW5jdGlvbigpe2lmKHRoaXMuc0cpcmV0dXJuICR9fSxjaGFpblRvOntnZXQ6ZnVuY3Rpb24oKXtpZigyPT09dGhpcy5zRylyZXR1cm4gWX19LHRyYW5zZm9ybVNlbGY6e2dldDpmdW5jdGlvbigpe2lmKDE9PT10aGlzLnNHKXJldHVybiBRfX0sdHJhbnNmb3JtOntnZXQ6ZnVuY3Rpb24oKXtpZigyPT09dGhpcy5zRylyZXR1cm4gcX19LHRyYW5zZm9ybUFsbDp7Z2V0OmZ1bmN0aW9uKCl7aWYoMj09PXRoaXMuc0cpcmV0dXJuIHp9fSxjb25kaXRpb246e2dldDpmdW5jdGlvbigpe2lmKDI9PT10aGlzLnNHKXJldHVybiBKfX0sY29uZGl0aW9uQWxsOntnZXQ6ZnVuY3Rpb24oKXtpZigyPT09dGhpcy5zRylyZXR1cm4gS319LGJvdGhXYXlzOntnZXQ6ZnVuY3Rpb24oKXtpZigyPT09dGhpcy5zRylyZXR1cm4gWn19LHVuQmluZDp7Z2V0OmZ1bmN0aW9uKCl7aWYoMj09PXRoaXMuc0cpcmV0dXJuIHR0fX0scG9sbEV2ZXJ5OntnZXQ6ZnVuY3Rpb24oKXtpZih0aGlzLnNHKXJldHVybiBldH19LHN0b3BQb2xsaW5nOntnZXQ6ZnVuY3Rpb24oKXtpZih0aGlzLnNHKXJldHVybiBpdH19LHNldE9wdGlvbjp7Z2V0OmZ1bmN0aW9uKCl7aWYoMj09PXRoaXMuc0cpcmV0dXJuIHN0fX0sZGlzYWxsb3dGcm9tOntnZXQ6ZnVuY3Rpb24oKXt2YXIgdDtpZigyPT09dGhpcy5zRyYmKHQ9dGhpcykpcmV0dXJuIF8oITEsZnVuY3Rpb24oZSl7cmV0dXJuIHQuXy5hRCh0LnN1YnNbdC5zdWJzLmxlbmd0aC0xXS5fLGUuXyksdH0pfX0sdXBkYXRlT246e2dldDpmdW5jdGlvbigpe3ZhciB0O2lmKHRoaXMuc0cmJih0PXRoaXMpKXJldHVybiBfKCExLGZ1bmN0aW9uKGUpe3JldHVybiBlLl8hPT10Ll8mJih0Ll8ucE1bZS5fLklEXT1lLl8sZS5fLmFTKG0odC5fLCEwKSxlLm9wdGlvbnMsITEsITApKSx0fSl9fSxyZW1vdmVVcGRhdGVyOntnZXQ6ZnVuY3Rpb24oKXt2YXIgdCxlO2lmKHRoaXMuc0cmJihlPXRoaXMpJiYodD10aGlzLl8uc1UpKXJldHVybiBfKCExLGZ1bmN0aW9uKGkpe2kuXy5zTVt0LklEXSYmKGRlbGV0ZSBlLl8ucE1baS5fLklEXSxpLl8uclModCkpfSl9fSx0bzp7Z2V0OmZ1bmN0aW9uKCl7dmFyIHQ7aWYoMT09PXRoaXMuc0cmJih0PXRoaXMpKXJldHVybiBfKCEwLGZ1bmN0aW9uKGUpe3JldHVybiBlLl8hPT10Ll8mJmUuYVAodCksdH0pfX0sYW5kOntnZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnNDKCk7aWYoMj09PXRoaXMuc0cpcmV0dXJuIHQ7aWYoMT09PXRoaXMuc0cpe2lmKCF0Ll8uaXNNdWx0aSl7dmFyIGU9dC5fO3QuXz10Ll89bmV3IG50KHQpLHQuXy5hZGRCUChlKX1yZXR1cm4gXyghMSxmdW5jdGlvbihlKXtyZXR1cm4gdC5fLmFkZEJQKGUuXyksdH0pfX19LG9uY2U6e2dldDpmdW5jdGlvbigpe2lmKDE9PT10aGlzLnNHKXt2YXIgdD10aGlzLnNDKCk7cmV0dXJuIHQudU89ITAsdH19fSx1cGRhdGU6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNldH19LHR3b1dheTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYm90aFdheXN9fSxwaXBlOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGFpblRvfX19KTt2YXIgVz1mdW5jdGlvbih0KXtyZXR1cm4gTy5pTyh0KXx8Ty5pRih0KXx8dyh0KSxPLmlCSSh0KSYmKHQ9dC5vYmplY3QpLHRoaXMuc0c9MSx0aGlzLnNTKHQpfSxZPWZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gSCh0aGlzLnN1YnNbdGhpcy5zdWJzLmxlbmd0aC0xXSkudG8odCxlLGkpfSwkPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl8uc1YodCksdGhpc30sUT1mdW5jdGlvbih0KXtyZXR1cm4gTy5pRih0KT90aGlzLl8uc3ModCx0aGlzLm9wdGlvbnMudXBkYXRlT25CaW5kKTpHKFwiZXJGTlwiLDEpLHRoaXN9LHE9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuXy5hTShcInRGXCIsdGhpcy5zdWJzLnNsaWNlKC0xKSx0LHRoaXMub3B0aW9ucy51cGRhdGVPbkJpbmQpLHRoaXN9LHo9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuXy5hTShcInRGXCIsdGhpcy5zdWJzLHQsdGhpcy5vcHRpb25zLnVwZGF0ZU9uQmluZCksdGhpc30sSj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fLmFNKFwiY05cIix0aGlzLnN1YnMuc2xpY2UoLTEpLHQpLHRoaXN9LEs9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuXy5hTShcImNOXCIsdGhpcy5zdWJzLHQpLHRoaXN9LFo9ZnVuY3Rpb24odCl7dmFyIGUsaT10aGlzLnN1YnNbdGhpcy5zdWJzLmxlbmd0aC0xXSxzPWkuXyxuPXRoaXMuXy5pc011bHRpP3RoaXMuXy5iaW5kaW5nczpbdGhpcy5fXTtmb3Iocy5hUyh0aGlzLl8saS5vcHRpb25zKSxpPTAsZT1uLmxlbmd0aDtpPGU7aSsrKXt2YXIgcj1uW2ldLGg9ci5zTVtzLklEXS50RjtyPXIuc01bcy5JRF0uY04sKGh8fHQpJiYoaD1PLmlGKHQpP3Q6aCkmJiExIT09dCYmKHMuc01bdGhpcy5fLklEXS50Rj1oKSxyJiYocy5zTVt0aGlzLl8uSURdLmNOPXIpfXJldHVybiB0aGlzfSx0dD1mdW5jdGlvbih0KXt2YXIgZSxpPXRoaXMuc3VicyxzPTA7Zm9yKGU9aS5sZW5ndGg7czxlO3MrKyl7dmFyIG49aVtzXTt0aGlzLl8uclMobi5fLHQpfXJldHVybiB0aGlzfSxldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fLmFQSSh0KSx0aGlzfSxpdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl8uclBJKCksdGhpc30sc3Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fLnNNW3RoaXMuc3Vic1t0aGlzLnN1YnMubGVuZ3RoLTFdLl8uSURdLm9wdHNbdF09ZSx0aGlzfSxudD1mdW5jdGlvbih0LGUsaSl7dmFyIHMsbjtpZih0LnNlPXQuc2Uuc2xpY2UoNiksRSh0aGlzLHRoaXMuSW49dCksdGhpcy5pc011bHRpPSEwLHRoaXMuYmluZGluZ3M9cz1bXSxlKWZvcih0PTAsbj1lLmxlbmd0aDt0PG47dCsrKXt2YXIgcj1lW3RdO3RoaXMuYWRkQlAocixpKX1yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcyx7dHlwZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnR5cGV9KX19LHZhbHVlOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQudmFsdWV9KX19fSl9LHJ0PW50LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQpO3JldHVybiBPYmplY3Qua2V5cyhSLnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gcnRbdF09ZnVuY3Rpb24oZSxpLHMsbil7dmFyIHIsaD10aGlzLmJpbmRpbmdzLG89MDtmb3Iocj1oLmxlbmd0aDtvPHI7bysrKXt2YXIgdT1oW29dO1widVNcIj09PXQmJihpPXUpLHVbdF0oZSxpLHMsbil9fX0pLHJ0LmFkZEJQPWZ1bmN0aW9uKHQsZSl7dGhpcy5iaW5kaW5ncy5wdXNoKGU/dGhpcy5jcmVhdGVCUCh0LGUsdGhpcy5Jbik6dCl9LGUuZXhwb3J0cz1ILGUuZXhwb3J0c319LHRoaXMpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLnVtZClkZWZpbmUoZnVuY3Rpb24oKXtyZXR1cm4gdCgwKX0pO2Vsc2V7aWYoXCJvYmplY3RcIiE9dHlwZW9mIG1vZHVsZXx8IW1vZHVsZS5leHBvcnRzKXJldHVybiB0aGlzLnNpbXBseWJpbmQ9dCgwKTttb2R1bGUuZXhwb3J0cz10KDApfX0pLmNhbGwodGhpcyxudWxsKTsiLCJ2YXIgUkVHRVggPSB7XG4gIGFueTogLy4vLFxuICB3aGl0ZVNwYWNlOiAvXFxzKy8sXG4gIG51bWVyaWM6IC9eXFxkJC8sXG4gIGxldHRlcjogL15bYS16QS1aXSQvLFxuICAvLyBhbHBoYW51bWVyaWM6IC9bXFxkYS16QS1aXS9cbiAgd2lkZW51bWVyaWM6IC9eWzAtOVxcISNcXCRcXCVcXCpcXCtcXC9cXD1cXD9cXF5cXHtcXHxcXH1cXChcXClcXH5cXC1cXC5dJC8sXG4gIGFscGhhbnVtZXJpYzogL15bMC05QS1aYS16XFwhI1xcJFxcJVxcJlxcJ1xcKlxcK1xcL1xcPVxcP1xcXlxcX1xcYFxce1xcfFxcfVxcKFxcKVxcflxcLVxcIF0kLyxcbiAgZW1haWw6IC9eW1xcd1xcLVxcLl0rQFtcXHdcXC1cXC5dK1xcLltBLVphLXpdezIsMTB9JC9cbn07ZXhwb3J0IGRlZmF1bHQgUkVHRVg7IiwiaW1wb3J0J0BkYW5pZWxrYWxlbi9pcyc7aW1wb3J0IElTIGZyb20nLi9jaGVja3MuanMnO2ltcG9ydCBET00gZnJvbSdxdWlja2RvbSc7aW1wb3J0J0BkYW5pZWxrYWxlbi9zaW1wbHliaW5kJztpbXBvcnQgUkVHRVggZnJvbScuL2NvbnN0YW50cy9yZWdleC5qcyc7dmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcbnZhciBpbmNsdWRlcyA9IGZ1bmN0aW9uICh0YXJnZXQsIGl0ZW0pIHtcbiAgcmV0dXJuIHRhcmdldCAmJiB0YXJnZXQuaW5kZXhPZihpdGVtKSAhPT0gLTE7XG59O1xudmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHJpbmcsIGNvdW50KSB7XG4gIHZhciBpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBqLCByZWYsIHJlc3VsdHMxO1xuICAgIHJlc3VsdHMxID0gW107XG5cbiAgICBmb3IgKGkgPSBqID0gMSwgcmVmID0gY291bnQ7IDEgPD0gcmVmID8gaiA8PSByZWYgOiBqID49IHJlZjsgaSA9IDEgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICByZXN1bHRzMS5wdXNoKHN0cmluZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHMxO1xuICB9KCkuam9pbignJyk7XG59O1xudmFyIHJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAodGFyZ2V0LCBpdGVtKSB7XG4gIHZhciBpdGVtSW5kZXg7XG4gIGl0ZW1JbmRleCA9IHRhcmdldC5pbmRleE9mKGl0ZW0pO1xuXG4gIGlmIChpdGVtSW5kZXggIT09IC0xKSB7XG4gICAgcmV0dXJuIHRhcmdldC5zcGxpY2UoaXRlbUluZGV4LCAxKTtcbiAgfVxufTtcbnZhciBpbnNlcnRBZnRlciA9IGZ1bmN0aW9uICh0YXJnZXQsIGl0ZW0sIG5ld0l0ZW0pIHtcbiAgdmFyIGl0ZW1JbmRleDtcbiAgaXRlbUluZGV4ID0gdGFyZ2V0LmluZGV4T2YoaXRlbSk7XG5cbiAgaWYgKGl0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICByZXR1cm4gdGFyZ2V0LnNwbGljZShpdGVtSW5kZXgsIDAsIG5ld0l0ZW0pO1xuICB9XG59O1xudmFyIGZpbmQgPSBmdW5jdGlvbiAodGFyZ2V0LCBmbikge1xuICB2YXIgcmVzdWx0cztcbiAgcmVzdWx0cyA9IHRhcmdldC5maWx0ZXIoZm4pO1xuICByZXR1cm4gcmVzdWx0c1swXTtcbn07XG52YXIgZGlmZiA9IGZ1bmN0aW9uIChzb3VyY2UsIGNvbXBhcmVlKSB7XG4gIHZhciBjb21wYXJlZVZhbCwgaSwgbWF4TGVuLCByZXN1bHQsIHNvdXJjZVZhbDtcbiAgcmVzdWx0ID0gW107XG4gIG1heExlbiA9IE1hdGgubWF4KHNvdXJjZS5sZW5ndGgsIGNvbXBhcmVlLmxlbmd0aCk7XG4gIGkgPSAtMTtcblxuICB3aGlsZSAoKytpIDwgbWF4TGVuKSB7XG4gICAgc291cmNlVmFsID0gc291cmNlW2ldO1xuICAgIGNvbXBhcmVlVmFsID0gY29tcGFyZWVbaV07XG5cbiAgICBpZiAoc291cmNlVmFsICE9PSBjb21wYXJlZVZhbCkge1xuICAgICAgaWYgKElTLmRlZmluZWQoc291cmNlVmFsKSAmJiAhaW5jbHVkZXMoY29tcGFyZWUsIHNvdXJjZVZhbCkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goc291cmNlVmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKElTLmRlZmluZWQoY29tcGFyZWVWYWwpICYmICFpbmNsdWRlcyhzb3VyY2UsIGNvbXBhcmVlVmFsKSkge1xuICAgICAgICByZXN1bHQucHVzaChjb21wYXJlZVZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgaGV4VG9SR0JBID0gZnVuY3Rpb24gKGhleCwgYWxwaGEpIHtcbiAgdmFyIEIsIEcsIFI7XG5cbiAgaWYgKGhleFswXSA9PT0gJyMnKSB7XG4gICAgaGV4ID0gaGV4LnNsaWNlKDEpO1xuICB9XG5cbiAgUiA9IHBhcnNlSW50KGhleC5zbGljZSgwLCAyKSwgMTYpO1xuICBHID0gcGFyc2VJbnQoaGV4LnNsaWNlKDIsIDQpLCAxNik7XG4gIEIgPSBwYXJzZUludChoZXguc2xpY2UoNCwgNiksIDE2KTtcbiAgcmV0dXJuIGByZ2JhKCR7Un0sICR7R30sICR7Qn0sICR7YWxwaGF9KWA7XG59O1xudmFyIGRlZmF1bHRDb2xvciA9IGZ1bmN0aW9uIChjb2xvciwgZGVmYXVsdENvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JyB8fCAhY29sb3IpIHtcbiAgICByZXR1cm4gZGVmYXVsdENvbG9yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxufTtcbnZhciBjYWxjUGFkZGluZyA9IGZ1bmN0aW9uIChkZXNpcmVkSGVpZ2h0LCBmb250U2l6ZSkge1xuICByZXR1cm4gTWF0aC5jZWlsKChkZXNpcmVkSGVpZ2h0IC0gZm9udFNpemUgKiAxLjIzMSkgLyAyKTtcbn07XG52YXIgdW5sb2NrU2Nyb2xsID0gZnVuY3Rpb24gKGV4Y2x1ZGVkRWwpIHtcbiAgd2luZG93Ll9pc0xvY2tlZCA9IGZhbHNlO1xuICByZXR1cm4gRE9NKHdpbmRvdykub2ZmKCd3aGVlbC5sb2NrJyk7XG59O1xudmFyIGxvY2tTY3JvbGwgPSBmdW5jdGlvbiAoZXhjbHVkZWRFbCkge1xuICBpZiAoIXdpbmRvdy5faXNMb2NrZWQpIHtcbiAgICB3aW5kb3cuX2lzTG9ja2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gRE9NKHdpbmRvdykub24oJ3doZWVsLmxvY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGV4Y2x1ZGVkRWwucmF3IHx8IERPTShldmVudC50YXJnZXQpLnBhcmVudE1hdGNoaW5nKGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudCA9PT0gZXhjbHVkZWRFbDtcbiAgICAgIH0pKSB7XG4gICAgICAgIGlmIChldmVudC53aGVlbERlbHRhID4gMCAmJiBleGNsdWRlZEVsLnJhdy5zY3JvbGxUb3AgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC53aGVlbERlbHRhIDwgMCAmJiBleGNsdWRlZEVsLnJhdy5zY3JvbGxIZWlnaHQgLSBleGNsdWRlZEVsLnJhdy5zY3JvbGxUb3AgPT09IGV4Y2x1ZGVkRWwucmF3LmNsaWVudEhlaWdodCkge1xuICAgICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbnZhciBmdXp6eU1hdGNoID0gZnVuY3Rpb24gKG5lZWRsZSwgaGF5c3RhY2ssIGNhc2VTZW5zaXRpdmUpIHtcbiAgdmFyIGhJLCBoTGVuZ3RoLCBtYXRjaGVkQ291bnQsIG5JLCBuTGVuZ3RoLCBuZWVkbGVDaGFyO1xuICBuTGVuZ3RoID0gbmVlZGxlLmxlbmd0aDtcbiAgaExlbmd0aCA9IGhheXN0YWNrLmxlbmd0aDtcblxuICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcbiAgICBuZWVkbGUgPSBuZWVkbGUudG9VcHBlckNhc2UoKTtcbiAgICBoYXlzdGFjayA9IGhheXN0YWNrLnRvVXBwZXJDYXNlKCk7XG4gIH1cblxuICBpZiAobkxlbmd0aCA+IGhMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobkxlbmd0aCA9PT0gaExlbmd0aCkge1xuICAgIHJldHVybiBuZWVkbGUgPT09IGhheXN0YWNrO1xuICB9XG5cbiAgbkkgPSBoSSA9IG1hdGNoZWRDb3VudCA9IDA7XG5cbiAgd2hpbGUgKG5JIDwgbkxlbmd0aCkge1xuICAgIG5lZWRsZUNoYXIgPSBuZWVkbGVbbkkrK107XG5cbiAgICB3aGlsZSAoaEkgPCBoTGVuZ3RoKSB7XG4gICAgICBpZiAoaGF5c3RhY2tbaEkrK10gPT09IG5lZWRsZUNoYXIpIHtcbiAgICAgICAgbWF0Y2hlZENvdW50Kys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaGVkQ291bnQgPT09IG5MZW5ndGg7XG59O1xudmFyIHN0YXJ0c1dpdGggPSBmdW5jdGlvbiAobmVlZGxlLCBoYXlzdGFjaywgY2FzZVNlbnNpdGl2ZSkge1xuICB2YXIgaTtcblxuICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcbiAgICBuZWVkbGUgPSBuZWVkbGUudG9VcHBlckNhc2UoKTtcbiAgICBoYXlzdGFjayA9IGhheXN0YWNrLnRvVXBwZXJDYXNlKCk7XG4gIH1cblxuICBpZiAobmVlZGxlLmxlbmd0aCA+IGhheXN0YWNrLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChuZWVkbGUubGVuZ3RoID09PSBoYXlzdGFjay5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmVlZGxlID09PSBoYXlzdGFjaztcbiAgfVxuXG4gIGkgPSAtMTtcblxuICB3aGlsZSAobmVlZGxlWysraV0pIHtcbiAgICBpZiAobmVlZGxlW2ldICE9PSBoYXlzdGFja1tpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBnZXRJbmRleE9mRmlyc3REaWZmID0gZnVuY3Rpb24gKHNvdXJjZVN0cmluZywgY29tcGFyZVN0cmluZykge1xuICB2YXIgY3VycmVudFBvcywgbWF4TGVuZ3RoO1xuICBjdXJyZW50UG9zID0gMDtcbiAgbWF4TGVuZ3RoID0gTWF0aC5tYXgoc291cmNlU3RyaW5nLmxlbmd0aCwgY29tcGFyZVN0cmluZy5sZW5ndGgpO1xuXG4gIHdoaWxlIChjdXJyZW50UG9zIDwgbWF4TGVuZ3RoKSB7XG4gICAgaWYgKHNvdXJjZVN0cmluZ1tjdXJyZW50UG9zXSAhPT0gY29tcGFyZVN0cmluZ1tjdXJyZW50UG9zXSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRQb3M7XG4gICAgfVxuXG4gICAgY3VycmVudFBvcysrO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIHBhcnNlQ3NzU2hvcnRoYW5kVmFsdWUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHZhciByZXN1bHQsIHZhbHVlcztcbiAgdmFsdWVzID0gc3RyaW5nLnNwbGl0KFJFR0VYLndoaXRlU3BhY2UpLm1hcChwYXJzZUZsb2F0KTtcbiAgcmVzdWx0ID0ge307XG5cbiAgc3dpdGNoICh2YWx1ZXMubGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmVzdWx0LnRvcCA9IHJlc3VsdC5yaWdodCA9IHJlc3VsdC5ib3R0b20gPSByZXN1bHQubGVmdCA9IHZhbHVlc1swXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmVzdWx0LnRvcCA9IHJlc3VsdC5ib3R0b20gPSB2YWx1ZXNbMF07XG4gICAgICByZXN1bHQucmlnaHQgPSByZXN1bHQubGVmdCA9IHZhbHVlc1sxXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAzOlxuICAgICAgcmVzdWx0LnRvcCA9IHZhbHVlc1swXTtcbiAgICAgIHJlc3VsdC5yaWdodCA9IHJlc3VsdC5sZWZ0ID0gdmFsdWVzWzFdO1xuICAgICAgcmVzdWx0LmJvdHRvbSA9IHZhbHVlc1syXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSA0OlxuICAgICAgcmVzdWx0LnRvcCA9IHZhbHVlc1swXTtcbiAgICAgIHJlc3VsdC5yaWdodCA9IHZhbHVlc1sxXTtcbiAgICAgIHJlc3VsdC5ib3R0b20gPSB2YWx1ZXNbMl07XG4gICAgICByZXN1bHQubGVmdCA9IHZhbHVlc1szXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIHNob3J0aGFuZFNpZGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2lkZSkge1xuICB2YXIgdmFsdWVzO1xuXG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICB2YWx1ZXMgPSBwYXJzZUNzc1Nob3J0aGFuZFZhbHVlKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZXNbc2lkZV07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDA7XG4gIH1cbn07XG52YXIgdXBkYXRlU2hvcnRoYW5kVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIHNpZGUsIG5ld1ZhbHVlKSB7XG4gIHZhciB2YWx1ZXM7XG4gIHZhbHVlcyA9IHBhcnNlQ3NzU2hvcnRoYW5kVmFsdWUoJycgKyAodmFsdWUgfHwgMCkpO1xuXG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICB2YWx1ZXMudG9wICs9IG5ld1ZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyaWdodCc6XG4gICAgICB2YWx1ZXMucmlnaHQgKz0gbmV3VmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICB2YWx1ZXMuYm90dG9tICs9IG5ld1ZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHZhbHVlcy5sZWZ0ICs9IG5ld1ZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgT2JqZWN0LmtleXModmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXNbc2lkZV0gKz0gbmV3VmFsdWU7XG4gICAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBgJHt2YWx1ZXMudG9wfXB4ICR7dmFsdWVzLnJpZ2h0fXB4ICR7dmFsdWVzLmJvdHRvbX1weCAke3ZhbHVlcy5sZWZ0fXB4YDtcbn07XG52YXIgaW5oZXJpdFByb3RvID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQsIGtleXMpIHtcbiAgdmFyIGosIGtleSwgbGVuLCByZWY7XG4gIHJlZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHBhcmVudC5wcm90b3R5cGUpO1xuXG4gIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgIGtleSA9IHJlZltqXTtcblxuICAgIGlmIChrZXlzICYmICFrZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghY2hpbGQucHJvdG90eXBlW2tleV0pIHtcbiAgICAgIGNoaWxkLnByb3RvdHlwZVtrZXldID0gcGFyZW50LnByb3RvdHlwZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjaGlsZDtcbn07ZXhwb3J0e25vb3AsaW5jbHVkZXMscmVwZWF0LHJlbW92ZUl0ZW0saW5zZXJ0QWZ0ZXIsZmluZCxkaWZmLGhleFRvUkdCQSxkZWZhdWx0Q29sb3IsY2FsY1BhZGRpbmcsdW5sb2NrU2Nyb2xsLGxvY2tTY3JvbGwsZnV6enlNYXRjaCxzdGFydHNXaXRoLGdldEluZGV4T2ZGaXJzdERpZmYscGFyc2VDc3NTaG9ydGhhbmRWYWx1ZSxzaG9ydGhhbmRTaWRlVmFsdWUsdXBkYXRlU2hvcnRoYW5kVmFsdWUsaW5oZXJpdFByb3RvfTsiLCJ2YXIgUkVRVUlSRURfRklFTERfTUVUSE9EUyA9IFsnX2dldFZhbHVlJywgJ19zZXRWYWx1ZScsICdfdmFsaWRhdGUnXTtleHBvcnQgZGVmYXVsdCBSRVFVSVJFRF9GSUVMRF9NRVRIT0RTOyIsIiEoZnVuY3Rpb24od2luKSB7XG5cbi8qKlxuICogRmFzdERvbVxuICpcbiAqIEVsaW1pbmF0ZXMgbGF5b3V0IHRocmFzaGluZ1xuICogYnkgYmF0Y2hpbmcgRE9NIHJlYWQvd3JpdGVcbiAqIGludGVyYWN0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIFdpbHNvbiBQYWdlIDx3aWxzb25wYWdlQG1lLmNvbT5cbiAqIEBhdXRob3IgS29ybmVsIExlc2luc2tpIDxrb3JuZWwubGVzaW5za2lAZnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNaW5pIGxvZ2dlclxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG52YXIgZGVidWcgPSAwID8gY29uc29sZS5sb2cuYmluZChjb25zb2xlLCAnW2Zhc3Rkb21dJykgOiBmdW5jdGlvbigpIHt9O1xuXG4vKipcbiAqIE5vcm1hbGl6ZWQgckFGXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG52YXIgcmFmID0gd2luLnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICB8fCB3aW4ud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gIHx8IHdpbi5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgfHwgd2luLm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gIHx8IGZ1bmN0aW9uKGNiKSB7IHJldHVybiBzZXRUaW1lb3V0KGNiLCAxNik7IH07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIGBGYXN0RG9tYC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRmFzdERvbSgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnJlYWRzID0gW107XG4gIHNlbGYud3JpdGVzID0gW107XG4gIHNlbGYucmFmID0gcmFmLmJpbmQod2luKTsgLy8gdGVzdCBob29rXG4gIGRlYnVnKCdpbml0aWFsaXplZCcsIHNlbGYpO1xufVxuXG5GYXN0RG9tLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEZhc3REb20sXG5cbiAgLyoqXG4gICAqIEFkZHMgYSBqb2IgdG8gdGhlIHJlYWQgYmF0Y2ggYW5kXG4gICAqIHNjaGVkdWxlcyBhIG5ldyBmcmFtZSBpZiBuZWVkIGJlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgbWVhc3VyZTogZnVuY3Rpb24oZm4sIGN0eCkge1xuICAgIGRlYnVnKCdtZWFzdXJlJyk7XG4gICAgdmFyIHRhc2sgPSAhY3R4ID8gZm4gOiBmbi5iaW5kKGN0eCk7XG4gICAgdGhpcy5yZWFkcy5wdXNoKHRhc2spO1xuICAgIHNjaGVkdWxlRmx1c2godGhpcyk7XG4gICAgcmV0dXJuIHRhc2s7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgYSBqb2IgdG8gdGhlXG4gICAqIHdyaXRlIGJhdGNoIGFuZCBzY2hlZHVsZXNcbiAgICogYSBuZXcgZnJhbWUgaWYgbmVlZCBiZS5cbiAgICpcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG11dGF0ZTogZnVuY3Rpb24oZm4sIGN0eCkge1xuICAgIGRlYnVnKCdtdXRhdGUnKTtcbiAgICB2YXIgdGFzayA9ICFjdHggPyBmbiA6IGZuLmJpbmQoY3R4KTtcbiAgICB0aGlzLndyaXRlcy5wdXNoKHRhc2spO1xuICAgIHNjaGVkdWxlRmx1c2godGhpcyk7XG4gICAgcmV0dXJuIHRhc2s7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFycyBhIHNjaGVkdWxlZCAncmVhZCcgb3IgJ3dyaXRlJyB0YXNrLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFza1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSBzdWNjZXNzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbih0YXNrKSB7XG4gICAgZGVidWcoJ2NsZWFyJywgdGFzayk7XG4gICAgcmV0dXJuIHJlbW92ZSh0aGlzLnJlYWRzLCB0YXNrKSB8fCByZW1vdmUodGhpcy53cml0ZXMsIHRhc2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHRlbmQgdGhpcyBGYXN0RG9tIHdpdGggc29tZVxuICAgKiBjdXN0b20gZnVuY3Rpb25hbGl0eS5cbiAgICpcbiAgICogQmVjYXVzZSBmYXN0ZG9tIG11c3QgKmFsd2F5cyogYmUgYVxuICAgKiBzaW5nbGV0b24sIHdlJ3JlIGFjdHVhbGx5IGV4dGVuZGluZ1xuICAgKiB0aGUgZmFzdGRvbSBpbnN0YW5jZS4gVGhpcyBtZWFucyB0YXNrc1xuICAgKiBzY2hlZHVsZWQgYnkgYW4gZXh0ZW5zaW9uIHN0aWxsIGVudGVyXG4gICAqIGZhc3Rkb20ncyBnbG9iYWwgdGFzayBxdWV1ZS5cbiAgICpcbiAgICogVGhlICdzdXBlcicgaW5zdGFuY2UgY2FuIGJlIGFjY2Vzc2VkXG4gICAqIGZyb20gYHRoaXMuZmFzdGRvbWAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBteUZhc3Rkb20gPSBmYXN0ZG9tLmV4dGVuZCh7XG4gICAqICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAqICAgICAvLyBydW5zIG9uIGNyZWF0aW9uXG4gICAqICAgfSxcbiAgICpcbiAgICogICAvLyBvdmVycmlkZSBhIG1ldGhvZFxuICAgKiAgIG1lYXN1cmU6IGZ1bmN0aW9uKGZuKSB7XG4gICAqICAgICAvLyBkbyBleHRyYSBzdHVmZiAuLi5cbiAgICpcbiAgICogICAgIC8vIHRoZW4gY2FsbCB0aGUgb3JpZ2luYWxcbiAgICogICAgIHJldHVybiB0aGlzLmZhc3Rkb20ubWVhc3VyZShmbik7XG4gICAqICAgfSxcbiAgICpcbiAgICogICAuLi5cbiAgICogfSk7XG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMgIHByb3BlcnRpZXMgdG8gbWl4aW5cbiAgICogQHJldHVybiB7RmFzdERvbX1cbiAgICovXG4gIGV4dGVuZDogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICBkZWJ1ZygnZXh0ZW5kJywgcHJvcHMpO1xuICAgIGlmICh0eXBlb2YgcHJvcHMgIT0gJ29iamVjdCcpIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgb2JqZWN0Jyk7XG5cbiAgICB2YXIgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgIG1peGluKGNoaWxkLCBwcm9wcyk7XG4gICAgY2hpbGQuZmFzdGRvbSA9IHRoaXM7XG5cbiAgICAvLyBydW4gb3B0aW9uYWwgY3JlYXRpb24gaG9va1xuICAgIGlmIChjaGlsZC5pbml0aWFsaXplKSBjaGlsZC5pbml0aWFsaXplKCk7XG5cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0sXG5cbiAgLy8gb3ZlcnJpZGUgdGhpcyB3aXRoIGEgZnVuY3Rpb25cbiAgLy8gdG8gcHJldmVudCBFcnJvcnMgaW4gY29uc29sZVxuICAvLyB3aGVuIHRhc2tzIHRocm93XG4gIGNhdGNoOiBudWxsXG59O1xuXG4vKipcbiAqIFNjaGVkdWxlcyBhIG5ldyByZWFkL3dyaXRlXG4gKiBiYXRjaCBpZiBvbmUgaXNuJ3QgcGVuZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzY2hlZHVsZUZsdXNoKGZhc3Rkb20pIHtcbiAgaWYgKCFmYXN0ZG9tLnNjaGVkdWxlZCkge1xuICAgIGZhc3Rkb20uc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBmYXN0ZG9tLnJhZihmbHVzaC5iaW5kKG51bGwsIGZhc3Rkb20pKTtcbiAgICBkZWJ1ZygnZmx1c2ggc2NoZWR1bGVkJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSdW5zIHF1ZXVlZCBgcmVhZGAgYW5kIGB3cml0ZWAgdGFza3MuXG4gKlxuICogRXJyb3JzIGFyZSBjYXVnaHQgYW5kIHRocm93biBieSBkZWZhdWx0LlxuICogSWYgYSBgLmNhdGNoYCBmdW5jdGlvbiBoYXMgYmVlbiBkZWZpbmVkXG4gKiBpdCBpcyBjYWxsZWQgaW5zdGVhZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBmbHVzaChmYXN0ZG9tKSB7XG4gIGRlYnVnKCdmbHVzaCcpO1xuXG4gIHZhciB3cml0ZXMgPSBmYXN0ZG9tLndyaXRlcztcbiAgdmFyIHJlYWRzID0gZmFzdGRvbS5yZWFkcztcbiAgdmFyIGVycm9yO1xuXG4gIHRyeSB7XG4gICAgZGVidWcoJ2ZsdXNoaW5nIHJlYWRzJywgcmVhZHMubGVuZ3RoKTtcbiAgICBydW5UYXNrcyhyZWFkcyk7XG4gICAgZGVidWcoJ2ZsdXNoaW5nIHdyaXRlcycsIHdyaXRlcy5sZW5ndGgpO1xuICAgIHJ1blRhc2tzKHdyaXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgZXJyb3IgPSBlOyB9XG5cbiAgZmFzdGRvbS5zY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBJZiB0aGUgYmF0Y2ggZXJyb3JlZCB3ZSBtYXkgc3RpbGwgaGF2ZSB0YXNrcyBxdWV1ZWRcbiAgaWYgKHJlYWRzLmxlbmd0aCB8fCB3cml0ZXMubGVuZ3RoKSBzY2hlZHVsZUZsdXNoKGZhc3Rkb20pO1xuXG4gIGlmIChlcnJvcikge1xuICAgIGRlYnVnKCd0YXNrIGVycm9yZWQnLCBlcnJvci5tZXNzYWdlKTtcbiAgICBpZiAoZmFzdGRvbS5jYXRjaCkgZmFzdGRvbS5jYXRjaChlcnJvcik7XG4gICAgZWxzZSB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIFdlIHJ1biB0aGlzIGluc2lkZSBhIHRyeSBjYXRjaFxuICogc28gdGhhdCBpZiBhbnkgam9icyBlcnJvciwgd2VcbiAqIGFyZSBhYmxlIHRvIHJlY292ZXIgYW5kIGNvbnRpbnVlXG4gKiB0byBmbHVzaCB0aGUgYmF0Y2ggdW50aWwgaXQncyBlbXB0eS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5UYXNrcyh0YXNrcykge1xuICBkZWJ1ZygncnVuIHRhc2tzJyk7XG4gIHZhciB0YXNrOyB3aGlsZSAodGFzayA9IHRhc2tzLnNoaWZ0KCkpIHRhc2soKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIEFycmF5LlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBhcnJheVxuICogQHBhcmFtICB7Kn0gaXRlbVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBpdGVtKSB7XG4gIHZhciBpbmRleCA9IGFycmF5LmluZGV4T2YoaXRlbSk7XG4gIHJldHVybiAhIX5pbmRleCAmJiAhIWFycmF5LnNwbGljZShpbmRleCwgMSk7XG59XG5cbi8qKlxuICogTWl4aW4gb3duIHByb3BlcnRpZXMgb2Ygc291cmNlXG4gKiBvYmplY3QgaW50byB0aGUgdGFyZ2V0LlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtPYmplY3R9IHNvdXJjZVxuICovXG5mdW5jdGlvbiBtaXhpbih0YXJnZXQsIHNvdXJjZSkge1xuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG59XG5cbi8vIFRoZXJlIHNob3VsZCBuZXZlciBiZSBtb3JlIHRoYW5cbi8vIG9uZSBpbnN0YW5jZSBvZiBgRmFzdERvbWAgaW4gYW4gYXBwXG52YXIgZXhwb3J0cyA9IHdpbi5mYXN0ZG9tID0gKHdpbi5mYXN0ZG9tIHx8IG5ldyBGYXN0RG9tKCkpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuLy8gRXhwb3NlIHRvIENKUyAmIEFNRFxuaWYgKCh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nKSBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBleHBvcnRzOyB9KTtcbmVsc2UgaWYgKCh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JykgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG59KSggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzKTtcbiIsImltcG9ydCdAZGFuaWVsa2FsZW4vaXMnO2ltcG9ydCBJUyBmcm9tJy4uL2NoZWNrcy5qcyc7aW1wb3J0IFNpbXBseUJpbmQgZnJvbSdAZGFuaWVsa2FsZW4vc2ltcGx5YmluZCc7dmFyIENvbmRpdGlvbjtcbkNvbmRpdGlvbiA9IGNsYXNzIENvbmRpdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGZpZWxkMSwgc2V0dGluZ3MsIGNhbGxiYWNrMSkge1xuICAgIHZhciBwcm9wZXJ0eSwgdGFyZ2V0O1xuICAgIHRoaXMuZmllbGQgPSBmaWVsZDE7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjazE7XG4gICAgdGhpcy5zYXRpc2ZpZWQgPSBmYWxzZTtcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5zZXR0aW5ncy52YWx1ZTtcbiAgICB0aGlzLnByb3BlcnR5ID0gdGhpcy5zZXR0aW5ncy5wcm9wZXJ0eSB8fCAnX3ZhbHVlJztcblxuICAgIGlmICh0aGlzLnNldHRpbmdzLnByb3BlcnR5ID09PSAndmFsdWUnKSB7XG4gICAgICB0aGlzLnByb3BlcnR5ID0gJ192YWx1ZSc7XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gdGhpcy5maWVsZC5hbGxGaWVsZHNbdGhpcy5zZXR0aW5ncy50YXJnZXRdO1xuXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oYGNvbmRpdGlvbiB0YXJnZXQgbm90IGZvdW5kIGZvciB0aGUgcHJvdmlkZWQgSUQgJyR7dGhpcy5zZXR0aW5ncy50YXJnZXR9J2AsIHRoaXMuZmllbGQpO1xuICAgIH1cblxuICAgIHByb3BlcnR5ID0gSVMuYXJyYXkodGhpcy50YXJnZXRbdGhpcy5wcm9wZXJ0eV0pID8gYGFycmF5OiR7dGhpcy5wcm9wZXJ0eX1gIDogdGhpcy5wcm9wZXJ0eTtcbiAgICBTaW1wbHlCaW5kKHByb3BlcnR5LCB7XG4gICAgICB1cGRhdGVPbkJpbmQ6IGZhbHNlXG4gICAgfSkub2YodGhpcy50YXJnZXQpLmFuZCgndmlzaWJsZScpLm9mKHRoaXMudGFyZ2V0LnN0YXRlKS50byh0aGlzLmNhbGxiYWNrKTtcbiAgICBTaW1wbHlCaW5kKCdzYXRpc2ZpZWQnLCB7XG4gICAgICB1cGRhdGVPbkJpbmQ6IGZhbHNlXG4gICAgfSkub2YodGhpcykudG8oKG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4ge1xuICAgICAgdmFyIGJhc2U7XG5cbiAgICAgIGlmIChvbGRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgKGJhc2UgPSB0aGlzLmZpZWxkKS5lbWl0ID09PSBcImZ1bmN0aW9uXCIgPyBiYXNlLmVtaXQoJ2NvbmRpdGlvbkNoYW5nZScsIHRoaXMpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdGVzdCgpIHtcbiAgICB2YXIgY29tcGFyaXNvbiwgY29tcGFyaXNvbk9wZXJhdG9ycywgcGFzc2VkQ29tcGFyaXNvbnMsIHJlZiwgdGFyZ2V0VmFsdWU7XG5cbiAgICBpZiAoISgocmVmID0gdGhpcy50YXJnZXQpICE9IG51bGwgPyByZWYuc3RhdGUudmlzaWJsZSA6IHZvaWQgMCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb21wYXJpc29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICBjYXNlICFJUy5vYmplY3RQbGFpbih0aGlzLnZhbHVlKTpcbiAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcblxuICAgICAgICBjYXNlICFJUy5yZWdleCh0aGlzLnZhbHVlKTpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJyRyZWdleCc6IHRoaXMudmFsdWVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIGNhc2UgISh0aGlzLnZhbHVlID09PSAndmFsaWQnICYmICF0aGlzLnNldHRpbmdzLnByb3BlcnR5IHx8ICFJUy5kZWZpbmVkKHRoaXMudmFsdWUpKTpcbiAgICAgICAgICByZXR1cm4gJ3ZhbGlkJztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnJGVxJzogdGhpcy52YWx1ZVxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfS5jYWxsKHRoaXMpO1xuXG4gICAgaWYgKGNvbXBhcmlzb24gPT09ICd2YWxpZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnRhcmdldC52YWxpZGF0ZSgpO1xuICAgIH1cblxuICAgIHRhcmdldFZhbHVlID0gKCgpID0+IHtcbiAgICAgIHZhciBuZXN0ZWRPYmplY3QsIHByb3BlcnR5Q2hhaW47XG5cbiAgICAgIGlmICh0aGlzLnByb3BlcnR5ID09PSAnX3ZhbHVlJykge1xuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHByb3BlcnR5Q2hhaW4gPSB0aGlzLnByb3BlcnR5LnNwbGl0KCcuJyk7XG5cbiAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgY2FzZSBwcm9wZXJ0eUNoYWluLmxlbmd0aCAhPT0gMTpcbiAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRbdGhpcy5wcm9wZXJ0eV07XG5cbiAgICAgICAgY2FzZSAhSVMuZGVmaW5lZCh0aGlzLnRhcmdldFt0aGlzLnByb3BlcnR5XSk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0W3RoaXMucHJvcGVydHldO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbmVzdGVkT2JqZWN0ID0gdGhpcy50YXJnZXQ7XG5cbiAgICAgICAgICB3aGlsZSAoSVMub2JqZWN0KG5lc3RlZE9iamVjdCkpIHtcbiAgICAgICAgICAgIG5lc3RlZE9iamVjdCA9IG5lc3RlZE9iamVjdFtwcm9wZXJ0eUNoYWluLnBvcCgpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmVzdGVkT2JqZWN0O1xuICAgICAgfVxuICAgIH0pKCk7XG5cbiAgICBjb21wYXJpc29uT3BlcmF0b3JzID0gT2JqZWN0LmtleXMoY29tcGFyaXNvbik7XG4gICAgcGFzc2VkQ29tcGFyaXNvbnMgPSBjb21wYXJpc29uT3BlcmF0b3JzLmZpbHRlcihmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgIHZhciBzZWVrZWRWYWx1ZTtcbiAgICAgIHNlZWtlZFZhbHVlID0gY29tcGFyaXNvbltvcGVyYXRvcl07XG5cbiAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnJGVxJzpcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0VmFsdWUgPT09IHNlZWtlZFZhbHVlO1xuXG4gICAgICAgIGNhc2UgJyRuZSc6XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFZhbHVlICE9PSBzZWVrZWRWYWx1ZTtcblxuICAgICAgICBjYXNlICckZ3QnOlxuICAgICAgICAgIHJldHVybiB0YXJnZXRWYWx1ZSA+IHNlZWtlZFZhbHVlO1xuXG4gICAgICAgIGNhc2UgJyRndGUnOlxuICAgICAgICAgIHJldHVybiB0YXJnZXRWYWx1ZSA+PSBzZWVrZWRWYWx1ZTtcblxuICAgICAgICBjYXNlICckbHQnOlxuICAgICAgICAgIHJldHVybiB0YXJnZXRWYWx1ZSA8IHNlZWtlZFZhbHVlO1xuXG4gICAgICAgIGNhc2UgJyRsdGUnOlxuICAgICAgICAgIHJldHVybiB0YXJnZXRWYWx1ZSA8PSBzZWVrZWRWYWx1ZTtcblxuICAgICAgICBjYXNlICckY3QnOlxuICAgICAgICAgIHJldHVybiBoZWxwZXJzLmluY2x1ZGVzKHRhcmdldFZhbHVlLCBzZWVrZWRWYWx1ZSk7XG5cbiAgICAgICAgY2FzZSAnJG5jdCc6XG4gICAgICAgICAgcmV0dXJuICFoZWxwZXJzLmluY2x1ZGVzKHRhcmdldFZhbHVlLCBzZWVrZWRWYWx1ZSk7XG5cbiAgICAgICAgY2FzZSAnJHJlZ2V4JzpcbiAgICAgICAgICByZXR1cm4gc2Vla2VkVmFsdWUudGVzdCh0YXJnZXRWYWx1ZSk7XG5cbiAgICAgICAgY2FzZSAnJG5yZWdleCc6XG4gICAgICAgICAgcmV0dXJuICFzZWVrZWRWYWx1ZS50ZXN0KHRhcmdldFZhbHVlKTtcblxuICAgICAgICBjYXNlICckbWFzayc6XG4gICAgICAgICAgcmV0dXJuIGhlbHBlcnMudGVzdE1hc2sodGFyZ2V0VmFsdWUsIHNlZWtlZFZhbHVlKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcGFzc2VkQ29tcGFyaXNvbnMubGVuZ3RoID09PSBjb21wYXJpc29uT3BlcmF0b3JzLmxlbmd0aDtcbiAgfVxuXG4gIHN0YXRpYyB2YWxpZGF0ZShjb25kaXRpb25zKSB7XG4gICAgdmFyIHZhbGlkQ29uZGl0aW9ucztcblxuICAgIGlmIChjb25kaXRpb25zKSB7XG4gICAgICB2YWxpZENvbmRpdGlvbnMgPSBjb25kaXRpb25zLmZpbHRlcihmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiBjb25kaXRpb24uc2F0aXNmaWVkID0gY29uZGl0aW9uLnRlc3QoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHZhbGlkQ29uZGl0aW9ucy5sZW5ndGggPT09IGNvbmRpdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBpbml0KGZpZWxkLCBjb25kaXRpb25zLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsKSB7XG4gICAgICAgIGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBmaWVsZC52YWxpZGF0ZUNvbmRpdGlvbnMoKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZmllbGQuY29uZGl0aW9ucyA9IGNvbmRpdGlvbnMubWFwKGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb24oZmllbGQsIGNvbmRpdGlvbiwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfVxuXG59O1xudmFyIENvbmRpdGlvbiQxID0gQ29uZGl0aW9uO2V4cG9ydCBkZWZhdWx0IENvbmRpdGlvbiQxOyIsImltcG9ydCdAZGFuaWVsa2FsZW4vaXMnO2ltcG9ydCBJUyBmcm9tJy4uL2NoZWNrcy5qcyc7dmFyIHRyYW5zZm9ybVNldHRpbmdzID0ge1xuICBjb25kaXRpb25zOiBmdW5jdGlvbiAoY29uZGl0aW9ucykge1xuICAgIHZhciByZXN1bHRzLCB0YXJnZXQsIHZhbHVlO1xuXG4gICAgaWYgKElTLm9iamVjdFBsYWluKGNvbmRpdGlvbnMpKSB7XG4gICAgICByZXN1bHRzID0gW107XG5cbiAgICAgIGZvciAodGFyZ2V0IGluIGNvbmRpdGlvbnMpIHtcbiAgICAgICAgdmFsdWUgPSBjb25kaXRpb25zW3RhcmdldF07XG4gICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9IGVsc2UgaWYgKElTLmFycmF5KGNvbmRpdGlvbnMpKSB7XG4gICAgICByZXR1cm4gY29uZGl0aW9ucy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKElTLnN0cmluZyhpdGVtKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IGl0ZW1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGNob2ljZXM6IGZ1bmN0aW9uIChjaG9pY2VzKSB7XG4gICAgdmFyIGxhYmVsLCByZXN1bHRzLCB2YWx1ZTtcblxuICAgIGlmIChJUy5vYmplY3RQbGFpbihjaG9pY2VzKSkge1xuICAgICAgcmVzdWx0cyA9IFtdO1xuXG4gICAgICBmb3IgKGxhYmVsIGluIGNob2ljZXMpIHtcbiAgICAgICAgdmFsdWUgPSBjaG9pY2VzW2xhYmVsXTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSBlbHNlIGlmIChJUy5hcnJheShjaG9pY2VzKSkge1xuICAgICAgcmV0dXJuIGNob2ljZXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmICghSVMub2JqZWN0UGxhaW4oaXRlbSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWw6IGl0ZW0sXG4gICAgICAgICAgICB2YWx1ZTogaXRlbVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgdmFsaWRXaGVuUmVnZXg6IGZ1bmN0aW9uIChyZWdleCkge1xuICAgIGlmIChJUy5zdHJpbmcocmVnZXgpKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZWdleDtcbiAgICB9XG4gIH1cbn07ZXhwb3J0IGRlZmF1bHQgdHJhbnNmb3JtU2V0dGluZ3M7IiwidmFyIGdsb2JhbERlZmF1bHRzID0ge1xuICBmb250RmFtaWx5OiAnc3lzdGVtLXVpLCBzYW5zLXNlcmlmJyxcbiAgdGVtcGxhdGVzOiB7fSxcbiAgZXZlbnRzOiBudWxsLFxuICBsYWJlbDogZmFsc2UsXG4gIGVycm9yOiAnJyxcbiAgaGVscDogJycsXG4gIHJlcXVpcmVkOiBmYWxzZSxcbiAgZGlzYWJsZWQ6IGZhbHNlLFxuICBkZWZhdWx0VmFsdWU6IG51bGwsXG4gIHdpZHRoOiAnMTAwJScsXG4gIG1vYmlsZVdpZHRoOiBudWxsLFxuICBtb2JpbGVUaHJlc2hvbGQ6IDczNixcbiAgYm9yZGVyOiAxLFxuICBtYXJnaW46IG51bGwsXG4gIHBhZGRpbmc6IG51bGwsXG4gIGRpc3RhbmNlOiBudWxsLFxuICBpbnB1dFBhZGRpbmc6IDEyLFxuICBmb250U2l6ZTogMTQsXG4gIGxhYmVsU2l6ZTogbnVsbCxcbiAgaWNvbjogbnVsbCxcbiAgaWNvblNpemU6IDIyLFxuICBnZXR0ZXI6IG51bGwsXG4gIHNldHRlcjogbnVsbCxcbiAgdmFsaWRhdG9yOiBudWxsLFxuICBjbGVhckVycm9yT25WYWxpZDogdHJ1ZSxcbiAgbWFrZVJvb21Gb3JIZWxwOiB0cnVlXG59O2V4cG9ydCBkZWZhdWx0IGdsb2JhbERlZmF1bHRzOyIsImltcG9ydCdAZGFuaWVsa2FsZW4vaXMnO2ltcG9ydCBJUyBmcm9tJy4uL2NoZWNrcy5qcyc7aW1wb3J0J3F1aWNrZG9tJztpbXBvcnQgU2ltcGx5QmluZCBmcm9tJ0BkYW5pZWxrYWxlbi9zaW1wbHliaW5kJztpbXBvcnQnLi4vY29uc3RhbnRzL3JlZ2V4LmpzJztpbXBvcnQge3VwZGF0ZVNob3J0aGFuZFZhbHVlfWZyb20nLi4vaGVscGVycy5qcyc7aW1wb3J0IGV4dGVuZCBmcm9tJ3NtYXJ0LWV4dGVuZCc7aW1wb3J0IGZhc3Rkb20gZnJvbSdmYXN0ZG9tJztpbXBvcnQgQ29uZGl0aW9uIGZyb20nLi4vY29tcG9uZW50cy9jb25kaXRpb24uanMnO2ltcG9ydCB0cmFuc2Zvcm1TZXR0aW5ncyBmcm9tJy4vdHJhbnNmb3JtU2V0dGluZ3MuanMnO2ltcG9ydCBnbG9iYWxEZWZhdWx0cyBmcm9tJy4vZ2xvYmFsRGVmYXVsdHMuanMnO3ZhciBGaWVsZCwgY3VycmVudElEO1xuY3VycmVudElEID0gMDtcblxuRmllbGQgPSBmdW5jdGlvbiAoKSB7XG4gIGNsYXNzIEZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncywgYnVpbGRlciwgc2V0dGluZ092ZXJyaWRlcywgdGVtcGxhdGVPdmVycmlkZXMpIHtcbiAgICAgIHZhciByZWYsIHNoYWxsb3dTZXR0aW5ncywgdHJhbnNmb3JtU2V0dGluZ3NfO1xuICAgICAgdGhpcy5idWlsZGVyID0gYnVpbGRlcjtcblxuICAgICAgaWYgKHNldHRpbmdPdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKHNldHRpbmdPdmVycmlkZXMuZ2xvYmFsRGVmYXVsdHMpIHtcbiAgICAgICAgICB0aGlzLmdsb2JhbERlZmF1bHRzID0gc2V0dGluZ092ZXJyaWRlcy5nbG9iYWxEZWZhdWx0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5nT3ZlcnJpZGVzW3NldHRpbmdzLnR5cGVdKSB7XG4gICAgICAgICAgdGhpcy5kZWZhdWx0cyA9IHNldHRpbmdPdmVycmlkZXNbc2V0dGluZ3MudHlwZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRlbXBsYXRlT3ZlcnJpZGVzICYmIHRlbXBsYXRlT3ZlcnJpZGVzW3NldHRpbmdzLnR5cGVdKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVzID0gdGVtcGxhdGVPdmVycmlkZXNbc2V0dGluZ3MudHlwZV07XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZU92ZXJyaWRlc1tzZXR0aW5ncy50eXBlXS5kZWZhdWx0O1xuICAgICAgfVxuXG4gICAgICBzaGFsbG93U2V0dGluZ3MgPSB0aGlzLnNoYWxsb3dTZXR0aW5ncyA/IEZpZWxkLnNoYWxsb3dTZXR0aW5ncy5jb25jYXQodGhpcy5zaGFsbG93U2V0dGluZ3MpIDogRmllbGQuc2hhbGxvd1NldHRpbmdzO1xuICAgICAgdHJhbnNmb3JtU2V0dGluZ3NfID0gdGhpcy50cmFuc2Zvcm1TZXR0aW5ncyA/IEZpZWxkLnRyYW5zZm9ybVNldHRpbmdzLmNvbmNhdCh0aGlzLnRyYW5zZm9ybVNldHRpbmdzKSA6IEZpZWxkLnRyYW5zZm9ybVNldHRpbmdzO1xuICAgICAgdGhpcy5zZXR0aW5ncyA9IGV4dGVuZC5kZWVwLmNsb25lLm5vdERlZXAoc2hhbGxvd1NldHRpbmdzKS50cmFuc2Zvcm0odHJhbnNmb3JtU2V0dGluZ3NfKSh0aGlzLmdsb2JhbERlZmF1bHRzLCB0aGlzLmRlZmF1bHRzLCBzZXR0aW5ncyk7XG4gICAgICB0aGlzLklEID0gdGhpcy5zZXR0aW5ncy5JRCB8fCBjdXJyZW50SUQrKyArICcnO1xuICAgICAgdGhpcy50eXBlID0gc2V0dGluZ3MudHlwZTtcbiAgICAgIHRoaXMubmFtZSA9IHNldHRpbmdzLm5hbWU7XG4gICAgICB0aGlzLmFsbEZpZWxkcyA9IHRoaXMuc2V0dGluZ3MuZmllbGRJbnN0YW5jZXMgfHwgRmllbGQuaW5zdGFuY2VzO1xuICAgICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgICAgdGhpcy5fZXZlbnRDYWxsYmFja3MgPSB7fTtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICBmb2N1c2VkOiBmYWxzZSxcbiAgICAgICAgaG92ZXJlZDogZmFsc2UsXG4gICAgICAgIGZpbGxlZDogZmFsc2UsXG4gICAgICAgIGludGVyYWN0ZWQ6IGZhbHNlLFxuICAgICAgICBpc01vYmlsZTogZmFsc2UsXG4gICAgICAgIGRpc2FibGVkOiB0aGlzLnNldHRpbmdzLmRpc2FibGVkLFxuICAgICAgICBtYXJnaW46IHRoaXMuc2V0dGluZ3MubWFyZ2luLFxuICAgICAgICBwYWRkaW5nOiB0aGlzLnNldHRpbmdzLnBhZGRpbmcsXG4gICAgICAgIHdpZHRoOiB0aGlzLnNldHRpbmdzLndpZHRoLFxuICAgICAgICBzaG93TGFiZWw6IHRoaXMuc2V0dGluZ3MubGFiZWwsXG4gICAgICAgIGxhYmVsOiB0aGlzLnNldHRpbmdzLmxhYmVsLFxuICAgICAgICBzaG93SGVscDogdGhpcy5zZXR0aW5ncy5oZWxwLFxuICAgICAgICBoZWxwOiB0aGlzLnNldHRpbmdzLmhlbHAsXG4gICAgICAgIHNob3dFcnJvcjogZmFsc2UsXG4gICAgICAgIGVycm9yOiB0aGlzLnNldHRpbmdzLmVycm9yXG4gICAgICB9O1xuXG4gICAgICBpZiAoSVMuZGVmaW5lZCh0aGlzLnNldHRpbmdzLnBsYWNlaG9sZGVyKSkge1xuICAgICAgICB0aGlzLnN0YXRlLnBsYWNlaG9sZGVyID0gdGhpcy5zZXR0aW5ncy5wbGFjZWhvbGRlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKElTLm51bWJlcih0aGlzLnNldHRpbmdzLndpZHRoKSAmJiB0aGlzLnNldHRpbmdzLndpZHRoIDw9IDEpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS53aWR0aCA9IGAke3RoaXMuc2V0dGluZ3Mud2lkdGggKiAxMDB9JWA7XG4gICAgICB9XG5cbiAgICAgIGlmICgocmVmID0gdGhpcy5zZXR0aW5ncy5jb25kaXRpb25zKSAhPSBudWxsID8gcmVmLmxlbmd0aCA6IHZvaWQgMCkge1xuICAgICAgICB0aGlzLnN0YXRlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgQ29uZGl0aW9uLmluaXQodGhpcywgdGhpcy5zZXR0aW5ncy5jb25kaXRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYWxsRmllbGRzW3RoaXMuSURdKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBEdXBsaWNhdGUgZmllbGQgSURzIGZvdW5kOiAnJHt0aGlzLklEfSdgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmFsbEZpZWxkc1t0aGlzLklEXSA9IHRoaXM7XG4gICAgfVxuXG4gICAgX2NvbnN0cnVjdG9yRW5kKCkge1xuICAgICAgdmFyIGJhc2UsIGhhbmRsZXIsIHJlZiwgdGFyZ2V0O1xuICAgICAgdGhpcy5lbC5jaGlsZGY7IC8vLmZpZWxkLm9uICdpbnNlcnRlZCcsICgpPT4gQGVtaXQoJ2luc2VydGVkJylcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuSUQpIHtcbiAgICAgICAgdGhpcy5lbC5yYXcuaWQgPSB0aGlzLklEO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGlmICgoYmFzZSA9IHRoaXMuc2V0dGluZ3MpLmRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgYmFzZS5kZWZhdWx0VmFsdWUgPSB0aGlzLnNldHRpbmdzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnNldHRpbmdzLm11bHRpcGxlID8gW10uY29uY2F0KHRoaXMuc2V0dGluZ3MuZGVmYXVsdFZhbHVlKSA6IHRoaXMuc2V0dGluZ3MuZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBTaW1wbHlCaW5kKCdzaG93RXJyb3InLCB7XG4gICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICAgIH0pLm9mKHRoaXMuc3RhdGUpLnRvKCdoZWxwJykub2YodGhpcy5zdGF0ZSkudHJhbnNmb3JtKHNob3cgPT4ge1xuICAgICAgICBpZiAoc2hvdyAmJiB0aGlzLnN0YXRlLmVycm9yICYmIElTLnN0cmluZyh0aGlzLnN0YXRlLmVycm9yKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLmhlbHAgfHwgdGhpcy5zdGF0ZS5oZWxwO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2Vycm9yJywge1xuICAgICAgICB1cGRhdGVPbkJpbmQ6IGZhbHNlXG4gICAgICB9KS5vZih0aGlzLnN0YXRlKS50bygnaGVscCcpLm9mKHRoaXMuc3RhdGUpLmNvbmRpdGlvbihlcnJvciA9PiB7XG4gICAgICAgIHJldHVybiBlcnJvciAmJiB0aGlzLnN0YXRlLnNob3dFcnJvcjtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnaGVscCcpLm9mKHRoaXMuc3RhdGUpLnRvKCdodG1sJykub2YodGhpcy5lbC5jaGlsZC5oZWxwKS5hbmQudG8oJ3Nob3dIZWxwJykub2YodGhpcy5zdGF0ZSk7XG4gICAgICBTaW1wbHlCaW5kKCdsYWJlbCcpLm9mKHRoaXMuc3RhdGUpLnRvKCd0ZXh0Jykub2YodGhpcy5lbC5jaGlsZC5sYWJlbCkuYW5kLnRvKCdzaG93TGFiZWwnKS5vZih0aGlzLnN0YXRlKTtcbiAgICAgIFNpbXBseUJpbmQoJ21hcmdpbicpLm9mKHRoaXMuc3RhdGUpLnRvKHRoaXMuZWwuc3R5bGUuYmluZCh0aGlzLmVsLCAnbWFyZ2luJykpO1xuICAgICAgU2ltcGx5QmluZCgncGFkZGluZycpLm9mKHRoaXMuc3RhdGUpLnRvKHRoaXMuZWwuc3R5bGUuYmluZCh0aGlzLmVsLCAncGFkZGluZycpKTtcbiAgICAgIFNpbXBseUJpbmQoJ3Nob3dIZWxwJykub2YodGhpcy5zdGF0ZSkudG8oKHNob3csIHByZXZTaG93KSA9PiB7XG4gICAgICAgIHZhciBjaGFuZ2VBbW91bnQ7XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubWFrZVJvb21Gb3JIZWxwKSB7XG4gICAgICAgICAgY2hhbmdlQW1vdW50ID0gISFzaG93ID09PSAhIXByZXZTaG93ID8gMCA6IHNob3cgPyAyNSA6IHByZXZTaG93ID8gLTI1IDogdm9pZCAwO1xuXG4gICAgICAgICAgaWYgKGNoYW5nZUFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUubWFyZ2luID0gdXBkYXRlU2hvcnRoYW5kVmFsdWUodGhpcy5zdGF0ZS5tYXJnaW4sICdib3R0b20nLCBjaGFuZ2VBbW91bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdmb2N1c2VkJywge1xuICAgICAgICB1cGRhdGVPbkJpbmQ6IGZhbHNlXG4gICAgICB9KS5vZih0aGlzLnN0YXRlKS50byhmb2N1c2VkID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChmb2N1c2VkID8gJ2ZvY3VzJyA6ICdibHVyJyk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubW9iaWxlV2lkdGgpIHtcbiAgICAgICAgU2ltcGx5QmluZCgoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGZhc3Rkb20ubWVhc3VyZSgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc01vYmlsZSA9IHdpbmRvdy5pbm5lcldpZHRoIDw9IHRoaXMuc2V0dGluZ3MubW9iaWxlVGhyZXNob2xkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KS51cGRhdGVPbignZXZlbnQ6cmVzaXplJykub2Yod2luZG93KTtcbiAgICAgIH1cblxuICAgICAgaWYgKElTLm9iamVjdCh0aGlzLnNldHRpbmdzLmV2ZW50cykpIHtcbiAgICAgICAgcmVmID0gdGhpcy5zZXR0aW5ncy5ldmVudHM7XG5cbiAgICAgICAgZm9yICh0YXJnZXQgaW4gcmVmKSB7XG4gICAgICAgICAgaGFuZGxlciA9IHJlZlt0YXJnZXRdO1xuICAgICAgICAgIHRoaXMub24odGFyZ2V0LCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmVtaXQoJ2NyZWF0ZWQnLCB0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzLmVsLnJhdy5fcXVpY2tGaWVsZCA9IHRoaXM7XG4gICAgfVxuXG4gICAgX2Zvcm1hdFdpZHRoKHdpZHRoKSB7XG4gICAgICB3aWR0aCA9IHRoaXMuc3RhdGUuaXNNb2JpbGUgPyB0aGlzLnNldHRpbmdzLm1vYmlsZVdpZHRoIHx8IHdpZHRoIDogd2lkdGg7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRpc3RhbmNlICYmIHdpZHRoICE9PSAnMTAwJScpIHtcbiAgICAgICAgd2lkdGggPSBgY2FsYygke3dpZHRofSAtICR7dGhpcy5zZXR0aW5ncy5kaXN0YW5jZX1weClgO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuXG4gICAgYXBwZW5kVG8odGFyZ2V0KSB7XG4gICAgICB0aGlzLmVsLmFwcGVuZFRvKHRhcmdldCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwcmVwZW5kVG8odGFyZ2V0KSB7XG4gICAgICB0aGlzLmVsLnByZXBlbmRUbyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaW5zZXJ0QWZ0ZXIodGFyZ2V0KSB7XG4gICAgICB0aGlzLmVsLmluc2VydEFmdGVyKHRhcmdldCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpbnNlcnRCZWZvcmUodGFyZ2V0KSB7XG4gICAgICB0aGlzLmVsLmluc2VydEJlZm9yZSh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZGV0YWNoKHRhcmdldCkge1xuICAgICAgdGhpcy5lbC5kZXRhY2godGFyZ2V0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJlbW92ZSgpIHtcbiAgICAgIHRoaXMuZWwucmVtb3ZlKCk7XG4gICAgICByZXR1cm4gdGhpcy5kZXN0cm95KGZhbHNlKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KHJlbW92ZUZyb21ET00gPSB0cnVlKSB7XG4gICAgICB2YXIgY2hpbGQsIGksIGxlbiwgcmVmO1xuICAgICAgU2ltcGx5QmluZC51bkJpbmRBbGwodGhpcyk7XG4gICAgICBTaW1wbHlCaW5kLnVuQmluZEFsbCh0aGlzLnN0YXRlKTtcbiAgICAgIFNpbXBseUJpbmQudW5CaW5kQWxsKHRoaXMuZWwpO1xuICAgICAgcmVmID0gdGhpcy5lbC5jaGlsZDtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNoaWxkID0gcmVmW2ldO1xuICAgICAgICBTaW1wbHlCaW5kLnVuQmluZEFsbChjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW1vdmVGcm9tRE9NKSB7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9kZXN0cm95KSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIHRoaXMuYWxsRmllbGRzW3RoaXMuSURdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgb24oZXZlbnROYW1lcywgY2FsbGJhY2ssIHVzZUNhcHR1cmUpIHtcbiAgICAgIHRoaXMuZWwub24uY2FsbCh0aGlzLmVsLCBldmVudE5hbWVzLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBvbmNlKGV2ZW50TmFtZXMsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKSB7XG4gICAgICByZXR1cm4gdGhpcy5vbihldmVudE5hbWVzLCAoKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZXMsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMuZWwsIGFyZ3VtZW50cyk7XG4gICAgICB9LCB1c2VDYXB0dXJlKTtcbiAgICB9XG5cbiAgICBvZmYoKSB7XG4gICAgICB0aGlzLmVsLm9mZi5hcHBseSh0aGlzLmVsLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZW1pdCgpIHtcbiAgICAgIHRoaXMuZWwuZW1pdFByaXZhdGUuYXBwbHkodGhpcy5lbCwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhbGlkYXRlKHByb3ZpZGVkVmFsdWUgPSB0aGlzW3RoaXMuY29yZVZhbHVlUHJvcF0sIHRlc3RVbnJlcXVpcmVkLCByZXBvcnQpIHtcbiAgICAgIHZhciBpc1ZhbGlkO1xuXG4gICAgICBpc1ZhbGlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgY2FzZSAhdGhpcy5zZXR0aW5ncy52YWxpZGF0b3I6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy52YWxpZGF0b3IocHJvdmlkZWRWYWx1ZSk7XG5cbiAgICAgICAgICBjYXNlICEoIXRoaXMuc2V0dGluZ3MucmVxdWlyZWQgJiYgIXRlc3RVbnJlcXVpcmVkKTpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgY2FzZSB0aGlzLl92YWxpZGF0ZShwcm92aWRlZFZhbHVlLCB0ZXN0VW5yZXF1aXJlZCwgcmVwb3J0KSAhPT0gZmFsc2U6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICBjYXNlICF0aGlzLnNldHRpbmdzLnJlcXVpcmVkOlxuICAgICAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgICAgICBjYXNlICF0aGlzLnNldHRpbmdzLm11bHRpcGxlOlxuICAgICAgICAgICAgICAgIHJldHVybiAhIShwcm92aWRlZFZhbHVlICE9IG51bGwgPyBwcm92aWRlZFZhbHVlLmxlbmd0aCA6IHZvaWQgMCk7XG5cbiAgICAgICAgICAgICAgY2FzZSB0eXBlb2YgcHJvdmlkZWRWYWx1ZSAhPT0gJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhcHJvdmlkZWRWYWx1ZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlZFZhbHVlICE9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LmNhbGwodGhpcyk7XG5cbiAgICAgIGlmIChpc1ZhbGlkICYmIHRoaXMuc2V0dGluZ3MuY2xlYXJFcnJvck9uVmFsaWQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zaG93RXJyb3IgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgfVxuXG4gICAgdmFsaWRhdGVDb25kaXRpb25zKGNvbmRpdGlvbnMpIHtcbiAgICAgIHZhciBwYXNzZWRDb25kaXRpb25zLCB0b2dnbGVWaXNpYmlsaXR5O1xuXG4gICAgICBpZiAoY29uZGl0aW9ucykge1xuICAgICAgICB0b2dnbGVWaXNpYmlsaXR5ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25kaXRpb25zID0gdGhpcy5jb25kaXRpb25zO1xuICAgICAgICB0b2dnbGVWaXNpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcGFzc2VkQ29uZGl0aW9ucyA9IENvbmRpdGlvbi52YWxpZGF0ZShjb25kaXRpb25zKTtcblxuICAgICAgaWYgKHRvZ2dsZVZpc2liaWxpdHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUudmlzaWJsZSA9IHBhc3NlZENvbmRpdGlvbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFzc2VkQ29uZGl0aW9ucztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZUFuZFJlcG9ydChwcm92aWRlZFZhbHVlLCB0ZXN0VW5yZXF1aXJlZCkge1xuICAgICAgdmFyIGlzVmFsaWQ7XG4gICAgICBpc1ZhbGlkID0gdGhpcy52YWxpZGF0ZShwcm92aWRlZFZhbHVlLCB0ZXN0VW5yZXF1aXJlZCwgdHJ1ZSk7XG4gICAgICB0aGlzLnN0YXRlLnNob3dFcnJvciA9ICFpc1ZhbGlkO1xuICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgfVxuXG4gIH1cbiAgRmllbGQuaW5zdGFuY2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgRmllbGQuc2hhbGxvd1NldHRpbmdzID0gWyd0ZW1wbGF0ZXMnLCAnZmllbGRJbnN0YW5jZXMnLCAndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG4gIEZpZWxkLnRyYW5zZm9ybVNldHRpbmdzID0gdHJhbnNmb3JtU2V0dGluZ3M7XG4gIEZpZWxkLnByb3RvdHlwZS5nbG9iYWxEZWZhdWx0cyA9IGdsb2JhbERlZmF1bHRzO1xuICBGaWVsZC5wcm90b3R5cGUuY29yZVZhbHVlUHJvcCA9ICdfdmFsdWUnO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhGaWVsZC5wcm90b3R5cGUsIHtcbiAgICAncmVtb3ZlTGlzdGVuZXInOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2Vscyc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5jaGlsZDtcbiAgICAgIH1cbiAgICB9LFxuICAgICd2YWx1ZVJhdyc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICAndmFsdWUnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZ2V0dGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MuZ2V0dGVyKHRoaXMuX2dldFZhbHVlKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldFZhbHVlKHRoaXMuc2V0dGluZ3Muc2V0dGVyID8gdGhpcy5zZXR0aW5ncy5zZXR0ZXIodmFsdWUpIDogdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBGaWVsZDtcbn0uY2FsbCh1bmRlZmluZWQpO1xuXG52YXIgRmllbGQkMSA9IEZpZWxkO2V4cG9ydCBkZWZhdWx0IEZpZWxkJDE7IiwidmFyIGtleUNvZGVzO1xudmFyIEtFWUNPREVTID0ga2V5Q29kZXMgPSB7XG4gIGRlbGV0ZTogOCxcbiAgZW50ZXI6IDEzLFxuICBlc2M6IDI3LFxuICBjdHJsOiAxNyxcbiAgYWx0OiAxOCxcbiAgc2hpZnQ6IDE2LFxuICBzdXBlcjogOTEsXG4gIHN1cGVyMjogOTMsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gIGh5cGhlbjogNDUsXG4gIHVuZGVyc2NvcmU6IDk1LFxuICBxdWVzdGlvbjogNjMsXG4gIGV4Y2xhbWF0aW9uOiAzMyxcbiAgZnJvbnRzbGFzaDogNDcsXG4gIGJhY2tzbGFzaDogOTIsXG4gIGNvbW1hOiA0NCxcbiAgcGVyaW9kOiA0NixcbiAgc3BhY2U6IDMyLFxuICBhbnlBcnJvdzogZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0ga2V5Q29kZXMudXAgfHwgY29kZSA9PT0ga2V5Q29kZXMuZG93biB8fCBjb2RlID09PSBrZXlDb2Rlcy5sZWZ0IHx8IGNvZGUgPT09IGtleUNvZGVzLnJpZ2h0O1xuICB9LFxuICBhbnlNb2RpZmllcjogZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0ga2V5Q29kZXMuY3RybCB8fCBjb2RlID09PSBrZXlDb2Rlcy5hbHQgfHwgY29kZSA9PT0ga2V5Q29kZXMuc2hpZnQgfHwgY29kZSA9PT0ga2V5Q29kZXMuc3VwZXIgfHwgY29kZSA9PT0ga2V5Q29kZXMuc3VwZXIyO1xuICB9LFxuICBhbnlBbHBoYTogZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gOTcgPD0gY29kZSAmJiBjb2RlIDw9IDEyMiB8fCA2NSA8PSBjb2RlICYmIGNvZGUgPD0gOTA7XG4gIH0sXG4gIGFueU51bWVyaWM6IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIDQ4IDw9IGNvZGUgJiYgY29kZSA8PSA1NztcbiAgfSxcbiAgYW55QWxwaGFOdW1lcmljOiBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiBrZXlDb2Rlcy5hbnlBbHBoYShjb2RlKSB8fCBrZXlDb2Rlcy5hbnlOdW1lcmljKGNvZGUpO1xuICB9LFxuICBhbnlQcmludGFibGU6IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIGtleUNvZGVzLmFueUFscGhhKGNvZGUpIHx8IGtleUNvZGVzLmFueU51bWVyaWMoY29kZSkgfHwgY29kZSA9PT0ga2V5Q29kZXMuaHlwaGVuIHx8IGNvZGUgPT09IGtleUNvZGVzLnVuZGVyc2NvcmUgfHwgY29kZSA9PT0ga2V5Q29kZXMucXVlc3Rpb24gfHwgY29kZSA9PT0ga2V5Q29kZXMuZXhjbGFtYXRpb24gfHwgY29kZSA9PT0ga2V5Q29kZXMuZnJvbnRzbGFzaCB8fCBjb2RlID09PSBrZXlDb2Rlcy5iYWNrc2xhc2ggfHwgY29kZSA9PT0ga2V5Q29kZXMuY29tbWEgfHwgY29kZSA9PT0ga2V5Q29kZXMucGVyaW9kIHx8IGNvZGUgPT09IGtleUNvZGVzLnNwYWNlO1xuICB9XG59O2V4cG9ydCBkZWZhdWx0IEtFWUNPREVTOyIsImltcG9ydCBET00gZnJvbSdxdWlja2RvbSc7dmFyIGNoZWNrbWFyayA9IERPTS50ZW1wbGF0ZShbJypzdmcnLCB7XG4gIGF0dHJzOiB7XG4gICAgd2lkdGg6ICcxMnB4JyxcbiAgICBoZWlnaHQ6ICcxMnB4JyxcbiAgICB2aWV3Qm94OiAnNSA3IDEyIDEyJyxcbiAgICB0YWJpbmRleDogLTEsXG4gICAgZm9jdXNhYmxlOiBmYWxzZVxuICB9LFxuICBzdHlsZToge1xuICAgIHdpZHRoOiAnOXB4JyxcbiAgICBoZWlnaHQ6ICc5cHgnXG4gIH1cbn0sIFsnKnBvbHlsaW5lJywge1xuICBhdHRyczoge1xuICAgICdzdHJva2Utd2lkdGgnOiAnMicsXG4gICAgJ3N0cm9rZS1saW5lY2FwJzogJ3JvdW5kJyxcbiAgICAnc3Ryb2tlLWxpbmVqb2luJzogJ3JvdW5kJyxcbiAgICBmaWxsOiAnbm9uZScsXG4gICAgcG9pbnRzOiAnNyAxMy44ODg4ODg5IDkuNjY2NjY2NjcgMTcgMTUgOScsXG4gICAgdGFiaW5kZXg6IC0xLFxuICAgIGZvY3VzYWJsZTogZmFsc2VcbiAgfVxufV1dKTtleHBvcnQgZGVmYXVsdCBjaGVja21hcms7IiwiaW1wb3J0IERPTSBmcm9tJ3F1aWNrZG9tJzt2YXIgYW5nbGVEb3duID0gRE9NLnRlbXBsYXRlKFsnKnN2ZycsIHtcbiAgYXR0cnM6IHtcbiAgICB3aWR0aDogJzE3OTJweCcsXG4gICAgaGVpZ2h0OiAnMTc5MnB4JyxcbiAgICB2aWV3Qm94OiAnMCAwIDE3OTIgMTc5MicsXG4gICAgdGFiaW5kZXg6IC0xLFxuICAgIGZvY3VzYWJsZTogZmFsc2VcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIG91dGxpbmU6ICdub25lJ1xuICB9XG59LCBbJypwYXRoJywge1xuICBhdHRyczoge1xuICAgIHRhYmluZGV4OiAtMSxcbiAgICBmb2N1c2FibGU6IGZhbHNlLFxuICAgIGQ6ICdNMTM5NSA3MzZxMCAxMy0xMCAyM2wtNDY2IDQ2NnEtMTAgMTAtMjMgMTB0LTIzLTEwbC00NjYtNDY2cS0xMC0xMC0xMC0yM3QxMC0yM2w1MC01MHExMC0xMCAyMy0xMHQyMyAxMGwzOTMgMzkzIDM5My0zOTNxMTAtMTAgMjMtMTB0MjMgMTBsNTAgNTBxMTAgMTAgMTAgMjN6J1xuICB9XG59XV0pO2V4cG9ydCBkZWZhdWx0IGFuZ2xlRG93bjsiLCJpbXBvcnQgRE9NIGZyb20ncXVpY2tkb20nO3ZhciBjYXJldFVwID0gRE9NLnRlbXBsYXRlKFsnKnN2ZycsIHtcbiAgYXR0cnM6IHtcbiAgICB2aWV3Qm94OiAnMCAwIDUxMiA1MTInLFxuICAgIHRhYmluZGV4OiAtMSxcbiAgICBmb2N1c2FibGU6IGZhbHNlXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICBvdXRsaW5lOiAnbm9uZSdcbiAgfVxufSwgWycqcGF0aCcsIHtcbiAgYXR0cnM6IHtcbiAgICB0YWJpbmRleDogLTEsXG4gICAgZm9jdXNhYmxlOiBmYWxzZSxcbiAgICBkOiAnTTQwMiAzNDdjMCA1LTIgMTAtNSAxMy00IDQtOCA2LTEzIDZoLTI1NmMtNSAwLTktMi0xMy02LTMtMy01LTgtNS0xM3MyLTkgNS0xMmwxMjgtMTI4YzQtNCA4LTYgMTMtNnM5IDIgMTMgNmwxMjggMTI4YzMgMyA1IDcgNSAxMnonXG4gIH1cbn1dXSk7ZXhwb3J0IGRlZmF1bHQgY2FyZXRVcDsiLCJpbXBvcnQgRE9NIGZyb20ncXVpY2tkb20nO3ZhciBjYXJldERvd24gPSBET00udGVtcGxhdGUoWycqc3ZnJywge1xuICBhdHRyczoge1xuICAgIHZpZXdCb3g6ICcwIDAgNTEyIDUxMicsXG4gICAgdGFiaW5kZXg6IC0xLFxuICAgIGZvY3VzYWJsZTogZmFsc2VcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIG91dGxpbmU6ICdub25lJ1xuICB9XG59LCBbJypwYXRoJywge1xuICBhdHRyczoge1xuICAgIHRhYmluZGV4OiAtMSxcbiAgICBmb2N1c2FibGU6IGZhbHNlLFxuICAgIGQ6ICdNNDAyIDIwMWMwIDUtMiA5LTUgMTNsLTEyOCAxMjhjLTQgNC04IDUtMTMgNXMtOS0xLTEzLTVsLTEyOC0xMjhjLTMtNC01LTgtNS0xM3MyLTkgNS0xM2M0LTMgOC01IDEzLTVoMjU2YzUgMCA5IDIgMTMgNSAzIDQgNSA4IDUgMTN6J1xuICB9XG59XV0pO2V4cG9ydCBkZWZhdWx0IGNhcmV0RG93bjsiLCJpbXBvcnQgRE9NIGZyb20ncXVpY2tkb20nO3ZhciBwbHVzID0gRE9NLnRlbXBsYXRlKFsnKnN2ZycsIHtcbiAgYXR0cnM6IHtcbiAgICB2aWV3Qm94OiAnMCAwIDE1IDE1JyxcbiAgICB0YWJpbmRleDogLTEsXG4gICAgZm9jdXNhYmxlOiBmYWxzZVxuICB9LFxuICBzdHlsZToge1xuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgb3V0bGluZTogJ25vbmUnXG4gIH1cbn0sIFsnKnBvbHlnb24nLCB7XG4gIGF0dHJzOiB7XG4gICAgdGFiaW5kZXg6IC0xLFxuICAgIGZvY3VzYWJsZTogZmFsc2UsXG4gICAgcG9pbnRzOiAnOSAwIDYgMCA2IDYgMCA2IDAgOSA2IDkgNiAxNSA5IDE1IDkgOSAxNSA5IDE1IDYgOSA2J1xuICB9XG59XV0pO2V4cG9ydCBkZWZhdWx0IHBsdXM7IiwiaW1wb3J0IERPTSBmcm9tJ3F1aWNrZG9tJzt2YXIgY2xvbmUgPSBET00udGVtcGxhdGUoWycqc3ZnJywge1xuICBhdHRyczoge1xuICAgIHZpZXdCb3g6ICcwIDAgMTggMjAnLFxuICAgIHRhYmluZGV4OiAtMSxcbiAgICBmb2N1c2FibGU6IGZhbHNlXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICBvdXRsaW5lOiAnbm9uZSdcbiAgfVxufSwgWycqcGF0aCcsIHtcbiAgYXR0cnM6IHtcbiAgICB0YWJpbmRleDogLTEsXG4gICAgZm9jdXNhYmxlOiBmYWxzZSxcbiAgICBkOiAnTTEzLjQxNCwwIEw2LDAgQzQuODk3LDAgNCwwLjg5OCA0LDIgTDQsMTQgQzQsMTUuMTAzIDQuODk3LDE2IDYsMTYgTDE2LDE2IEMxNy4xMDMsMTYgMTgsMTUuMTAzIDE4LDE0IEwxOCw0LjU4NiBMMTMuNDE0LDAgWiBNMTYuMDAxLDE0IEw2LDE0IEw2LDIgTDEyLDIgTDEyLDYgTDE2LDYgTDE2LjAwMSwxNCBaJ1xuICB9XG59XSwgWycqcGF0aCcsIHtcbiAgYXR0cnM6IHtcbiAgICB0YWJpbmRleDogLTEsXG4gICAgZm9jdXNhYmxlOiBmYWxzZSxcbiAgICBkOiAnTTIsNi40MjM3OTI4MiBMMCw2LjQyMzc5MjgyIEwwLDE4IEMwLDE5LjEwMyAwLjg5NywyMCAyLDIwIEwxNCwyMCBMMTQsMTggTDIsMTggTDIsNi40MjM3OTI4MiBaJ1xuICB9XG59XV0pO2V4cG9ydCBkZWZhdWx0IGNsb25lOyIsImltcG9ydCdxdWlja2RvbSc7aW1wb3J0IHBsdXMgZnJvbScuL3BsdXMuanMnO3ZhciByZW1vdmUgPSBwbHVzLmV4dGVuZCh7XG4gIG9wdGlvbnM6IHtcbiAgICBzdHlsZToge1xuICAgICAgdHJhbnNmb3JtOiAncm90YXRlKDQ1ZGVnKSdcbiAgICB9XG4gIH1cbn0pO2V4cG9ydCBkZWZhdWx0IHJlbW92ZTsiLCJpbXBvcnQgRE9NIGZyb20ncXVpY2tkb20nO2ltcG9ydCB7aGV4VG9SR0JBfWZyb20nLi4vLi4vaGVscGVycy5qcyc7aW1wb3J0IGNoZWNrbWFyayBmcm9tJy4uLy4uL3N2Zy9jaGVja21hcmsuanMnO2ltcG9ydCcuLi8uLi9zdmcvYW5nbGVEb3duLmpzJztpbXBvcnQgY2FyZXRVcCBmcm9tJy4uLy4uL3N2Zy9jYXJldFVwLmpzJztpbXBvcnQgY2FyZXREb3duIGZyb20nLi4vLi4vc3ZnL2NhcmV0RG93bi5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9wbHVzLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2Nsb25lLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3JlbW92ZS5qcyc7dmFyIHRlbXBsYXRlID0gRE9NLnRlbXBsYXRlKFsnZGl2Jywge1xuICByZWY6ICdkcm9wZG93bicsXG4gIHN0eWxlQWZ0ZXJJbnNlcnQ6IHRydWUsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgekluZGV4OiAxMCxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgdG9wOiBmdW5jdGlvbiAoZHJvcGRvd24pIHtcbiAgICAgIGlmIChkcm9wZG93bi5maWVsZC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnJhdy5zdHlsZS5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJy03cHgnO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGVmdDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMucGFyZW50LnJlY3QubGVmdCAtIDUgPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC01O1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlzcGxheTogJ25vbmUnLFxuICAgIC8vIGJhY2tncm91bmRDb2xvcjogaGV4VG9SR0JBKCdmNmY2ZjYnLCAwLjkpXG4gICAgYmFja2dyb3VuZENvbG9yOiAnI2Y2ZjZmNicsXG4gICAgYm94U2hhZG93OiBgMHB4IDZweCAxMHB4ICR7aGV4VG9SR0JBKCcwMDAwMDAnLCAwLjMyKX1gLFxuICAgIGJvcmRlcldpZHRoOiAnMXB4JyxcbiAgICBib3JkZXJTdHlsZTogJ3NvbGlkJyxcbiAgICBib3JkZXJDb2xvcjogJyNkMWQxZDEnLFxuICAgIGJvcmRlclJhZGl1czogJzVweCcsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgcGFkZGluZzogJzRweCAwJyxcbiAgICAkaXNPcGVuOiB7XG4gICAgICAkaGFzVmlzaWJsZUNob2ljZXM6IHtcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgfVxuICAgIH1cbiAgfVxufV0pO1xudmFyIGxpc3QgPSBET00udGVtcGxhdGUoWydkaXYnLCB7XG4gIHJlZjogJ2xpc3QnLFxuICBwYXNzU3RhdGVUb0NoaWxkcmVuOiBmYWxzZSxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBvdmVyZmxvdzogJ3Njcm9sbCcsXG4gICAgb3ZlcmZsb3dTY3JvbGxpbmc6ICd0b3VjaCcsXG4gICAgb3ZlcmZsb3dTdHlsZTogJy1tcy1hdXRvaGlkaW5nLXNjcm9sbGJhcidcbiAgfVxufV0pO1xudmFyIGNob2ljZSA9IERPTS50ZW1wbGF0ZShbJ2RpdicsIHtcbiAgc3R5bGU6IHtcbiAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgZm9udFNpemU6ICcwJyxcbiAgICBjb2xvcjogJyMwMDAwMDAnLFxuICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICBsaW5lSGVpZ2h0OiAnMWVtJyxcbiAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAkdmlzaWJsZToge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgIH0sXG4gICAgJHVuYXZhaWxhYmxlOiB7XG4gICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICB9LFxuICAgICRob3Zlcjoge1xuICAgICAgY29sb3I6ICcjZmZmZmZmJyxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJyM0Qzk2RkYnXG4gICAgfVxuICB9XG59LCBbJ2RpdicsIC8vIENoZWNrbWFya1xue1xuICBzdHlsZToge1xuICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgIHdpZHRoOiAnMjBweCcsXG4gICAgLy8gaGVpZ2h0OiAoKS0+IEBwYXJlbnQucmF3LnN0eWxlLmhlaWdodFxuICAgIC8vIGxpbmVIZWlnaHQ6ICgpLT4gQHBhcmVudC5zdHlsZSgnaGVpZ2h0JylcbiAgICAvLyBmb250U2l6ZTogKCktPiBAcGFyZW50LnN0eWxlKCdoZWlnaHQnKVxuICAgIGxpbmVIZWlnaHQ6ICcyMHB4JyxcbiAgICBmb250U2l6ZTogJzEzcHgnLFxuICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgY29sb3I6ICdpbmhlcml0JyxcbiAgICBzdHJva2U6ICdjdXJyZW50Q29sb3InLFxuICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgICRzZWxlY3RlZDoge1xuICAgICAgdmlzaWJpbGl0eTogJ3Zpc2libGUnXG4gICAgfVxuICB9XG59LCBjaGVja21hcmtdLCBbJ2RpdicsIC8vIFRleHRcbntcbiAgc3R5bGVBZnRlckluc2VydDogdHJ1ZSxcbiAgc3R5bGU6IHtcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnLFxuICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIHdvcmRXcmFwOiAnbm9ybWFsJyxcbiAgICBtYXhXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGBjYWxjKDEwMCUgLSAke3RoaXMucHJldi5zdHlsZVNhZmUoJ3dpZHRoJywgdHJ1ZSl9KWA7XG4gICAgfSxcbiAgICBwYWRkaW5nUmlnaHQ6ICcxMHB4JyxcbiAgICBsaW5lSGVpZ2h0OiAnMjBweCcsXG4gICAgZm9udFNpemU6ICcxMXB4JyxcbiAgICBmb250RmFtaWx5OiBmdW5jdGlvbiAoZHJvcGRvd24pIHtcbiAgICAgIHJldHVybiBkcm9wZG93bi5zZXR0aW5ncy5mb250RmFtaWx5O1xuICAgIH0sXG4gICAgY29sb3I6ICdpbmhlcml0JyxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94J1xuICB9XG59XV0pO1xudmFyIHNjcm9sbEluZGljYXRvclVwID0gRE9NLnRlbXBsYXRlKFsnZGl2Jywge1xuICByZWY6ICdzY3JvbGxJbmRpY2F0b3JVcCcsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgZGlzcGxheTogJ25vbmUnLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMjBweCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiAnI2Y2ZjZmNicsXG4gICAgY29sb3I6ICcjMDAwMDAwJyxcbiAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICR2aXNpYmxlOiB7XG4gICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgfVxuICB9XG59LCBbJ2RpdicsIHtcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6ICc1MCUnLFxuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgd2lkdGg6ICcxNXB4JyxcbiAgICBoZWlnaHQ6ICcxNXB4JyxcbiAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgIG1hcmdpbjogJzAgYXV0bycsXG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtNTAlKSdcbiAgfVxufSwgY2FyZXRVcF1dKTtcbnZhciBzY3JvbGxJbmRpY2F0b3JEb3duID0gRE9NLnRlbXBsYXRlKFsnZGl2Jywge1xuICByZWY6ICdzY3JvbGxJbmRpY2F0b3JEb3duJyxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcyMHB4JyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjZmNmY2JyxcbiAgICBjb2xvcjogJyMwMDAwMDAnLFxuICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgJHZpc2libGU6IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICB9XG4gIH1cbn0sIFsnZGl2Jywge1xuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogJzUwJScsXG4gICAgbGVmdDogMCxcbiAgICByaWdodDogMCxcbiAgICB3aWR0aDogJzE1cHgnLFxuICAgIGhlaWdodDogJzE1cHgnLFxuICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgbWFyZ2luOiAnMCBhdXRvJyxcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC01MCUpJ1xuICB9XG59LCBjYXJldERvd25dXSk7XG52YXIgaGVscCA9IERPTS50ZW1wbGF0ZShbJ2RpdicsIHtcbiAgcmVmOiAnaGVscCcsXG4gIHN0eWxlOiB7XG4gICAgZGlzcGxheTogJ25vbmUnLFxuICAgIGJvcmRlclRvcDogJzJweCBzb2xpZCByZ2JhKDAsMCwwLDAuMDUpJyxcbiAgICBwYWRkaW5nOiAnNHB4IDEycHggMXB4JyxcbiAgICBjb2xvcjogJ3JnYmEoMCwwLDAsMC41KScsXG4gICAgZm9udFdlaWdodDogJzUwMCcsXG4gICAgZm9udFNpemU6ICcxMXB4JyxcbiAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgJHNob3dIZWxwOiB7XG4gICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgfVxuICB9XG59XSk7dmFyIHRlbXBsYXRlJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDogdGVtcGxhdGUsbGlzdDogbGlzdCxjaG9pY2U6IGNob2ljZSxzY3JvbGxJbmRpY2F0b3JVcDogc2Nyb2xsSW5kaWNhdG9yVXAsc2Nyb2xsSW5kaWNhdG9yRG93bjogc2Nyb2xsSW5kaWNhdG9yRG93bixoZWxwOiBoZWxwfSk7ZXhwb3J0e3RlbXBsYXRlJDEgYXMgYSx0ZW1wbGF0ZSBhcyBiLGxpc3QgYXMgYyxjaG9pY2UgYXMgZCxzY3JvbGxJbmRpY2F0b3JVcCBhcyBlLHNjcm9sbEluZGljYXRvckRvd24gYXMgZixoZWxwIGFzIGd9OyIsInZhciBkZWZhdWx0cyA9IHtcbiAgbWF4SGVpZ2h0OiAzMDAsXG4gIG11bHRpcGxlOiBmYWxzZSxcbiAgbG9ja1Njcm9sbDogdHJ1ZSxcbiAgdHlwZUJ1ZmZlcjogZmFsc2UsXG4gIGhlbHA6ICcnLFxuICB0ZW1wbGF0ZXM6IHt9XG59O2V4cG9ydCBkZWZhdWx0IGRlZmF1bHRzOyIsImltcG9ydCdAZGFuaWVsa2FsZW4vaXMnO2ltcG9ydCBJUyBmcm9tJy4uLy4uL2NoZWNrcy5qcyc7aW1wb3J0IERPTSBmcm9tJ3F1aWNrZG9tJztpbXBvcnQgU2ltcGx5QmluZCBmcm9tJ0BkYW5pZWxrYWxlbi9zaW1wbHliaW5kJztpbXBvcnQnLi4vLi4vY29uc3RhbnRzL3JlZ2V4LmpzJztpbXBvcnQge3JlbW92ZUl0ZW0sbm9vcCxsb2NrU2Nyb2xsLHVubG9ja1Njcm9sbCxzdGFydHNXaXRofWZyb20nLi4vLi4vaGVscGVycy5qcyc7aW1wb3J0IGV4dGVuZCBmcm9tJ3NtYXJ0LWV4dGVuZCc7aW1wb3J0IENvbmRpdGlvbiBmcm9tJy4uL2NvbmRpdGlvbi5qcyc7aW1wb3J0IGdsb2JhbERlZmF1bHRzIGZyb20nLi4vLi4vZmllbGQvZ2xvYmFsRGVmYXVsdHMuanMnO2ltcG9ydCBLRVlDT0RFUyBmcm9tJy4uLy4uL2NvbnN0YW50cy9rZXlDb2Rlcy5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jaGVja21hcmsuanMnO2ltcG9ydCcuLi8uLi9zdmcvYW5nbGVEb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NhcmV0VXAuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2FyZXREb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3BsdXMuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2xvbmUuanMnO2ltcG9ydCcuLi8uLi9zdmcvcmVtb3ZlLmpzJztpbXBvcnQge2EgYXMgdGVtcGxhdGV9ZnJvbScuL3RlbXBsYXRlLWI5NjFmODFmLmpzJztpbXBvcnQgZGVmYXVsdHMgZnJvbScuL2RlZmF1bHRzLmpzJzt2YXIgQ2hvaWNlLCBEcm9wZG93biwgTGlzdDtcblxuRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gIGNsYXNzIERyb3Bkb3duIHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsQ2hvaWNlcywgZmllbGQpIHtcbiAgICAgIHRoaXMuaW5pdGlhbENob2ljZXMgPSBpbml0aWFsQ2hvaWNlcztcbiAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICB0aGlzLnR5cGVCdWZmZXIgPSAnJztcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSBleHRlbmQuZGVlcC5jbG9uZS5maWx0ZXIodGhpcy5fc2V0dGluZ0ZpbHRlcnMpKGdsb2JhbERlZmF1bHRzLCB0aGlzLmRlZmF1bHRzLCB0aGlzLmZpZWxkLnNldHRpbmdzLmRyb3Bkb3duKTtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLnNldHRpbmdzLm11bHRpcGxlID8gW10gOiBudWxsO1xuICAgICAgdGhpcy5sYXN0U2VsZWN0ZWQgPSBudWxsO1xuICAgICAgdGhpcy5jaG9pY2VzID0gW107XG4gICAgICB0aGlzLmN1cnJlbnRIaWdobGlnaHRlZCA9IG51bGw7XG4gICAgICB0aGlzLnZpc2libGVDaG9pY2VzQ291bnQgPSAwO1xuICAgICAgdGhpcy52aXNpYmxlQ2hvaWNlcyA9IFtdO1xuICAgICAgdGhpcy5lbHMgPSB7fTtcbiAgICAgIHRoaXMuX3NlbGVjdGVkQ2FsbGJhY2sgPSBub29wO1xuXG4gICAgICB0aGlzLl9jcmVhdGVFbGVtZW50cygpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5ncygpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlRWxlbWVudHMoKSB7XG4gICAgICB2YXIgY2hvaWNlLCBnbG9iYWxPcHRzLCBpLCBsZW4sIHJlZjtcbiAgICAgIGdsb2JhbE9wdHMgPSB7XG4gICAgICAgIHJlbGF0ZWRJbnN0YW5jZTogdGhpc1xuICAgICAgfTtcbiAgICAgIHRoaXMuZWxzLmNvbnRhaW5lciA9IHRoaXMudGVtcGxhdGUuZGVmYXVsdC5zcGF3bih0aGlzLnNldHRpbmdzLnRlbXBsYXRlcy5kZWZhdWx0LCBleHRlbmQoe1xuICAgICAgICBwYXNzU3RhdGVUb0NoaWxkcmVuOiBmYWxzZVxuICAgICAgfSwgZ2xvYmFsT3B0cykpO1xuICAgICAgdGhpcy5lbHMubGlzdCA9IHRoaXMudGVtcGxhdGUubGlzdC5zcGF3bih0aGlzLnNldHRpbmdzLnRlbXBsYXRlcy5saXN0LCBnbG9iYWxPcHRzKS5hcHBlbmRUbyh0aGlzLmVscy5jb250YWluZXIpO1xuICAgICAgdGhpcy5lbHMuaGVscCA9IHRoaXMudGVtcGxhdGUuaGVscC5zcGF3bih0aGlzLnNldHRpbmdzLnRlbXBsYXRlcy5oZWxwLCBnbG9iYWxPcHRzKS5hcHBlbmRUbyh0aGlzLmVscy5jb250YWluZXIpO1xuICAgICAgdGhpcy5lbHMuc2Nyb2xsSW5kaWNhdG9yVXAgPSB0aGlzLnRlbXBsYXRlLnNjcm9sbEluZGljYXRvclVwLnNwYXduKHRoaXMuc2V0dGluZ3MudGVtcGxhdGVzLnNjcm9sbEluZGljYXRvclVwLCBnbG9iYWxPcHRzKS5hcHBlbmRUbyh0aGlzLmVscy5jb250YWluZXIpO1xuICAgICAgdGhpcy5lbHMuc2Nyb2xsSW5kaWNhdG9yRG93biA9IHRoaXMudGVtcGxhdGUuc2Nyb2xsSW5kaWNhdG9yRG93bi5zcGF3bih0aGlzLnNldHRpbmdzLnRlbXBsYXRlcy5zY3JvbGxJbmRpY2F0b3JEb3duLCBnbG9iYWxPcHRzKS5hcHBlbmRUbyh0aGlzLmVscy5jb250YWluZXIpO1xuICAgICAgdGhpcy5saXN0ID0gbmV3IExpc3QodGhpcyk7XG4gICAgICByZWYgPSB0aGlzLmluaXRpYWxDaG9pY2VzO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY2hvaWNlID0gcmVmW2ldO1xuICAgICAgICB0aGlzLmFkZENob2ljZShjaG9pY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5ncygpIHtcbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX2VsU3RhdGUoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfZGlzcGxheSgpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fYXR0YWNoQmluZGluZ3Nfc2Nyb2xsSW5kaWNhdG9ycygpO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc19lbFN0YXRlKCkge1xuICAgICAgU2ltcGx5QmluZCgnaGVscCcpLm9mKHRoaXMuc2V0dGluZ3MpLnRvKCd0ZXh0Jykub2YodGhpcy5lbHMuaGVscCkuYW5kLnRvKHNob3dIZWxwID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxzLmhlbHAuc3RhdGUoJ3Nob3dIZWxwJywgc2hvd0hlbHApO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCd2aXNpYmxlQ2hvaWNlc0NvdW50Jykub2YodGhpcykudG8oY291bnQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbHMuY29udGFpbmVyLnN0YXRlKCdoYXNWaXNpYmxlQ2hvaWNlcycsICEhY291bnQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gU2ltcGx5QmluZCgnY3VycmVudEhpZ2hsaWdodGVkJykub2YodGhpcykudG8oKGN1cnJlbnQsIHByZXYpID0+IHtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICBwcmV2LmVsLnN0YXRlKCdob3ZlcicsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnQuZWwuc3RhdGUoJ2hvdmVyJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc19kaXNwbGF5KCkge1xuICAgICAgU2ltcGx5QmluZCgnaXNPcGVuJywge1xuICAgICAgICB1cGRhdGVPbkJpbmQ6IGZhbHNlXG4gICAgICB9KS5vZih0aGlzKS50byhpc09wZW4gPT4ge1xuICAgICAgICB0aGlzLmVscy5jb250YWluZXIuc3RhdGUoJ2lzT3BlbicsIGlzT3Blbik7XG5cbiAgICAgICAgaWYgKCFpc09wZW4pIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRIaWdobGlnaHRlZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5sb2NrU2Nyb2xsKSB7XG4gICAgICAgICAgaWYgKGlzT3Blbikge1xuICAgICAgICAgICAgbG9ja1Njcm9sbCh0aGlzLmVscy5saXN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5sb2NrU2Nyb2xsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzT3Blbikge1xuICAgICAgICAgIHRoaXMubGlzdC5hcHBlbmRDaG9pY2VzKCk7XG4gICAgICAgICAgdGhpcy5saXN0LmNhbGNEaXNwbGF5KCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCAmJiAhdGhpcy5zZXR0aW5ncy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5zY3JvbGxUb0Nob2ljZSh0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5zZXRUcmFuc2xhdGUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnbGFzdFNlbGVjdGVkJywge1xuICAgICAgICB1cGRhdGVPbkJpbmQ6IGZhbHNlLFxuICAgICAgICB1cGRhdGVFdmVuSWZTYW1lOiB0cnVlXG4gICAgICB9KS5vZih0aGlzKS50bygobmV3Q2hvaWNlLCBwcmV2Q2hvaWNlKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZENhbGxiYWNrKG5ld0Nob2ljZSwgcHJldkNob2ljZSk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2ZvY3VzZWQnLCB7XG4gICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICAgIH0pLm9mKHRoaXMuZmllbGQuc3RhdGUpLnRvKGZvY3VzZWQgPT4ge1xuICAgICAgICBpZiAoIWZvY3VzZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5lbC5jaGlsZC5pbnB1dC5vZmYoJ2tleWRvd24uZHJvcGRvd25OYXYnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5lbC5jaGlsZC5pbnB1dC5vbigna2V5ZG93bi5kcm9wZG93bk5hdicsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEtFWUNPREVTLnVwOlxuICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZ2hsaWdodFByZXYoKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgS0VZQ09ERVMuZG93bjpcbiAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oaWdobGlnaHROZXh0KCk7XG5cbiAgICAgICAgICAgICAgICBjYXNlIEtFWUNPREVTLmVudGVyOlxuICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudEhpZ2hsaWdodGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxhc3RTZWxlY3RlZCA9IHRoaXMuY3VycmVudEhpZ2hsaWdodGVkO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgS0VZQ09ERVMuZXNjOlxuICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXRoaXMuc2V0dGluZ3MudHlwZUJ1ZmZlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIFNpbXBseUJpbmQoJ2ZvY3VzZWQnLCB7XG4gICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICAgIH0pLm9mKHRoaXMuZmllbGQuc3RhdGUpLnRvKGZvY3VzZWQgPT4ge1xuICAgICAgICBpZiAoIWZvY3VzZWQpIHtcbiAgICAgICAgICByZXR1cm4gRE9NKGRvY3VtZW50KS5vZmYoJ2tleXByZXNzLmRyb3Bkb3duVHlwZUJ1ZmZlcicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBET00oZG9jdW1lbnQpLm9uKCdrZXlwcmVzcy5kcm9wZG93blR5cGVCdWZmZXInLCBldmVudCA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICBpZiAoIUtFWUNPREVTLmFueVByaW50YWJsZShldmVudC5rZXlDb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGVCdWZmZXIgKz0gZXZlbnQua2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBTaW1wbHlCaW5kKCd0eXBlQnVmZmVyJywge1xuICAgICAgICB1cGRhdGVPbkJpbmQ6IGZhbHNlXG4gICAgICB9KS5vZih0aGlzKS50bygoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnR5cGVCdWZmZXJUaW1lb3V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZUJ1ZmZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50eXBlQnVmZmVyID0gJyc7XG4gICAgICAgIH0sIDE1MDApO1xuICAgICAgfSkuYW5kLnRvKGJ1ZmZlciA9PiB7XG4gICAgICAgIHZhciBjaG9pY2UsIGksIGxlbiwgcmVmO1xuXG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICByZWYgPSB0aGlzLnZpc2libGVDaG9pY2VzO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaG9pY2UgPSByZWZbaV07XG5cbiAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKGJ1ZmZlciwgY2hvaWNlLmxhYmVsKSkge1xuICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRIaWdobGlnaHRlZCA9IGNob2ljZTtcblxuICAgICAgICAgICAgICBpZiAoIXRoaXMubGlzdC5jaG9pY2VJblZpZXcoY2hvaWNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdC5zY3JvbGxUb0Nob2ljZShjaG9pY2UpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX3Njcm9sbEluZGljYXRvcnMoKSB7XG4gICAgICBTaW1wbHlCaW5kKCdzY3JvbGxUb3AnLCB7XG4gICAgICAgIHVwZGF0ZUV2ZW5JZlNhbWU6IHRydWVcbiAgICAgIH0pLm9mKHRoaXMuZWxzLmxpc3QucmF3KS50byhzY3JvbGxUb3AgPT4ge1xuICAgICAgICB2YXIgc2hvd0JvdHRvbUluZGljYXRvciwgc2hvd1RvcEluZGljYXRvcjtcbiAgICAgICAgc2hvd1RvcEluZGljYXRvciA9IHNjcm9sbFRvcCA+IDA7XG4gICAgICAgIHNob3dCb3R0b21JbmRpY2F0b3IgPSB0aGlzLmVscy5saXN0LnJhdy5zY3JvbGxIZWlnaHQgLSB0aGlzLmVscy5saXN0LnJhdy5jbGllbnRIZWlnaHQgPiBzY3JvbGxUb3A7XG4gICAgICAgIHRoaXMuZWxzLnNjcm9sbEluZGljYXRvclVwLnN0YXRlKCd2aXNpYmxlJywgc2hvd1RvcEluZGljYXRvcik7XG4gICAgICAgIHJldHVybiB0aGlzLmVscy5zY3JvbGxJbmRpY2F0b3JEb3duLnN0YXRlKCd2aXNpYmxlJywgc2hvd0JvdHRvbUluZGljYXRvcik7XG4gICAgICB9KS5jb25kaXRpb24oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pc09wZW4gJiYgIXRoaXMuc2V0dGluZ3MuaGVscCAmJiB0aGlzLmVscy5saXN0LnJhdy5zY3JvbGxIZWlnaHQgIT09IHRoaXMuZWxzLmxpc3QucmF3LmNsaWVudEhlaWdodCAmJiB0aGlzLmVscy5saXN0LnJhdy5jbGllbnRIZWlnaHQgPj0gMTAwO1xuICAgICAgfSkudXBkYXRlT24oJ2V2ZW50OnNjcm9sbCcpLm9mKHRoaXMuZWxzLmxpc3QucmF3KS51cGRhdGVPbignaXNPcGVuJykub2YodGhpcyk7XG4gICAgICB0aGlzLmVscy5zY3JvbGxJbmRpY2F0b3JVcC5vbignbW91c2VlbnRlcicsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5zdGFydFNjcm9sbGluZygndXAnKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbHMuc2Nyb2xsSW5kaWNhdG9yVXAub24oJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3Quc3RvcFNjcm9sbGluZygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVscy5zY3JvbGxJbmRpY2F0b3JEb3duLm9uKCdtb3VzZWVudGVyJywgKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0LnN0YXJ0U2Nyb2xsaW5nKCdkb3duJyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLmVscy5zY3JvbGxJbmRpY2F0b3JEb3duLm9uKCdtb3VzZWxlYXZlJywgKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0LnN0b3BTY3JvbGxpbmcoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkZENob2ljZShjb25maWcpIHtcbiAgICAgIHZhciBpLCBpdGVtLCBsZW4sIG5ld0Nob2ljZTtcblxuICAgICAgaWYgKElTLmFycmF5KGNvbmZpZykpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY29uZmlnLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IGNvbmZpZ1tpXTtcbiAgICAgICAgICB0aGlzLmFkZENob2ljZShpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoSVMuc3RyaW5nKGNvbmZpZykpIHtcbiAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgIGxhYmVsOiBjb25maWcsXG4gICAgICAgICAgdmFsdWU6IGNvbmZpZ1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChJUy5vYmplY3RQbGFpbihjb25maWcpKSB7XG4gICAgICAgIGlmIChjb25maWcudmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbmZpZy52YWx1ZSA9IGNvbmZpZy5sYWJlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcubGFiZWwgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbmZpZy5sYWJlbCA9IGNvbmZpZy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBuZXdDaG9pY2UgPSBuZXcgQ2hvaWNlKHRoaXMsIGNvbmZpZywgdGhpcy5saXN0LCB0aGlzLmNob2ljZXMubGVuZ3RoKTtcblxuICAgICAgaWYgKHRoaXMubGlzdC5hcHBlbmRlZENob2ljZXMpIHtcbiAgICAgICAgbmV3Q2hvaWNlLmluaXQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jaG9pY2VzLnB1c2gobmV3Q2hvaWNlKTtcbiAgICAgIHJldHVybiBuZXdDaG9pY2U7XG4gICAgfVxuXG4gICAgcmVtb3ZlQ2hvaWNlKGNob2ljZSkge1xuICAgICAgdmFyIGksIGl0ZW0sIGxlbjtcblxuICAgICAgaWYgKElTLmFycmF5KGNob2ljZSkpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY2hvaWNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IGNob2ljZVtpXTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNob2ljZShpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNob2ljZSA9IHRoaXMuZmluZENob2ljZUFueShjaG9pY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNob2ljZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaG9pY2UucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgcmVwbGFjZUNob2ljZXMobmV3Q2hvaWNlcykge1xuICAgICAgdGhpcy5yZW1vdmVDaG9pY2UodGhpcy5jaG9pY2VzLnNsaWNlKCkpO1xuICAgICAgdGhpcy5hZGRDaG9pY2UobmV3Q2hvaWNlcyk7XG4gICAgfVxuXG4gICAgYXBwZW5kVG8odGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5lbHMuY29udGFpbmVyLmFwcGVuZFRvKHRhcmdldCk7XG4gICAgfVxuXG4gICAgb25TZWxlY3RlZChjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmaW5kQ2hvaWNlKHByb3ZpZGVkVmFsdWUsIGJ5TGFiZWwpIHtcbiAgICAgIHZhciBtYXRjaGVzO1xuICAgICAgbWF0Y2hlcyA9IHRoaXMuY2hvaWNlcy5maWx0ZXIoZnVuY3Rpb24gKGNob2ljZSkge1xuICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgY2FzZSAhSVMub2JqZWN0KHByb3ZpZGVkVmFsdWUpOlxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVkVmFsdWUgPT09IGNob2ljZTtcblxuICAgICAgICAgIGNhc2UgIWJ5TGFiZWw6XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZWRWYWx1ZSA9PT0gY2hvaWNlLmxhYmVsO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlZFZhbHVlID09PSBjaG9pY2UudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1hdGNoZXNbMF07XG4gICAgfVxuXG4gICAgZmluZENob2ljZUFueShwcm92aWRlZFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kQ2hvaWNlKHByb3ZpZGVkVmFsdWUpIHx8IHRoaXMuZmluZENob2ljZShwcm92aWRlZFZhbHVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBoaWdobGlnaHRQcmV2KCkge1xuICAgICAgdmFyIGNob2ljZSwgY3VycmVudEluZGV4O1xuICAgICAgY3VycmVudEluZGV4ID0gdGhpcy52aXNpYmxlQ2hvaWNlcy5pbmRleE9mKHRoaXMuY3VycmVudEhpZ2hsaWdodGVkKTtcblxuICAgICAgaWYgKGN1cnJlbnRJbmRleCA+IDApIHtcbiAgICAgICAgdGhpcy5jdXJyZW50SGlnaGxpZ2h0ZWQgPSBjaG9pY2UgPSB0aGlzLnZpc2libGVDaG9pY2VzW2N1cnJlbnRJbmRleCAtIDFdO1xuXG4gICAgICAgIGlmICghdGhpcy5saXN0LmNob2ljZUluVmlldyhjaG9pY2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5zY3JvbGxVcChjaG9pY2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN1cnJlbnRIaWdobGlnaHRlZCA9IGNob2ljZSA9IHRoaXMudmlzaWJsZUNob2ljZXNbdGhpcy52aXNpYmxlQ2hvaWNlcy5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoIXRoaXMubGlzdC5jaG9pY2VJblZpZXcoY2hvaWNlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Quc2Nyb2xsVG9DaG9pY2UoY2hvaWNlLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGhpZ2hsaWdodE5leHQoKSB7XG4gICAgICB2YXIgY2hvaWNlLCBjdXJyZW50SW5kZXg7XG4gICAgICBjdXJyZW50SW5kZXggPSB0aGlzLnZpc2libGVDaG9pY2VzLmluZGV4T2YodGhpcy5jdXJyZW50SGlnaGxpZ2h0ZWQpO1xuXG4gICAgICBpZiAoY3VycmVudEluZGV4IDwgdGhpcy52aXNpYmxlQ2hvaWNlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEhpZ2hsaWdodGVkID0gY2hvaWNlID0gdGhpcy52aXNpYmxlQ2hvaWNlc1tjdXJyZW50SW5kZXggKyAxXTtcblxuICAgICAgICBpZiAoIXRoaXMubGlzdC5jaG9pY2VJblZpZXcoY2hvaWNlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Quc2Nyb2xsRG93bihjaG9pY2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN1cnJlbnRIaWdobGlnaHRlZCA9IGNob2ljZSA9IHRoaXMudmlzaWJsZUNob2ljZXNbMF07XG5cbiAgICAgICAgaWYgKCF0aGlzLmxpc3QuY2hvaWNlSW5WaWV3KGNob2ljZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5saXN0LnNjcm9sbFRvQ2hvaWNlKGNob2ljZSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuICBEcm9wZG93bi5wcm90b3R5cGUudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgRHJvcGRvd24ucHJvdG90eXBlLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIERyb3Bkb3duLnByb3RvdHlwZS5fc2V0dGluZ0ZpbHRlcnMgPSB7XG4gICAgbWF4SGVpZ2h0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBJUy5udW1iZXIodmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIERyb3Bkb3duO1xufS5jYWxsKHVuZGVmaW5lZCk7XG5cbkxpc3QgPSBjbGFzcyBMaXN0IHtcbiAgY29uc3RydWN0b3IoZHJvcGRvd24pIHtcbiAgICB0aGlzLmNob2ljZUluVmlldyA9IHRoaXMuY2hvaWNlSW5WaWV3LmJpbmQodGhpcyk7XG4gICAgdGhpcy5kcm9wZG93biA9IGRyb3Bkb3duO1xuICAgICh7XG4gICAgICBlbHM6IHRoaXMuZWxzLFxuICAgICAgZmllbGQ6IHRoaXMuZmllbGQsXG4gICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5nc1xuICAgIH0gPSB0aGlzLmRyb3Bkb3duKTtcbiAgICB0aGlzLmVsID0gdGhpcy5lbHMubGlzdDtcbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuZWxzLmNvbnRhaW5lcjtcbiAgICB0aGlzLmFwcGVuZGVkQ2hvaWNlcyA9IGZhbHNlO1xuICB9XG5cbiAgYXBwZW5kQ2hvaWNlcygpIHtcbiAgICB2YXIgY2hvaWNlLCBpLCBsZW4sIHJlZjtcblxuICAgIGlmICh0aGlzLmFwcGVuZGVkQ2hvaWNlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlZiA9IHRoaXMuZHJvcGRvd24uY2hvaWNlcztcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2hvaWNlID0gcmVmW2ldO1xuICAgICAgY2hvaWNlLmluaXQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hcHBlbmRlZENob2ljZXMgPSB0cnVlO1xuICB9XG5cbiAgY2FsY0Rpc3BsYXkoKSB7XG4gICAgdmFyIGJvdHRvbUN1dG9mZiwgY2xpcHBpbmdQYXJlbnQsIGNsaXBwaW5nUmVjdCwgY3V0b2ZmLCBoZWlnaHQsIGlzQm90dG9tQ3V0b2ZmLCBpc1RvcEN1dG9mZiwgbmVlZHNOZXdIZWlnaHQsIHBhZGRpbmcsIHNjcm9sbEhlaWdodCwgc2VsZlJlY3QsIHRvcEN1dG9mZiwgdHJhbnNsYXRpb24sIHdpbmRvd0N1dG9mZiwgd2luZG93SGVpZ2h0O1xuICAgIHdpbmRvd0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB0cmFuc2xhdGlvbiA9IHRoaXMudHJhbnNsYXRpb24gfHwgMDtcbiAgICBjbGlwcGluZ1BhcmVudCA9IHRoaXMuY29udGFpbmVyLnBhcmVudE1hdGNoaW5nKGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgIHZhciBvdmVyZmxvdztcbiAgICAgIG92ZXJmbG93ID0gcGFyZW50LnN0eWxlKCdvdmVyZmxvd1knKTtcbiAgICAgIHJldHVybiBvdmVyZmxvdyA9PT0gJ2hpZGRlbicgfHwgb3ZlcmZsb3cgPT09ICdzY3JvbGwnO1xuICAgIH0pO1xuICAgIHNjcm9sbEhlaWdodCA9IHRoaXMuZWwucmF3LnNjcm9sbEhlaWdodCB8fCAyZTMwODtcbiAgICBzZWxmUmVjdCA9IGV4dGVuZC5jbG9uZSh0aGlzLmNvbnRhaW5lci5yZWN0KTtcbiAgICBwYWRkaW5nID0gc2VsZlJlY3QuaGVpZ2h0IC0gdGhpcy5lbC5oZWlnaHQ7XG4gICAgaGVpZ2h0ID0gTWF0aC5taW4oc2Nyb2xsSGVpZ2h0LCB0aGlzLnNldHRpbmdzLm1heEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IC0gNDApO1xuICAgIHNlbGZSZWN0LmJvdHRvbSA9IHNlbGZSZWN0LnRvcCArIGhlaWdodDtcblxuICAgIGlmIChjbGlwcGluZ1BhcmVudCkge1xuICAgICAgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnQucmVjdDtcbiAgICAgIGJvdHRvbUN1dG9mZiA9IHNlbGZSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC5ib3R0b207XG4gICAgICB0b3BDdXRvZmYgPSBjbGlwcGluZ1JlY3QudG9wIC0gc2VsZlJlY3QudG9wO1xuICAgICAgaXNCb3R0b21DdXRvZmYgPSBib3R0b21DdXRvZmYgPiAwO1xuICAgICAgaXNUb3BDdXRvZmYgPSB0b3BDdXRvZmYgPiAwO1xuXG4gICAgICBpZiAoc2VsZlJlY3QudG9wID49IGNsaXBwaW5nUmVjdC5ib3R0b20gfHwgY2xpcHBpbmdSZWN0LnRvcCA+PSBzZWxmUmVjdC5ib3R0b20pIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBUaGUgZHJvcGRvd24gZm9yIGVsZW1lbnQgJyR7dGhpcy5maWVsZC5JRH0nIGNhbm5vdCBiZSBkaXNwbGF5ZWQgYXMgaXQncyBoaWRkZW4gYnkgdGhlIHBhcmVudCBvdmVyZmxvd2ApO1xuICAgICAgfSBlbHNlIGlmIChpc0JvdHRvbUN1dG9mZiB8fCBpc1RvcEN1dG9mZikge1xuICAgICAgICBuZWVkc05ld0hlaWdodCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHNlbGZSZWN0LnRvcCAtIGJvdHRvbUN1dG9mZiA+IGNsaXBwaW5nUmVjdC50b3AgJiYgIWlzVG9wQ3V0b2ZmKSB7XG4gICAgICAgICAgdHJhbnNsYXRpb24gPSBib3R0b21DdXRvZmY7XG4gICAgICAgICAgc2VsZlJlY3QudG9wIC09IHRyYW5zbGF0aW9uO1xuICAgICAgICAgIHNlbGZSZWN0LmJvdHRvbSAtPSB0cmFuc2xhdGlvbjtcbiAgICAgICAgICBjdXRvZmYgPSBjbGlwcGluZ1JlY3QudG9wIC0gc2VsZlJlY3QudG9wO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGZSZWN0LmJvdHRvbSAtIHRvcEN1dG9mZiA8IGNsaXBwaW5nUmVjdC5ib3R0b20pIHtcbiAgICAgICAgICB0cmFuc2xhdGlvbiA9IHRvcEN1dG9mZiAqIC0xO1xuICAgICAgICAgIHNlbGZSZWN0LnRvcCArPSB0cmFuc2xhdGlvbjtcbiAgICAgICAgICBzZWxmUmVjdC5ib3R0b20gKz0gdHJhbnNsYXRpb247XG4gICAgICAgICAgY3V0b2ZmID0gc2VsZlJlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LmJvdHRvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZWVkc05ld0hlaWdodCA9IGN1dG9mZiA+IDApIHtcbiAgICAgICAgICBoZWlnaHQgPSBjdXRvZmYgLSBwYWRkaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2luZG93Q3V0b2ZmID0gc2VsZlJlY3QudG9wICsgaGVpZ2h0IC0gd2luZG93SGVpZ2h0O1xuXG4gICAgaWYgKHdpbmRvd0N1dG9mZiA+IDAgJiYgaGVpZ2h0IDwgd2luZG93SGVpZ2h0KSB7XG4gICAgICB0cmFuc2xhdGlvbiArPSB3aW5kb3dDdXRvZmYgKyAxMDtcbiAgICB9XG5cbiAgICB0aGlzLnNldERpbWVuc2lvbnMoaGVpZ2h0LCB0aGlzLmZpZWxkLmVsLmNoaWxkLmlubmVyd3JhcC53aWR0aCArIDEwKTtcbiAgICByZXR1cm4gdGhpcy5zZXRUcmFuc2xhdGUodHJhbnNsYXRpb24pO1xuICB9XG5cbiAgc2V0RGltZW5zaW9ucyhoZWlnaHQsIHdpZHRoKSB7XG4gICAgaWYgKGhlaWdodCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmVsLnN0eWxlKCdtYXhIZWlnaHQnLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbC5zdHlsZSgnbWluV2lkdGgnLCB3aWR0aCk7XG4gICAgfVxuICB9XG5cbiAgc2V0VHJhbnNsYXRlKHRyYW5zbGF0aW9uKSB7XG4gICAgdGhpcy50cmFuc2xhdGlvbiA9IHRyYW5zbGF0aW9uO1xuICAgIHRyYW5zbGF0aW9uICo9IC0xO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5zdHlsZSgndHJhbnNmb3JtJywgYHRyYW5zbGF0ZVkoJHt0cmFuc2xhdGlvbn1weClgKTtcbiAgfVxuXG4gIHNjcm9sbFRvQ2hvaWNlKGNob2ljZSwgb2Zmc2V0ID0gMykge1xuICAgIHZhciBkaXN0YW5lRnJvbVRvcCwgc2VsZWN0ZWRIZWlnaHQ7XG4gICAgZGlzdGFuZUZyb21Ub3AgPSBjaG9pY2UuZWwucmF3Lm9mZnNldFRvcDtcbiAgICBzZWxlY3RlZEhlaWdodCA9IGNob2ljZS5lbC5oZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXMuZWwucmF3LnNjcm9sbFRvcCA9IGRpc3RhbmVGcm9tVG9wIC0gc2VsZWN0ZWRIZWlnaHQgKiBvZmZzZXQ7XG4gIH1cblxuICBzY3JvbGxEb3duKGNob2ljZSkge1xuICAgIHJldHVybiB0aGlzLmVsLnJhdy5zY3JvbGxUb3AgKz0gY2hvaWNlLmVsLmhlaWdodDtcbiAgfVxuXG4gIHNjcm9sbFVwKGNob2ljZSkge1xuICAgIHJldHVybiB0aGlzLmVsLnJhdy5zY3JvbGxUb3AgLT0gY2hvaWNlLmVsLmhlaWdodDtcbiAgfVxuXG4gIGNob2ljZUluVmlldyhjaG9pY2UpIHtcbiAgICB2YXIgY2hvaWNlUmVjdCwgZG93blBhZGRpbmcsIGxpc3RSZWN0LCB1cFBhZGRpbmc7XG4gICAgY2hvaWNlUmVjdCA9IGNob2ljZS5lbC5yZWN0O1xuICAgIGxpc3RSZWN0ID0gdGhpcy5lbC5yZWN0O1xuICAgIHVwUGFkZGluZyA9IHRoaXMuZWxzLnNjcm9sbEluZGljYXRvclVwLnN0YXRlKCd2aXNpYmxlJykgPyBwYXJzZUZsb2F0KHRoaXMuZWxzLnNjcm9sbEluZGljYXRvclVwLnN0eWxlU2FmZSgnaGVpZ2h0JywgdHJ1ZSkpIDogdm9pZCAwO1xuICAgIGRvd25QYWRkaW5nID0gdGhpcy5lbHMuc2Nyb2xsSW5kaWNhdG9yRG93bi5zdGF0ZSgndmlzaWJsZScpID8gcGFyc2VGbG9hdCh0aGlzLmVscy5zY3JvbGxJbmRpY2F0b3JEb3duLnN0eWxlU2FmZSgnaGVpZ2h0JywgdHJ1ZSkpIDogdm9pZCAwO1xuICAgIHJldHVybiBjaG9pY2VSZWN0LmJvdHRvbSA8PSBsaXN0UmVjdC5ib3R0b20gLSBkb3duUGFkZGluZyAmJiBjaG9pY2VSZWN0LnRvcCA+PSBsaXN0UmVjdC50b3AgKyB1cFBhZGRpbmc7XG4gIH1cblxuICBzdGFydFNjcm9sbGluZyhkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5zY3JvbGxJbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZWwucmF3LnNjcm9sbFRvcCArPSBkaXJlY3Rpb24gPT09ICd1cCcgPyAtMjAgOiAyMDtcbiAgICB9LCA1MCk7XG4gIH1cblxuICBzdG9wU2Nyb2xsaW5nKCkge1xuICAgIHJldHVybiBjbGVhckludGVydmFsKHRoaXMuc2Nyb2xsSW50ZXJ2YWxJRCk7XG4gIH1cblxufTtcbkNob2ljZSA9IGNsYXNzIENob2ljZSB7XG4gIGNvbnN0cnVjdG9yKGRyb3Bkb3duLCBzZXR0aW5ncywgbGlzdCwgaW5kZXgpIHtcbiAgICB2YXIgcmVmO1xuICAgIHRoaXMuZHJvcGRvd24gPSBkcm9wZG93bjtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgKHtcbiAgICAgIGxhYmVsOiB0aGlzLmxhYmVsLFxuICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICBjb25kaXRpb25zOiB0aGlzLmNvbmRpdGlvbnNcbiAgICB9ID0gdGhpcy5zZXR0aW5ncyk7XG5cbiAgICBpZiAodGhpcy5sYWJlbCA9PSBudWxsKSB7XG4gICAgICB0aGlzLmxhYmVsID0gdGhpcy52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52YWx1ZSA9PSBudWxsKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5sYWJlbDtcbiAgICB9XG5cbiAgICB0aGlzLmZpZWxkID0gdGhpcy5kcm9wZG93bi5maWVsZDtcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVuYXZhaWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgaWYgKChyZWYgPSB0aGlzLmNvbmRpdGlvbnMpICE9IG51bGwgPyByZWYubGVuZ3RoIDogdm9pZCAwKSB7XG4gICAgICB0aGlzLnVuYXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWxsRmllbGRzID0gdGhpcy5maWVsZC5hbGxGaWVsZHM7XG4gICAgICBDb25kaXRpb24uaW5pdCh0aGlzLCB0aGlzLmNvbmRpdGlvbnMsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5hdmFpbGFibGUgPSAhQ29uZGl0aW9uLnZhbGlkYXRlKHRoaXMuY29uZGl0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpbml0KCkge1xuICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5lbCA9IHRoaXMuZHJvcGRvd24udGVtcGxhdGUuY2hvaWNlLnNwYXduKG51bGwsIHtcbiAgICAgIHJlbGF0ZWRJbnN0YW5jZTogdGhpcy5kcm9wZG93blxuICAgIH0pO1xuICAgIHRoaXMuZWwuY2hpbGRyZW5bMV0udGV4dCA9IHRoaXMubGFiZWw7XG4gICAgdGhpcy5lbC5hcHBlbmRUbyh0aGlzLmxpc3QuZWwpO1xuICAgIHJldHVybiB0aGlzLl9hdHRhY2hCaW5kaW5ncygpO1xuICB9XG5cbiAgcmVtb3ZlKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVsLnJlbW92ZSgpO1xuICB9XG5cbiAgX2F0dGFjaEJpbmRpbmdzKCkge1xuICAgIHJldHVybiAoKCkgPT4ge1xuICAgICAgU2ltcGx5QmluZCgndmlzaWJsZScpLm9mKHRoaXMpLnRvKCh2aXNpYmxlLCBwcmV2KSA9PiB7XG4gICAgICAgIHRoaXMuZHJvcGRvd24udmlzaWJsZUNob2ljZXNDb3VudCArPSB2aXNpYmxlID8gMSA6IC0xO1xuICAgICAgICB0aGlzLmVsLnN0YXRlKCd2aXNpYmxlJywgdmlzaWJsZSk7XG5cbiAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICB0aGlzLmRyb3Bkb3duLnZpc2libGVDaG9pY2VzLnB1c2godGhpcyk7XG5cbiAgICAgICAgICBpZiAoSVMuZGVmaW5lZChwcmV2KSkge1xuICAgICAgICAgICAgLy8gaW5kaWNhdGVzIHN0YXRlIGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wZG93bi52aXNpYmxlQ2hvaWNlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVtb3ZlSXRlbSh0aGlzLmRyb3Bkb3duLnZpc2libGVDaG9pY2VzLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdzZWxlY3RlZCcpLm9mKHRoaXMpLnRvKHNlbGVjdGVkID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ3NlbGVjdGVkJywgc2VsZWN0ZWQpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCd1bmF2YWlsYWJsZScpLm9mKHRoaXMpLnRvKHVuYXZhaWxhYmxlID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ3VuYXZhaWxhYmxlJywgdW5hdmFpbGFibGUpO1xuICAgICAgfSkuYW5kLnRvKHVuYXZhaWxhYmxlID0+IHtcbiAgICAgICAgaWYgKHVuYXZhaWxhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdldmVudDpjbGljaycpLm9mKHRoaXMuZWwpLnRvKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd24ubGFzdFNlbGVjdGVkID0gdGhpcztcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6bW91c2Vkb3duJykub2YodGhpcy5lbCkudG8oZXZlbnQgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBTaW1wbHlCaW5kKCdldmVudDptb3VzZWVudGVyJykub2YodGhpcy5lbCkudG8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5kcm9wZG93bi5jdXJyZW50SGlnaGxpZ2h0ZWQgPSB0aGlzO1xuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIHRvZ2dsZShuZXdWYWx1ZSwgdW5hdmFpbGFibGUpIHtcbiAgICB2YXIgbmV3U3RhdGUsIHByZXZTdGF0ZSwgcmVmLCB3YXNTZWxlY3RlZDtcbiAgICBwcmV2U3RhdGUgPSB0aGlzLnNlbGVjdGVkO1xuICAgIG5ld1N0YXRlID0gSVMuZGVmaW5lZChuZXdWYWx1ZSkgPyBuZXdWYWx1ZSA6ICF0aGlzLnNlbGVjdGVkO1xuXG4gICAgaWYgKCFuZXdTdGF0ZSkge1xuICAgICAgaWYgKHRoaXMuZHJvcGRvd24uc2V0dGluZ3MubXVsdGlwbGUgJiYgcHJldlN0YXRlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBuZXdTdGF0ZTtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUl0ZW0odGhpcy5maWVsZC5fdmFsdWUsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FzU2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkO1xuXG4gICAgICAgIGlmIChJUy5kZWZpbmVkKG5ld1ZhbHVlKSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBuZXdTdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bmF2YWlsYWJsZSAmJiB3YXNTZWxlY3RlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpZWxkLl92YWx1ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IG5ld1N0YXRlO1xuXG4gICAgICBpZiAodGhpcy5maWVsZC5zZXR0aW5ncy5tdWx0aXBsZSkge1xuICAgICAgICB0aGlzLmZpZWxkLl92YWx1ZS5wdXNoKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKChyZWYgPSB0aGlzLmZpZWxkLl92YWx1ZSkgIT0gbnVsbCkge1xuICAgICAgICAgIHJlZi50b2dnbGUoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maWVsZC5fdmFsdWUgPSB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5maWVsZC5sYXN0U2VsZWN0ZWQgPSB0aGlzO1xuICAgIH1cbiAgfVxuXG59O1xudmFyIERyb3Bkb3duJDEgPSBEcm9wZG93bjtleHBvcnQgZGVmYXVsdCBEcm9wZG93biQxO2V4cG9ydHtDaG9pY2V9OyIsIiFmdW5jdGlvbihlLHIpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXIoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLHIpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMudGV4dE1hc2tDb3JlPXIoKTplLnRleHRNYXNrQ29yZT1yKCl9KHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gcihuKXtpZih0W25dKXJldHVybiB0W25dLmV4cG9ydHM7dmFyIG89dFtuXT17ZXhwb3J0czp7fSxpZDpuLGxvYWRlZDohMX07cmV0dXJuIGVbbl0uY2FsbChvLmV4cG9ydHMsbyxvLmV4cG9ydHMsciksby5sb2FkZWQ9ITAsby5leHBvcnRzfXZhciB0PXt9O3JldHVybiByLm09ZSxyLmM9dCxyLnA9XCJcIixyKDApfShbZnVuY3Rpb24oZSxyLHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPXQoMyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJjb25mb3JtVG9NYXNrXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4obykuZGVmYXVsdH19KTt2YXIgaT10KDIpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiYWRqdXN0Q2FyZXRQb3NpdGlvblwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBuKGkpLmRlZmF1bHR9fSk7dmFyIGE9dCg1KTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcImNyZWF0ZVRleHRNYXNrSW5wdXRFbGVtZW50XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4oYSkuZGVmYXVsdH19KX0sZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLnBsYWNlaG9sZGVyQ2hhcj1cIl9cIn0sZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KGUpe3ZhciByPWUucHJldmlvdXNDb25mb3JtZWRWYWx1ZSx0PXZvaWQgMD09PXI/bzpyLGk9ZS5wcmV2aW91c1BsYWNlaG9sZGVyLGE9dm9pZCAwPT09aT9vOmksdT1lLmN1cnJlbnRDYXJldFBvc2l0aW9uLGw9dm9pZCAwPT09dT8wOnUscz1lLmNvbmZvcm1lZFZhbHVlLGY9ZS5yYXdWYWx1ZSxkPWUucGxhY2Vob2xkZXJDaGFyLGM9ZS5wbGFjZWhvbGRlcix2PWUuaW5kZXhlc09mUGlwZWRDaGFycyxwPXZvaWQgMD09PXY/bjp2LGg9ZS5jYXJldFRyYXBJbmRleGVzLGc9dm9pZCAwPT09aD9uOmg7aWYoMD09PWwpcmV0dXJuIDA7dmFyIG09Zi5sZW5ndGgseT10Lmxlbmd0aCxiPWMubGVuZ3RoLEM9cy5sZW5ndGgsUD1tLXkseD1QPjAsTz0wPT09eSxrPVA+MSYmIXgmJiFPO2lmKGspcmV0dXJuIGw7dmFyIGo9eCYmKHQ9PT1zfHxzPT09YyksTT0wLFQ9dm9pZCAwLHc9dm9pZCAwO2lmKGopTT1sLVA7ZWxzZXt2YXIgXz1zLnRvTG93ZXJDYXNlKCksVj1mLnRvTG93ZXJDYXNlKCksUz1WLnN1YnN0cigwLGwpLnNwbGl0KG8pLE49Uy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIF8uaW5kZXhPZihlKSE9PS0xfSk7dz1OW04ubGVuZ3RoLTFdO3ZhciBFPWEuc3Vic3RyKDAsTi5sZW5ndGgpLnNwbGl0KG8pLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZSE9PWR9KS5sZW5ndGgsQT1jLnN1YnN0cigwLE4ubGVuZ3RoKS5zcGxpdChvKS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUhPT1kfSkubGVuZ3RoLFI9QSE9PUUsST12b2lkIDAhPT1hW04ubGVuZ3RoLTFdJiZ2b2lkIDAhPT1jW04ubGVuZ3RoLTJdJiZhW04ubGVuZ3RoLTFdIT09ZCYmYVtOLmxlbmd0aC0xXSE9PWNbTi5sZW5ndGgtMV0mJmFbTi5sZW5ndGgtMV09PT1jW04ubGVuZ3RoLTJdOyF4JiYoUnx8SSkmJkU+MCYmYy5pbmRleE9mKHcpPi0xJiZ2b2lkIDAhPT1mW2xdJiYoVD0hMCx3PWZbbF0pO2Zvcih2YXIgSj1wLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gX1tlXX0pLHE9Si5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT13fSkubGVuZ3RoLEY9Ti5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT13fSkubGVuZ3RoLEw9Yy5zdWJzdHIoMCxjLmluZGV4T2YoZCkpLnNwbGl0KG8pLmZpbHRlcihmdW5jdGlvbihlLHIpe3JldHVybiBlPT09dyYmZltyXSE9PWV9KS5sZW5ndGgsVz1MK0YrcSsoVD8xOjApLHo9MCxCPTA7QjxDO0IrKyl7dmFyIEQ9X1tCXTtpZihNPUIrMSxEPT09dyYmeisrLHo+PVcpYnJlYWt9fWlmKHgpe2Zvcih2YXIgRz1NLEg9TTtIPD1iO0grKylpZihjW0hdPT09ZCYmKEc9SCksY1tIXT09PWR8fGcuaW5kZXhPZihIKSE9PS0xfHxIPT09YilyZXR1cm4gR31lbHNlIGlmKFQpe2Zvcih2YXIgSz1NLTE7Sz49MDtLLS0paWYoc1tLXT09PXd8fGcuaW5kZXhPZihLKSE9PS0xfHwwPT09SylyZXR1cm4gS31lbHNlIGZvcih2YXIgUT1NO1E+PTA7US0tKWlmKGNbUS0xXT09PWR8fGcuaW5kZXhPZihRKSE9PS0xfHwwPT09USlyZXR1cm4gUX1PYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLmRlZmF1bHQ9dDt2YXIgbj1bXSxvPVwiXCJ9LGZ1bmN0aW9uKGUscix0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOmEscj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06YSx0PWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp7fSxuPXQuZ3VpZGUsdT12b2lkIDA9PT1ufHxuLGw9dC5wcmV2aW91c0NvbmZvcm1lZFZhbHVlLHM9dm9pZCAwPT09bD9hOmwsZj10LnBsYWNlaG9sZGVyQ2hhcixkPXZvaWQgMD09PWY/aS5wbGFjZWhvbGRlckNoYXI6ZixjPXQucGxhY2Vob2xkZXIsdj12b2lkIDA9PT1jPygwLG8uY29udmVydE1hc2tUb1BsYWNlaG9sZGVyKShyLGQpOmMscD10LmN1cnJlbnRDYXJldFBvc2l0aW9uLGg9dC5rZWVwQ2hhclBvc2l0aW9ucyxnPXU9PT0hMSYmdm9pZCAwIT09cyxtPWUubGVuZ3RoLHk9cy5sZW5ndGgsYj12Lmxlbmd0aCxDPXIubGVuZ3RoLFA9bS15LHg9UD4wLE89cCsoeD8tUDowKSxrPU8rTWF0aC5hYnMoUCk7aWYoaD09PSEwJiYheCl7Zm9yKHZhciBqPWEsTT1PO008aztNKyspdltNXT09PWQmJihqKz1kKTtlPWUuc2xpY2UoMCxPKStqK2Uuc2xpY2UoTyxtKX1mb3IodmFyIFQ9ZS5zcGxpdChhKS5tYXAoZnVuY3Rpb24oZSxyKXtyZXR1cm57Y2hhcjplLGlzTmV3OnI+PU8mJnI8a319KSx3PW0tMTt3Pj0wO3ctLSl7dmFyIF89VFt3XS5jaGFyO2lmKF8hPT1kKXt2YXIgVj13Pj1PJiZ5PT09QztfPT09dltWP3ctUDp3XSYmVC5zcGxpY2UodywxKX19dmFyIFM9YSxOPSExO2U6Zm9yKHZhciBFPTA7RTxiO0UrKyl7dmFyIEE9dltFXTtpZihBPT09ZCl7aWYoVC5sZW5ndGg+MClmb3IoO1QubGVuZ3RoPjA7KXt2YXIgUj1ULnNoaWZ0KCksST1SLmNoYXIsSj1SLmlzTmV3O2lmKEk9PT1kJiZnIT09ITApe1MrPWQ7Y29udGludWUgZX1pZihyW0VdLnRlc3QoSSkpe2lmKGg9PT0hMCYmSiE9PSExJiZzIT09YSYmdSE9PSExJiZ4KXtmb3IodmFyIHE9VC5sZW5ndGgsRj1udWxsLEw9MDtMPHE7TCsrKXt2YXIgVz1UW0xdO2lmKFcuY2hhciE9PWQmJlcuaXNOZXc9PT0hMSlicmVhaztpZihXLmNoYXI9PT1kKXtGPUw7YnJlYWt9fW51bGwhPT1GPyhTKz1JLFQuc3BsaWNlKEYsMSkpOkUtLX1lbHNlIFMrPUk7Y29udGludWUgZX1OPSEwfWc9PT0hMSYmKFMrPXYuc3Vic3RyKEUsYikpO2JyZWFrfVMrPUF9aWYoZyYmeD09PSExKXtmb3IodmFyIHo9bnVsbCxCPTA7QjxTLmxlbmd0aDtCKyspdltCXT09PWQmJih6PUIpO1M9bnVsbCE9PXo/Uy5zdWJzdHIoMCx6KzEpOmF9cmV0dXJue2NvbmZvcm1lZFZhbHVlOlMsbWV0YTp7c29tZUNoYXJzUmVqZWN0ZWQ6Tn19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHIuZGVmYXVsdD1uO3ZhciBvPXQoNCksaT10KDEpLGE9XCJcIn0sZnVuY3Rpb24oZSxyLHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06bCxyPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp1LnBsYWNlaG9sZGVyQ2hhcjtpZihlLmluZGV4T2YocikhPT0tMSl0aHJvdyBuZXcgRXJyb3IoXCJQbGFjZWhvbGRlciBjaGFyYWN0ZXIgbXVzdCBub3QgYmUgdXNlZCBhcyBwYXJ0IG9mIHRoZSBtYXNrLiBQbGVhc2Ugc3BlY2lmeSBhIGNoYXJhY3RlciB0aGF0IGlzIG5vdCBwcmVzZW50IGluIHlvdXIgbWFzayBhcyB5b3VyIHBsYWNlaG9sZGVyIGNoYXJhY3Rlci5cXG5cXG5cIisoXCJUaGUgcGxhY2Vob2xkZXIgY2hhcmFjdGVyIHRoYXQgd2FzIHJlY2VpdmVkIGlzOiBcIitKU09OLnN0cmluZ2lmeShyKStcIlxcblxcblwiKSsoXCJUaGUgbWFzayB0aGF0IHdhcyByZWNlaXZlZCBpczogXCIrSlNPTi5zdHJpbmdpZnkoZSkpKTtyZXR1cm4gZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBSZWdFeHA/cjplfSkuam9pbihcIlwiKX1mdW5jdGlvbiBvKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlfHxlIGluc3RhbmNlb2YgU3RyaW5nfWZ1bmN0aW9uIGkoZSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGUmJnZvaWQgMD09PWUubGVuZ3RoJiYhaXNOYU4oZSl9ZnVuY3Rpb24gYShlKXtmb3IodmFyIHI9W10sdD12b2lkIDA7dD1lLmluZGV4T2YocyksdCE9PS0xOylyLnB1c2godCksZS5zcGxpY2UodCwxKTtyZXR1cm57bWFza1dpdGhvdXRDYXJldFRyYXBzOmUsaW5kZXhlczpyfX1PYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLmNvbnZlcnRNYXNrVG9QbGFjZWhvbGRlcj1uLHIuaXNTdHJpbmc9byxyLmlzTnVtYmVyPWksci5wcm9jZXNzQ2FyZXRUcmFwcz1hO3ZhciB1PXQoMSksbD1bXSxzPVwiW11cIn0sZnVuY3Rpb24oZSxyLHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIG8oZSl7dmFyIHI9e3ByZXZpb3VzQ29uZm9ybWVkVmFsdWU6dm9pZCAwLHByZXZpb3VzUGxhY2Vob2xkZXI6dm9pZCAwfTtyZXR1cm57c3RhdGU6cix1cGRhdGU6ZnVuY3Rpb24odCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOmUsbz1uLmlucHV0RWxlbWVudCxzPW4ubWFzayxkPW4uZ3VpZGUsbT1uLnBpcGUsYj1uLnBsYWNlaG9sZGVyQ2hhcixDPXZvaWQgMD09PWI/cC5wbGFjZWhvbGRlckNoYXI6YixQPW4ua2VlcENoYXJQb3NpdGlvbnMseD12b2lkIDAhPT1QJiZQLE89bi5zaG93TWFzayxrPXZvaWQgMCE9PU8mJk87aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHQmJih0PW8udmFsdWUpLHQhPT1yLnByZXZpb3VzQ29uZm9ybWVkVmFsdWUpeyhcInVuZGVmaW5lZFwiPT10eXBlb2Ygcz9cInVuZGVmaW5lZFwiOmwocykpPT09eSYmdm9pZCAwIT09cy5waXBlJiZ2b2lkIDAhPT1zLm1hc2smJihtPXMucGlwZSxzPXMubWFzayk7dmFyIGo9dm9pZCAwLE09dm9pZCAwO2lmKHMgaW5zdGFuY2VvZiBBcnJheSYmKGo9KDAsdi5jb252ZXJ0TWFza1RvUGxhY2Vob2xkZXIpKHMsQykpLHMhPT0hMSl7dmFyIFQ9YSh0KSx3PW8uc2VsZWN0aW9uRW5kLF89ci5wcmV2aW91c0NvbmZvcm1lZFZhbHVlLFY9ci5wcmV2aW91c1BsYWNlaG9sZGVyLFM9dm9pZCAwO2lmKChcInVuZGVmaW5lZFwiPT10eXBlb2Ygcz9cInVuZGVmaW5lZFwiOmwocykpPT09aCl7aWYoTT1zKFQse2N1cnJlbnRDYXJldFBvc2l0aW9uOncscHJldmlvdXNDb25mb3JtZWRWYWx1ZTpfLHBsYWNlaG9sZGVyQ2hhcjpDfSksTT09PSExKXJldHVybjt2YXIgTj0oMCx2LnByb2Nlc3NDYXJldFRyYXBzKShNKSxFPU4ubWFza1dpdGhvdXRDYXJldFRyYXBzLEE9Ti5pbmRleGVzO009RSxTPUEsaj0oMCx2LmNvbnZlcnRNYXNrVG9QbGFjZWhvbGRlcikoTSxDKX1lbHNlIE09czt2YXIgUj17cHJldmlvdXNDb25mb3JtZWRWYWx1ZTpfLGd1aWRlOmQscGxhY2Vob2xkZXJDaGFyOkMscGlwZTptLHBsYWNlaG9sZGVyOmosY3VycmVudENhcmV0UG9zaXRpb246dyxrZWVwQ2hhclBvc2l0aW9uczp4fSxJPSgwLGMuZGVmYXVsdCkoVCxNLFIpLEo9SS5jb25mb3JtZWRWYWx1ZSxxPShcInVuZGVmaW5lZFwiPT10eXBlb2YgbT9cInVuZGVmaW5lZFwiOmwobSkpPT09aCxGPXt9O3EmJihGPW0oSix1KHtyYXdWYWx1ZTpUfSxSKSksRj09PSExP0Y9e3ZhbHVlOl8scmVqZWN0ZWQ6ITB9OigwLHYuaXNTdHJpbmcpKEYpJiYoRj17dmFsdWU6Rn0pKTt2YXIgTD1xP0YudmFsdWU6SixXPSgwLGYuZGVmYXVsdCkoe3ByZXZpb3VzQ29uZm9ybWVkVmFsdWU6XyxwcmV2aW91c1BsYWNlaG9sZGVyOlYsY29uZm9ybWVkVmFsdWU6TCxwbGFjZWhvbGRlcjpqLHJhd1ZhbHVlOlQsY3VycmVudENhcmV0UG9zaXRpb246dyxwbGFjZWhvbGRlckNoYXI6QyxpbmRleGVzT2ZQaXBlZENoYXJzOkYuaW5kZXhlc09mUGlwZWRDaGFycyxjYXJldFRyYXBJbmRleGVzOlN9KSx6PUw9PT1qJiYwPT09VyxCPWs/ajpnLEQ9ej9COkw7ci5wcmV2aW91c0NvbmZvcm1lZFZhbHVlPUQsci5wcmV2aW91c1BsYWNlaG9sZGVyPWosby52YWx1ZSE9PUQmJihvLnZhbHVlPUQsaShvLFcpKX19fX19ZnVuY3Rpb24gaShlLHIpe2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQ9PT1lJiYoYj9DKGZ1bmN0aW9uKCl7cmV0dXJuIGUuc2V0U2VsZWN0aW9uUmFuZ2UocixyLG0pfSwwKTplLnNldFNlbGVjdGlvblJhbmdlKHIscixtKSl9ZnVuY3Rpb24gYShlKXtpZigoMCx2LmlzU3RyaW5nKShlKSlyZXR1cm4gZTtpZigoMCx2LmlzTnVtYmVyKShlKSlyZXR1cm4gU3RyaW5nKGUpO2lmKHZvaWQgMD09PWV8fG51bGw9PT1lKXJldHVybiBnO3Rocm93IG5ldyBFcnJvcihcIlRoZSAndmFsdWUnIHByb3ZpZGVkIHRvIFRleHQgTWFzayBuZWVkcyB0byBiZSBhIHN0cmluZyBvciBhIG51bWJlci4gVGhlIHZhbHVlIHJlY2VpdmVkIHdhczpcXG5cXG4gXCIrSlNPTi5zdHJpbmdpZnkoZSkpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3ZhciB0PWFyZ3VtZW50c1tyXTtmb3IodmFyIG4gaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmKGVbbl09dFtuXSl9cmV0dXJuIGV9LGw9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX07ci5kZWZhdWx0PW87dmFyIHM9dCgyKSxmPW4ocyksZD10KDMpLGM9bihkKSx2PXQoNCkscD10KDEpLGg9XCJmdW5jdGlvblwiLGc9XCJcIixtPVwibm9uZVwiLHk9XCJvYmplY3RcIixiPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJi9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxDPVwidW5kZWZpbmVkXCIhPXR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU/cmVxdWVzdEFuaW1hdGlvbkZyYW1lOnNldFRpbWVvdXR9XSl9KTsiLCIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLnRleHRNYXNrQWRkb25zPXQoKTplLnRleHRNYXNrQWRkb25zPXQoKX0odGhpcyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXtmdW5jdGlvbiB0KHIpe2lmKG5bcl0pcmV0dXJuIG5bcl0uZXhwb3J0czt2YXIgbz1uW3JdPXtleHBvcnRzOnt9LGlkOnIsbG9hZGVkOiExfTtyZXR1cm4gZVtyXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyx0KSxvLmxvYWRlZD0hMCxvLmV4cG9ydHN9dmFyIG49e307cmV0dXJuIHQubT1lLHQuYz1uLHQucD1cIlwiLHQoMCl9KFtmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89bigxKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImNyZWF0ZUF1dG9Db3JyZWN0ZWREYXRlUGlwZVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiByKG8pLmRlZmF1bHR9fSk7dmFyIGk9bigyKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImNyZWF0ZU51bWJlck1hc2tcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcihpKS5kZWZhdWx0fX0pO3ZhciB1PW4oMyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJlbWFpbE1hc2tcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcih1KS5kZWZhdWx0fX0pfSxmdW5jdGlvbihlLHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06XCJtbSBkZCB5eXl5XCI7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBuPVtdLHI9ZS5zcGxpdCgvW15kbXldKy8pLG89e2RkOjMxLG1tOjEyLHl5Ojk5LHl5eXk6OTk5OX0saT17ZGQ6MSxtbToxLHl5OjAseXl5eToxfSx1PXQuc3BsaXQoXCJcIik7ci5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciByPWUuaW5kZXhPZih0KSxpPXBhcnNlSW50KG9bdF0udG9TdHJpbmcoKS5zdWJzdHIoMCwxKSwxMCk7cGFyc2VJbnQodVtyXSwxMCk+aSYmKHVbcisxXT11W3JdLHVbcl09MCxuLnB1c2gocikpfSk7dmFyIGM9ci5zb21lKGZ1bmN0aW9uKG4pe3ZhciByPWUuaW5kZXhPZihuKSx1PW4ubGVuZ3RoLGM9dC5zdWJzdHIocix1KS5yZXBsYWNlKC9cXEQvZyxcIlwiKSxsPXBhcnNlSW50KGMsMTApO3JldHVybiBsPm9bbl18fGMubGVuZ3RoPT09dSYmbDxpW25dfSk7cmV0dXJuIWMmJnt2YWx1ZTp1LmpvaW4oXCJcIiksaW5kZXhlc09mUGlwZWRDaGFyczpufX19T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PW59LGZ1bmN0aW9uKGUsdCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbigpe2Z1bmN0aW9uIGUoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06Yyx0PWUubGVuZ3RoO2lmKGU9PT1jfHxlWzBdPT09aFswXSYmMT09PXQpcmV0dXJuIGguc3BsaXQoYykuY29uY2F0KFt2XSkuY29uY2F0KG0uc3BsaXQoYykpO2lmKGU9PT1TJiZNKXJldHVybiBoLnNwbGl0KGMpLmNvbmNhdChbXCIwXCIsUyx2XSkuY29uY2F0KG0uc3BsaXQoYykpO3ZhciBuPWUubGFzdEluZGV4T2YoUyksdT1uIT09LTEsbD1lWzBdPT09cyYmSSxhPXZvaWQgMCxnPXZvaWQgMCxiPXZvaWQgMDtpZihlLnNsaWNlKFYqLTEpPT09bSYmKGU9ZS5zbGljZSgwLFYqLTEpKSx1JiYoTXx8RCk/KGE9ZS5zbGljZShlLnNsaWNlKDAsJCk9PT1oPyQ6MCxuKSxnPWUuc2xpY2UobisxLHQpLGc9cihnLnJlcGxhY2UoZixjKSkpOmE9ZS5zbGljZSgwLCQpPT09aD9lLnNsaWNlKCQpOmUsTiYmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBOP1widW5kZWZpbmVkXCI6aShOKSk9PT1wKXt2YXIgTz1cIi5cIj09PV8/XCJbLl1cIjpcIlwiK18saj0oYS5tYXRjaChuZXcgUmVnRXhwKE8sXCJnXCIpKXx8W10pLmxlbmd0aDthPWEuc2xpY2UoMCxOK2oqcSl9cmV0dXJuIGE9YS5yZXBsYWNlKGYsYyksQXx8KGE9YS5yZXBsYWNlKC9eMCsoMCR8W14wXSkvLFwiJDFcIikpLGE9eD9vKGEsXyk6YSxiPXIoYSksKHUmJk18fEQ9PT0hMCkmJihlW24tMV0hPT1TJiZiLnB1c2goeSksYi5wdXNoKFMseSksZyYmKChcInVuZGVmaW5lZFwiPT10eXBlb2YgQz9cInVuZGVmaW5lZFwiOmkoQykpPT09cCYmKGc9Zy5zbGljZSgwLEMpKSxiPWIuY29uY2F0KGcpKSxEPT09ITAmJmVbbi0xXT09PVMmJmIucHVzaCh2KSksJD4wJiYoYj1oLnNwbGl0KGMpLmNvbmNhdChiKSksbCYmKGIubGVuZ3RoPT09JCYmYi5wdXNoKHYpLGI9W2RdLmNvbmNhdChiKSksbS5sZW5ndGg+MCYmKGI9Yi5jb25jYXQobS5zcGxpdChjKSkpLGJ9dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LG49dC5wcmVmaXgsaD12b2lkIDA9PT1uP3U6bixnPXQuc3VmZml4LG09dm9pZCAwPT09Zz9jOmcsYj10LmluY2x1ZGVUaG91c2FuZHNTZXBhcmF0b3IseD12b2lkIDA9PT1ifHxiLE89dC50aG91c2FuZHNTZXBhcmF0b3JTeW1ib2wsXz12b2lkIDA9PT1PP2w6TyxqPXQuYWxsb3dEZWNpbWFsLE09dm9pZCAwIT09aiYmaixQPXQuZGVjaW1hbFN5bWJvbCxTPXZvaWQgMD09PVA/YTpQLHc9dC5kZWNpbWFsTGltaXQsQz12b2lkIDA9PT13PzI6dyxrPXQucmVxdWlyZURlY2ltYWwsRD12b2lkIDAhPT1rJiZrLEU9dC5hbGxvd05lZ2F0aXZlLEk9dm9pZCAwIT09RSYmRSxSPXQuYWxsb3dMZWFkaW5nWmVyb2VzLEE9dm9pZCAwIT09UiYmUixMPXQuaW50ZWdlckxpbWl0LE49dm9pZCAwPT09TD9udWxsOkwsJD1oJiZoLmxlbmd0aHx8MCxWPW0mJm0ubGVuZ3RofHwwLHE9XyYmXy5sZW5ndGh8fDA7cmV0dXJuIGUuaW5zdGFuY2VPZj1cImNyZWF0ZU51bWJlck1hc2tcIixlfWZ1bmN0aW9uIHIoZSl7cmV0dXJuIGUuc3BsaXQoYykubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB2LnRlc3QoZSk/djplfSl9ZnVuY3Rpb24gbyhlLHQpe3JldHVybiBlLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csdCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGk9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX07dC5kZWZhdWx0PW47dmFyIHU9XCIkXCIsYz1cIlwiLGw9XCIsXCIsYT1cIi5cIixzPVwiLVwiLGQ9Ly0vLGY9L1xcRCsvZyxwPVwibnVtYmVyXCIsdj0vXFxkLyx5PVwiW11cIn0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIG8oZSx0KXtlPWUucmVwbGFjZShPLHYpO3ZhciBuPXQucGxhY2Vob2xkZXJDaGFyLHI9dC5jdXJyZW50Q2FyZXRQb3NpdGlvbixvPWUuaW5kZXhPZih5KSxzPWUubGFzdEluZGV4T2YocCksZD1zPG8/LTE6cyxmPWkoZSxvKzEseSksaD1pKGUsZC0xLHApLGc9dShlLG8sbiksbT1jKGUsbyxkLG4pLGI9bChlLGQsbixyKTtnPWEoZyksbT1hKG0pLGI9YShiLCEwKTt2YXIgeD1nLmNvbmNhdChmKS5jb25jYXQobSkuY29uY2F0KGgpLmNvbmNhdChiKTtyZXR1cm4geH1mdW5jdGlvbiBpKGUsdCxuKXt2YXIgcj1bXTtyZXR1cm4gZVt0XT09PW4/ci5wdXNoKG4pOnIucHVzaChoLG4pLHIucHVzaChoKSxyfWZ1bmN0aW9uIHUoZSx0KXtyZXR1cm4gdD09PS0xP2U6ZS5zbGljZSgwLHQpfWZ1bmN0aW9uIGMoZSx0LG4scil7dmFyIG89djtyZXR1cm4gdCE9PS0xJiYobz1uPT09LTE/ZS5zbGljZSh0KzEsZS5sZW5ndGgpOmUuc2xpY2UodCsxLG4pKSxvPW8ucmVwbGFjZShuZXcgUmVnRXhwKFwiW1xcXFxzXCIrcitcIl1cIixtKSx2KSxvPT09eT9mOm8ubGVuZ3RoPDE/ZzpvW28ubGVuZ3RoLTFdPT09cD9vLnNsaWNlKDAsby5sZW5ndGgtMSk6b31mdW5jdGlvbiBsKGUsdCxuLHIpe3ZhciBvPXY7cmV0dXJuIHQhPT0tMSYmKG89ZS5zbGljZSh0KzEsZS5sZW5ndGgpKSxvPW8ucmVwbGFjZShuZXcgUmVnRXhwKFwiW1xcXFxzXCIrbitcIi5dXCIsbSksdiksMD09PW8ubGVuZ3RoP2VbdC0xXT09PXAmJnIhPT1lLmxlbmd0aD9mOnY6b31mdW5jdGlvbiBhKGUsdCl7cmV0dXJuIGUuc3BsaXQodikubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlPT09Zz9lOnQ/eDpifSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9big0KSxkPXIocyksZj1cIipcIixwPVwiLlwiLHY9XCJcIix5PVwiQFwiLGg9XCJbXVwiLGc9XCIgXCIsbT1cImdcIixiPS9bXlxcc10vLHg9L1teLlxcc10vLE89L1xccy9nO3QuZGVmYXVsdD17bWFzazpvLHBpcGU6ZC5kZWZhdWx0fX0sZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKGUsdCl7dmFyIG49dC5jdXJyZW50Q2FyZXRQb3NpdGlvbixpPXQucmF3VmFsdWUsZj10LnByZXZpb3VzQ29uZm9ybWVkVmFsdWUscD10LnBsYWNlaG9sZGVyQ2hhcix2PWU7dj1yKHYpO3ZhciB5PXYuaW5kZXhPZihjKSxoPW51bGw9PT1pLm1hdGNoKG5ldyBSZWdFeHAoXCJbXkBcXFxccy5cIitwK1wiXVwiKSk7aWYoaClyZXR1cm4gdTtpZih2LmluZGV4T2YoYSkhPT0tMXx8eSE9PS0xJiZuIT09eSsxfHxpLmluZGV4T2Yobyk9PT0tMSYmZiE9PXUmJmkuaW5kZXhPZihsKSE9PS0xKXJldHVybiExO3ZhciBnPXYuaW5kZXhPZihvKSxtPXYuc2xpY2UoZysxLHYubGVuZ3RoKTtyZXR1cm4obS5tYXRjaChkKXx8cykubGVuZ3RoPjEmJnYuc3Vic3RyKC0xKT09PWwmJm4hPT1pLmxlbmd0aCYmKHY9di5zbGljZSgwLHYubGVuZ3RoLTEpKSx2fWZ1bmN0aW9uIHIoZSl7dmFyIHQ9MDtyZXR1cm4gZS5yZXBsYWNlKGksZnVuY3Rpb24oKXtyZXR1cm4gdCsrLDE9PT10P286dX0pfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD1uO3ZhciBvPVwiQFwiLGk9L0AvZyx1PVwiXCIsYz1cIkAuXCIsbD1cIi5cIixhPVwiLi5cIixzPVtdLGQ9L1xcLi9nfV0pfSk7IiwiaW1wb3J0J0BkYW5pZWxrYWxlbi9pcyc7aW1wb3J0IElTIGZyb20nLi4vY2hlY2tzLmpzJztpbXBvcnQncXVpY2tkb20nO2ltcG9ydCdAZGFuaWVsa2FsZW4vc2ltcGx5YmluZCc7aW1wb3J0IFJFR0VYIGZyb20nLi4vY29uc3RhbnRzL3JlZ2V4LmpzJztpbXBvcnQge3JlcGVhdH1mcm9tJy4uL2hlbHBlcnMuanMnO2ltcG9ydCBleHRlbmQgZnJvbSdzbWFydC1leHRlbmQnO2ltcG9ydCBtYXNrQ29yZSBmcm9tJ3RleHQtbWFzay1jb3JlJztpbXBvcnQgbWFza0FkZG9ucyBmcm9tJ3RleHQtbWFzay1hZGRvbnMnO3ZhciBNYXNrLCBkZWZhdWx0UGF0dGVybkNoYXJzO1xuZGVmYXVsdFBhdHRlcm5DaGFycyA9IHtcbiAgJzEnOiBSRUdFWC5udW1lcmljLFxuICAnIyc6IFJFR0VYLndpZGVudW1lcmljLFxuICAnYSc6IFJFR0VYLmxldHRlcixcbiAgJyonOiBSRUdFWC5hbnlcbn07XG5NYXNrID0gY2xhc3MgTWFzayB7XG4gIGNvbnN0cnVjdG9yKGZpZWxkLCBjb25maWcpIHtcbiAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy52YWx1ZSA9ICcnO1xuICAgIHRoaXMucHJldlZhbHVlID0gJyc7XG4gICAgdGhpcy5jdXJzb3IgPSAwO1xuICAgIHRoaXMucHJldkN1cnNvciA9IDA7XG4gICAgdGhpcy5wYXR0ZXJuID0gdGhpcy5wYXR0ZXJuUmF3ID0gdGhpcy5jb25maWcucGF0dGVybjtcbiAgICB0aGlzLnBhdHRlcm5TZXR0ZXIgPSB0aGlzLmNvbmZpZy5zZXR0ZXI7XG4gICAgdGhpcy5wbGFjZWhvbGRlckNoYXIgPSB0aGlzLmNvbmZpZy5wbGFjZWhvbGRlcjtcbiAgICB0aGlzLnBsYWNlaG9sZGVyUmVnZXggPSBuZXcgUmVnRXhwKCdcXFxcJyArICh0aGlzLnBsYWNlaG9sZGVyQ2hhciB8fCAnXycpLCAnZycpO1xuICAgIHRoaXMuZ3VpZGUgPSB0aGlzLmNvbmZpZy5ndWlkZTtcbiAgICB0aGlzLmtlZXBDaGFyUG9zaXRpb25zID0gdGhpcy5jb25maWcua2VlcENoYXJQb3NpdGlvbnM7XG4gICAgdGhpcy5jaGFycyA9IGV4dGVuZC5jbG9uZShkZWZhdWx0UGF0dGVybkNoYXJzLCB0aGlzLmNvbmZpZy5jdXN0b21QYXR0ZXJucyk7XG4gICAgdGhpcy5zZXRQYXR0ZXJuKHRoaXMucGF0dGVybik7XG4gIH1cblxuICBnZXRTdGF0ZShwYXR0ZXJuLCByYXdWYWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICByYXdWYWx1ZSxcbiAgICAgIGd1aWRlOiB0aGlzLmd1aWRlLFxuICAgICAgcGxhY2Vob2xkZXJDaGFyOiB0aGlzLnBsYWNlaG9sZGVyQ2hhcixcbiAgICAgIGtlZXBDaGFyUG9zaXRpb25zOiB0aGlzLmtlZXBDaGFyUG9zaXRpb25zLFxuICAgICAgY3VycmVudENhcmV0UG9zaXRpb246IHRoaXMuZmllbGQuZWwgPyB0aGlzLmZpZWxkLnNlbGVjdGlvbigpLmVuZCA6IHRoaXMuY3Vyc29yLFxuICAgICAgcHJldmlvdXNDb25mb3JtZWRWYWx1ZTogdGhpcy5wcmV2VmFsdWUsXG4gICAgICBwbGFjZWhvbGRlcjogdGhpcy5nZXRQbGFjZWhvbGRlcihwYXR0ZXJuKVxuICAgIH07XG4gIH1cblxuICBnZXRQbGFjZWhvbGRlcihwYXR0ZXJuKSB7XG4gICAgdmFyIGNoYXIsIGosIGxlbiwgcGxhY2Vob2xkZXI7XG5cbiAgICBpZiAoSVMuZnVuY3Rpb24ocGF0dGVybikpIDsgZWxzZSB7XG4gICAgICBwbGFjZWhvbGRlciA9ICcnO1xuXG4gICAgICBmb3IgKGogPSAwLCBsZW4gPSBwYXR0ZXJuLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIGNoYXIgPSBwYXR0ZXJuW2pdO1xuXG4gICAgICAgIGlmIChJUy5yZWdleChjaGFyKSkge1xuICAgICAgICAgIHBsYWNlaG9sZGVyICs9IHRoaXMucGxhY2Vob2xkZXJDaGFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBsYWNlaG9sZGVyICs9IGNoYXI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgIH1cbiAgfVxuXG4gIHJlc29sdmVQYXR0ZXJuKHBhdHRlcm4sIGlucHV0LCBzdGF0ZSkge1xuICAgIHZhciBjaGFyLCBjb3B5LCBpLCBqLCBsZW4sIG9mZnNldCwgdHJhcEluZGV4ZXM7XG4gICAgcGF0dGVybiA9IHR5cGVvZiBwYXR0ZXJuID09PSAnZnVuY3Rpb24nID8gcGF0dGVybihpbnB1dCwgdGhpcy5nZXRTdGF0ZShwYXR0ZXJuLCBpbnB1dCkpIDogcGF0dGVybjtcbiAgICBvZmZzZXQgPSAwO1xuICAgIHRyYXBJbmRleGVzID0gW107XG4gICAgY29weSA9IHBhdHRlcm4uc2xpY2UoKTtcblxuICAgIGZvciAoaSA9IGogPSAwLCBsZW4gPSBjb3B5Lmxlbmd0aDsgaiA8IGxlbjsgaSA9ICsraikge1xuICAgICAgY2hhciA9IGNvcHlbaV07XG5cbiAgICAgIGlmICghKGNoYXIgPT09ICdbXScpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0cmFwSW5kZXhlcy5wdXNoKGkgLSBvZmZzZXQpO1xuICAgICAgcGF0dGVybi5zcGxpY2UoaSAtIG9mZnNldCwgMSk7XG4gICAgICBvZmZzZXQrKztcbiAgICB9XG5cbiAgICB0aGlzLnByZXZQYXR0ZXJuID0gdGhpcy5yZXNvbHZlZFBhdHRlcm47XG4gICAgdGhpcy5yZXNvbHZlZFBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgIHJldHVybiB7XG4gICAgICBwYXR0ZXJuLFxuICAgICAgY2FyZXRUcmFwSW5kZXhlczogdHJhcEluZGV4ZXNcbiAgICB9O1xuICB9XG5cbiAgc2V0UGF0dGVybihzdHJpbmcsIHVwZGF0ZVZhbHVlID0gdHJ1ZSwgdXBkYXRlRmllbGQpIHtcbiAgICB0aGlzLnBhdHRlcm5SYXcgPSBzdHJpbmc7XG4gICAgdGhpcy5wYXR0ZXJuID0gdGhpcy5wYXJzZVBhdHRlcm4oc3RyaW5nKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMucGFyc2VUcmFuc2Zvcm0oc3RyaW5nKTtcblxuICAgIGlmICh1cGRhdGVWYWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc2V0VmFsdWUodGhpcy52YWx1ZSk7XG5cbiAgICAgIGlmICh1cGRhdGVGaWVsZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZC52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcGFyc2VQYXR0ZXJuKHN0cmluZykge1xuICAgIHZhciBjaGFyLCBlc2NhcGVkLCBpLCBqLCBsZW4sIHBhdHRlcm47XG5cbiAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICBjYXNlIHN0cmluZyAhPT0gJ0VNQUlMJzpcbiAgICAgICAgcmV0dXJuIG1hc2tBZGRvbnMuZW1haWxNYXNrLm1hc2s7XG5cbiAgICAgIGNhc2Ugc3RyaW5nICE9PSAnUEhPTkUnOlxuICAgICAgICB0aGlzLnBhdHRlcm5TZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gcmVwZWF0KCcjJywgTWF0aC5tYXgoNywgdmFsdWUubGVuZ3RoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ndWlkZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gJyMnO1xuXG4gICAgICBjYXNlIHN0cmluZyAhPT0gJ05BTUUnOlxuICAgICAgICB0aGlzLnBhdHRlcm5TZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UodGhpcy5wbGFjZWhvbGRlclJlZ2V4LCAnJykudHJpbSgpO1xuICAgICAgICAgIHJldHVybiByZXBlYXQoJ2EnLCBNYXRoLm1heCgyLCB2YWx1ZS5sZW5ndGgpKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gJ2EnO1xuXG4gICAgICBjYXNlIHN0cmluZyAhPT0gJ0ZVTExOQU1FJzpcbiAgICAgICAgdGhpcy5wYXR0ZXJuU2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHNwbGl0O1xuXG4gICAgICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAgICAgICAgIHZhbHVlICs9ICd4JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzcGxpdCA9IHZhbHVlLnJlcGxhY2UodGhpcy5wbGFjZWhvbGRlclJlZ2V4LCAnJykudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG5cbiAgICAgICAgICBpZiAoc3BsaXQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNwbGl0Lm1hcChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGVhdCgnYScsIE1hdGgubWF4KDIsIHBhcnQubGVuZ3RoKSk7XG4gICAgICAgICAgfSkuam9pbignICcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAnYSc7XG5cbiAgICAgIGNhc2Ugc3RyaW5nICE9PSAnREFURSc6XG4gICAgICAgIHJldHVybiBbL1xcZC8sIC9cXGQvLCAnLycsIC9cXGQvLCAvXFxkLywgJy8nLCAvXFxkLywgL1xcZC8sIC9cXGQvLCAvXFxkL107XG5cbiAgICAgIGNhc2UgIShzdHJpbmdbMF0gPT09ICdEQVRFJyAmJiBJUy5zdHJpbmcoc3RyaW5nWzFdKSk6XG4gICAgICAgIHJldHVybiBzdHJpbmdbMV0uc3BsaXQoJycpLm1hcChjaGFyID0+IHtcbiAgICAgICAgICBpZiAoUkVHRVgubGV0dGVyLnRlc3QoY2hhcikpIHtcbiAgICAgICAgICAgIHJldHVybiAvXFxkLztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNoYXI7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgY2FzZSBzdHJpbmcgIT09ICdOVU1CRVInOlxuICAgICAgICByZXR1cm4gbWFza0FkZG9ucy5jcmVhdGVOdW1iZXJNYXNrKHtcbiAgICAgICAgICBwcmVmaXg6IHRoaXMuY29uZmlnLnByZWZpeCB8fCAnJyxcbiAgICAgICAgICBzdWZmaXg6IHRoaXMuY29uZmlnLnN1ZmZpeCB8fCAnJyxcbiAgICAgICAgICBpbmNsdWRlVGhvdXNhbmRzU2VwYXJhdG9yOiB0aGlzLmNvbmZpZy5zZXAgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgdGhvdXNhbmRzU2VwYXJhdG9yU3ltYm9sOiBJUy5zdHJpbmcodGhpcy5jb25maWcuc2VwKSA/IHRoaXMuY29uZmlnLnNlcCA6IHZvaWQgMCxcbiAgICAgICAgICBhbGxvd0RlY2ltYWw6IHRoaXMuY29uZmlnLmRlY2ltYWwsXG4gICAgICAgICAgZGVjaW1hbExpbWl0OiBJUy5udW1iZXIodGhpcy5jb25maWcuZGVjaW1hbCkgPyB0aGlzLmNvbmZpZy5kZWNpbWFsIDogdm9pZCAwLFxuICAgICAgICAgIGludGVnZXJMaW1pdDogSVMubnVtYmVyKHRoaXMuY29uZmlnLmxpbWl0KSA/IHRoaXMuY29uZmlnLmxpbWl0IDogdm9pZCAwXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICFJUy5hcnJheShzdHJpbmcpOlxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBwYXR0ZXJuID0gW107XG5cbiAgICAgICAgZm9yIChpID0gaiA9IDAsIGxlbiA9IHN0cmluZy5sZW5ndGg7IGogPCBsZW47IGkgPSArK2opIHtcbiAgICAgICAgICBjaGFyID0gc3RyaW5nW2ldO1xuXG4gICAgICAgICAgaWYgKGNoYXIgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXR0ZXJuLnB1c2goZXNjYXBlZCA/IGNoYXIgOiB0aGlzLmNoYXJzW2NoYXJdIHx8IGNoYXIpO1xuICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlVHJhbnNmb3JtKHN0cmluZykge1xuICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgIGNhc2Ugc3RyaW5nICE9PSAnRU1BSUwnOlxuICAgICAgICByZXR1cm4gbWFza0FkZG9ucy5lbWFpbE1hc2sucGlwZTtcblxuICAgICAgY2FzZSBzdHJpbmcgIT09ICdEQVRFJzpcbiAgICAgICAgcmV0dXJuIG1hc2tBZGRvbnMuY3JlYXRlQXV0b0NvcnJlY3RlZERhdGVQaXBlKCdtbS9kZC95eXl5Jyk7XG5cbiAgICAgIGNhc2UgIShzdHJpbmdbMF0gPT09ICdEQVRFJyAmJiBJUy5zdHJpbmcoc3RyaW5nWzFdKSk6XG4gICAgICAgIHJldHVybiBtYXNrQWRkb25zLmNyZWF0ZUF1dG9Db3JyZWN0ZWREYXRlUGlwZShzdHJpbmdbMV0pO1xuXG4gICAgICBjYXNlICF0aGlzLmNvbmZpZy50cmFuc2Zvcm06XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy50cmFuc2Zvcm07XG4gICAgfVxuICB9XG5cbiAgc2V0VmFsdWUoaW5wdXQpIHtcbiAgICB2YXIgY2FyZXRUcmFwSW5kZXhlcywgY29uZm9ybWVkVmFsdWUsIGluZGV4ZXNPZlBpcGVkQ2hhcnMsIG5ld1BhdHRlcm4sIHBhdHRlcm4sIHN0YXRlLCB0cmFuc2Zvcm1lZDtcblxuICAgIGlmICh0aGlzLnBhdHRlcm5TZXR0ZXIpIHtcbiAgICAgIG5ld1BhdHRlcm4gPSB0aGlzLnBhdHRlcm5TZXR0ZXIoaW5wdXQpIHx8IHRoaXMucGF0dGVybjtcblxuICAgICAgaWYgKG5ld1BhdHRlcm4gIT09IHRoaXMucGF0dGVyblJhdyAmJiBuZXdQYXR0ZXJuICE9PSB0aGlzLnBhdHRlcm4pIHtcbiAgICAgICAgdGhpcy5zZXRQYXR0ZXJuKG5ld1BhdHRlcm4sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAoe1xuICAgICAgY2FyZXRUcmFwSW5kZXhlcyxcbiAgICAgIHBhdHRlcm5cbiAgICB9ID0gdGhpcy5yZXNvbHZlUGF0dGVybih0aGlzLnBhdHRlcm4sIGlucHV0KSk7XG5cbiAgICBpZiAocGF0dGVybiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMucHJldlZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICB0aGlzLnByZXZDdXJzb3IgPSB0aGlzLmN1cnNvcjtcbiAgICBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUocGF0dGVybiwgaW5wdXQpO1xuICAgICh7XG4gICAgICBjb25mb3JtZWRWYWx1ZVxuICAgIH0gPSBtYXNrQ29yZS5jb25mb3JtVG9NYXNrKGlucHV0LCBwYXR0ZXJuLCBzdGF0ZSkpO1xuXG4gICAgaWYgKHRoaXMudHJhbnNmb3JtKSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IHRoaXMudHJhbnNmb3JtKGNvbmZvcm1lZFZhbHVlLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybWVkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKElTLnN0cmluZyh0cmFuc2Zvcm1lZCkpIHtcbiAgICAgIGNvbmZvcm1lZFZhbHVlID0gdHJhbnNmb3JtZWQ7XG4gICAgfSBlbHNlIGlmIChJUy5vYmplY3QodHJhbnNmb3JtZWQpKSB7XG4gICAgICBpbmRleGVzT2ZQaXBlZENoYXJzID0gdHJhbnNmb3JtZWQuaW5kZXhlc09mUGlwZWRDaGFycztcbiAgICAgIGNvbmZvcm1lZFZhbHVlID0gdHJhbnNmb3JtZWQudmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJzb3IgPSBtYXNrQ29yZS5hZGp1c3RDYXJldFBvc2l0aW9uKGV4dGVuZChzdGF0ZSwge1xuICAgICAgaW5kZXhlc09mUGlwZWRDaGFycyxcbiAgICAgIGNhcmV0VHJhcEluZGV4ZXMsXG4gICAgICBjb25mb3JtZWRWYWx1ZVxuICAgIH0pKTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZSA9IGNvbmZvcm1lZFZhbHVlO1xuICB9XG5cbiAgdmFsaWRhdGUoaW5wdXQpIHtcbiAgICB2YXIgY2hhciwgaSwgaiwgbGVuLCBwYXR0ZXJuO1xuXG4gICAgaWYgKGlucHV0ICE9PSB0aGlzLnZhbHVlICYmIHRoaXMucGF0dGVyblNldHRlcikge1xuICAgICAgcGF0dGVybiA9IHRoaXMucGF0dGVyblNldHRlcihpbnB1dCkgfHwgdGhpcy5wYXR0ZXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5yZXNvbHZlZFBhdHRlcm47XG5cbiAgICAgIGlmICghcGF0dGVybikge1xuICAgICAgICAoe1xuICAgICAgICAgIHBhdHRlcm5cbiAgICAgICAgfSA9IHRoaXMucmVzb2x2ZVBhdHRlcm4odGhpcy5wYXR0ZXJuLCBpbnB1dCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXR0ZXJuID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gaiA9IDAsIGxlbiA9IHBhdHRlcm4ubGVuZ3RoOyBqIDwgbGVuOyBpID0gKytqKSB7XG4gICAgICBjaGFyID0gcGF0dGVybltpXTtcblxuICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICBjYXNlICEhaW5wdXRbaV06XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNhc2UgIShJUy5yZWdleChjaGFyKSAmJiAhY2hhci50ZXN0KGlucHV0W2ldKSk6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNhc2UgIShJUy5zdHJpbmcoY2hhcikgJiYgaW5wdXRbaV0gIT09IGNoYXIpOlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlzRW1wdHkoKSB7XG4gICAgdmFyIGNoYXIsIGksIGlucHV0LCBqLCBsZW4sIHBhdHRlcm47XG4gICAgaW5wdXQgPSB0aGlzLnZhbHVlO1xuICAgIHBhdHRlcm4gPSB0aGlzLnJlc29sdmVkUGF0dGVybjtcblxuICAgIGlmICghcGF0dGVybikge1xuICAgICAgaWYgKHRoaXMucGF0dGVyblNldHRlcikge1xuICAgICAgICBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuU2V0dGVyKGlucHV0KTtcbiAgICAgIH1cblxuICAgICAgKHtcbiAgICAgICAgcGF0dGVyblxuICAgICAgfSA9IHRoaXMucmVzb2x2ZVBhdHRlcm4ocGF0dGVybiB8fCB0aGlzLnBhdHRlcm4sIGlucHV0KSk7XG4gICAgfVxuXG4gICAgaWYgKGlucHV0ID09PSB0aGlzLmNvbmZpZy5wcmVmaXggfHwgaW5wdXQgPT09IHRoaXMuY29uZmlnLnN1ZmZpeCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gaiA9IDAsIGxlbiA9IHBhdHRlcm4ubGVuZ3RoOyBqIDwgbGVuOyBpID0gKytqKSB7XG4gICAgICBjaGFyID0gcGF0dGVybltpXTtcblxuICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICBjYXNlICEhaW5wdXRbaV06XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgY2FzZSAhSVMucmVnZXgoY2hhcik6XG4gICAgICAgICAgcmV0dXJuICFjaGFyLnRlc3QoaW5wdXRbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG59O1xudmFyIE1hc2skMSA9IE1hc2s7ZXhwb3J0IGRlZmF1bHQgTWFzayQxOyIsInZhciBDT0xPUlMgPSB7XG4gIHJlZDogJyNjYzQ4MjAnLFxuICBncmVlbjogJyM3MmMzMjInLFxuICBvcmFuZ2U6ICcjZmY5YzAwJyxcbiAgYmxhY2s6ICcjMTgxODE4JyxcbiAgZ3JleV9kYXJrOiAnIzVlNWU1ZScsXG4gIGdyZXk6ICcjOTA5MDkwJyxcbiAgZ3JleV9zZW1pX2xpZ2h0OiAnI2JlYmViZScsXG4gIGdyZXlfbGlnaHQ6ICcjZDNkM2QzJyxcbiAgZ3JleV9saWdodDI6ICcjZGRkZGRkJyxcbiAgZ3JleV9saWdodDM6ICcjZjJmNWY3JyxcbiAgZ3JleV9saWdodDQ6ICcjZTVlNWU1J1xufTtleHBvcnQgZGVmYXVsdCBDT0xPUlM7IiwiaW1wb3J0IERPTSBmcm9tJ3F1aWNrZG9tJztpbXBvcnQge3Nob3J0aGFuZFNpZGVWYWx1ZSxjYWxjUGFkZGluZyxkZWZhdWx0Q29sb3IsaGV4VG9SR0JBfWZyb20nLi4vLi4vaGVscGVycy5qcyc7aW1wb3J0IENPTE9SUyBmcm9tJy4uLy4uL2NvbnN0YW50cy9jb2xvcnMuanMnO3ZhciB0ZXh0RmllbGRUZW1wbGF0ZSA9IERPTS50ZW1wbGF0ZShbJ2RpdicsIHtcbiAgcmVmOiAnZmllbGQnLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBmb250RmFtaWx5OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5mb250RmFtaWx5O1xuICAgIH0sXG4gICAgdGV4dEFsaWduOiAnbGVmdCcsXG4gICAgJHZpc2libGU6IHtcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snXG4gICAgfSxcbiAgICAkc2hvd0Vycm9yOiB7XG4gICAgICBhbmltYXRpb246ICcwLjJzIGZpZWxkRXJyb3JTaGFrZSdcbiAgICB9XG4gIH1cbn0sIFsnZGl2Jywge1xuICByZWY6ICdsYWJlbCcsXG4gIHN0eWxlQWZ0ZXJJbnNlcnQ6IHRydWUsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgekluZGV4OiAxLFxuICAgIHRvcDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHlsZVBhcnNlZCgnZm9udFNpemUnLCB0cnVlKSAqIDAuNztcbiAgICB9LFxuICAgIGxlZnQ6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgdmFyIHJlZjtcbiAgICAgIHJldHVybiBzaG9ydGhhbmRTaWRlVmFsdWUoZmllbGQuc2V0dGluZ3MucGFkZGluZywgJ2xlZnQnKSArICgoKHJlZiA9IGZpZWxkLmVsLmNoaWxkLmljb24pICE9IG51bGwgPyByZWYud2lkdGggOiB2b2lkIDApIHx8IDApO1xuICAgIH0sXG4gICAgcGFkZGluZzogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gYDAgJHtmaWVsZC5zZXR0aW5ncy5pbnB1dFBhZGRpbmd9cHhgO1xuICAgIH0sXG4gICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgIGZvbnRTaXplOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5sYWJlbFNpemUgfHwgZmllbGQuc2V0dGluZ3MuZm9udFNpemUgKiAoMTEgLyAxNCk7XG4gICAgfSxcbiAgICBmb250V2VpZ2h0OiA2MDAsXG4gICAgbGluZUhlaWdodDogMSxcbiAgICBjb2xvcjogQ09MT1JTLmdyZXksXG4gICAgb3BhY2l0eTogMCxcbiAgICB0cmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzLCBjb2xvciAwLjJzJyxcbiAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgY3Vyc29yOiAnZGVmYXVsdCcsXG4gICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICRmaWxsZWQ6IHtcbiAgICAgICRzaG93TGFiZWw6IHtcbiAgICAgICAgb3BhY2l0eTogMVxuICAgICAgfVxuICAgIH0sXG4gICAgJGZvY3VzOiB7XG4gICAgICBjb2xvcjogQ09MT1JTLm9yYW5nZVxuICAgIH0sXG4gICAgJHNob3dFcnJvcjoge1xuICAgICAgY29sb3I6IENPTE9SUy5yZWRcbiAgICB9XG4gIH1cbn1dLCBbJ2RpdicsIHtcbiAgcmVmOiAnaW5uZXJ3cmFwJyxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBoZWlnaHQ6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLmhlaWdodDtcbiAgICB9LFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcbiAgICBib3JkZXJXaWR0aDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuc2V0dGluZ3MuYm9yZGVyO1xuICAgIH0sXG4gICAgYm9yZGVyU3R5bGU6ICdzb2xpZCcsXG4gICAgYm9yZGVyQ29sb3I6IENPTE9SUy5ncmV5X2xpZ2h0LFxuICAgIGJvcmRlclJhZGl1czogJzJweCcsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgIHRyYW5zaXRpb246ICdib3JkZXItY29sb3IgMC4ycycsXG4gICAgJGZvY3VzOiB7XG4gICAgICBib3JkZXJDb2xvcjogQ09MT1JTLm9yYW5nZVxuICAgIH0sXG4gICAgJHNob3dFcnJvcjoge1xuICAgICAgYm9yZGVyQ29sb3I6IENPTE9SUy5yZWRcbiAgICB9LFxuICAgICRkaXNhYmxlZDoge1xuICAgICAgYm9yZGVyQ29sb3I6IENPTE9SUy5ncmV5X2xpZ2h0LFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBDT0xPUlMuZ3JleV9saWdodFxuICAgIH1cbiAgfVxufSwgWydpbnB1dCcsIHtcbiAgcmVmOiAnaW5wdXQnLFxuICB0eXBlOiAndGV4dCcsXG4gIHN0eWxlQWZ0ZXJJbnNlcnQ6IHRydWUsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgekluZGV4OiAzLFxuICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgIGhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnN0eWxlU2FmZSgnaGVpZ2h0JywgMSkgfHwgdGhpcy5wYXJlbnQuc3R5bGVTYWZlKCdoZWlnaHQnKTtcbiAgICB9LFxuICAgIHdpZHRoOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHZhciBpY29uU2libGluZywgaW5wdXRTaWJsaW5nLCBwYWRkaW5nLCBwYWRkaW5nTGVmdCwgcGFkZGluZ1JpZ2h0LCBzdWJ0cmFjdCwgd2lkdGg7XG5cbiAgICAgIGlmICghZmllbGQuc2V0dGluZ3MuYXV0b1dpZHRoKSB7XG4gICAgICAgIHN1YnRyYWN0ID0gMDtcblxuICAgICAgICBpZiAoaWNvblNpYmxpbmcgPSBmaWVsZC5lbC5jaGlsZC5pY29uKSB7XG4gICAgICAgICAgc3VidHJhY3QgKz0gaWNvblNpYmxpbmcud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5wdXRTaWJsaW5nID0gZmllbGQuZWwuY2hpbGRbZmllbGQuc2V0dGluZ3MuaW5wdXRTaWJsaW5nXSkge1xuICAgICAgICAgIHdpZHRoID0gaW5wdXRTaWJsaW5nLnN0eWxlUGFyc2VkKCd3aWR0aCcsIDEpIHx8IDA7XG4gICAgICAgICAgcGFkZGluZyA9IGlucHV0U2libGluZy5zdHlsZVBhcnNlZCgncGFkZGluZycsIDEpIHx8IDA7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBpbnB1dFNpYmxpbmcuc3R5bGVQYXJzZWQoJ3BhZGRpbmdMZWZ0JywgMSkgfHwgcGFkZGluZyB8fCAwO1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IGlucHV0U2libGluZy5zdHlsZVBhcnNlZCgncGFkZGluZ1JpZ2h0JywgMSkgfHwgcGFkZGluZyB8fCAwO1xuICAgICAgICAgIHN1YnRyYWN0ICs9IHdpZHRoICsgcGFkZGluZ0xlZnQgKyBwYWRkaW5nUmlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYGNhbGMoMTAwJSAtICR7c3VidHJhY3R9cHgpYDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBhZGRpbmc6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgaWYgKHRoaXMucGFkZGluZyA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucGFkZGluZyA9IE1hdGgubWF4KDAsIGNhbGNQYWRkaW5nKGZpZWxkLnNldHRpbmdzLmhlaWdodCwgMTQpIC0gMyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBgJHt0aGlzLnBhZGRpbmd9cHggJHtmaWVsZC5zZXR0aW5ncy5pbnB1dFBhZGRpbmd9cHhgO1xuICAgIH0sXG4gICAgbWFyZ2luOiAnMCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgIGFwcGVhcmFuY2U6ICdub25lJyxcbiAgICBib3JkZXI6ICdub25lJyxcbiAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgIGZvbnRTaXplOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5mb250U2l6ZTtcbiAgICB9LFxuICAgIGNvbG9yOiBDT0xPUlMuYmxhY2ssXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgYm94U2hhZG93OiAnbm9uZScsXG4gICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgYmFja2dyb3VuZENsaXA6ICdjb250ZW50LWJveCcsXG4gICAgLy8gc2VtaS1maXggZm9yIHllbGxvdyBhdXRvZmlsbCBiYWNrZ3JvdW5kXG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgwKScsXG4gICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAwLjJzLCAtd2Via2l0LXRyYW5zZm9ybSAwLjJzJyxcbiAgICAkZGlzYWJsZWQ6IHtcbiAgICAgIGN1cnNvcjogJ25vdC1hbGxvd2VkJ1xuICAgIH0sXG4gICAgJGZpbGxlZDoge1xuICAgICAgJHNob3dMYWJlbDoge1xuICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgIHZhciBsYWJlbCwgdG90YWxIZWlnaHQsIHRyYW5zbGF0aW9uLCB3b3JrYWJsZUhlaWdodDtcblxuICAgICAgICAgIGlmICh0aGlzLnRyYW5zbGF0aW9uICE9IG51bGwgfHwgIShsYWJlbCA9IGZpZWxkLmVsLmNoaWxkLmxhYmVsKSB8fCBsYWJlbC5zdHlsZVNhZmUoJ3Bvc2l0aW9uJywgMSkgIT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvdGFsSGVpZ2h0ID0gdGhpcy5wYXJlbnQuc3R5bGVQYXJzZWQoJ2hlaWdodCcsIDEpO1xuICAgICAgICAgIHdvcmthYmxlSGVpZ2h0ID0gdG90YWxIZWlnaHQgLSAobGFiZWwuc3R5bGVQYXJzZWQoJ2ZvbnRTaXplJywgMSkgKyBsYWJlbC5zdHlsZVBhcnNlZCgndG9wJywgMSkgKiAyKTtcbiAgICAgICAgICB0cmFuc2xhdGlvbiA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3IoKHRvdGFsSGVpZ2h0IC0gd29ya2FibGVIZWlnaHQpIC8gNCkpO1xuICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlWSgke3RyYW5zbGF0aW9ufXB4KWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1dLCBbJ2RpdicsIHtcbiAgcmVmOiAncGxhY2Vob2xkZXInLFxuICBzdHlsZUFmdGVySW5zZXJ0OiB0cnVlLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHpJbmRleDogMixcbiAgICB0b3A6ICcwcHgnLFxuICAgIGxlZnQ6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgdmFyIHJlZjtcbiAgICAgIHJldHVybiAoKHJlZiA9IGZpZWxkLmVsLmNoaWxkLmljb24pICE9IG51bGwgPyByZWYud2lkdGggOiB2b2lkIDApIHx8IDA7XG4gICAgfSxcbiAgICBmb250RmFtaWx5OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5lbC5jaGlsZC5pbnB1dC5zdHlsZVNhZmUoJ2ZvbnRGYW1pbHknLCAxKTtcbiAgICB9LFxuICAgIGZvbnRTaXplOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5lbC5jaGlsZC5pbnB1dC5zdHlsZVNhZmUoJ2ZvbnRTaXplJywgMSk7XG4gICAgfSxcbiAgICBwYWRkaW5nOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHZhciBob3JpeiwgdmVydGk7XG4gICAgICB2ZXJ0aSA9IGZpZWxkLmVsLmNoaWxkLmlucHV0LnN0eWxlUGFyc2VkKCdwYWRkaW5nVG9wJywgMSkgfHwgZmllbGQuZWwuY2hpbGQuaW5wdXQuc3R5bGVQYXJzZWQoJ3BhZGRpbmdUb3AnKTtcbiAgICAgIGhvcml6ID0gZmllbGQuZWwuY2hpbGQuaW5wdXQuc3R5bGVQYXJzZWQoJ3BhZGRpbmdMZWZ0JywgMSkgfHwgZmllbGQuZWwuY2hpbGQuaW5wdXQuc3R5bGVQYXJzZWQoJ3BhZGRpbmdMZWZ0Jyk7XG4gICAgICByZXR1cm4gYCR7dmVydGkgKyAzfXB4ICR7aG9yaXp9cHhgO1xuICAgIH0sXG4gICAgY29sb3I6IENPTE9SUy5ibGFjayxcbiAgICBvcGFjaXR5OiAwLjUsXG4gICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDApJyxcbiAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIDAuMnMsIC13ZWJraXQtdHJhbnNmb3JtIDAuMnMnLFxuICAgICRmaWxsZWQ6IHtcbiAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgICAgJHNob3dMYWJlbDoge1xuICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgIHJldHVybiBmaWVsZC5lbC5jaGlsZC5pbnB1dC5yYXcuc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XV0sIFsnZGl2Jywge1xuICByZWY6ICdoZWxwJyxcbiAgc3R5bGVBZnRlckluc2VydDogdHJ1ZSxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6ICcxMTAlJyxcbiAgICBsZWZ0OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBzaG9ydGhhbmRTaWRlVmFsdWUoZmllbGQuc2V0dGluZ3MucGFkZGluZywgJ2xlZnQnKTtcbiAgICB9LFxuICAgIGZvbnRGYW1pbHk6ICdpbmhlcml0JyxcbiAgICBmb250U2l6ZTogJzExcHgnLFxuICAgIGNvbG9yOiBDT0xPUlMuZ3JleSxcbiAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgJHNob3dFcnJvcjoge1xuICAgICAgY29sb3I6IENPTE9SUy5yZWRcbiAgICB9LFxuICAgICRzaG93SGVscDoge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgIH1cbiAgfVxufV1dKTtcbnZhciBpY29uID0gRE9NLnRlbXBsYXRlKFsnZGl2Jywge1xuICByZWY6ICdpY29uJyxcbiAgc3R5bGVBZnRlckluc2VydDogdHJ1ZSxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB6SW5kZXg6IDIsXG4gICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgd2lkdGg6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLmljb25TaXplO1xuICAgIH0sXG4gICAgaGVpZ2h0OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5pY29uU2l6ZTtcbiAgICB9LFxuICAgIGZvbnRTaXplOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5pY29uU2l6ZTtcbiAgICB9LFxuICAgIHBhZGRpbmdMZWZ0OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5pbnB1dFBhZGRpbmc7XG4gICAgfSxcbiAgICBwYWRkaW5nVG9wOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5zdHlsZVBhcnNlZCgnaGVpZ2h0JywgMSkgLyAyIC0gZmllbGQuc2V0dGluZ3MuaWNvblNpemUgLyAyO1xuICAgIH0sXG4gICAgbGluZUhlaWdodDogJzFlbScsXG4gICAgdXNlclNlbGVjdDogJ25vbmUnXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICB3aWR0aDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnNlcnRlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJhdy5vZmZzZXRXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdHlsZVBhcnNlZCgnd2lkdGgnLCAxKSB8fCB0aGlzLnJlbGF0ZWQuc2V0dGluZ3MuaWNvblNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1dKTsgLy8gQHN0eWxlUGFyc2VkKCd3aWR0aCcsMSkgb3IgQHJhdy5vZmZzZXRXaWR0aCBvciBAcmVsYXRlZC5zZXR0aW5ncy5pY29uU2l6ZSBvciAwXG5cbnZhciBjaGVja21hcmsgPSBET00udGVtcGxhdGUoWydkaXYnLCB7XG4gIHJlZjogJ2NoZWNrbWFyaycsXG4gIHN0eWxlQWZ0ZXJJbnNlcnQ6IHRydWUsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgekluZGV4OiA0LFxuICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICB3aWR0aDogMjYsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgcGFkZGluZ1RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnN0eWxlUGFyc2VkKCdoZWlnaHQnLCAxKSAvIDIgLSAxMztcbiAgICB9LFxuICAgIHBhZGRpbmdSaWdodDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuc2V0dGluZ3MuaW5wdXRQYWRkaW5nO1xuICAgIH0sXG4gICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgJGZpbGxlZDoge1xuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaydcbiAgICB9XG4gIH1cbn0sIFsnZGl2Jywge1xuICByZWY6ICdjaGVja21hcmtfaW5uZXJ3cmFwJyxcbiAgc3R5bGU6IHtcbiAgICB3aWR0aDogJzIwcHgnLFxuICAgIGhlaWdodDogJzIwcHgnLFxuICAgIGJvcmRlclJhZGl1czogJzUwJScsXG4gICAgYm9yZGVyV2lkdGg6ICczcHgnLFxuICAgIGJvcmRlclN0eWxlOiAnc29saWQnLFxuICAgIGJvcmRlckNvbG9yOiBDT0xPUlMuZ3JlZW4sXG4gICAgdHJhbnNmb3JtOiAnc2NhbGUoMC44KScsXG4gICAgLy8gdHJhbnNmb3JtT3JpZ2luOiAnMTAwJSAwJ1xuICAgICRzaG93RXJyb3I6IHtcbiAgICAgIGJvcmRlckNvbG9yOiBDT0xPUlMucmVkXG4gICAgfVxuICB9XG59LCBbJ2RpdicsIHtcbiAgcmVmOiAnY2hlY2ttYXJrX21hc2sxJyxcbiAgc3R5bGVBZnRlckluc2VydDogdHJ1ZSxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6ICctNHB4JyxcbiAgICBsZWZ0OiAnLTEwcHgnLFxuICAgIHdpZHRoOiAnMTVweCcsXG4gICAgaGVpZ2h0OiAnMzBweCcsXG4gICAgYm9yZGVyUmFkaXVzOiAnMzBweCAwIDAgMzBweCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0Q29sb3IoZmllbGQuZWxzLmlubmVyd3JhcC5zdHlsZVNhZmUoJ2JhY2tncm91bmRDb2xvcicsIDEpLCAnd2hpdGUnKTtcbiAgICB9LFxuICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgtNDVkZWcpJyxcbiAgICB0cmFuc2Zvcm1PcmlnaW46ICcxNXB4IDE1cHggMCdcbiAgfVxufV0sIFsnZGl2Jywge1xuICByZWY6ICdjaGVja21hcmtfbWFzazInLFxuICBzdHlsZUFmdGVySW5zZXJ0OiB0cnVlLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogJy01cHgnLFxuICAgIGxlZnQ6ICc4cHgnLFxuICAgIHdpZHRoOiAnMTVweCcsXG4gICAgaGVpZ2h0OiAnMzBweCcsXG4gICAgYm9yZGVyUmFkaXVzOiAnMCAzMHB4IDMwcHggMCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0Q29sb3IoZmllbGQuZWxzLmlubmVyd3JhcC5zdHlsZVNhZmUoJ2JhY2tncm91bmRDb2xvcicsIDEpLCAnd2hpdGUnKTtcbiAgICB9LFxuICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgtNDVkZWcpJyxcbiAgICB0cmFuc2Zvcm1PcmlnaW46ICcwIDE1cHggMCcsXG4gICAgJGZpbGxlZDoge1xuICAgICAgYW5pbWF0aW9uOiAnNC4yNXMgZWFzZS1pbiBjaGVja21hcmtSb3RhdGVQbGFjZWhvbGRlcicsXG4gICAgICAkaW52YWxpZDoge1xuICAgICAgICBhbmltYXRpb246ICcnXG4gICAgICB9XG4gICAgfVxuICB9XG59XSwgWydkaXYnLCB7XG4gIHJlZjogJ2NoZWNrbWFya19saW5lV3JhcHBlcicsXG4gIHN0eWxlOiB7XG4gICAgJGZpbGxlZDoge1xuICAgICAgJGludmFsaWQ6IHtcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIHpJbmRleDogMixcbiAgICAgICAgYW5pbWF0aW9uOiAnMC41NXMgY2hlY2ttYXJrQW5pbWF0ZUVycm9yJyxcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiAnNTAlIDEwcHgnXG4gICAgICB9XG4gICAgfVxuICB9XG59LCBbJ2RpdicsIHtcbiAgcmVmOiAnY2hlY2ttYXJrX2xpbmVTaG9ydCcsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgekluZGV4OiAyLFxuICAgIHRvcDogJzEwcHgnLFxuICAgIGxlZnQ6ICczcHgnLFxuICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgd2lkdGg6ICc4cHgnLFxuICAgIGhlaWdodDogJzNweCcsXG4gICAgYm9yZGVyUmFkaXVzOiAnMnB4JyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IENPTE9SUy5ncmVlbixcbiAgICB0cmFuc2Zvcm06ICdyb3RhdGUoNDVkZWcpJyxcbiAgICAkZmlsbGVkOiB7XG4gICAgICBhbmltYXRpb246ICcwLjc1cyBjaGVja21hcmtBbmltYXRlU3VjY2Vzc1RpcCdcbiAgICB9LFxuICAgICRpbnZhbGlkOiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IENPTE9SUy5yZWQsXG4gICAgICBsZWZ0OiAnNHB4JyxcbiAgICAgIHRvcDogJzhweCcsXG4gICAgICB3aWR0aDogJzEycHgnLFxuICAgICAgJGZpbGxlZDoge1xuICAgICAgICBhbmltYXRpb246ICcnXG4gICAgICB9XG4gICAgfVxuICB9XG59XSwgWydkaXYnLCB7XG4gIHJlZjogJ2NoZWNrbWFya19saW5lTG9uZycsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgekluZGV4OiAyLFxuICAgIHRvcDogJzhweCcsXG4gICAgcmlnaHQ6ICcycHgnLFxuICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgd2lkdGg6ICcxMnB4JyxcbiAgICBoZWlnaHQ6ICczcHgnLFxuICAgIGJvcmRlclJhZGl1czogJzJweCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiBDT0xPUlMuZ3JlZW4sXG4gICAgdHJhbnNmb3JtOiAncm90YXRlKC00NWRlZyknLFxuICAgICRmaWxsZWQ6IHtcbiAgICAgIGFuaW1hdGlvbjogJzAuNzVzIGNoZWNrbWFya0FuaW1hdGVTdWNjZXNzTG9uZydcbiAgICB9LFxuICAgICRpbnZhbGlkOiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IENPTE9SUy5yZWQsXG4gICAgICB0b3A6ICc4cHgnLFxuICAgICAgbGVmdDogJzRweCcsXG4gICAgICByaWdodDogJ2F1dG8nLFxuICAgICAgJGZpbGxlZDoge1xuICAgICAgICBhbmltYXRpb246ICcnXG4gICAgICB9XG4gICAgfVxuICB9XG59XV0sIFsnZGl2Jywge1xuICByZWY6ICdjaGVja21hcmtfcGxhY2Vob2xkZXInLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHpJbmRleDogMixcbiAgICB0b3A6ICctNHB4JyxcbiAgICBsZWZ0OiAnLTNweCcsXG4gICAgd2lkdGg6ICcyMHB4JyxcbiAgICBoZWlnaHQ6ICcyMHB4JyxcbiAgICBib3JkZXJSYWRpdXM6ICc1MCUnLFxuICAgIGJvcmRlcldpZHRoOiAnM3B4JyxcbiAgICBib3JkZXJTdHlsZTogJ3NvbGlkJyxcbiAgICBib3JkZXJDb2xvcjogaGV4VG9SR0JBKENPTE9SUy5ncmVlbiwgMC40KSxcbiAgICAkaW52YWxpZDoge1xuICAgICAgYm9yZGVyQ29sb3I6IGhleFRvUkdCQShDT0xPUlMucmVkLCAwLjQpXG4gICAgfVxuICB9XG59XSwgWydkaXYnLCB7XG4gIHJlZjogJ2NoZWNrbWFya19wYXRjaCcsXG4gIHN0eWxlQWZ0ZXJJbnNlcnQ6IHRydWUsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgekluZGV4OiAxLFxuICAgIHRvcDogJy0ycHgnLFxuICAgIGxlZnQ6ICc2cHgnLFxuICAgIHdpZHRoOiAnNHB4JyxcbiAgICBoZWlnaHQ6ICcyOHB4JyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRDb2xvcihmaWVsZC5lbHMuaW5uZXJ3cmFwLnN0eWxlU2FmZSgnYmFja2dyb3VuZENvbG9yJywgMSksICd3aGl0ZScpO1xuICAgIH0sXG4gICAgdHJhbnNmb3JtOiAncm90YXRlKC00NWRlZyknXG4gIH1cbn1dXV0pO3ZhciB0ZW1wbGF0ZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDogdGV4dEZpZWxkVGVtcGxhdGUsaWNvbjogaWNvbixjaGVja21hcms6IGNoZWNrbWFya30pO2V4cG9ydHt0ZXh0RmllbGRUZW1wbGF0ZSBhcyBhLHRlbXBsYXRlcyBhcyBiLGljb24gYXMgYyxjaGVja21hcmsgYXMgZH07IiwidmFyIGRlZmF1bHRzID0ge1xuICBwbGFjZWhvbGRlcjogdHJ1ZSxcbiAgdmFsaWRXaGVuSXNDaG9pY2U6IGZhbHNlLFxuICB2YWxpZFdoZW5SZWdleDogZmFsc2UsXG4gIGF1dG9XaWR0aDogZmFsc2UsXG4gIG1heFdpZHRoOiAnMTAwJScsXG4gIG1pbldpZHRoOiAyLFxuICBoZWlnaHQ6IDQ2LFxuICBjaGVja21hcms6IHRydWUsXG4gIGtleWJvYXJkOiAndGV4dCcsXG4gIGRyb3Bkb3duOiB7XG4gICAgbG9ja1Njcm9sbDogZmFsc2VcbiAgfSxcbiAgY2hvaWNlczogbnVsbCxcbiAgbWluTGVuZ3RoOiBudWxsLFxuICBtYXhMZW5ndGg6IG51bGwsXG4gIGlucHV0U2libGluZzogJ2NoZWNrbWFyaycsXG4gIG1hc2s6IHtcbiAgICBwYXR0ZXJuOiBmYWxzZSxcbiAgICBwbGFjZWhvbGRlcjogJ18nLFxuICAgIGd1aWRlOiB0cnVlLFxuICAgIGN1c3RvbVBhdHRlcm5zOiBmYWxzZVxuICB9XG59O2V4cG9ydCBkZWZhdWx0IGRlZmF1bHRzOyIsImltcG9ydCdAZGFuaWVsa2FsZW4vaXMnO2ltcG9ydCBJUyBmcm9tJy4uLy4uL2NoZWNrcy5qcyc7aW1wb3J0IERPTSBmcm9tJ3F1aWNrZG9tJztpbXBvcnQgU2ltcGx5QmluZCBmcm9tJ0BkYW5pZWxrYWxlbi9zaW1wbHliaW5kJztpbXBvcnQgUkVHRVggZnJvbScuLi8uLi9jb25zdGFudHMvcmVnZXguanMnO2ltcG9ydCB7ZnV6enlNYXRjaCxnZXRJbmRleE9mRmlyc3REaWZmLGluY2x1ZGVzfWZyb20nLi4vLi4vaGVscGVycy5qcyc7aW1wb3J0IGV4dGVuZCBmcm9tJ3NtYXJ0LWV4dGVuZCc7aW1wb3J0J2Zhc3Rkb20nO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL2NvbmRpdGlvbi5qcyc7aW1wb3J0Jy4uLy4uL2ZpZWxkL3RyYW5zZm9ybVNldHRpbmdzLmpzJztpbXBvcnQnLi4vLi4vZmllbGQvZ2xvYmFsRGVmYXVsdHMuanMnO2ltcG9ydCBGaWVsZCBmcm9tJy4uLy4uL2ZpZWxkL2luZGV4LmpzJztpbXBvcnQgS0VZQ09ERVMgZnJvbScuLi8uLi9jb25zdGFudHMva2V5Q29kZXMuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2hlY2ttYXJrLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2FuZ2xlRG93bi5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jYXJldFVwLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NhcmV0RG93bi5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9wbHVzLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2Nsb25lLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3JlbW92ZS5qcyc7aW1wb3J0Jy4uLy4uL2NvbXBvbmVudHMvZHJvcGRvd24vdGVtcGxhdGUtYjk2MWY4MWYuanMnO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL2Ryb3Bkb3duL2RlZmF1bHRzLmpzJztpbXBvcnQgRHJvcGRvd24gZnJvbScuLi8uLi9jb21wb25lbnRzL2Ryb3Bkb3duL2luZGV4LmpzJztpbXBvcnQndGV4dC1tYXNrLWNvcmUnO2ltcG9ydCd0ZXh0LW1hc2stYWRkb25zJztpbXBvcnQgTWFzayBmcm9tJy4uLy4uL2NvbXBvbmVudHMvbWFzay5qcyc7aW1wb3J0Jy4uLy4uL2NvbnN0YW50cy9jb2xvcnMuanMnO2ltcG9ydCB7YSBhcyB0ZXh0RmllbGRUZW1wbGF0ZSxiIGFzIHRlbXBsYXRlc31mcm9tJy4vdGVtcGxhdGUtMjMzZTk0MTMuanMnO2ltcG9ydCBkZWZhdWx0cyBmcm9tJy4vZGVmYXVsdHMuanMnO3ZhciBUZXh0RmllbGQ7XG5cblRleHRGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgY2xhc3MgVGV4dEZpZWxkIGV4dGVuZHMgRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcblxuICAgICAgaWYgKHRoaXMuX3ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSAnJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGF0ZS50eXBpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuY3Vyc29yID0ge1xuICAgICAgICBwcmV2OiAwLFxuICAgICAgICBjdXJyZW50OiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAoIXRoaXMuc2V0dGluZ3MudmFsaWRXaGVuUmVnZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Mua2V5Ym9hcmQgPT09ICdlbWFpbCcgJiYgdGhpcy5zZXR0aW5ncy5yZXF1aXJlZCkge1xuICAgICAgICAgIHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuUmVnZXggPSBSRUdFWC5lbWFpbDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLm1hc2sgPT09ICdOQU1FJyB8fCB0aGlzLnNldHRpbmdzLm1hc2sucGF0dGVybiA9PT0gJ05BTUUnKSB7XG4gICAgICAgICAgdGhpcy5zZXR0aW5ncy52YWxpZFdoZW5SZWdleCA9IC9eW2EtekEtWl17Mn0vO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MubWFzayA9PT0gJ0ZVTExOQU1FJyB8fCB0aGlzLnNldHRpbmdzLm1hc2sucGF0dGVybiA9PT0gJ0ZVTExOQU1FJykge1xuICAgICAgICAgIHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuUmVnZXggPSAvXlthLXpBLVpdK1xccytbYS16QS1aXSsvO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5tYXNrLnBhdHRlcm4pIHtcbiAgICAgICAgaWYgKElTLnN0cmluZyh0aGlzLnNldHRpbmdzLm1hc2spKSB7XG4gICAgICAgICAgdGhpcy5zZXR0aW5ncy5tYXNrID0gZXh0ZW5kLmRlZXAuY2xvbmUodGhpcy5kZWZhdWx0cy5tYXNrLCB7XG4gICAgICAgICAgICBwYXR0ZXJuOiB0aGlzLnNldHRpbmdzLm1hc2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChJUy5vYmplY3QodGhpcy5zZXR0aW5ncy5tYXNrKSkge1xuICAgICAgICAgIHRoaXMuc2V0dGluZ3MubWFzay5wYXR0ZXJuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLmtleWJvYXJkKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnREFURSc7XG5cbiAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05VTUJFUic7XG5cbiAgICAgICAgICAgICAgY2FzZSAncGhvbmUnOlxuICAgICAgICAgICAgICBjYXNlICd0ZWwnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnUEhPTkUnO1xuXG4gICAgICAgICAgICAgIGNhc2UgJ2VtYWlsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0VNQUlMJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubWFzay5wYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMubWFzayA9IG5ldyBNYXNrKHRoaXMsIHRoaXMuc2V0dGluZ3MubWFzayk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnRzKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzKCk7XG5cbiAgICAgIHRoaXMuX2NvbnN0cnVjdG9yRW5kKCk7XG4gICAgfVxuXG4gICAgX2dldFZhbHVlKCkge1xuICAgICAgaWYgKHRoaXMuZHJvcGRvd24gJiYgdGhpcy5zZWxlY3RlZCAmJiB0aGlzLl92YWx1ZSA9PT0gdGhpcy5zZWxlY3RlZC5sYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZC52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0VmFsdWUobmV3VmFsdWUpIHtcbiAgICAgIGlmIChJUy5zdHJpbmcobmV3VmFsdWUpIHx8IElTLm51bWJlcihuZXdWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBTdHJpbmcobmV3VmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB0aGlzLm1hc2sgPyB0aGlzLm1hc2suc2V0VmFsdWUobmV3VmFsdWUpIDogbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3JlY2FsY0Rpc3BsYXkoKSB7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdGhpcy5fdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2NyZWF0ZUVsZW1lbnRzKCkge1xuICAgICAgdmFyIGdsb2JhbE9wdHM7XG4gICAgICBnbG9iYWxPcHRzID0ge1xuICAgICAgICByZWxhdGVkSW5zdGFuY2U6IHRoaXNcbiAgICAgIH07XG4gICAgICB0aGlzLmVsID0gdGhpcy50ZW1wbGF0ZS5zcGF3bih0aGlzLnNldHRpbmdzLnRlbXBsYXRlcy5kZWZhdWx0LCBnbG9iYWxPcHRzKTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2hvaWNlcykge1xuICAgICAgICB0aGlzLmRyb3Bkb3duID0gbmV3IERyb3Bkb3duKHRoaXMuc2V0dGluZ3MuY2hvaWNlcywgdGhpcyk7XG4gICAgICAgIHRoaXMuZHJvcGRvd24uYXBwZW5kVG8odGhpcy5lbC5jaGlsZC5pbm5lcndyYXApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5pY29uKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVzLmljb24uc3Bhd24odGhpcy5zZXR0aW5ncy50ZW1wbGF0ZXMuaWNvbiwgZ2xvYmFsT3B0cykuYXBwZW5kKHRoaXMuc2V0dGluZ3MuaWNvbikuaW5zZXJ0QmVmb3JlKHRoaXMuZWwuY2hpbGQuaW5wdXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jaGVja21hcmspIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuY2hlY2ttYXJrLnNwYXduKHRoaXMuc2V0dGluZ3MudGVtcGxhdGVzLmNoZWNrbWFyaywgZ2xvYmFsT3B0cykuaW5zZXJ0QWZ0ZXIodGhpcy5lbC5jaGlsZC5pbnB1dCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWwuY2hpbGQuaW5wdXQucHJvcCgndHlwZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLmtleWJvYXJkKSB7XG4gICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICBjYXNlICd0ZWwnOlxuICAgICAgICAgIGNhc2UgJ3Bob25lJzpcbiAgICAgICAgICAgIHJldHVybiAndGVsJztcblxuICAgICAgICAgIGNhc2UgJ3Bhc3N3b3JkJzpcbiAgICAgICAgICAgIHJldHVybiAncGFzc3dvcmQnO1xuXG4gICAgICAgICAgY2FzZSAndXJsJzpcbiAgICAgICAgICAgIHJldHVybiAndXJsJztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyB3aGVuICdlbWFpbCcgdGhlbiAnZW1haWwnXG4gICAgICAgICAgICByZXR1cm4gJ3RleHQnO1xuICAgICAgICB9XG4gICAgICB9LmNhbGwodGhpcykpO1xuICAgICAgdGhpcy5lbC5zdGF0ZSgnaGFzTGFiZWwnLCB0aGlzLnNldHRpbmdzLmxhYmVsKTtcbiAgICAgIHRoaXMuZWwuY2hpbGQuaW5uZXJ3cmFwLnJhdy5fcXVpY2tGaWVsZCA9IHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3Ll9xdWlja0ZpZWxkID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLmVsLmNoaWxkZjtcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3MoKSB7XG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19lbFN0YXRlKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX2Rpc3BsYXkoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfZGlzcGxheV9hdXRvV2lkdGgoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfdmFsdWUoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfYXV0b2NvbXBsZXRlKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX3N0YXRlVHJpZ2dlcnMoKTtcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3NfZWxTdGF0ZSgpIHtcbiAgICAgIFNpbXBseUJpbmQoJ3Zpc2libGUnKS5vZih0aGlzLnN0YXRlKS50byh2aXNpYmxlID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ3Zpc2libGUnLCB2aXNpYmxlKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnaG92ZXJlZCcpLm9mKHRoaXMuc3RhdGUpLnRvKGhvdmVyZWQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnaG92ZXInLCBob3ZlcmVkKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZm9jdXNlZCcpLm9mKHRoaXMuc3RhdGUpLnRvKGZvY3VzZWQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnZm9jdXMnLCBmb2N1c2VkKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZmlsbGVkJykub2YodGhpcy5zdGF0ZSkudG8oZmlsbGVkID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ2ZpbGxlZCcsIGZpbGxlZCk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2Rpc2FibGVkJykub2YodGhpcy5zdGF0ZSkudG8oZGlzYWJsZWQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnZGlzYWJsZWQnLCBkaXNhYmxlZCk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ3Nob3dMYWJlbCcpLm9mKHRoaXMuc3RhdGUpLnRvKHNob3dMYWJlbCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdzaG93TGFiZWwnLCBzaG93TGFiZWwpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdzaG93RXJyb3InKS5vZih0aGlzLnN0YXRlKS50byhzaG93RXJyb3IgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnc2hvd0Vycm9yJywgc2hvd0Vycm9yKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnc2hvd0hlbHAnKS5vZih0aGlzLnN0YXRlKS50byhzaG93SGVscCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdzaG93SGVscCcsIHNob3dIZWxwKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgndmFsaWQnKS5vZih0aGlzLnN0YXRlKS50byh2YWxpZCA9PiB7XG4gICAgICAgIHRoaXMuZWwuc3RhdGUoJ3ZhbGlkJywgdmFsaWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnaW52YWxpZCcsICF2YWxpZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3NfZGlzcGxheSgpIHtcbiAgICAgIFNpbXBseUJpbmQoJ3BsYWNlaG9sZGVyJykub2YodGhpcy5zdGF0ZSkudG8oJ3RleHQnKS5vZih0aGlzLmVsLmNoaWxkLnBsYWNlaG9sZGVyKS50cmFuc2Zvcm0ocGxhY2Vob2xkZXIgPT4ge1xuICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgY2FzZSAhKHBsYWNlaG9sZGVyID09PSB0cnVlICYmIHRoaXMuc2V0dGluZ3MubGFiZWwpOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MubGFiZWw7XG5cbiAgICAgICAgICBjYXNlICFJUy5zdHJpbmcocGxhY2Vob2xkZXIpOlxuICAgICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdkaXNhYmxlZCcsIHtcbiAgICAgICAgdXBkYXRlT25CaW5kOiB0aGlzLnN0YXRlLmRpc2FibGVkXG4gICAgICB9KS5vZih0aGlzLnN0YXRlKS50bygoZGlzYWJsZWQsIHByZXYpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2hlY2ttYXJrKSB7XG4gICAgICAgICAgaWYgKGRpc2FibGVkIHx8ICFkaXNhYmxlZCAmJiBwcmV2ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5lbC5jaGlsZC5jaGVja21hcmtfbWFzazEucmVjYWxjU3R5bGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5lbC5jaGlsZC5jaGVja21hcmtfbWFzazIucmVjYWxjU3R5bGUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2hpbGQuY2hlY2ttYXJrX3BhdGNoLnJlY2FsY1N0eWxlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gLy8gQGVsLmNoaWxkLmNoZWNrbWFyay5yZWNhbGNTdHlsZSh0cnVlKVxuXG5cbiAgICBfYXR0YWNoQmluZGluZ3NfZGlzcGxheV9hdXRvV2lkdGgoKSB7XG4gICAgICBTaW1wbHlCaW5kKCd3aWR0aCcsIHtcbiAgICAgICAgdXBkYXRlRXZlbklmU2FtZTogdHJ1ZVxuICAgICAgfSkub2YodGhpcy5zdGF0ZSkudG8od2lkdGggPT4ge1xuICAgICAgICByZXR1cm4gKHRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoID8gdGhpcy5lbC5jaGlsZC5pbnB1dCA6IHRoaXMuZWwpLnN0eWxlKCd3aWR0aCcsIHdpZHRoKTtcbiAgICAgIH0pLnRyYW5zZm9ybSh0aGlzLl9mb3JtYXRXaWR0aC5iaW5kKHRoaXMpKS51cGRhdGVPbignaXNNb2JpbGUnKS5vZih0aGlzLnN0YXRlKTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoKSB7XG4gICAgICAgIFNpbXBseUJpbmQoJ192YWx1ZScsIHtcbiAgICAgICAgICB1cGRhdGVFdmVuSWZTYW1lOiB0cnVlLFxuICAgICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICAgICAgfSkub2YodGhpcykudG8oJ3dpZHRoJykub2YodGhpcy5zdGF0ZSkudHJhbnNmb3JtKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gYCR7dGhpcy5fZ2V0SW5wdXRBdXRvV2lkdGgoKX1weGA7XG4gICAgICAgIH0pLnVwZGF0ZU9uKCdldmVudDppbnNlcnRlZCcpLm9mKHRoaXMuZWwpLnVwZGF0ZU9uKCd2aXNpYmxlJykub2YodGhpcy5zdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX3ZhbHVlKCkge1xuICAgICAgdmFyIGlucHV0LCByZXNldElucHV0O1xuICAgICAgaW5wdXQgPSB0aGlzLmVsLmNoaWxkLmlucHV0LnJhdztcblxuICAgICAgcmVzZXRJbnB1dCA9ICgpID0+IHtcbiAgICAgICAgdmFyIGZpbGxlZDtcbiAgICAgICAgZmlsbGVkID0gIXRoaXMubWFzay5pc0VtcHR5KCk7XG5cbiAgICAgICAgaWYgKCFmaWxsZWQpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbih0aGlzLm1hc2suY3Vyc29yID0gMCk7XG4gICAgICAgICAgdGhpcy5fdmFsdWUgPSAnJztcbiAgICAgICAgICB0aGlzLnN0YXRlLmZpbGxlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbGxlZDtcbiAgICAgIH07XG5cbiAgICAgIFNpbXBseUJpbmQoJ2V2ZW50OmlucHV0Jykub2YoaW5wdXQpLnRvKCgpID0+IHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGlucHV0LnZhbHVlO1xuXG4gICAgICAgIGlmICh0aGlzLm1hc2spIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbih0aGlzLm1hc2suY3Vyc29yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2lucHV0JywgdGhpcy52YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ192YWx1ZScsIHtcbiAgICAgICAgdXBkYXRlRXZlbklmU2FtZTogISF0aGlzLm1hc2tcbiAgICAgIH0pLm9mKHRoaXMpLnRvKCd2YWx1ZScpLm9mKGlucHV0KS5hbmQudG8odmFsdWUgPT4ge1xuICAgICAgICB2YXIgZmlsbGVkO1xuICAgICAgICBmaWxsZWQgPSAhIXZhbHVlO1xuXG4gICAgICAgIGlmIChmaWxsZWQgJiYgdGhpcy5tYXNrICYmIHRoaXMubWFzay5ndWlkZSAmJiAoIXRoaXMuc3RhdGUuZm9jdXNlZCB8fCB0aGlzLm1hc2suY3Vyc29yID09PSAwKSkge1xuICAgICAgICAgIGZpbGxlZCA9IHJlc2V0SW5wdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbGVkID0gZmlsbGVkO1xuXG4gICAgICAgIGlmIChmaWxsZWQpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmludGVyYWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZS52YWxpZCA9IHRoaXMudmFsaWRhdGUodm9pZCAwLCB0cnVlKTtcblxuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuZm9jdXNlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2lucHV0JywgdGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6a2V5ZG93bicpLm9mKHRoaXMuZWwuY2hpbGQuaW5wdXQpLnRvKGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWUNPREVTLmVudGVyKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdzdWJtaXQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoYGtleS0ke2V2ZW50LmtleUNvZGV9YCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMubWFzayAmJiB0aGlzLm1hc2suZ3VpZGUpIHtcbiAgICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6Ymx1cicpLm9mKHRoaXMuZWwuY2hpbGQuaW5wdXQpLnRvKHJlc2V0SW5wdXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc19hdXRvY29tcGxldGUoKSB7XG4gICAgICBpZiAodGhpcy5kcm9wZG93bikge1xuICAgICAgICBTaW1wbHlCaW5kLmRlZmF1bHRPcHRpb25zLnVwZGF0ZU9uQmluZCA9IGZhbHNlO1xuICAgICAgICBTaW1wbHlCaW5kKCd0eXBpbmcnLCB7XG4gICAgICAgICAgdXBkYXRlRXZlbklmU2FtZTogdHJ1ZVxuICAgICAgICB9KS5vZih0aGlzLnN0YXRlKS50byhpc1R5cGluZyA9PiB7XG4gICAgICAgICAgaWYgKGlzVHlwaW5nKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZHJvcGRvd24uaXNPcGVuKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmRyb3Bkb3duLmxpc3QuY2FsY0Rpc3BsYXkoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIFNpbXBseUJpbmQoJ2V2ZW50OmNsaWNrJykub2YoZG9jdW1lbnQpLm9uY2UudG8oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRyb3Bkb3duLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICB9KS5jb25kaXRpb24oZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAhRE9NKGV2ZW50LnRhcmdldCkucGFyZW50TWF0Y2hpbmcocGFyZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQgPT09IHRoaXMuZWwuY2hpbGQuaW5uZXJ3cmFwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd24uaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgU2ltcGx5QmluZCgnX3ZhbHVlJykub2YodGhpcykudG8odmFsdWUgPT4ge1xuICAgICAgICAgIHZhciBjaG9pY2UsIGksIGxlbiwgcmVmLCBzaG91bGRCZVZpc2libGU7XG4gICAgICAgICAgcmVmID0gdGhpcy5kcm9wZG93bi5jaG9pY2VzO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaG9pY2UgPSByZWZbaV07XG4gICAgICAgICAgICBzaG91bGRCZVZpc2libGUgPSAhdmFsdWUgPyB0cnVlIDogZnV6enlNYXRjaCh2YWx1ZSwgY2hvaWNlLmxhYmVsKTtcblxuICAgICAgICAgICAgaWYgKGNob2ljZS52aXNpYmxlICE9PSBzaG91bGRCZVZpc2libGUpIHtcbiAgICAgICAgICAgICAgY2hvaWNlLnZpc2libGUgPSBzaG91bGRCZVZpc2libGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuZHJvcGRvd24uaXNPcGVuICYmICF2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRyb3Bkb3duLm9uU2VsZWN0ZWQoc2VsZWN0ZWRDaG9pY2UgPT4ge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZENob2ljZTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gc2VsZWN0ZWRDaG9pY2UubGFiZWw7XG4gICAgICAgICAgdGhpcy5kcm9wZG93bi5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24odGhpcy5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFNpbXBseUJpbmQuZGVmYXVsdE9wdGlvbnMudXBkYXRlT25CaW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3Nfc3RhdGVUcmlnZ2VycygpIHtcbiAgICAgIFNpbXBseUJpbmQoJ2V2ZW50Om1vdXNlZW50ZXInKS5vZih0aGlzLmVsLmNoaWxkLmlucHV0KS50bygoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmhvdmVyZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdldmVudDptb3VzZWxlYXZlJykub2YodGhpcy5lbC5jaGlsZC5pbnB1dCkudG8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5ob3ZlcmVkID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2V2ZW50OmZvY3VzJykub2YodGhpcy5lbC5jaGlsZC5pbnB1dCkudG8oKCkgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlLmZvY3VzZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRpc2FibGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmx1cigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2V2ZW50OmJsdXInKS5vZih0aGlzLmVsLmNoaWxkLmlucHV0KS50bygoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnR5cGluZyA9IHRoaXMuc3RhdGUuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdldmVudDppbnB1dCcpLm9mKHRoaXMuZWwuY2hpbGQuaW5wdXQpLnRvKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUudHlwaW5nID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6a2V5ZG93bicpLm9mKHRoaXMuZWwuY2hpbGQuaW5wdXQpLnRvKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yLnByZXYgPSB0aGlzLnNlbGVjdGlvbigpLmVuZDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9zY2hlZHVsZUN1cnNvclJlc2V0KCkge1xuICAgICAgdmFyIGN1cnJlbnRDdXJzb3IsIGRpZmZJbmRleCwgbmV3Q3Vyc29yO1xuICAgICAgZGlmZkluZGV4ID0gZ2V0SW5kZXhPZkZpcnN0RGlmZih0aGlzLm1hc2sudmFsdWUsIHRoaXMubWFzay5wcmV2LnZhbHVlKTtcbiAgICAgIGN1cnJlbnRDdXJzb3IgPSB0aGlzLmN1cnNvci5jdXJyZW50O1xuICAgICAgbmV3Q3Vyc29yID0gdGhpcy5tYXNrLm5vcm1hbGl6ZUN1cnNvclBvcyhjdXJyZW50Q3Vyc29yLCB0aGlzLmN1cnNvci5wcmV2KTtcblxuICAgICAgaWYgKG5ld0N1cnNvciAhPT0gY3VycmVudEN1cnNvcikge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbihuZXdDdXJzb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRWYWx1ZUlmTm90U2V0KCkge1xuICAgICAgaWYgKHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlICE9PSB0aGlzLl92YWx1ZSkge1xuICAgICAgICB0aGlzLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRJbnB1dEF1dG9XaWR0aCgpIHtcbiAgICAgIHZhciBpbnB1dFdpZHRoLCBsYWJlbFdpZHRoO1xuXG4gICAgICBpZiAodGhpcy5fdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc2V0VmFsdWVJZk5vdFNldCgpO1xuXG4gICAgICAgIHRoaXMuZWwuY2hpbGQuaW5wdXQuc3R5bGUoJ3dpZHRoJywgMCk7XG4gICAgICAgIHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LnNjcm9sbExlZnQgPSAxZSsxMDtcbiAgICAgICAgaW5wdXRXaWR0aCA9IE1hdGgubWF4KHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LnNjcm9sbExlZnQgKyB0aGlzLmVsLmNoaWxkLmlucHV0LnJhdy5vZmZzZXRXaWR0aCwgdGhpcy5lbC5jaGlsZC5pbnB1dC5yYXcuc2Nyb2xsV2lkdGgpICsgMjtcbiAgICAgICAgbGFiZWxXaWR0aCA9IHRoaXMuc2V0dGluZ3MubGFiZWwgJiYgdGhpcy5lbC5jaGlsZC5sYWJlbC5zdHlsZVNhZmUoJ3Bvc2l0aW9uJykgPT09ICdhYnNvbHV0ZScgPyB0aGlzLmVsLmNoaWxkLmxhYmVsLnJlY3Qud2lkdGggOiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRXaWR0aCA9IHRoaXMuZWwuY2hpbGQucGxhY2Vob2xkZXIucmVjdC53aWR0aDtcbiAgICAgICAgbGFiZWxXaWR0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLl9nZXRXaWR0aFNldHRpbmcoJ21heCcpLCBNYXRoLm1heCh0aGlzLl9nZXRXaWR0aFNldHRpbmcoJ21pbicpLCBpbnB1dFdpZHRoLCBsYWJlbFdpZHRoKSk7XG4gICAgfVxuXG4gICAgX2dldFdpZHRoU2V0dGluZyh0YXJnZXQpIHtcbiAgICAgIHZhciBwYXJlbnQsIHBhcmVudFdpZHRoLCByZXN1bHQ7XG5cbiAgICAgIGlmICh0YXJnZXQgPT09ICdtaW4nIHx8IHRhcmdldCA9PT0gJ21heCcpIHtcbiAgICAgICAgdGFyZ2V0ICs9ICdXaWR0aCc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zZXR0aW5nc1t0YXJnZXRdID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLnNldHRpbmdzW3RhcmdldF07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnNldHRpbmdzW3RhcmdldF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlc3VsdCA9IHBhcnNlRmxvYXQodGhpcy5zZXR0aW5nc1t0YXJnZXRdKTtcblxuICAgICAgICBpZiAoaW5jbHVkZXModGhpcy5zZXR0aW5nc1t0YXJnZXRdLCAnJScpKSB7XG4gICAgICAgICAgaWYgKChwYXJlbnQgPSB0aGlzLmVsLnBhcmVudCkgJiYgcGFyZW50LnN0eWxlKCdkaXNwbGF5JykgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgIHBhcmVudFdpZHRoID0gcGFyZW50LnN0eWxlUGFyc2VkKCd3aWR0aCcpIC0gcGFyZW50LnN0eWxlUGFyc2VkKCdwYWRkaW5nTGVmdCcpIC0gcGFyZW50LnN0eWxlUGFyc2VkKCdwYWRkaW5nUmlnaHQnKSAtIDI7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJlbnRXaWR0aCAqIChyZXN1bHQgLyAxMDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0IHx8ICh0YXJnZXQgPT09ICdtaW5XaWR0aCcgPyAwIDogMmUzMDgpO1xuICAgIH1cblxuICAgIF92YWxpZGF0ZShwcm92aWRlZFZhbHVlKSB7XG4gICAgICB2YXIgbWF0Y2hpbmdDaG9pY2UsIHJlZjtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuUmVnZXggJiYgSVMucmVnZXgodGhpcy5zZXR0aW5ncy52YWxpZFdoZW5SZWdleCkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnZhbGlkV2hlblJlZ2V4LnRlc3QocHJvdmlkZWRWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuSXNDaG9pY2UgJiYgKChyZWYgPSB0aGlzLnNldHRpbmdzLmNob2ljZXMpICE9IG51bGwgPyByZWYubGVuZ3RoIDogdm9pZCAwKSkge1xuICAgICAgICBtYXRjaGluZ0Nob2ljZSA9IHRoaXMuc2V0dGluZ3MuY2hvaWNlcy5maWx0ZXIoZnVuY3Rpb24gKGNob2ljZSkge1xuICAgICAgICAgIHJldHVybiBjaG9pY2UudmFsdWUgPT09IHByb3ZpZGVkVmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghbWF0Y2hpbmdDaG9pY2UubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLm1pbkxlbmd0aCkge1xuICAgICAgICBpZiAocHJvdmlkZWRWYWx1ZS5sZW5ndGggPCB0aGlzLnNldHRpbmdzLm1pbkxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5tYXhMZW5ndGgpIHtcbiAgICAgICAgaWYgKHByb3ZpZGVkVmFsdWUubGVuZ3RoID49IHRoaXMuc2V0dGluZ3MubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1hc2spIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hc2sudmFsaWRhdGUocHJvdmlkZWRWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc2VsZWN0aW9uKGFyZykge1xuICAgICAgdmFyIGVuZCwgc3RhcnQ7XG5cbiAgICAgIGlmIChJUy5vYmplY3QoYXJnKSkge1xuICAgICAgICBzdGFydCA9IGFyZy5zdGFydDtcbiAgICAgICAgZW5kID0gYXJnLmVuZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gYXJnO1xuICAgICAgICBlbmQgPSBhcmd1bWVudHNbMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGlmICghZW5kIHx8IGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsLmNoaWxkLmlucHV0LnJhdy5zZXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgJ3N0YXJ0JzogdGhpcy5lbC5jaGlsZC5pbnB1dC5yYXcuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgJ2VuZCc6IHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LnNlbGVjdGlvbkVuZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvY3VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgYmx1cigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsLmNoaWxkLmlucHV0LnJhdy5ibHVyKCk7XG4gICAgfVxuXG4gIH1cbiAgVGV4dEZpZWxkLnByb3RvdHlwZS50ZW1wbGF0ZSA9IHRleHRGaWVsZFRlbXBsYXRlO1xuICBUZXh0RmllbGQucHJvdG90eXBlLnRlbXBsYXRlcyA9IHRlbXBsYXRlcztcbiAgVGV4dEZpZWxkLnByb3RvdHlwZS5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICByZXR1cm4gVGV4dEZpZWxkO1xufS5jYWxsKHVuZGVmaW5lZCk7XG5cbnZhciBUZXh0RmllbGQkMSA9IFRleHRGaWVsZDtleHBvcnQgZGVmYXVsdCBUZXh0RmllbGQkMTsiLCJpbXBvcnQncXVpY2tjc3MnO2ltcG9ydCByZWdpc3RlckFuaW1hdGlvbnMgZnJvbScuL2FuaW1hdGlvbnMuanMnO2ltcG9ydCdAZGFuaWVsa2FsZW4vaXMnO2ltcG9ydCBJUyBmcm9tJy4vY2hlY2tzLmpzJztpbXBvcnQnLi9jb25zb2xlUGF0Y2guanMnO2ltcG9ydCdxdWlja2RvbSc7aW1wb3J0J0BkYW5pZWxrYWxlbi9zaW1wbHliaW5kJztpbXBvcnQnLi9jb25zdGFudHMvcmVnZXguanMnO2ltcG9ydCcuL2hlbHBlcnMuanMnO2ltcG9ydCBleHRlbmQgZnJvbSdzbWFydC1leHRlbmQnO2ltcG9ydCBSRVFVSVJFRF9GSUVMRF9NRVRIT0RTIGZyb20nLi9jb25zdGFudHMvcmVxRmllbGRNZXRob2RzLmpzJztpbXBvcnQnZmFzdGRvbSc7aW1wb3J0Jy4vY29tcG9uZW50cy9jb25kaXRpb24uanMnO2ltcG9ydCcuL2ZpZWxkL3RyYW5zZm9ybVNldHRpbmdzLmpzJztpbXBvcnQnLi9maWVsZC9nbG9iYWxEZWZhdWx0cy5qcyc7aW1wb3J0IEZpZWxkIGZyb20nLi9maWVsZC9pbmRleC5qcyc7aW1wb3J0Jy4vY29uc3RhbnRzL2tleUNvZGVzLmpzJztpbXBvcnQnLi9zdmcvY2hlY2ttYXJrLmpzJztpbXBvcnQnLi9zdmcvYW5nbGVEb3duLmpzJztpbXBvcnQnLi9zdmcvY2FyZXRVcC5qcyc7aW1wb3J0Jy4vc3ZnL2NhcmV0RG93bi5qcyc7aW1wb3J0Jy4vc3ZnL3BsdXMuanMnO2ltcG9ydCcuL3N2Zy9jbG9uZS5qcyc7aW1wb3J0Jy4vc3ZnL3JlbW92ZS5qcyc7aW1wb3J0Jy4vY29tcG9uZW50cy9kcm9wZG93bi90ZW1wbGF0ZS1iOTYxZjgxZi5qcyc7aW1wb3J0Jy4vY29tcG9uZW50cy9kcm9wZG93bi9kZWZhdWx0cy5qcyc7aW1wb3J0Jy4vY29tcG9uZW50cy9kcm9wZG93bi9pbmRleC5qcyc7aW1wb3J0J3RleHQtbWFzay1jb3JlJztpbXBvcnQndGV4dC1tYXNrLWFkZG9ucyc7aW1wb3J0Jy4vY29tcG9uZW50cy9tYXNrLmpzJztpbXBvcnQnLi9jb25zdGFudHMvY29sb3JzLmpzJztpbXBvcnQnLi9maWVsZHMvdGV4dC90ZW1wbGF0ZS0yMzNlOTQxMy5qcyc7aW1wb3J0Jy4vZmllbGRzL3RleHQvZGVmYXVsdHMuanMnO2ltcG9ydCBUZXh0RmllbGQgZnJvbScuL2ZpZWxkcy90ZXh0L2luZGV4LmpzJzt2YXIgdmVyc2lvbiA9IFwiMS4wLjg5XCI7dmFyIGNyZWF0ZUJ1aWxkZXIsIHF1aWNrZmllbGQ7XG5cbmNyZWF0ZUJ1aWxkZXIgPSBmdW5jdGlvbiAoc2V0dGluZ092ZXJyaWRlcywgdGVtcGxhdGVPdmVycmlkZXMpIHtcbiAgdmFyIGJ1aWxkZXI7XG5cbiAgYnVpbGRlciA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgc2V0dGluZ3MgPSBleHRlbmQuY2xvbmUoLi4uYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBpZiAoIUlTLm9iamVjdChzZXR0aW5ncykpIHtcbiAgICAgIHNldHRpbmdzID0ge307XG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzLnR5cGUgPT0gbnVsbCkge1xuICAgICAgc2V0dGluZ3MudHlwZSA9ICd0ZXh0JztcbiAgICB9XG5cbiAgICBpZiAoIUZpZWxkW3NldHRpbmdzLnR5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFF1aWNrRmllbGQ6ICcke3NldHRpbmdzLnR5cGV9JyBpcyBub3QgYSB2YWxpZC9yZWdpc3RlcmVkIGZpZWxkIHR5cGVgKTtcbiAgICB9XG5cbiAgICByZWdpc3RlckFuaW1hdGlvbnMoKTtcbiAgICByZXR1cm4gbmV3IEZpZWxkW3NldHRpbmdzLnR5cGVdKHNldHRpbmdzLCBidWlsZGVyLCBzZXR0aW5nT3ZlcnJpZGVzLCB0ZW1wbGF0ZU92ZXJyaWRlcyk7XG4gIH07XG5cbiAgYnVpbGRlci5yZWdpc3RlciA9IGZ1bmN0aW9uICh0eXBlLCB0YXJnZXRGaWVsZCkge1xuICAgIHZhciBpLCBsZW4sIHJlcXVpcmVkTWV0aG9kO1xuXG4gICAgaWYgKCFJUy5zdHJpbmcodHlwZSkgfHwgIUlTLmZ1bmN0aW9uKHRhcmdldEZpZWxkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVpY2tGaWVsZCBSZWdpc3RyYXRpb246IGludmFsaWQgYXJndW1lbnRzXCIpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IFJFUVVJUkVEX0ZJRUxEX01FVEhPRFMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlcXVpcmVkTWV0aG9kID0gUkVRVUlSRURfRklFTERfTUVUSE9EU1tpXTtcblxuICAgICAgaWYgKCF0YXJnZXRGaWVsZC5wcm90b3R5cGVbcmVxdWlyZWRNZXRob2RdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUXVpY2tGaWVsZCBSZWdpc3RyYXRpb246ICcke3JlcXVpcmVkTWV0aG9kfScgbWV0aG9kIGlzIHJlcXVpcmVkIGluIG9yZGVyIHRvIHJlZ2lzdGVyIHRoZSBmaWVsZGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIEZpZWxkW3R5cGVdID0gdGFyZ2V0RmllbGQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgYnVpbGRlci5jb25maWcgPSBmdW5jdGlvbiAobmV3U2V0dGluZ3MsIG5ld1RlbXBsYXRlcykge1xuICAgIHZhciBjb25maWcsIGdsb2JhbENvbmZpZywgbmFtZSQkMSwgb3JpZ2luYWxUZW1wbGF0ZXMsIG91dHB1dFNldHRpbmdzLCBvdXRwdXRUZW1wbGF0ZXMsIHJlZiwgdGVtcGxhdGVzLCB0eXBlO1xuXG4gICAgaWYgKCFJUy5vYmplY3QobmV3U2V0dGluZ3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFF1aWNrRmllbGQgQ29uZmlnOiBpbnZhbGlkIGNvbmZpZyBvYmplY3QgcHJvdmlkZWQgJHtTdHJpbmcobmV3U2V0dGluZ3MpfWApO1xuICAgIH1cblxuICAgIG91dHB1dFNldHRpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIGZvciAodHlwZSBpbiBuZXdTZXR0aW5ncykge1xuICAgICAgY29uZmlnID0gbmV3U2V0dGluZ3NbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlID09PSAnZ2xvYmFsJykge1xuICAgICAgICBvdXRwdXRTZXR0aW5ncy5nbG9iYWxEZWZhdWx0cyA9IGV4dGVuZC5kZWVwLm5vdERlZXAoRmllbGQuc2hhbGxvd1NldHRpbmdzKS5jbG9uZShGaWVsZC5wcm90b3R5cGUuZ2xvYmFsRGVmYXVsdHMsIGNvbmZpZyk7XG4gICAgICB9IGVsc2UgaWYgKEZpZWxkW3R5cGVdKSB7XG4gICAgICAgIG91dHB1dFNldHRpbmdzW3R5cGVdID0gZXh0ZW5kLmNsb25lLmRlZXAubm90RGVlcChGaWVsZC5zaGFsbG93U2V0dGluZ3MpKEZpZWxkW3R5cGVdLnByb3RvdHlwZS5kZWZhdWx0cywgY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoSVMub2JqZWN0KG5ld1RlbXBsYXRlcykpIHtcbiAgICAgIG91dHB1dFRlbXBsYXRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBnbG9iYWxDb25maWcgPSBuZXdUZW1wbGF0ZXMuZ2xvYmFsO1xuXG4gICAgICBpZiAoZ2xvYmFsQ29uZmlnICYmIGdsb2JhbENvbmZpZy5maWVsZCAmJiAhZ2xvYmFsQ29uZmlnLmRlZmF1bHQpIHtcbiAgICAgICAgZ2xvYmFsQ29uZmlnLmRlZmF1bHQgPSBnbG9iYWxDb25maWcuZmllbGQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodHlwZSBpbiBGaWVsZCkge1xuICAgICAgICBvcmlnaW5hbFRlbXBsYXRlcyA9IChyZWYgPSBGaWVsZFt0eXBlXS5wcm90b3R5cGUpICE9IG51bGwgPyByZWYudGVtcGxhdGVzIDogdm9pZCAwO1xuICAgICAgICB0ZW1wbGF0ZXMgPSBuZXdUZW1wbGF0ZXNbdHlwZV0gfHwgZ2xvYmFsQ29uZmlnO1xuXG4gICAgICAgIGlmICghb3JpZ2luYWxUZW1wbGF0ZXMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGVtcGxhdGVzKSB7XG4gICAgICAgICAgb3V0cHV0VGVtcGxhdGVzW3R5cGVdID0gb3JpZ2luYWxUZW1wbGF0ZXM7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGVtcGxhdGVzLmZpZWxkICYmICF0ZW1wbGF0ZXMuZGVmYXVsdCkge1xuICAgICAgICAgIHRlbXBsYXRlcy5kZWZhdWx0ID0gdGVtcGxhdGVzLmZpZWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0VGVtcGxhdGVzW3R5cGVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICBmb3IgKG5hbWUkJDEgaW4gdGVtcGxhdGVzKSB7XG4gICAgICAgICAgY29uZmlnID0gdGVtcGxhdGVzW25hbWUkJDFdO1xuXG4gICAgICAgICAgaWYgKG5hbWUkJDEgPT09ICdmaWVsZCcgfHwgIW9yaWdpbmFsVGVtcGxhdGVzW25hbWUkJDFdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZ2xvYmFsQ29uZmlnICYmIGdsb2JhbENvbmZpZ1tuYW1lJCQxXSkge1xuICAgICAgICAgICAgY29uZmlnID0gZXh0ZW5kLmNsb25lLmRlZXAuY29uY2F0KGdsb2JhbENvbmZpZ1tuYW1lJCQxXSwgY29uZmlnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvdXRwdXRUZW1wbGF0ZXNbdHlwZV1bbmFtZSQkMV0gPSBvcmlnaW5hbFRlbXBsYXRlc1tuYW1lJCQxXS5leHRlbmQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobmFtZSQkMSBpbiBvcmlnaW5hbFRlbXBsYXRlcykge1xuICAgICAgICAgIGNvbmZpZyA9IG9yaWdpbmFsVGVtcGxhdGVzW25hbWUkJDFdO1xuXG4gICAgICAgICAgaWYgKCFvdXRwdXRUZW1wbGF0ZXNbdHlwZV1bbmFtZSQkMV0pIHtcbiAgICAgICAgICAgIG91dHB1dFRlbXBsYXRlc1t0eXBlXVtuYW1lJCQxXSA9IGNvbmZpZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQnVpbGRlcihvdXRwdXRTZXR0aW5ncywgb3V0cHV0VGVtcGxhdGVzKTtcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnVpbGRlciwgJ2ZpZWxkcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBleHRlbmQuY2xvbmUub3duLm5vdEtleXMoJ2luc3RhbmNlcycpKEZpZWxkKTtcbiAgICB9XG4gIH0pO1xuICBidWlsZGVyLnNldHRpbmdPdmVycmlkZXMgPSBzZXR0aW5nT3ZlcnJpZGVzO1xuICBidWlsZGVyLnRlbXBsYXRlT3ZlcnJpZGVzID0gdGVtcGxhdGVPdmVycmlkZXM7XG4gIGJ1aWxkZXIudmVyc2lvbiA9IHZlcnNpb247XG4gIGJ1aWxkZXIuRmllbGQgPSBGaWVsZDtcbiAgcmV0dXJuIGJ1aWxkZXI7XG59O1xuLy8gaW1wb3J0IE51bWJlckZpZWxkIGZyb20gJy4vZmllbGRzL251bWJlcidcbi8vIGltcG9ydCBTZWxlY3RGaWVsZCBmcm9tICcuL2ZpZWxkcy9zZWxlY3QnXG4vLyBpbXBvcnQgQ2hvaWNlRmllbGQgZnJvbSAnLi9maWVsZHMvY2hvaWNlJ1xuLy8gaW1wb3J0IFRydWVmYWxzZUZpZWxkIGZyb20gJy4vZmllbGRzL3RydWVmYWxzZSdcbi8vIGltcG9ydCBUb2dnbGVGaWVsZCBmcm9tICcuL2ZpZWxkcy90b2dnbGUnXG4vLyBpbXBvcnQgR3JvdXBGaWVsZCBmcm9tICcuL2ZpZWxkcy9ncm91cCdcbi8vIGltcG9ydCBSZXBlYXRlckZpZWxkIGZyb20gJy4vZmllbGRzL3JlcGVhdGVyJ1xuLy8gaW1wb3J0IEZpbGVGaWVsZCBmcm9tICcuL2ZpZWxkcy9maWxlJ1xuLy8gaW1wb3J0IENoZWNrYm94RmllbGQgZnJvbSAnLi9maWVsZHMvY2hlY2tib3gnXG5cbnF1aWNrZmllbGQgPSBjcmVhdGVCdWlsZGVyKCk7XG5xdWlja2ZpZWxkLnJlZ2lzdGVyKCd0ZXh0JywgVGV4dEZpZWxkKTsgLy8gcXVpY2tmaWVsZC5yZWdpc3RlciAndGV4dGFyZWEnLCBUZXh0YXJlYUZpZWxkXG4vLyBxdWlja2ZpZWxkLnJlZ2lzdGVyICdudW1iZXInLCBOdW1iZXJGaWVsZFxuLy8gcXVpY2tmaWVsZC5yZWdpc3RlciAnc2VsZWN0JywgU2VsZWN0RmllbGRcbi8vIHF1aWNrZmllbGQucmVnaXN0ZXIgJ2Nob2ljZScsIENob2ljZUZpZWxkXG4vLyBxdWlja2ZpZWxkLnJlZ2lzdGVyICd0cnVlZmFsc2UnLCBUcnVlZmFsc2VGaWVsZFxuLy8gcXVpY2tmaWVsZC5yZWdpc3RlciAndG9nZ2xlJywgVG9nZ2xlRmllbGRcbi8vIHF1aWNrZmllbGQucmVnaXN0ZXIgJ2dyb3VwJywgR3JvdXBGaWVsZFxuLy8gcXVpY2tmaWVsZC5yZWdpc3RlciAncmVwZWF0ZXInLCBSZXBlYXRlckZpZWxkXG4vLyBxdWlja2ZpZWxkLnJlZ2lzdGVyICdjaGVja2JveCcsIEZpbGVGaWVsZFxuLy8gcXVpY2tmaWVsZC5yZWdpc3RlciAnZmlsZScsIENoZWNrYm94RmllbGRcblxudmFyIHF1aWNrZmllbGQkMSA9IHF1aWNrZmllbGQ7ZXhwb3J0IGRlZmF1bHQgcXVpY2tmaWVsZCQxOyIsInZhciBkZWZhdWx0cyA9IHtcbiAgcGxhY2Vob2xkZXI6IHRydWUsXG4gIHZhbGlkV2hlblJlZ2V4OiBmYWxzZSxcbiAgYXV0b1dpZHRoOiBmYWxzZSxcbiAgYXV0b0hlaWdodDogdHJ1ZSxcbiAgbWluSGVpZ2h0OiA0NixcbiAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgbWF4SGVpZ2h0OiAyZTMwOCxcbiAgbWluV2lkdGg6IDIsXG4gIG1pbkxlbmd0aDogbnVsbCxcbiAgbWF4TGVuZ3RoOiBudWxsLFxuICBjb3VudGVyOiBmYWxzZVxufTsgLy8gZHJvcGRvd246IHtzdG9yZVNlbGVjdGVkOmZhbHNlLCBsb2NrU2Nyb2xsOmZhbHNlfVxuLy8gY2hvaWNlczogbnVsbFxuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdHM7IiwiaW1wb3J0IERPTSBmcm9tJ3F1aWNrZG9tJztpbXBvcnQge3Nob3J0aGFuZFNpZGVWYWx1ZX1mcm9tJy4uLy4uL2hlbHBlcnMuanMnO2ltcG9ydCcuLi8uLi9jb25zdGFudHMvY29sb3JzLmpzJztpbXBvcnQge2EgYXMgdGV4dEZpZWxkVGVtcGxhdGV9ZnJvbScuLi90ZXh0L3RlbXBsYXRlLTIzM2U5NDEzLmpzJzt2YXIgdGVtcGxhdGUgPSB0ZXh0RmllbGRUZW1wbGF0ZS5leHRlbmQoe1xuICBjaGlsZHJlbjoge1xuICAgICdpbm5lcndyYXAnOiB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgIGhlaWdodDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGQuc2V0dGluZ3MubWluSGVpZ2h0IHx8IDQ2O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd2lkdGg6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgaWYgKCFmaWVsZC5zZXR0aW5ncy5hdXRvV2lkdGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcxMDAlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdsYWJlbCc6IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBsZWZ0OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG9ydGhhbmRTaWRlVmFsdWUoZmllbGQuc2V0dGluZ3MucGFkZGluZywgJ2xlZnQnKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvcDogJzcuNnB4J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnaW5wdXQnOiB7XG4gICAgICB0eXBlOiAndGV4dGFyZWEnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICBzdHlsZUFmdGVySW5zZXJ0OiB0cnVlLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHJlc2l6ZTogJ25vbmUnLFxuICAgICAgICAgIHdoaXRlU3BhY2U6ICdub3JtYWwnLFxuICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgaGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYGNhbGMoMTAwJSAtICR7dGhpcy5zdHlsZVNhZmUoJ21hcmdpblRvcCcsIHRydWUpfSAtICR7dGhpcy5zdHlsZVNhZmUoJ21hcmdpbkJvdHRvbScsIHRydWUpfSlgO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbWFyZ2luOiAnMCcsXG4gICAgICAgICAgbWFyZ2luVG9wOiAnMTVweCcsXG4gICAgICAgICAgbWFyZ2luQm90dG9tOiAnMTJweCcsXG4gICAgICAgICAgcGFkZGluZzogJzAgMTJweCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3BsYWNlaG9sZGVyJzoge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICBzdHlsZUFmdGVySW5zZXJ0OiB0cnVlLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgcGFkZGluZzogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICB2YXIgaG9yaXosIHZlcnRpO1xuICAgICAgICAgICAgaG9yaXogPSBmaWVsZC5lbC5jaGlsZC5pbnB1dC5zdHlsZVNhZmUoJ3BhZGRpbmdMZWZ0JywgdHJ1ZSkgfHwgZmllbGQuZWwuY2hpbGQuaW5wdXQuc3R5bGVTYWZlKCdwYWRkaW5nTGVmdCcpO1xuICAgICAgICAgICAgdmVydGkgPSBmaWVsZC5lbC5jaGlsZC5pbnB1dC5zdHlsZVNhZmUoJ21hcmdpblRvcCcsIHRydWUpIHx8IGZpZWxkLmVsLmNoaWxkLmlucHV0LnN0eWxlU2FmZSgnbWFyZ2luVG9wJyk7XG4gICAgICAgICAgICByZXR1cm4gYCR7dmVydGl9ICR7aG9yaXp9YDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xudmFyIGNvdW50ZXIgPSBET00udGVtcGxhdGUoWydkaXYnLCB7XG4gIHJlZjogJ2NvdW50ZXInLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIGJvdHRvbTogLTEwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGZvbnRTaXplOiAxMCxcbiAgICBmb250V2VpZ2h0OiA1MDBcbiAgfVxufV0pO3ZhciB0ZW1wbGF0ZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDogdGVtcGxhdGUsY291bnRlcjogY291bnRlcn0pO2V4cG9ydHt0ZW1wbGF0ZSBhcyBhLHRlbXBsYXRlcyBhcyBiLGNvdW50ZXIgYXMgY307IiwiaW1wb3J0J0BkYW5pZWxrYWxlbi9pcyc7aW1wb3J0IElTIGZyb20nLi4vLi4vY2hlY2tzLmpzJztpbXBvcnQncXVpY2tkb20nO2ltcG9ydCBTaW1wbHlCaW5kIGZyb20nQGRhbmllbGthbGVuL3NpbXBseWJpbmQnO2ltcG9ydCcuLi8uLi9jb25zdGFudHMvcmVnZXguanMnO2ltcG9ydCB7aW5oZXJpdFByb3RvfWZyb20nLi4vLi4vaGVscGVycy5qcyc7aW1wb3J0J3NtYXJ0LWV4dGVuZCc7aW1wb3J0J2Zhc3Rkb20nO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL2NvbmRpdGlvbi5qcyc7aW1wb3J0Jy4uLy4uL2ZpZWxkL3RyYW5zZm9ybVNldHRpbmdzLmpzJztpbXBvcnQnLi4vLi4vZmllbGQvZ2xvYmFsRGVmYXVsdHMuanMnO2ltcG9ydCBGaWVsZCBmcm9tJy4uLy4uL2ZpZWxkL2luZGV4LmpzJztpbXBvcnQnLi4vLi4vY29uc3RhbnRzL2tleUNvZGVzLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NoZWNrbWFyay5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9hbmdsZURvd24uanMnO2ltcG9ydCcuLi8uLi9zdmcvY2FyZXRVcC5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jYXJldERvd24uanMnO2ltcG9ydCcuLi8uLi9zdmcvcGx1cy5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jbG9uZS5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9yZW1vdmUuanMnO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL2Ryb3Bkb3duL3RlbXBsYXRlLWI5NjFmODFmLmpzJztpbXBvcnQnLi4vLi4vY29tcG9uZW50cy9kcm9wZG93bi9kZWZhdWx0cy5qcyc7aW1wb3J0Jy4uLy4uL2NvbXBvbmVudHMvZHJvcGRvd24vaW5kZXguanMnO2ltcG9ydCd0ZXh0LW1hc2stY29yZSc7aW1wb3J0J3RleHQtbWFzay1hZGRvbnMnO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL21hc2suanMnO2ltcG9ydCcuLi8uLi9jb25zdGFudHMvY29sb3JzLmpzJztpbXBvcnQnLi4vdGV4dC90ZW1wbGF0ZS0yMzNlOTQxMy5qcyc7aW1wb3J0Jy4uL3RleHQvZGVmYXVsdHMuanMnO2ltcG9ydCBUZXh0RmllbGQgZnJvbScuLi90ZXh0L2luZGV4LmpzJztpbXBvcnQgZGVmYXVsdHMgZnJvbScuL2RlZmF1bHRzLmpzJztpbXBvcnQge2EgYXMgdGVtcGxhdGUsYiBhcyB0ZW1wbGF0ZXN9ZnJvbScuL3RlbXBsYXRlLTY1ZmVkYTA1LmpzJzt2YXIgVGV4dGFyZWFGaWVsZDtcblxuVGV4dGFyZWFGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgY2xhc3MgVGV4dGFyZWFGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG5cbiAgICAgIGlmICh0aGlzLl92YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhdGUuaGVpZ2h0ID0gdGhpcy5zZXR0aW5ncy5hdXRvSGVpZ2h0ID8gJ2F1dG8nIDogdGhpcy5zZXR0aW5ncy5oZWlnaHQ7XG4gICAgICB0aGlzLnN0YXRlLnR5cGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5jdXJzb3IgPSB7XG4gICAgICAgIHByZXY6IDAsXG4gICAgICAgIGN1cnJlbnQ6IDBcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnRzKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzKCk7XG5cbiAgICAgIHRoaXMuX2NvbnN0cnVjdG9yRW5kKCk7XG4gICAgfVxuXG4gICAgX2dldFZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cblxuICAgIF9zZXRWYWx1ZShuZXdWYWx1ZSkge1xuICAgICAgaWYgKElTLnN0cmluZyhuZXdWYWx1ZSkgfHwgSVMubnVtYmVyKG5ld1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSBTdHJpbmcobmV3VmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9yZWNhbGNEaXNwbGF5KCkge1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYXV0b0hlaWdodCB8fCB0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB0aGlzLl92YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfY3JlYXRlRWxlbWVudHMoKSB7XG4gICAgICB2YXIgZm9yY2VPcHRzO1xuICAgICAgZm9yY2VPcHRzID0ge1xuICAgICAgICByZWxhdGVkSW5zdGFuY2U6IHRoaXNcbiAgICAgIH07XG4gICAgICB0aGlzLmVsID0gdGhpcy50ZW1wbGF0ZS5zcGF3bih0aGlzLnNldHRpbmdzLnRlbXBsYXRlcy5kZWZhdWx0cywgZm9yY2VPcHRzKTtcbiAgICAgIHRoaXMuZWwuc3RhdGUoJ2hhc0xhYmVsJywgdGhpcy5zZXR0aW5ncy5sYWJlbCk7XG4gICAgICB0aGlzLmVsLmNoaWxkLmlubmVyd3JhcC5yYXcuX3F1aWNrRmllbGQgPSB0aGlzLmVsLmNoaWxkLmlucHV0LnJhdy5fcXVpY2tGaWVsZCA9IHRoaXM7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzKCkge1xuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfZWxTdGF0ZSgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19kaXNwbGF5KCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX2Rpc3BsYXlfYXV0b1dpZHRoKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX2Rpc3BsYXlfYXV0b0hlaWdodCgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc192YWx1ZSgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19hdXRvY29tcGxldGUoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3Nfc3RhdGVUcmlnZ2VycygpO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc19kaXNwbGF5X2F1dG9IZWlnaHQoKSB7XG4gICAgICBTaW1wbHlCaW5kKCdoZWlnaHQnLCB7XG4gICAgICAgIHVwZGF0ZUV2ZW5JZlNhbWU6IHRydWVcbiAgICAgIH0pLm9mKHRoaXMuc3RhdGUpLnRyYW5zZm9ybVNlbGYoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkgJiYgaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpKSB7XG4gICAgICAgICAgcmV0dXJuICdhdXRvJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pLnRvKGhlaWdodCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmNoaWxkLmlubmVyd3JhcC5zdHlsZSgnaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICAgIH0pLnVwZGF0ZU9uKCdldmVudDppbnNlcnRlZCcpLm9mKHRoaXMpO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5hdXRvSGVpZ2h0KSB7XG4gICAgICAgIFNpbXBseUJpbmQoJ192YWx1ZScsIHtcbiAgICAgICAgICB1cGRhdGVFdmVuSWZTYW1lOiB0cnVlLFxuICAgICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICAgICAgfSkub2YodGhpcykudG8oJ2hlaWdodCcpLm9mKHRoaXMuc3RhdGUpLnRyYW5zZm9ybSgoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dldElucHV0QXV0b0hlaWdodCgpO1xuICAgICAgICB9KS51cGRhdGVPbignZXZlbnQ6aW5zZXJ0ZWQnKS5vZih0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3NfZGlzcGxheV9hdXRvV2lkdGgoKSB7XG4gICAgICBTaW1wbHlCaW5kKCd3aWR0aCcsIHtcbiAgICAgICAgdXBkYXRlRXZlbklmU2FtZTogdHJ1ZVxuICAgICAgfSkub2YodGhpcy5zdGF0ZSkudG8od2lkdGggPT4ge1xuICAgICAgICByZXR1cm4gKHRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoID8gdGhpcy5lbC5jaGlsZC5pbm5lcndyYXAgOiB0aGlzLmVsKS5zdHlsZSgnd2lkdGgnLCB3aWR0aCk7XG4gICAgICB9KS50cmFuc2Zvcm0odGhpcy5fZm9ybWF0V2lkdGguYmluZCh0aGlzKSkudXBkYXRlT24oJ2lzTW9iaWxlJykub2YodGhpcy5zdGF0ZSk7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCkge1xuICAgICAgICBTaW1wbHlCaW5kKCdfdmFsdWUnLCB7XG4gICAgICAgICAgdXBkYXRlRXZlbklmU2FtZTogdHJ1ZSxcbiAgICAgICAgICB1cGRhdGVPbkJpbmQ6IGZhbHNlXG4gICAgICAgIH0pLm9mKHRoaXMpLnRvKCd3aWR0aCcpLm9mKHRoaXMuc3RhdGUpLnRyYW5zZm9ybSgoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dldElucHV0QXV0b1dpZHRoKCk7XG4gICAgICAgIH0pLnVwZGF0ZU9uKCdldmVudDppbnNlcnRlZCcpLm9mKHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc192YWx1ZSgpIHtcbiAgICAgIHZhciBpbnB1dDtcbiAgICAgIGlucHV0ID0gdGhpcy5lbC5jaGlsZC5pbnB1dC5yYXc7XG4gICAgICBTaW1wbHlCaW5kKCdldmVudDppbnB1dCcpLm9mKGlucHV0KS50bygoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID0gaW5wdXQudmFsdWU7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ192YWx1ZScpLm9mKHRoaXMpLnRvKCd2YWx1ZScpLm9mKGlucHV0KS5hbmQudG8odmFsdWUgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlLmZpbGxlZCA9ICEhdmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5pbnRlcmFjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUudmFsaWQgPSB0aGlzLnZhbGlkYXRlKHZvaWQgMCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2lucHV0JywgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX2F1dG9jb21wbGV0ZSgpIHt9XG5cbiAgICBfZ2V0SW5wdXRBdXRvSGVpZ2h0KCkge1xuICAgICAgdmFyIGlucHV0SGVpZ2h0LCBwcmV2SGVpZ2h0O1xuICAgICAgcHJldkhlaWdodCA9IHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LnN0eWxlLmhlaWdodDtcblxuICAgICAgaWYgKHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3NldFZhbHVlSWZOb3RTZXQoKTtcblxuICAgICAgICB0aGlzLmVsLmNoaWxkLmlucHV0LnN0eWxlKCdoZWlnaHQnLCAwKTtcbiAgICAgICAgaW5wdXRIZWlnaHQgPSB0aGlzLmVsLmNoaWxkLmlucHV0LnJhdy5zY3JvbGxIZWlnaHQgKyAyO1xuICAgICAgICBpbnB1dEhlaWdodCArPSB0aGlzLmVsLmNoaWxkLmlucHV0LnN0eWxlUGFyc2VkKCdtYXJnaW5Ub3AnKSArIHRoaXMuZWwuY2hpbGQuaW5wdXQuc3R5bGVQYXJzZWQoJ21hcmdpbkJvdHRvbScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRIZWlnaHQgPSB0aGlzLmVsLmNoaWxkLnBsYWNlaG9sZGVyLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbC5jaGlsZC5pbnB1dC5zdHlsZSgnaGVpZ2h0JywgcHJldkhlaWdodCk7XG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5zZXR0aW5ncy5tYXhIZWlnaHQsIE1hdGgubWF4KGlucHV0SGVpZ2h0LCB0aGlzLnNldHRpbmdzLm1pbkhlaWdodCkpO1xuICAgIH1cblxuICAgIF9nZXRJbnB1dEF1dG9XaWR0aCgpIHtcbiAgICAgIHZhciBpbnB1dFBhZGRpbmcsIGlucHV0V2lkdGgsIGxhYmVsV2lkdGg7XG5cbiAgICAgIGlmICh0aGlzLl92YWx1ZSkge1xuICAgICAgICB0aGlzLl9zZXRWYWx1ZUlmTm90U2V0KCk7XG5cbiAgICAgICAgdGhpcy5lbC5jaGlsZC5pbnB1dC5zdHlsZSh7XG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgd2hpdGVTcGFjZTogJ25vd3JhcCdcbiAgICAgICAgfSkucmF3LnNjcm9sbExlZnQgPSAxZSsxMDtcbiAgICAgICAgaW5wdXRQYWRkaW5nID0gdGhpcy5lbC5jaGlsZC5pbnB1dC5zdHlsZVBhcnNlZCgncGFkZGluZ0xlZnQnKSB8fCB0aGlzLmVsLmNoaWxkLmlucHV0LnN0eWxlUGFyc2VkKCdwYWRkaW5nJyk7XG4gICAgICAgIGlucHV0V2lkdGggPSBNYXRoLm1heCh0aGlzLmVsLmNoaWxkLmlucHV0LnJhdy5zY3JvbGxMZWZ0ICsgdGhpcy5lbC5jaGlsZC5pbnB1dC5yYXcub2Zmc2V0V2lkdGgsIHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LnNjcm9sbFdpZHRoKSArIDIgKyBpbnB1dFBhZGRpbmcgKyAxO1xuICAgICAgICBsYWJlbFdpZHRoID0gdGhpcy5zZXR0aW5ncy5sYWJlbCAmJiB0aGlzLmVsLmNoaWxkLmxhYmVsLnN0eWxlU2FmZSgncG9zaXRpb24nKSA9PT0gJ2Fic29sdXRlJyA/IHRoaXMuZWwuY2hpbGQubGFiZWwucmVjdC53aWR0aCA6IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dFdpZHRoID0gdGhpcy5lbC5jaGlsZC5wbGFjZWhvbGRlci5yZWN0LndpZHRoO1xuICAgICAgICBsYWJlbFdpZHRoID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbC5jaGlsZC5pbnB1dC5zdHlsZSh7XG4gICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgIHdoaXRlU3BhY2U6ICdub3JtYWwnXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLl9nZXRXaWR0aFNldHRpbmcoJ21heCcpLCBNYXRoLm1heCh0aGlzLl9nZXRXaWR0aFNldHRpbmcoJ21pbicpLCBpbnB1dFdpZHRoLCBsYWJlbFdpZHRoKSk7XG4gICAgfVxuXG4gIH1cbiAgVGV4dGFyZWFGaWVsZC5wcm90b3R5cGUudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgVGV4dGFyZWFGaWVsZC5wcm90b3R5cGUudGVtcGxhdGVzID0gdGVtcGxhdGVzO1xuICBUZXh0YXJlYUZpZWxkLnByb3RvdHlwZS5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICBpbmhlcml0UHJvdG8oVGV4dGFyZWFGaWVsZCwgVGV4dEZpZWxkKTtcbiAgcmV0dXJuIFRleHRhcmVhRmllbGQ7XG59LmNhbGwodW5kZWZpbmVkKTtcblxudmFyIFRleHRhcmVhRmllbGQkMSA9IFRleHRhcmVhRmllbGQ7ZXhwb3J0IGRlZmF1bHQgVGV4dGFyZWFGaWVsZCQxOyIsInZhciBkZWZhdWx0cyA9IHtcbiAgcGxhY2Vob2xkZXI6IHRydWUsXG4gIHZhbGlkV2hlbk1pbjogZmFsc2UsXG4gIHZhbGlkV2hlbk1heDogZmFsc2UsXG4gIGF1dG9XaWR0aDogZmFsc2UsXG4gIG1heFdpZHRoOiAnMTAwJScsXG4gIGhlaWdodDogNDYsXG4gIGJ1dHRvbnM6IHRydWUsXG4gIG1pblZhbHVlOiAtMmUzMDgsXG4gIG1heFZhbHVlOiAyZTMwOCxcbiAgc3RlcDogMSxcbiAgZW5mb3JjZTogZmFsc2UsXG4gIGlucHV0U2libGluZzogJ2J1dHRvbnMnXG59O2V4cG9ydCBkZWZhdWx0IGRlZmF1bHRzOyIsImltcG9ydCBET00gZnJvbSdxdWlja2RvbSc7aW1wb3J0Jy4uLy4uL3N2Zy9jaGVja21hcmsuanMnO2ltcG9ydCcuLi8uLi9zdmcvYW5nbGVEb3duLmpzJztpbXBvcnQgY2FyZXRVcCBmcm9tJy4uLy4uL3N2Zy9jYXJldFVwLmpzJztpbXBvcnQgY2FyZXREb3duIGZyb20nLi4vLi4vc3ZnL2NhcmV0RG93bi5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9wbHVzLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2Nsb25lLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3JlbW92ZS5qcyc7aW1wb3J0IENPTE9SUyBmcm9tJy4uLy4uL2NvbnN0YW50cy9jb2xvcnMuanMnO2ltcG9ydCB7YSBhcyB0ZXh0RmllbGRUZW1wbGF0ZX1mcm9tJy4uL3RleHQvdGVtcGxhdGUtMjMzZTk0MTMuanMnO3ZhciB0ZW1wbGF0ZSA9IHRleHRGaWVsZFRlbXBsYXRlLmV4dGVuZCgpO1xudmFyIHN0ZXBCdXR0b24gPSBET00udGVtcGxhdGUoWydkaXYnLCB7XG4gIHN0YXRlVHJpZ2dlcnM6IHtcbiAgICAnYWN0aXZlJzoge1xuICAgICAgb246ICdtb3VzZWRvd24nLFxuICAgICAgb2ZmOiAnbW91c2V1cCcsXG4gICAgICBidWJibGVzOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgYXR0cnM6IHtcbiAgICB0YWJpbmRleDogLTFcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogMTcsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgb3V0bGluZTogJ25vbmUnLFxuICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgIGZpbGw6IENPTE9SUy5ncmV5LFxuICAgICRhY3RpdmU6IHtcbiAgICAgIGZpbGw6IENPTE9SUy5ncmV5X2RhcmtcbiAgICB9XG4gIH1cbn1dKTtcbnZhciBidXR0b25zID0gRE9NLnRlbXBsYXRlKFsnZGl2Jywge1xuICByZWY6ICdidXR0b25zJyxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB6SW5kZXg6IDMsXG4gICAgdG9wOiAnNTAlJyxcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC01MCUpJyxcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICB3aWR0aDogMTcsXG4gICAgcGFkZGluZ1JpZ2h0OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5pbnB1dFBhZGRpbmc7XG4gICAgfSxcbiAgICBvdXRsaW5lOiAnbm9uZSdcbiAgfVxufSwgc3RlcEJ1dHRvbi5leHRlbmQoe1xuICBjaGlsZHJlbjogW2NhcmV0VXBdLFxuICBvcHRpb25zOiB7XG4gICAgcmVmOiAnc3RlcFVwJ1xuICB9XG59KSwgc3RlcEJ1dHRvbi5leHRlbmQoe1xuICBjaGlsZHJlbjogW2NhcmV0RG93bl0sXG4gIG9wdGlvbnM6IHtcbiAgICByZWY6ICdzdGVwRG93bidcbiAgfVxufSldKTt2YXIgdGVtcGxhdGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe2RlZmF1bHQ6IHRlbXBsYXRlLHN0ZXBCdXR0b246IHN0ZXBCdXR0b24sYnV0dG9uczogYnV0dG9uc30pO2V4cG9ydHt0ZW1wbGF0ZSBhcyBhLHRlbXBsYXRlcyBhcyBiLGJ1dHRvbnMgYXMgYyxzdGVwQnV0dG9uIGFzIGR9OyIsImltcG9ydCdAZGFuaWVsa2FsZW4vaXMnO2ltcG9ydCcuLi8uLi9jaGVja3MuanMnO2ltcG9ydCdxdWlja2RvbSc7aW1wb3J0IFNpbXBseUJpbmQgZnJvbSdAZGFuaWVsa2FsZW4vc2ltcGx5YmluZCc7aW1wb3J0Jy4uLy4uL2NvbnN0YW50cy9yZWdleC5qcyc7aW1wb3J0IHtpbmhlcml0UHJvdG99ZnJvbScuLi8uLi9oZWxwZXJzLmpzJztpbXBvcnQgZXh0ZW5kIGZyb20nc21hcnQtZXh0ZW5kJztpbXBvcnQnZmFzdGRvbSc7aW1wb3J0Jy4uLy4uL2NvbXBvbmVudHMvY29uZGl0aW9uLmpzJztpbXBvcnQnLi4vLi4vZmllbGQvdHJhbnNmb3JtU2V0dGluZ3MuanMnO2ltcG9ydCcuLi8uLi9maWVsZC9nbG9iYWxEZWZhdWx0cy5qcyc7aW1wb3J0IEZpZWxkIGZyb20nLi4vLi4vZmllbGQvaW5kZXguanMnO2ltcG9ydCBLRVlDT0RFUyBmcm9tJy4uLy4uL2NvbnN0YW50cy9rZXlDb2Rlcy5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jaGVja21hcmsuanMnO2ltcG9ydCcuLi8uLi9zdmcvYW5nbGVEb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NhcmV0VXAuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2FyZXREb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3BsdXMuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2xvbmUuanMnO2ltcG9ydCcuLi8uLi9zdmcvcmVtb3ZlLmpzJztpbXBvcnQnLi4vLi4vY29tcG9uZW50cy9kcm9wZG93bi90ZW1wbGF0ZS1iOTYxZjgxZi5qcyc7aW1wb3J0Jy4uLy4uL2NvbXBvbmVudHMvZHJvcGRvd24vZGVmYXVsdHMuanMnO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL2Ryb3Bkb3duL2luZGV4LmpzJztpbXBvcnQndGV4dC1tYXNrLWNvcmUnO2ltcG9ydCd0ZXh0LW1hc2stYWRkb25zJztpbXBvcnQnLi4vLi4vY29tcG9uZW50cy9tYXNrLmpzJztpbXBvcnQnLi4vLi4vY29uc3RhbnRzL2NvbG9ycy5qcyc7aW1wb3J0Jy4uL3RleHQvdGVtcGxhdGUtMjMzZTk0MTMuanMnO2ltcG9ydCcuLi90ZXh0L2RlZmF1bHRzLmpzJztpbXBvcnQgVGV4dEZpZWxkIGZyb20nLi4vdGV4dC9pbmRleC5qcyc7aW1wb3J0IGRlZmF1bHRzIGZyb20nLi9kZWZhdWx0cy5qcyc7aW1wb3J0IHthIGFzIHRlbXBsYXRlLGIgYXMgdGVtcGxhdGVzLGMgYXMgYnV0dG9uc31mcm9tJy4vdGVtcGxhdGUtYzkyMmUxNjMuanMnO3ZhciBOdW1iZXJGaWVsZDtcblxuTnVtYmVyRmllbGQgPSBmdW5jdGlvbiAoKSB7XG4gIGNsYXNzIE51bWJlckZpZWxkIGV4dGVuZHMgRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgdmFyIHJlZjtcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG5cbiAgICAgIGlmICh0aGlzLl92YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmVuZm9yY2UgJiYgdGhpcy5zZXR0aW5ncy5taW5WYWx1ZSAmJiB0aGlzLnNldHRpbmdzLm1pblZhbHVlICE9PSAtMmUzMDgpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgfHwgKHRoaXMuX3ZhbHVlID0gdGhpcy5zZXR0aW5ncy5taW5WYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0dGluZ3Muc3RlcCA9IE51bWJlcih0aGlzLnNldHRpbmdzLnN0ZXApIHx8IDE7XG4gICAgICB0aGlzLnN0YXRlLnR5cGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5jdXJzb3IgPSB7XG4gICAgICAgIHByZXY6IDAsXG4gICAgICAgIGN1cnJlbnQ6IDBcbiAgICAgIH07XG4gICAgICB0aGlzLnByZWNpc2lvbiA9ICgocmVmID0gdGhpcy5zZXR0aW5ncy5zdGVwLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVsxXSkgIT0gbnVsbCA/IHJlZi5sZW5ndGggOiB2b2lkIDApIHx8IDA7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnRzKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzKCk7XG5cbiAgICAgIHRoaXMuX2NvbnN0cnVjdG9yRW5kKCk7XG4gICAgfVxuXG4gICAgX2dldFZhbHVlKCkge1xuICAgICAgcmV0dXJuIE51bWJlcih0aGlzLl92YWx1ZSkgfHwgMDtcbiAgICB9XG5cbiAgICBfc2V0VmFsdWUobmV3VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZSA9IHRoaXMuX25vcm1hbGl6ZVZhbHVlKG5ld1ZhbHVlLCB0aGlzLnNldHRpbmdzLmVuZm9yY2UpO1xuICAgIH1cblxuICAgIF9jcmVhdGVFbGVtZW50cygpIHtcbiAgICAgIHZhciBnbG9iYWxPcHRzO1xuICAgICAgZ2xvYmFsT3B0cyA9IHtcbiAgICAgICAgcmVsYXRlZEluc3RhbmNlOiB0aGlzXG4gICAgICB9O1xuICAgICAgdGhpcy5lbCA9IHRoaXMudGVtcGxhdGUuc3Bhd24odGhpcy5zZXR0aW5ncy50ZW1wbGF0ZXMuZGVmYXVsdHMsIGdsb2JhbE9wdHMpO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5idXR0b25zKSB7XG4gICAgICAgIGJ1dHRvbnMuc3Bhd24odGhpcy5zZXR0aW5ncy50ZW1wbGF0ZXMuYnV0dG9ucywgZ2xvYmFsT3B0cykuaW5zZXJ0QWZ0ZXIodGhpcy5lbC5jaGlsZC5pbnB1dCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWwuc3RhdGUoJ2hhc0xhYmVsJywgdGhpcy5zZXR0aW5ncy5sYWJlbCk7XG4gICAgICB0aGlzLmVsLmNoaWxkLmlubmVyd3JhcC5yYXcuX3F1aWNrRmllbGQgPSB0aGlzLmVsLmNoaWxkZi5pbnB1dC5yYXcuX3F1aWNrRmllbGQgPSB0aGlzO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5ncygpIHtcbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX2VsU3RhdGUoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfZGlzcGxheSgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19kaXNwbGF5X2F1dG9XaWR0aCgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc192YWx1ZSgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19zdGF0ZVRyaWdnZXJzKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX3N0ZXBFdmVudHMoKTtcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3NfdmFsdWUoKSB7XG4gICAgICB2YXIgaW5wdXQ7XG4gICAgICBpbnB1dCA9IHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3O1xuICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6aW5wdXQnKS5vZihpbnB1dCkudG8oKCkgPT4ge1xuICAgICAgICB2YXIgbmV3VmFsdWUsIHNlbGVjdE51bWJlclBhcnQ7XG4gICAgICAgIHRoaXMuY3Vyc29yLnByZXYgPSB0aGlzLmN1cnNvci5jdXJyZW50O1xuICAgICAgICB0aGlzLmN1cnNvci5jdXJyZW50ID0gdGhpcy5zZWxlY3Rpb24oKS5lbmQ7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5wdXQudmFsdWU7XG5cbiAgICAgICAgaWYgKG5ld1ZhbHVlW25ld1ZhbHVlLmxlbmd0aCAtIDFdID09PSAnLScpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5taW5WYWx1ZSA+IC0xKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IC0xO1xuICAgICAgICAgICAgc2VsZWN0TnVtYmVyUGFydCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0VmFsdWUobmV3VmFsdWUpO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmZvY3VzZWQpIHtcbiAgICAgICAgICBpZiAoc2VsZWN0TnVtYmVyUGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uKDEsIDIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24odGhpcy5jdXJzb3IuY3VycmVudCwgdGhpcy5jdXJzb3IuY3VycmVudCArIChTdHJpbmcodGhpcy5fdmFsdWUpLmxlbmd0aCAtIG5ld1ZhbHVlLmxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdfdmFsdWUnKS5vZih0aGlzKS50bygndmFsdWUnKS5vZihpbnB1dCkuYW5kLnRvKHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsZWQgPSAhIVN0cmluZyh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmludGVyYWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZS52YWxpZCA9IHRoaXMudmFsaWRhdGUodm9pZCAwLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnaW5wdXQnLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2V2ZW50OmJsdXInKS5vZihpbnB1dCkudG8oKCkgPT4ge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmVuZm9yY2UpIHtcbiAgICAgICAgICB2YWx1ZSA9IE51bWJlcih0aGlzLl92YWx1ZSkgfHwgMDtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMCB8fCAhdGhpcy5zdGF0ZS5pbnRlcmFjdGVkICYmIHZhbHVlID09PSB0aGlzLnNldHRpbmdzLm1pblZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6a2V5ZG93bicpLm9mKHRoaXMuZWwuY2hpbGQuaW5wdXQpLnRvKGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWUNPREVTLmVudGVyKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdzdWJtaXQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoYGtleS0ke2V2ZW50LmtleUNvZGV9YCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3Nfc3RlcEV2ZW50cygpIHtcbiAgICAgIHZhciBzdG9wUHJvcGFnYXRpb247XG4gICAgICBTaW1wbHlCaW5kKCdldmVudDprZXlkb3duJykub2YodGhpcy5lbC5jaGlsZC5pbnB1dCkudG8oZXZlbnQgPT4ge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICBjYXNlIEtFWUNPREVTLnVwOlxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ZXBVcCgpO1xuXG4gICAgICAgICAgY2FzZSBLRVlDT0RFUy5kb3duOlxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ZXBEb3duKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5idXR0b25zKSB7XG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNpbXBseUJpbmQoJ2V2ZW50OmNsaWNrJykub2YodGhpcy5lbC5jaGlsZC5zdGVwVXApLnRvKHRoaXMuc3RlcFVwLmJpbmQodGhpcykpLmFuZC50byhzdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICBTaW1wbHlCaW5kKCdldmVudDpjbGljaycpLm9mKHRoaXMuZWwuY2hpbGQuc3RlcERvd24pLnRvKHRoaXMuc3RlcERvd24uYmluZCh0aGlzKSkuYW5kLnRvKHN0b3BQcm9wYWdhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3NldFZhbHVlSWZOb3RTZXQoKSB7XG4gICAgICBpZiAoTnVtYmVyKHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKSAhPT0gdGhpcy5fdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlID0gdGhpcy5fdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX25vcm1hbGl6ZVZhbHVlKHZhbHVlLCBlbmZvcmNlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlID8gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMCA6IDA7XG5cbiAgICAgIGlmICh2YWx1ZSAlIHRoaXMuc2V0dGluZ3Muc3RlcCAmJiBlbmZvcmNlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IHRoaXMuc2V0dGluZ3Muc3RlcCkge1xuICAgICAgICAgIHZhbHVlID0gdGhpcy5zZXR0aW5ncy5zdGVwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gdGhpcy5fcm91bmRUb05lYXJlc3QodmFsdWUsIHRoaXMuc2V0dGluZ3Muc3RlcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlIDwgdGhpcy5zZXR0aW5ncy5taW5WYWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuc2V0dGluZ3MubWluVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSA+IHRoaXMuc2V0dGluZ3MubWF4VmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnNldHRpbmdzLm1heFZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgX3JvdW5kVG9OZWFyZXN0KHZhbHVlLCB0YXJnZXQpIHtcbiAgICAgIHZhciBtdWx0aXBsaWVyO1xuICAgICAgdmFsdWUgPSAodmFsdWUgfHwgMCkudG9GaXhlZCh0aGlzLnByZWNpc2lvbikgKiAxO1xuICAgICAgbXVsdGlwbGllciA9IHRhcmdldCA8IDEgPyAxIC8gdGFyZ2V0IDogMTtcbiAgICAgIHRhcmdldCAqPSBtdWx0aXBsaWVyO1xuICAgICAgdmFsdWUgKj0gbXVsdGlwbGllcjtcbiAgICAgIHZhbHVlID0gTWF0aC5jZWlsKHZhbHVlIC8gdGFyZ2V0KSAqIHRhcmdldCAvIG11bHRpcGxpZXI7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgc3RlcFVwKCkge1xuICAgICAgdmFyIG5ld1ZhbHVlLCByb3VuZGVkO1xuICAgICAgcm91bmRlZCA9IHRoaXMuX3JvdW5kVG9OZWFyZXN0KHRoaXMuX3ZhbHVlLCB0aGlzLnNldHRpbmdzLnN0ZXApO1xuICAgICAgbmV3VmFsdWUgPSBNYXRoLm1pbihyb3VuZGVkICsgdGhpcy5zZXR0aW5ncy5zdGVwLCB0aGlzLl92YWx1ZSArIHRoaXMuc2V0dGluZ3Muc3RlcCk7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0VmFsdWUodGhpcy5fcm91bmRUb05lYXJlc3QobmV3VmFsdWUsIHRoaXMuc2V0dGluZ3Muc3RlcCkpO1xuICAgIH1cblxuICAgIHN0ZXBEb3duKCkge1xuICAgICAgdmFyIG5ld1ZhbHVlLCByb3VuZGVkO1xuICAgICAgcm91bmRlZCA9IHRoaXMuX3JvdW5kVG9OZWFyZXN0KHRoaXMuX3ZhbHVlLCB0aGlzLnNldHRpbmdzLnN0ZXApO1xuICAgICAgbmV3VmFsdWUgPSBNYXRoLm1heChyb3VuZGVkIC0gdGhpcy5zZXR0aW5ncy5zdGVwLCB0aGlzLl92YWx1ZSAtIHRoaXMuc2V0dGluZ3Muc3RlcCk7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0VmFsdWUodGhpcy5fcm91bmRUb05lYXJlc3QobmV3VmFsdWUsIHRoaXMuc2V0dGluZ3Muc3RlcCkpO1xuICAgIH1cblxuICB9XG4gIE51bWJlckZpZWxkLnByb3RvdHlwZS50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICBOdW1iZXJGaWVsZC5wcm90b3R5cGUudGVtcGxhdGVzID0gdGVtcGxhdGVzO1xuICBOdW1iZXJGaWVsZC5wcm90b3R5cGUuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgaW5oZXJpdFByb3RvKE51bWJlckZpZWxkLCBUZXh0RmllbGQpO1xuICByZXR1cm4gTnVtYmVyRmllbGQ7XG59LmNhbGwodW5kZWZpbmVkKTtcblxuZXh0ZW5kLm5vdEtleXMoTnVtYmVyRmllbGQucHJvdG90eXBlKShOdW1iZXJGaWVsZC5wcm90b3R5cGUsIFRleHRGaWVsZC5wcm90b3R5cGUpO1xudmFyIE51bWJlckZpZWxkJDEgPSBOdW1iZXJGaWVsZDtleHBvcnQgZGVmYXVsdCBOdW1iZXJGaWVsZCQxOyIsInZhciBkZWZhdWx0cyA9IHtcbiAgcGxhY2Vob2xkZXI6IHRydWUsXG4gIHZhbGlkV2hlbklzQ2hvaWNlOiBmYWxzZSxcbiAgdmFsaWRXaGVuUmVnZXg6IGZhbHNlLFxuICB2YWxpZFdoZW5DaG9zZU1pbjogMmUzMDgsXG4gIGF1dG9XaWR0aDogZmFsc2UsXG4gIG1heFdpZHRoOiAnMTAwJScsXG4gIGhlaWdodDogNDYsXG4gIGxhYmVsRmlsdGVyOiBudWxsLFxuICBjaG9pY2VzOiBbXSxcbiAgbXVsdGlwbGU6IGZhbHNlLFxuICBkcm9wZG93bjoge1xuICAgIHR5cGVCdWZmZXI6IHRydWVcbiAgfSxcbiAgaW5wdXRTaWJsaW5nOiAnY2FyZXQnXG59O2V4cG9ydCBkZWZhdWx0IGRlZmF1bHRzOyIsImltcG9ydCdxdWlja2RvbSc7aW1wb3J0Jy4uLy4uL3N2Zy9jaGVja21hcmsuanMnO2ltcG9ydCcuLi8uLi9zdmcvYW5nbGVEb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NhcmV0VXAuanMnO2ltcG9ydCBjYXJldERvd24gZnJvbScuLi8uLi9zdmcvY2FyZXREb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3BsdXMuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2xvbmUuanMnO2ltcG9ydCcuLi8uLi9zdmcvcmVtb3ZlLmpzJztpbXBvcnQgQ09MT1JTIGZyb20nLi4vLi4vY29uc3RhbnRzL2NvbG9ycy5qcyc7aW1wb3J0IHthIGFzIHRleHRGaWVsZFRlbXBsYXRlfWZyb20nLi4vdGV4dC90ZW1wbGF0ZS0yMzNlOTQxMy5qcyc7dmFyIHRlbXBsYXRlID0gdGV4dEZpZWxkVGVtcGxhdGUuZXh0ZW5kKHtcbiAgY2hpbGRyZW46IHtcbiAgICBpbm5lcndyYXA6IHtcbiAgICAgIGNoaWxkcmVuOiB7XG4gICAgICAgICdpbnB1dCc6IFsnZGl2Jywge1xuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICB0YWJJbmRleDogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIG1hcmdpblRvcDogMyxcbiAgICAgICAgICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCcsXG4gICAgICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICAgICAgICAvLyBvdmVyZmxvdzogJ3Njcm9sbCdcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICAgICAgICAgIH1cbiAgICAgICAgfV0sXG4gICAgICAgICdjYXJldCc6IFsnZGl2Jywge1xuICAgICAgICAgIHJlZjogJ2NhcmV0JyxcbiAgICAgICAgICBzdHlsZUFmdGVySW5zZXJ0OiB0cnVlLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgIHpJbmRleDogMyxcbiAgICAgICAgICAgIHRvcDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5zdHlsZVBhcnNlZCgnaGVpZ2h0JywgdHJ1ZSkgLyAyIC0gdGhpcy5zdHlsZVBhcnNlZCgnaGVpZ2h0JykgLyAyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgd2lkdGg6IDE3LFxuICAgICAgICAgICAgaGVpZ2h0OiAxNyxcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5pbnB1dFBhZGRpbmc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICAgICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgICBmaWxsOiBDT0xPUlMuZ3JleVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgY2FyZXREb3duXVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7dmFyIHRlbXBsYXRlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtkZWZhdWx0OiB0ZW1wbGF0ZX0pO2V4cG9ydHt0ZW1wbGF0ZSBhcyBhLHRlbXBsYXRlcyBhcyBifTsiLCJpbXBvcnQnQGRhbmllbGthbGVuL2lzJztpbXBvcnQgSVMgZnJvbScuLi8uLi9jaGVja3MuanMnO2ltcG9ydCBET00gZnJvbSdxdWlja2RvbSc7aW1wb3J0IFNpbXBseUJpbmQgZnJvbSdAZGFuaWVsa2FsZW4vc2ltcGx5YmluZCc7aW1wb3J0Jy4uLy4uL2NvbnN0YW50cy9yZWdleC5qcyc7aW1wb3J0IHtpbmhlcml0UHJvdG8saW5jbHVkZXN9ZnJvbScuLi8uLi9oZWxwZXJzLmpzJztpbXBvcnQnc21hcnQtZXh0ZW5kJztpbXBvcnQnZmFzdGRvbSc7aW1wb3J0Jy4uLy4uL2NvbXBvbmVudHMvY29uZGl0aW9uLmpzJztpbXBvcnQnLi4vLi4vZmllbGQvdHJhbnNmb3JtU2V0dGluZ3MuanMnO2ltcG9ydCcuLi8uLi9maWVsZC9nbG9iYWxEZWZhdWx0cy5qcyc7aW1wb3J0IEZpZWxkIGZyb20nLi4vLi4vZmllbGQvaW5kZXguanMnO2ltcG9ydCcuLi8uLi9jb25zdGFudHMva2V5Q29kZXMuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2hlY2ttYXJrLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2FuZ2xlRG93bi5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jYXJldFVwLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NhcmV0RG93bi5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9wbHVzLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2Nsb25lLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3JlbW92ZS5qcyc7aW1wb3J0Jy4uLy4uL2NvbXBvbmVudHMvZHJvcGRvd24vdGVtcGxhdGUtYjk2MWY4MWYuanMnO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL2Ryb3Bkb3duL2RlZmF1bHRzLmpzJztpbXBvcnQgRHJvcGRvd24gZnJvbScuLi8uLi9jb21wb25lbnRzL2Ryb3Bkb3duL2luZGV4LmpzJztpbXBvcnQndGV4dC1tYXNrLWNvcmUnO2ltcG9ydCd0ZXh0LW1hc2stYWRkb25zJztpbXBvcnQnLi4vLi4vY29tcG9uZW50cy9tYXNrLmpzJztpbXBvcnQnLi4vLi4vY29uc3RhbnRzL2NvbG9ycy5qcyc7aW1wb3J0Jy4uL3RleHQvdGVtcGxhdGUtMjMzZTk0MTMuanMnO2ltcG9ydCcuLi90ZXh0L2RlZmF1bHRzLmpzJztpbXBvcnQgVGV4dEZpZWxkIGZyb20nLi4vdGV4dC9pbmRleC5qcyc7aW1wb3J0IGRlZmF1bHRzIGZyb20nLi9kZWZhdWx0cy5qcyc7aW1wb3J0IHthIGFzIHRlbXBsYXRlLGIgYXMgdGVtcGxhdGVzfWZyb20nLi90ZW1wbGF0ZS02YmJjZGRkMC5qcyc7dmFyIFNlbGVjdEZpZWxkO1xuXG5TZWxlY3RGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgY2xhc3MgU2VsZWN0RmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB2YXIgYmFzZTtcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICB0aGlzLnNldHRpbmdzLmRyb3Bkb3duLm11bHRpcGxlID0gdGhpcy5zZXR0aW5ncy5tdWx0aXBsZTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubXVsdGlwbGUpIHtcbiAgICAgICAgaWYgKChiYXNlID0gdGhpcy5zZXR0aW5ncy5kcm9wZG93bikuaGVscCA9PSBudWxsKSB7XG4gICAgICAgICAgYmFzZS5oZWxwID0gJ1RpcDogcHJlc3MgRVNDIHRvIGNsb3NlIHRoaXMgbWVudSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLnNldHRpbmdzLm11bHRpcGxlID8gW10gOiBudWxsO1xuICAgICAgdGhpcy5kcm9wZG93biA9IG5ldyBEcm9wZG93bih0aGlzLnNldHRpbmdzLmNob2ljZXMsIHRoaXMpO1xuXG4gICAgICB0aGlzLl9jcmVhdGVFbGVtZW50cygpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5ncygpO1xuXG4gICAgICB0aGlzLl9jb25zdHJ1Y3RvckVuZCgpO1xuICAgIH1cblxuICAgIF9nZXRWYWx1ZSgpIHtcbiAgICAgIHZhciByZWY7XG5cbiAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5tdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gKHJlZiA9IHRoaXMuX3ZhbHVlKSAhPSBudWxsID8gcmVmLnZhbHVlIDogdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlLm1hcChmdW5jdGlvbiAoY2hvaWNlKSB7XG4gICAgICAgICAgcmV0dXJuIGNob2ljZS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3NldFZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgICB2YXIgaSwgbGVuLCB2YWx1ZTtcblxuICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLm11bHRpcGxlIHx8ICFJUy5hcnJheShuZXdWYWx1ZSkpIHtcbiAgICAgICAgdGhpcy5zZXRDaG9pY2UobmV3VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbmV3VmFsdWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZSA9IG5ld1ZhbHVlW2ldO1xuICAgICAgICAgIHRoaXMuc2V0Q2hvaWNlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9yZWNhbGNEaXNwbGF5KCkge1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlTGFiZWwgPSB0aGlzLnZhbHVlTGFiZWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2NyZWF0ZUVsZW1lbnRzKCkge1xuICAgICAgdmFyIGZvcmNlT3B0cztcbiAgICAgIGZvcmNlT3B0cyA9IHtcbiAgICAgICAgcmVsYXRlZEluc3RhbmNlOiB0aGlzXG4gICAgICB9O1xuICAgICAgdGhpcy5lbCA9IHRoaXMudGVtcGxhdGUuc3Bhd24odGhpcy5zZXR0aW5ncy50ZW1wbGF0ZXMuZGVmYXVsdCwgZm9yY2VPcHRzKTtcbiAgICAgIHRoaXMuZHJvcGRvd24uYXBwZW5kVG8odGhpcy5lbC5jaGlsZC5pbm5lcndyYXApO1xuICAgICAgdGhpcy5lbC5jaGlsZC5wbGFjZWhvbGRlci5pbnNlcnRCZWZvcmUodGhpcy5lbC5jaGlsZC5pbnB1dCk7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmxhYmVsKSB7XG4gICAgICAgIHRoaXMuZWwuY2hpbGQubGFiZWwudGV4dCA9IHRoaXMuc2V0dGluZ3MubGFiZWw7XG4gICAgICAgIHRoaXMuZWwuc3RhdGUoJ2hhc0xhYmVsJywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWwuY2hpbGQuaW5uZXJ3cmFwLnJhdy5fcXVpY2tGaWVsZCA9IHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3Ll9xdWlja0ZpZWxkID0gdGhpcztcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3MoKSB7XG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19lbFN0YXRlKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX3ZhbHVlKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX2Rpc3BsYXkoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfZGlzcGxheV9hdXRvV2lkdGgoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfZHJvcGRvd24oKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3Nfc3RhdGVUcmlnZ2VycygpO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc19kaXNwbGF5X2F1dG9XaWR0aCgpIHtcbiAgICAgIFNpbXBseUJpbmQoJ3dpZHRoJywge1xuICAgICAgICB1cGRhdGVFdmVuSWZTYW1lOiB0cnVlXG4gICAgICB9KS5vZih0aGlzLnN0YXRlKS50byh3aWR0aCA9PiB7XG4gICAgICAgIHJldHVybiAodGhpcy5zZXR0aW5ncy5hdXRvV2lkdGggPyB0aGlzLmVsLmNoaWxkLmlucHV0IDogdGhpcy5lbCkuc3R5bGUoe1xuICAgICAgICAgIHdpZHRoXG4gICAgICAgIH0pO1xuICAgICAgfSkudHJhbnNmb3JtKHRoaXMuX2Zvcm1hdFdpZHRoLmJpbmQodGhpcykpLnVwZGF0ZU9uKCdpc01vYmlsZScpLm9mKHRoaXMuc3RhdGUpO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgpIHtcbiAgICAgICAgU2ltcGx5QmluZCgndmFsdWVMYWJlbCcsIHtcbiAgICAgICAgICB1cGRhdGVFdmVuSWZTYW1lOiB0cnVlLFxuICAgICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICAgICAgfSkub2YodGhpcykudG8oJ3dpZHRoJykub2YodGhpcy5zdGF0ZSkudHJhbnNmb3JtKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW5wdXRBdXRvV2lkdGgoKTtcbiAgICAgICAgfSkudXBkYXRlT24oJ2V2ZW50Omluc2VydGVkJykub2YodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2dldElucHV0QXV0b1dpZHRoKCkge1xuICAgICAgdmFyIGlucHV0V2lkdGgsIGxhYmVsV2lkdGg7XG5cbiAgICAgIGlmICh0aGlzLnZhbHVlTGFiZWwpIHtcbiAgICAgICAgdGhpcy5lbC5jaGlsZC5pbnB1dC5zdHlsZSgnd2lkdGgnLCAwKTtcbiAgICAgICAgaW5wdXRXaWR0aCA9IHRoaXMuZWwuY2hpbGQuaW5wdXQucmF3LnNjcm9sbFdpZHRoICsgMjtcbiAgICAgICAgbGFiZWxXaWR0aCA9IHRoaXMuZWwuY2hpbGQubGFiZWwuc3R5bGVTYWZlKCdwb3NpdGlvbicpID09PSAnYWJzb2x1dGUnID8gdGhpcy5lbC5jaGlsZC5sYWJlbC5yZWN0LndpZHRoIDogMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0V2lkdGggPSB0aGlzLmVsLmNoaWxkLnBsYWNlaG9sZGVyLnJlY3Qud2lkdGg7XG4gICAgICAgIGxhYmVsV2lkdGggPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTWF0aC5tYXgoaW5wdXRXaWR0aCwgbGFiZWxXaWR0aCk7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX3ZhbHVlKCkge1xuICAgICAgU2ltcGx5QmluZCgnYXJyYXk6X3ZhbHVlJykub2YodGhpcykudG8oc2VsZWN0ZWQgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlLmZpbGxlZCA9IHRoaXMuc2V0dGluZ3MubXVsdGlwbGUgPyAhIShzZWxlY3RlZCAhPSBudWxsID8gc2VsZWN0ZWQubGVuZ3RoIDogdm9pZCAwKSA6ICEhc2VsZWN0ZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZmlsbGVkKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5pbnRlcmFjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUudmFsaWQgPSB0aGlzLnZhbGlkYXRlKHZvaWQgMCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2lucHV0JywgdGhpcy52YWx1ZSk7XG4gICAgICB9KS5hbmQudG8oJ3ZhbHVlTGFiZWwnKS5vZih0aGlzKS50cmFuc2Zvcm0oc2VsZWN0ZWQgPT4ge1xuICAgICAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQubWFwKGZ1bmN0aW9uIChjaG9pY2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNob2ljZS5sYWJlbDtcbiAgICAgICAgICAgIH0pLmpvaW4oJywgJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZC5sYWJlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgndmFsdWVMYWJlbCcpLm9mKHRoaXMpLnRvKCd0ZXh0Jykub2YodGhpcy5lbC5jaGlsZC5pbnB1dCkudHJhbnNmb3JtKGxhYmVsID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubGFiZWxGb3JtYXQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5sYWJlbEZvcm1hdChsYWJlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3NfZHJvcGRvd24oKSB7XG4gICAgICBTaW1wbHlCaW5kKCdldmVudDpjbGljaycpLm9mKHRoaXMuZWwuY2hpbGQuaW5wdXQpLnRvKGV2ZW50ID0+IHtcbiAgICAgICAgdmFyIGVzY0xpc3RlbmVyO1xuXG4gICAgICAgIGlmICghKHRoaXMuc3RhdGUuZGlzYWJsZWQgfHwgdGhpcy5kcm9wZG93bi5jaG9pY2VzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICB0aGlzLmRyb3Bkb3duLmlzT3BlbiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICAgIERPTShkb2N1bWVudCkub24oJ2NsaWNrLmRyb3Bkb3duJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgaWYgKERPTShldmVudC50YXJnZXQpLnBhcmVudE1hdGNoaW5nKHBhcmVudCA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJlbnQgPT09IHRoaXMuZWwuY2hpbGQuaW5uZXJ3cmFwO1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wZG93bi5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICBlc2NMaXN0ZW5lciA9IFNpbXBseUJpbmQoJ2V2ZW50OmtleWRvd24nKS5vZihkb2N1bWVudCkub25jZS50bygoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wZG93bi5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICB9KS5jb25kaXRpb24oZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQua2V5Q29kZSA9PT0gMjc7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIFNpbXBseUJpbmQoJ2lzT3BlbicsIHtcbiAgICAgICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICAgICAgICB9KS5vZih0aGlzLmRyb3Bkb3duKS5vbmNlLnRvKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVzY0xpc3RlbmVyLnVuQmluZCgpO1xuICAgICAgICAgICAgcmV0dXJuIERPTShkb2N1bWVudCkub2ZmKCdjbGljay5kcm9wZG93bicpO1xuICAgICAgICAgIH0pLmNvbmRpdGlvbihmdW5jdGlvbiAoaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gIWlzT3BlbjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdldmVudDpjbGljaycpLm9mKHRoaXMuZWwuY2hpbGQuaW5uZXJ3cmFwKS50byhldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5jaGlsZC5pbnB1dC5lbWl0UHJpdmF0ZSgnY2xpY2snKTtcbiAgICAgIH0pLmNvbmRpdGlvbihldmVudCA9PiB7XG4gICAgICAgIHJldHVybiBldmVudC50YXJnZXQgPT09IHRoaXMuZWwuY2hpbGQuaW5uZXJ3cmFwLnJhdztcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZm9jdXNlZCcsIHtcbiAgICAgICAgdXBkYXRlT25CaW5kOiBmYWxzZVxuICAgICAgfSkub2YodGhpcy5zdGF0ZSkudG8oZm9jdXNlZCA9PiB7XG4gICAgICAgIHZhciB0cmlnZ2VyaW5nS2V5Y29kZXM7XG5cbiAgICAgICAgaWYgKCFmb2N1c2VkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2hpbGQuaW5wdXQub2ZmKCdrZXlkb3duLmRyb3Bkb3duVHJpZ2dlcicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyaWdnZXJpbmdLZXljb2RlcyA9IFszMiwgMzcsIDM4LCAzOSwgNDBdO1xuICAgICAgICAgIHJldHVybiB0aGlzLmVsLmNoaWxkLmlucHV0Lm9uKCdrZXlkb3duLmRyb3Bkb3duVHJpZ2dlcicsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHZhciByZWY7XG5cbiAgICAgICAgICAgIGlmIChpbmNsdWRlcyh0cmlnZ2VyaW5nS2V5Y29kZXMsIGV2ZW50LmtleUNvZGUpICYmICF0aGlzLmRyb3Bkb3duLmlzT3Blbikge1xuICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmlzT3BlbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgaWYgKChyZWYgPSB0aGlzLmRyb3Bkb3duLmxhc3RTZWxlY3RlZCkgIT0gbnVsbCA/IHJlZi5zZWxlY3RlZCA6IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uY3VycmVudEhpZ2hsaWdodGVkID0gdGhpcy5kcm9wZG93bi5sYXN0U2VsZWN0ZWQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gOSAmJiB0aGlzLmRyb3Bkb3duLmlzT3Blbikge1xuICAgICAgICAgICAgICAvLyBQcmV2ZW50IHRhYiBrZXlcbiAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5kcm9wZG93bi5vblNlbGVjdGVkKGNob2ljZSA9PiB7XG4gICAgICAgIGlmICghKGNob2ljZS5zZWxlY3RlZCAmJiAhdGhpcy5zZXR0aW5ncy5tdWx0aXBsZSkpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gY2hvaWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLm11bHRpcGxlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd24uaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc19zdGF0ZVRyaWdnZXJzKCkge1xuICAgICAgLy8jID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAvLyMgU3RhdGUgZXZlbnQgdHJpZ2dlcnNcbiAgICAgIC8vIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSBcbiAgICAgIFNpbXBseUJpbmQoJ2V2ZW50Om1vdXNlZW50ZXInKS5vZih0aGlzLmVsLmNoaWxkLmlucHV0KS50bygoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmhvdmVyZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdldmVudDptb3VzZWxlYXZlJykub2YodGhpcy5lbC5jaGlsZC5pbnB1dCkudG8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5ob3ZlcmVkID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2V2ZW50OmZvY3VzJykub2YodGhpcy5lbC5jaGlsZC5pbnB1dCkudG8oKCkgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlLmZvY3VzZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRpc2FibGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmx1cigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2V2ZW50OmJsdXInKS5vZih0aGlzLmVsLmNoaWxkLmlucHV0KS50bygoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF92YWxpZGF0ZShwcm92aWRlZFZhbHVlKSB7XG4gICAgICB2YXIgbWF0Y2hpbmdDaG9pY2UsIHJlZiwgcmVmMTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuUmVnZXggJiYgSVMucmVnZXgodGhpcy5zZXR0aW5ncy52YWxpZFdoZW5SZWdleCkpIHtcbiAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgIGNhc2UgIXRoaXMuc2V0dGluZ3MubXVsdGlwbGU6XG4gICAgICAgICAgICBpZiAoISgoKSA9PiB7XG4gICAgICAgICAgICAgIHZhciB2YWxpZENob2ljZXM7XG5cbiAgICAgICAgICAgICAgaWYgKHByb3ZpZGVkVmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFsaWRDaG9pY2VzID0gcHJvdmlkZWRWYWx1ZS5maWx0ZXIoY2hvaWNlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy52YWxpZFdoZW5SZWdleC50ZXN0KGNob2ljZSk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZhbGlkV2hlbkNob3NlTWluID09PSAyZTMwOCB8fCAhSVMubnVtYmVyKHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuQ2hvc2VNaW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkQ2hvaWNlcy5sZW5ndGggPT09IHByb3ZpZGVkVmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZENob2ljZXMubGVuZ3RoID49IHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuQ2hvc2VNaW47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MudmFsaWRXaGVuUmVnZXgudGVzdChwcm92aWRlZFZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy52YWxpZFdoZW5Jc0Nob2ljZSAmJiAoKHJlZiA9IHRoaXMuZHJvcGRvd24uY2hvaWNlcykgIT0gbnVsbCA/IHJlZi5sZW5ndGggOiB2b2lkIDApKSB7XG4gICAgICAgIG1hdGNoaW5nQ2hvaWNlID0gdGhpcy5kcm9wZG93bi5jaG9pY2VzLmZpbHRlcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbi52YWx1ZSA9PT0gcHJvdmlkZWRWYWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCEhIW1hdGNoaW5nQ2hvaWNlLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5tdWx0aXBsZSAmJiAtMSA+IChyZWYxID0gdGhpcy5zZXR0aW5ncy52YWxpZFdoZW5DaG9zZU1pbikgJiYgcmVmMSA8IDJlMzA4KSB7XG4gICAgICAgIGlmICghcHJvdmlkZWRWYWx1ZS5sZW5ndGggPj0gdGhpcy5zZXR0aW5ncy52YWxpZFdoZW5DaG9zZU1pbikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5tdWx0aXBsZSAmJiB0aGlzLnNldHRpbmdzLnJlcXVpcmVkKSB7XG4gICAgICAgIGlmICghcHJvdmlkZWRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgYWRkQ2hvaWNlKGNob2ljZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd24uYWRkQ2hvaWNlKGNob2ljZSk7XG4gICAgfVxuXG4gICAgc2V0Q2hvaWNlKGNob2ljZSkge1xuICAgICAgdmFyIG1hdGNoLCByZWY7XG5cbiAgICAgIGlmIChJUy5vYmplY3QoY2hvaWNlKSAmJiBjaG9pY2UgaW5zdGFuY2VvZiBEcm9wZG93bi5DaG9pY2UpIHtcbiAgICAgICAgcmV0dXJuIGNob2ljZS50b2dnbGUoKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPSB0aGlzLmRyb3Bkb3duLmZpbmRDaG9pY2VBbnkoY2hvaWNlKSkge1xuICAgICAgICByZXR1cm4gbWF0Y2gudG9nZ2xlKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLmFkZENob2ljZShjaG9pY2UpKSAhPSBudWxsID8gcmVmLnRvZ2dsZSh0cnVlKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuICBTZWxlY3RGaWVsZC5wcm90b3R5cGUudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgU2VsZWN0RmllbGQucHJvdG90eXBlLnRlbXBsYXRlcyA9IHRlbXBsYXRlcztcbiAgU2VsZWN0RmllbGQucHJvdG90eXBlLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIFNlbGVjdEZpZWxkLnByb3RvdHlwZS5jb3JlVmFsdWVQcm9wID0gJ3ZhbHVlJztcbiAgcmV0dXJuIFNlbGVjdEZpZWxkO1xufS5jYWxsKHVuZGVmaW5lZCk7XG5cbmluaGVyaXRQcm90byhTZWxlY3RGaWVsZCwgVGV4dEZpZWxkLCBbJ19nZXRNYXhXaWR0aCcsICdfYXR0YWNoQmluZGluZ3NfZWxTdGF0ZScsICdfYXR0YWNoQmluZGluZ3NfZGlzcGxheScsICdmb2N1cycsICdibHVyJ10pO1xudmFyIFNlbGVjdEZpZWxkJDEgPSBTZWxlY3RGaWVsZDtleHBvcnQgZGVmYXVsdCBTZWxlY3RGaWVsZCQxOyIsInZhciBkZWZhdWx0cyA9IHtcbiAgdmFsaWRXaGVuU2VsZWN0ZWQ6IGZhbHNlLFxuICB2YWxpZFdoZW5Jc0Nob2ljZTogZmFsc2UsXG4gIHNob3dTZWxlY3RBbGw6IGZhbHNlLFxuICBwZXJHcm91cDogNyxcbiAgc3BhY2luZzogOCxcbiAgY2hvaWNlczogW11cbn07ZXhwb3J0IGRlZmF1bHQgZGVmYXVsdHM7IiwiaW1wb3J0IERPTSBmcm9tJ3F1aWNrZG9tJztpbXBvcnQgQ09MT1JTIGZyb20nLi4vLi4vY29uc3RhbnRzL2NvbG9ycy5qcyc7dmFyIHRlbXBsYXRlID0gRE9NLnRlbXBsYXRlKFsnZGl2Jywge1xuICByZWY6ICdmaWVsZCcsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgZGlzcGxheTogJ25vbmUnLFxuICAgIHdpZHRoOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zdGF0ZS53aWR0aDtcbiAgICB9LFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIGZvbnRGYW1pbHk6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLmZvbnRGYW1pbHk7XG4gICAgfSxcbiAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAkdmlzaWJsZToge1xuICAgICAgJGhhc1Zpc2libGVDaG9pY2VzOiB7XG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snXG4gICAgICB9XG4gICAgfSxcbiAgICAkc2hvd0Vycm9yOiB7XG4gICAgICBhbmltYXRpb246ICcwLjJzIGZpZWxkRXJyb3JTaGFrZSdcbiAgICB9XG4gIH1cbn0sIFsnZGl2Jywge1xuICByZWY6ICdsYWJlbCcsXG4gIHN0eWxlOiB7XG4gICAgZGlzcGxheTogJ25vbmUnLFxuICAgIG1hcmdpbkJvdHRvbTogJzEycHgnLFxuICAgIGZvbnRGYW1pbHk6ICdpbmhlcml0JyxcbiAgICBmb250U2l6ZTogJzEzcHgnLFxuICAgIGZvbnRXZWlnaHQ6IDYwMCxcbiAgICBjb2xvcjogQ09MT1JTLmJsYWNrLFxuICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxuICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgJHNob3dMYWJlbDoge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgIH0sXG4gICAgJHNob3dFcnJvcjoge1xuICAgICAgY29sb3I6IENPTE9SUy5yZWRcbiAgICB9XG4gIH1cbn1dLCBbJ2RpdicsIHtcbiAgcmVmOiAnaW5uZXJ3cmFwJyxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBmb250RmFtaWx5OiAnaW5oZXJpdCdcbiAgfVxufV0sIFsnZGl2Jywge1xuICByZWY6ICdoZWxwJyxcbiAgc3R5bGU6IHtcbiAgICBtYXJnaW5Ub3A6ICcxMHB4JyxcbiAgICBmb250RmFtaWx5OiAnaW5oZXJpdCcsXG4gICAgZm9udFNpemU6ICcxMXB4JyxcbiAgICBjb2xvcjogQ09MT1JTLmdyZXksXG4gICAgZGlzcGxheTogJ25vbmUnLFxuICAgICRzaG93RXJyb3I6IHtcbiAgICAgIGNvbG9yOiBDT0xPUlMucmVkLFxuICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgIH0sXG4gICAgJHNob3dIZWxwOiB7XG4gICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgfVxuICB9XG59XV0pO1xudmFyIGNob2ljZUdyb3VwID0gRE9NLnRlbXBsYXRlKFsnZGl2Jywge1xuICByZWY6ICdjaG9pY2VHcm91cCcsXG4gIHN0eWxlOiB7XG4gICAgbWFyZ2luQm90dG9tOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5zcGFjaW5nO1xuICAgIH0sXG4gICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgIGZvbnRTaXplOiAnMCcsXG4gICAgd2hpdGVTcGFjZTogJ25vd3JhcCdcbiAgfVxufV0pO1xudmFyIGNob2ljZSA9IERPTS50ZW1wbGF0ZShbJ2RpdicsIHtcbiAgcmVmOiAnY2hvaWNlJyxcbiAgc3R5bGVBZnRlckluc2VydDogdHJ1ZSxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICB3aWR0aDogJ2F1dG8nLFxuICAgIG1hcmdpbkxlZnQ6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgaWYgKHRoaXMuaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGBjYWxjKDEwMCUgLSAoMTAwJSAtICR7ZmllbGQuc2V0dGluZ3Muc3BhY2luZ31weCkpYDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIG1pbkhlaWdodDogJzQ2cHgnXG4gICAgcGFkZGluZzogJzAgMTJweCcsXG4gICAgYm9yZGVyUmFkaXVzOiAnMnB4JyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgY29sb3I6IENPTE9SUy5ibGFjayxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICB2ZXJ0aWNhbEFsaWduOiAndG9wJyxcbiAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAkZGVmaW5lZFdpZHRoOiB7XG4gICAgICB3aWR0aDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBgY2FsYygoMTAwJSAtICR7ZmllbGQuc2V0dGluZ3Muc3BhY2luZyAqIChmaWVsZC5zZXR0aW5ncy5wZXJHcm91cCAtIDEpfXB4KSAvICR7ZmllbGQuc2V0dGluZ3MucGVyR3JvdXB9KWA7XG4gICAgICB9XG4gICAgfSxcbiAgICAkc2VsZWN0ZWQ6IHtcbiAgICAgIGNvbG9yOiBDT0xPUlMub3JhbmdlXG4gICAgfSxcbiAgICAkdW5hdmFpbGFibGU6IHtcbiAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgIH0sXG4gICAgJGRpc2FibGVkOiB7XG4gICAgICBjdXJzb3I6ICdub3QtYWxsb3dlZCcsXG4gICAgICBvcGFjaXR5OiAwLjcsXG4gICAgICBjb2xvcjogQ09MT1JTLmdyZXlcbiAgICB9XG4gIH1cbn0sIFsnZGl2Jywge1xuICByZWY6ICdib3JkZXInLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHpJbmRleDogMixcbiAgICB0b3A6ICcwJyxcbiAgICBsZWZ0OiAnMCcsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICBib3JkZXJXaWR0aDogJzFweCcsXG4gICAgYm9yZGVyU3R5bGU6ICdzb2xpZCcsXG4gICAgYm9yZGVyQ29sb3I6IENPTE9SUy5ncmV5X2xpZ2h0LFxuICAgIGJvcmRlclJhZGl1czogJzJweCcsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgJHNlbGVjdGVkOiB7XG4gICAgICBib3JkZXJDb2xvcjogJ2luaGVyaXQnLFxuICAgICAgYm9yZGVyV2lkdGg6ICcycHgnXG4gICAgfSxcbiAgICAkZGlzYWJsZWQ6IHtcbiAgICAgIGJvcmRlckNvbG9yOiBDT0xPUlMuZ3JleV9saWdodFxuICAgIH1cbiAgfVxufV0sIFsnZGl2Jywge1xuICByZWY6ICdsYWJlbCcsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICBwYWRkaW5nOiAnMTVweCAwcHgnLFxuICAgIGZvbnRGYW1pbHk6ICdpbmhlcml0JyxcbiAgICBmb250U2l6ZTogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuc2V0dGluZ3MuZm9udFNpemU7XG4gICAgfSxcbiAgICBmb250V2VpZ2h0OiAnNTAwJ1xuICB9XG59XV0pO1xudmFyIGNob2ljZUljb24gPSBET00udGVtcGxhdGUoWydkaXYnLCB7XG4gIHJlZjogJ2ljb24nLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogJzUwJScsXG4gICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICBmb250U2l6ZTogJzIwcHgnLFxuICAgIG9wYWNpdHk6IDAuMTYsXG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtNTAlKSdcbiAgfVxufV0pO3ZhciB0ZW1wbGF0ZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDogdGVtcGxhdGUsY2hvaWNlR3JvdXA6IGNob2ljZUdyb3VwLGNob2ljZTogY2hvaWNlLGNob2ljZUljb246IGNob2ljZUljb259KTtleHBvcnR7dGVtcGxhdGUgYXMgYSx0ZW1wbGF0ZXMgYXMgYixjaG9pY2UgYXMgYyxjaG9pY2VJY29uIGFzIGQsY2hvaWNlR3JvdXAgYXMgZX07IiwiaW1wb3J0J0BkYW5pZWxrYWxlbi9pcyc7aW1wb3J0IElTIGZyb20nLi4vLi4vY2hlY2tzLmpzJztpbXBvcnQncXVpY2tkb20nO2ltcG9ydCBTaW1wbHlCaW5kIGZyb20nQGRhbmllbGthbGVuL3NpbXBseWJpbmQnO2ltcG9ydCcuLi8uLi9jb25zdGFudHMvcmVnZXguanMnO2ltcG9ydCB7cmVtb3ZlSXRlbSxpbmNsdWRlc31mcm9tJy4uLy4uL2hlbHBlcnMuanMnO2ltcG9ydCdzbWFydC1leHRlbmQnO2ltcG9ydCdmYXN0ZG9tJztpbXBvcnQgQ29uZGl0aW9uIGZyb20nLi4vLi4vY29tcG9uZW50cy9jb25kaXRpb24uanMnO2ltcG9ydCcuLi8uLi9maWVsZC90cmFuc2Zvcm1TZXR0aW5ncy5qcyc7aW1wb3J0Jy4uLy4uL2ZpZWxkL2dsb2JhbERlZmF1bHRzLmpzJztpbXBvcnQgRmllbGQgZnJvbScuLi8uLi9maWVsZC9pbmRleC5qcyc7aW1wb3J0Jy4uLy4uL2NvbnN0YW50cy9jb2xvcnMuanMnO2ltcG9ydCBkZWZhdWx0cyBmcm9tJy4vZGVmYXVsdHMuanMnO2ltcG9ydCB7YSBhcyB0ZW1wbGF0ZSxiIGFzIHRlbXBsYXRlc31mcm9tJy4vdGVtcGxhdGUtYzg4ZmE5NWIuanMnO3ZhciBDaG9pY2UsIENob2ljZUZpZWxkO1xuXG5DaG9pY2VGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgY2xhc3MgQ2hvaWNlRmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB2YXIgcmVmO1xuICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcblxuICAgICAgaWYgKCEoKHJlZiA9IHRoaXMuc2V0dGluZ3MuY2hvaWNlcykgIT0gbnVsbCA/IHJlZi5sZW5ndGggOiB2b2lkIDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hvaWNlcyB3ZXJlIG5vdCBwcm92aWRlZCBmb3IgY2hvaWNlIGZpZWxkICcke3RoaXMuc2V0dGluZ3MubGFiZWwgfHwgdGhpcy5JRH0nYCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5zZXR0aW5ncy5tdWx0aXBsZSA/IFtdIDogbnVsbDtcbiAgICAgIHRoaXMubGFzdFNlbGVjdGVkID0gbnVsbDtcbiAgICAgIHRoaXMudmlzaWJsZUNob2ljZXNDb3VudCA9IDA7XG4gICAgICB0aGlzLmNob2ljZXMgPSB0aGlzLnNldHRpbmdzLmNob2ljZXM7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZhbGlkV2hlblNlbGVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuU2VsZWN0ZWQgPSAxO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldHRpbmdzLnBlckdyb3VwID0gTWF0aC5taW4odGhpcy5zZXR0aW5ncy5wZXJHcm91cCwgdGhpcy5jaG9pY2VzLmxlbmd0aCArICh0aGlzLnNldHRpbmdzLm11bHRpcGxlICYmIHRoaXMuc2V0dGluZ3Muc2hvd1NlbGVjdEFsbCA/IDEgOiAwKSk7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnRzKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzKCk7XG5cbiAgICAgIHRoaXMuX2NvbnN0cnVjdG9yRW5kKCk7XG4gICAgfVxuXG4gICAgX2dldFZhbHVlKCkge1xuICAgICAgdmFyIHJlZjtcblxuICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLm11bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiAocmVmID0gdGhpcy5fdmFsdWUpICE9IG51bGwgPyByZWYudmFsdWUgOiB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWUubWFwKGZ1bmN0aW9uIChjaG9pY2UpIHtcbiAgICAgICAgICByZXR1cm4gY2hvaWNlLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0VmFsdWUobmV3VmFsdWUpIHtcbiAgICAgIHZhciBpLCBsZW4sIHZhbHVlO1xuXG4gICAgICBpZiAoIXRoaXMuc2V0dGluZ3MubXVsdGlwbGUgfHwgIUlTLmFycmF5KG5ld1ZhbHVlKSkge1xuICAgICAgICB0aGlzLnNldENob2ljZShuZXdWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBuZXdWYWx1ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhbHVlID0gbmV3VmFsdWVbaV07XG4gICAgICAgICAgdGhpcy5zZXRDaG9pY2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2NyZWF0ZUVsZW1lbnRzKCkge1xuICAgICAgdmFyIGNob2ljZUdyb3VwcywgY2hvaWNlcywgZ2xvYmFsT3B0cywgcGVyR3JvdXA7XG4gICAgICBnbG9iYWxPcHRzID0ge1xuICAgICAgICByZWxhdGVkSW5zdGFuY2U6IHRoaXNcbiAgICAgIH07XG4gICAgICB0aGlzLmVsID0gdGhpcy50ZW1wbGF0ZS5zcGF3bih0aGlzLnNldHRpbmdzLnRlbXBsYXRlcy5kZWZhdWx0LCBnbG9iYWxPcHRzKTtcbiAgICAgIHRoaXMuY2hvaWNlcyA9IFtdO1xuICAgICAgY2hvaWNlcyA9IHRoaXMuc2V0dGluZ3MuY2hvaWNlcztcbiAgICAgIHBlckdyb3VwID0gdGhpcy5zZXR0aW5ncy5wZXJHcm91cDtcbiAgICAgIGNob2ljZUdyb3VwcyA9IEFycmF5KE1hdGguY2VpbChjaG9pY2VzLmxlbmd0aCAvIHBlckdyb3VwKSkuZmlsbCgpLm1hcChmdW5jdGlvbiAocywgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGNob2ljZXMuc2xpY2UoaW5kZXggKiBwZXJHcm91cCwgaW5kZXggKiBwZXJHcm91cCArIHBlckdyb3VwKTtcbiAgICAgIH0pO1xuICAgICAgY2hvaWNlR3JvdXBzLmZvckVhY2goKGNob2ljZXMsIGdyb3VwSW5kZXgpID0+IHtcbiAgICAgICAgdmFyIGdyb3VwRWw7XG4gICAgICAgIGdyb3VwRWwgPSB0aGlzLnRlbXBsYXRlcy5jaG9pY2VHcm91cC5zcGF3bih0aGlzLnNldHRpbmdzLnRlbXBsYXRlcy5jaG9pY2VHcm91cCwgZ2xvYmFsT3B0cykuYXBwZW5kVG8odGhpcy5lbC5jaGlsZC5pbm5lcndyYXApO1xuICAgICAgICByZXR1cm4gY2hvaWNlcy5mb3JFYWNoKChjaG9pY2UsIGluZGV4KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2hvaWNlcy5wdXNoKG5ldyBDaG9pY2UodGhpcywgY2hvaWNlLCBpbmRleCwgZ3JvdXBJbmRleCwgZ3JvdXBFbCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbC5jaGlsZC5pbm5lcndyYXAucmF3Ll9xdWlja0ZpZWxkID0gdGhpcztcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3MoKSB7XG4gICAgICB2YXIgY2hvaWNlLCBpLCBsZW4sIHJlZjtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfZWxTdGF0ZSgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19zdGF0ZVRyaWdnZXJzKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX2Rpc3BsYXkoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfdmFsdWUoKTtcblxuICAgICAgcmVmID0gdGhpcy5jaG9pY2VzO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY2hvaWNlID0gcmVmW2ldO1xuXG4gICAgICAgIGNob2ljZS5fYXR0YWNoQmluZGluZ3MoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3NfZWxTdGF0ZSgpIHtcbiAgICAgIFNpbXBseUJpbmQoJ3Zpc2libGUnKS5vZih0aGlzLnN0YXRlKS50byh2aXNpYmxlID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ3Zpc2libGUnLCB2aXNpYmxlKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnaG92ZXJlZCcpLm9mKHRoaXMuc3RhdGUpLnRvKGhvdmVyZWQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnaG92ZXJlZCcsIGhvdmVyZWQpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdmaWxsZWQnKS5vZih0aGlzLnN0YXRlKS50byhmaWxsZWQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnZmlsbGVkJywgZmlsbGVkKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZGlzYWJsZWQnKS5vZih0aGlzLnN0YXRlKS50byhkaXNhYmxlZCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdkaXNhYmxlZCcsIGRpc2FibGVkKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnc2hvd0xhYmVsJykub2YodGhpcy5zdGF0ZSkudG8oc2hvd0xhYmVsID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ3Nob3dMYWJlbCcsIHNob3dMYWJlbCk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ3Nob3dFcnJvcicpLm9mKHRoaXMuc3RhdGUpLnRvKHNob3dFcnJvciA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdzaG93RXJyb3InLCBzaG93RXJyb3IpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdzaG93SGVscCcpLm9mKHRoaXMuc3RhdGUpLnRvKHNob3dIZWxwID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ3Nob3dIZWxwJywgc2hvd0hlbHApO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCd2YWxpZCcpLm9mKHRoaXMuc3RhdGUpLnRvKHZhbGlkID0+IHtcbiAgICAgICAgdGhpcy5lbC5zdGF0ZSgndmFsaWQnLCB2YWxpZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdpbnZhbGlkJywgIXZhbGlkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc19zdGF0ZVRyaWdnZXJzKCkge1xuICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6bW91c2VlbnRlcicpLm9mKHRoaXMuZWwpLnRvKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaG92ZXJlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2V2ZW50Om1vdXNlbGVhdmUnKS5vZih0aGlzLmVsKS50bygoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmhvdmVyZWQgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc19kaXNwbGF5KCkge1xuICAgICAgU2ltcGx5QmluZCgnd2lkdGgnKS5vZih0aGlzLnN0YXRlKS50byh3aWR0aCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0eWxlKCd3aWR0aCcsIHdpZHRoKS5zdGF0ZSgnZGVmaW5lZFdpZHRoJywgd2lkdGggIT09ICdhdXRvJyk7XG4gICAgICB9KS50cmFuc2Zvcm0odGhpcy5fZm9ybWF0V2lkdGguYmluZCh0aGlzKSkudXBkYXRlT24oJ2lzTW9iaWxlJykub2YodGhpcy5zdGF0ZSk7XG4gICAgICBTaW1wbHlCaW5kKCd2aXNpYmxlQ2hvaWNlc0NvdW50Jykub2YodGhpcykudG8oY291bnQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnaGFzVmlzaWJsZUNob2ljZXMnLCAhIWNvdW50KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc192YWx1ZSgpIHtcbiAgICAgIFNpbXBseUJpbmQoJ192YWx1ZScpLm9mKHRoaXMpLnRvKHNlbGVjdGVkID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsZWQgPSAhIShzZWxlY3RlZCAhPSBudWxsID8gc2VsZWN0ZWQubGVuZ3RoIDogdm9pZCAwKTtcblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5maWxsZWQpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmludGVyYWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUudmFsaWQgPSB0aGlzLnZhbGlkYXRlKHZvaWQgMCwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2FycmF5Ol92YWx1ZScsIHtcbiAgICAgICAgdXBkYXRlT25CaW5kOiBmYWxzZVxuICAgICAgfSkub2YodGhpcykudG8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdpbnB1dCcsIHRoaXMudmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3ZhbGlkYXRlKHByb3ZpZGVkVmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLm11bHRpcGxlKSB7XG4gICAgICAgIGlmICghSVMuYXJyYXkocHJvdmlkZWRWYWx1ZSkpIHtcbiAgICAgICAgICBwcm92aWRlZFZhbHVlID0gW3Byb3ZpZGVkVmFsdWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3ZpZGVkVmFsdWUubGVuZ3RoICYmICFJUy5vYmplY3QocHJvdmlkZWRWYWx1ZVswXSkpIHtcbiAgICAgICAgICBwcm92aWRlZFZhbHVlID0gcHJvdmlkZWRWYWx1ZS5tYXAoZnVuY3Rpb24gKGNob2ljZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNob2ljZS52YWx1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKElTLm9iamVjdChwcm92aWRlZFZhbHVlKSkge1xuICAgICAgICAgIHByb3ZpZGVkVmFsdWUgPSBwcm92aWRlZFZhbHVlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChJUy5udW1iZXIodGhpcy5zZXR0aW5ncy52YWxpZFdoZW5TZWxlY3RlZCkpIHtcbiAgICAgICAgaWYgKCEoKHByb3ZpZGVkVmFsdWUgIT0gbnVsbCA/IHByb3ZpZGVkVmFsdWUubGVuZ3RoIDogdm9pZCAwKSA+PSB0aGlzLnNldHRpbmdzLnZhbGlkV2hlblNlbGVjdGVkKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy52YWxpZFdoZW5Jc0Nob2ljZSkge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5tdWx0aXBsZSkge1xuICAgICAgICAgIGlmICghaW5jbHVkZXMocHJvdmlkZWRWYWx1ZSwgdGhpcy5zZXR0aW5ncy52YWxpZFdoZW5Jc0Nob2ljZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHByb3ZpZGVkVmFsdWUgIT09IHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuSXNDaG9pY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZmluZENob2ljZShwcm92aWRlZFZhbHVlLCBieUxhYmVsKSB7XG4gICAgICB2YXIgbWF0Y2hlcztcbiAgICAgIG1hdGNoZXMgPSB0aGlzLmNob2ljZXMuZmlsdGVyKGZ1bmN0aW9uIChjaG9pY2UpIHtcbiAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgIGNhc2UgIUlTLm9iamVjdChwcm92aWRlZFZhbHVlKTpcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlZFZhbHVlID09PSBjaG9pY2U7XG5cbiAgICAgICAgICBjYXNlICFieUxhYmVsOlxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVkVmFsdWUgPT09IGNob2ljZS5sYWJlbDtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZWRWYWx1ZSA9PT0gY2hvaWNlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYXRjaGVzWzBdO1xuICAgIH1cblxuICAgIGZpbmRDaG9pY2VBbnkocHJvdmlkZWRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZENob2ljZShwcm92aWRlZFZhbHVlKSB8fCB0aGlzLmZpbmRDaG9pY2UocHJvdmlkZWRWYWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgc2V0Q2hvaWNlKGNob2ljZSkge1xuICAgICAgaWYgKElTLm9iamVjdChjaG9pY2UpICYmIGNob2ljZSBpbnN0YW5jZW9mIENob2ljZSkge1xuICAgICAgICByZXR1cm4gY2hvaWNlLnRvZ2dsZSgpO1xuICAgICAgfSBlbHNlIGlmIChjaG9pY2UgPSB0aGlzLmZpbmRDaG9pY2VBbnkoY2hvaWNlKSkge1xuICAgICAgICByZXR1cm4gY2hvaWNlLnRvZ2dsZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuICBDaG9pY2VGaWVsZC5wcm90b3R5cGUudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgQ2hvaWNlRmllbGQucHJvdG90eXBlLnRlbXBsYXRlcyA9IHRlbXBsYXRlcztcbiAgQ2hvaWNlRmllbGQucHJvdG90eXBlLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIHJldHVybiBDaG9pY2VGaWVsZDtcbn0uY2FsbCh1bmRlZmluZWQpO1xuXG5DaG9pY2UgPSBjbGFzcyBDaG9pY2Uge1xuICBjb25zdHJ1Y3RvcihmaWVsZCwgc2V0dGluZ3MsIGluZGV4MSwgZ3JvdXBJbmRleCwgZ3JvdXBFbCkge1xuICAgIHZhciBnbG9iYWxPcHRzLCBpY29uRWwsIHJlZjtcbiAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDE7XG4gICAgZ2xvYmFsT3B0cyA9IHtcbiAgICAgIHJlbGF0ZWRJbnN0YW5jZTogdGhpcy5maWVsZFxuICAgIH07XG4gICAgKHtcbiAgICAgIGxhYmVsOiB0aGlzLmxhYmVsLFxuICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICBjb25kaXRpb25zOiB0aGlzLmNvbmRpdGlvbnNcbiAgICB9ID0gdGhpcy5zZXR0aW5ncyk7XG5cbiAgICBpZiAodGhpcy5sYWJlbCA9PSBudWxsKSB7XG4gICAgICB0aGlzLmxhYmVsID0gdGhpcy52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52YWx1ZSA9PSBudWxsKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5sYWJlbDtcbiAgICB9XG5cbiAgICB0aGlzLmVsID0gdGhpcy5maWVsZC50ZW1wbGF0ZXMuY2hvaWNlLnNwYXduKHRoaXMuZmllbGQuc2V0dGluZ3MudGVtcGxhdGVzLmNob2ljZSwgZ2xvYmFsT3B0cykuYXBwZW5kVG8oZ3JvdXBFbCk7XG5cbiAgICBpZiAodGhpcy5pY29uKSB7XG4gICAgICBpY29uRWwgPSB0aGlzLnRlbXBsYXRlcy5jaG9pY2VJY29uLnNwYXduKHRoaXMuZmllbGQuc2V0dGluZ3MudGVtcGxhdGVzLmNob2ljZUljb24sIGdsb2JhbE9wdHMpLmluc2VydEJlZm9yZSh0aGlzLmVsLmNoaWxkLmxhYmVsKTtcbiAgICAgIGljb25FbC50ZXh0ID0gdGhpcy5pY29uO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVsLmluZGV4ID09IG51bGwpIHtcbiAgICAgIHRoaXMuZWwuaW5kZXggPSB0aGlzLmluZGV4O1xuICAgIH1cblxuICAgIHRoaXMuZWwudG90YWxJbmRleCA9IHRoaXMuaW5kZXggKiBncm91cEluZGV4O1xuICAgIHRoaXMuZWwucHJvcCgndGl0bGUnLCB0aGlzLmxhYmVsKTtcbiAgICB0aGlzLmVsLmNoaWxkLmxhYmVsLnRleHQgPSB0aGlzLmxhYmVsO1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGlzYWJsZWQgPSB0aGlzLnNldHRpbmdzLmRpc2FibGVkIHx8IGZhbHNlO1xuICAgIHRoaXMudW5hdmFpbGFibGUgPSBmYWxzZTtcblxuICAgIGlmICgocmVmID0gdGhpcy5jb25kaXRpb25zKSAhPSBudWxsID8gcmVmLmxlbmd0aCA6IHZvaWQgMCkge1xuICAgICAgdGhpcy51bmF2YWlsYWJsZSA9IHRydWU7XG4gICAgICB0aGlzLmFsbEZpZWxkcyA9IHRoaXMuZmllbGQuYWxsRmllbGRzO1xuICAgICAgQ29uZGl0aW9uLmluaXQodGhpcywgdGhpcy5jb25kaXRpb25zLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuYXZhaWxhYmxlID0gIUNvbmRpdGlvbi52YWxpZGF0ZSh0aGlzLmNvbmRpdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX2F0dGFjaEJpbmRpbmdzKCkge1xuICAgIHJldHVybiAoKCkgPT4ge1xuICAgICAgU2ltcGx5QmluZCgndmlzaWJsZScpLm9mKHRoaXMpLnRvKHZpc2libGUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgndmlzaWJsZScsIHZpc2libGUpO1xuICAgICAgfSkuYW5kLnRvKHZpc2libGUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZC52aXNpYmxlQ2hvaWNlc0NvdW50ICs9IHZpc2libGUgPyAxIDogLTE7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ3NlbGVjdGVkJywge1xuICAgICAgICB1cGRhdGVPbkJpbmQ6IGZhbHNlXG4gICAgICB9KS5vZih0aGlzKS50byhzZWxlY3RlZCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdzZWxlY3RlZCcsIHNlbGVjdGVkKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZGlzYWJsZWQnLCB7XG4gICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICAgIH0pLm9mKHRoaXMpLnRvKGRpc2FibGVkID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ2Rpc2FibGVkJywgZGlzYWJsZWQpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCd1bmF2YWlsYWJsZScsIHtcbiAgICAgICAgdXBkYXRlT25CaW5kOiBmYWxzZVxuICAgICAgfSkub2YodGhpcykudG8odW5hdmFpbGFibGUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgndW5hdmFpbGFibGUnLCB1bmF2YWlsYWJsZSk7XG4gICAgICB9KS5hbmQudG8odW5hdmFpbGFibGUgPT4ge1xuICAgICAgICBpZiAodW5hdmFpbGFibGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2dnbGUoZmFsc2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBTaW1wbHlCaW5kKCdldmVudDpjbGljaycpLm9mKHRoaXMuZWwpLnRvKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGQudmFsdWUgPSB0aGlzO1xuICAgICAgfSkuY29uZGl0aW9uKCgpID0+IHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRpc2FibGVkO1xuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIHRvZ2dsZShuZXdWYWx1ZSwgdW5hdmFpbGFibGUpIHtcbiAgICB2YXIgbmV3U3RhdGUsIHByZXZTdGF0ZSwgcmVmO1xuICAgIHByZXZTdGF0ZSA9IHRoaXMuc2VsZWN0ZWQ7XG4gICAgbmV3U3RhdGUgPSBJUy5kZWZpbmVkKG5ld1ZhbHVlKSA/IG5ld1ZhbHVlIDogIXRoaXMuc2VsZWN0ZWQ7XG5cbiAgICBpZiAoIW5ld1N0YXRlKSB7XG4gICAgICBpZiAodGhpcy5maWVsZC5zZXR0aW5ncy5tdWx0aXBsZSAmJiBwcmV2U3RhdGUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IG5ld1N0YXRlO1xuICAgICAgICByZXR1cm4gcmVtb3ZlSXRlbSh0aGlzLmZpZWxkLl92YWx1ZSwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoSVMuZGVmaW5lZChuZXdWYWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gbmV3U3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodW5hdmFpbGFibGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5fdmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBuZXdTdGF0ZTtcblxuICAgICAgaWYgKHRoaXMuZmllbGQuc2V0dGluZ3MubXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5maWVsZC5fdmFsdWUucHVzaCh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmZpZWxkLl92YWx1ZSAhPT0gdGhpcykge1xuICAgICAgICAgIGlmICgocmVmID0gdGhpcy5maWVsZC5fdmFsdWUpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlZi50b2dnbGUoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmllbGQuX3ZhbHVlID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZmllbGQubGFzdFNlbGVjdGVkID0gdGhpcztcbiAgICB9XG4gIH1cblxufTtcbnZhciBDaG9pY2VGaWVsZCQxID0gQ2hvaWNlRmllbGQ7ZXhwb3J0IGRlZmF1bHQgQ2hvaWNlRmllbGQkMTtleHBvcnR7Q2hvaWNlfTsiLCJpbXBvcnQnc21hcnQtZXh0ZW5kJztpbXBvcnQge2EgYXMgdGVtcGxhdGUsYyBhcyBjaG9pY2UsZCBhcyBjaG9pY2VJY29uLGUgYXMgY2hvaWNlR3JvdXB9ZnJvbScuLi9jaG9pY2UvdGVtcGxhdGUtYzg4ZmE5NWIuanMnO3ZhciB0ZW1wbGF0ZSQxID0gdGVtcGxhdGUuZXh0ZW5kKCk7XG52YXIgY2hvaWNlJDEgPSBjaG9pY2UuZXh0ZW5kKCk7XG52YXIgY2hvaWNlSWNvbiQxID0gY2hvaWNlSWNvbi5leHRlbmQoKTtcbnZhciBjaG9pY2VHcm91cCQxID0gY2hvaWNlR3JvdXAuZXh0ZW5kKCk7dmFyIHRlbXBsYXRlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtkZWZhdWx0OiB0ZW1wbGF0ZSQxLGNob2ljZTogY2hvaWNlJDEsY2hvaWNlSWNvbjogY2hvaWNlSWNvbiQxLGNob2ljZUdyb3VwOiBjaG9pY2VHcm91cCQxfSk7ZXhwb3J0e3RlbXBsYXRlJDEgYXMgYSx0ZW1wbGF0ZXMgYXMgYixjaG9pY2UkMSBhcyBjLGNob2ljZUljb24kMSBhcyBkLGNob2ljZUdyb3VwJDEgYXMgZX07IiwidmFyIGRlZmF1bHRzID0ge1xuICB2YWxpZFdoZW5TZWxlY3RlZDogZmFsc2UsXG4gIHZhbGlkV2hlbklzQ2hvaWNlOiBmYWxzZSxcbiAgdmFsaWRXaGVuVHJ1ZTogdHJ1ZSxcbiAgY2hvaWNlTGFiZWxzOiBbJ1RydWUnLCAnRmFsc2UnXSxcbiAgY2hvaWNlczogW3tcbiAgICB2YWx1ZTogdHJ1ZVxuICB9LCB7XG4gICAgdmFsdWU6IGZhbHNlXG4gIH1dLFxuICBzcGFjaW5nOiA4XG59O2V4cG9ydCBkZWZhdWx0IGRlZmF1bHRzOyIsImltcG9ydCdAZGFuaWVsa2FsZW4vaXMnO2ltcG9ydCcuLi8uLi9jaGVja3MuanMnO2ltcG9ydCdxdWlja2RvbSc7aW1wb3J0J0BkYW5pZWxrYWxlbi9zaW1wbHliaW5kJztpbXBvcnQnLi4vLi4vY29uc3RhbnRzL3JlZ2V4LmpzJztpbXBvcnQge2luaGVyaXRQcm90b31mcm9tJy4uLy4uL2hlbHBlcnMuanMnO2ltcG9ydCdzbWFydC1leHRlbmQnO2ltcG9ydCdmYXN0ZG9tJztpbXBvcnQnLi4vLi4vY29tcG9uZW50cy9jb25kaXRpb24uanMnO2ltcG9ydCcuLi8uLi9maWVsZC90cmFuc2Zvcm1TZXR0aW5ncy5qcyc7aW1wb3J0Jy4uLy4uL2ZpZWxkL2dsb2JhbERlZmF1bHRzLmpzJztpbXBvcnQgRmllbGQgZnJvbScuLi8uLi9maWVsZC9pbmRleC5qcyc7aW1wb3J0Jy4uLy4uL2NvbnN0YW50cy9jb2xvcnMuanMnO2ltcG9ydCcuLi9jaG9pY2UvZGVmYXVsdHMuanMnO2ltcG9ydCcuLi9jaG9pY2UvdGVtcGxhdGUtYzg4ZmE5NWIuanMnO2ltcG9ydCBDaG9pY2VGaWVsZCBmcm9tJy4uL2Nob2ljZS9pbmRleC5qcyc7aW1wb3J0IHthIGFzIHRlbXBsYXRlLGIgYXMgdGVtcGxhdGVzfWZyb20nLi90ZW1wbGF0ZS0zZDZjNTRhMC5qcyc7aW1wb3J0IGRlZmF1bHRzIGZyb20nLi9kZWZhdWx0cy5qcyc7dmFyIFRydWVGYWxzZUZpZWxkO1xuXG5UcnVlRmFsc2VGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgY2xhc3MgVHJ1ZUZhbHNlRmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgdGhpcy5sYXN0U2VsZWN0ZWQgPSBudWxsO1xuICAgICAgdGhpcy52aXNpYmxlQ2hvaWNlc0NvdW50ID0gMjtcbiAgICAgIHRoaXMuY2hvaWNlcyA9IHRoaXMuc2V0dGluZ3MuY2hvaWNlcztcbiAgICAgIHRoaXMuY2hvaWNlc1swXS5sYWJlbCA9IHRoaXMuc2V0dGluZ3MuY2hvaWNlTGFiZWxzWzBdO1xuICAgICAgdGhpcy5jaG9pY2VzWzFdLmxhYmVsID0gdGhpcy5zZXR0aW5ncy5jaG9pY2VMYWJlbHNbMV07XG4gICAgICB0aGlzLnNldHRpbmdzLnBlckdyb3VwID0gMjtcblxuICAgICAgdGhpcy5fY3JlYXRlRWxlbWVudHMoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3MoKTtcblxuICAgICAgdGhpcy5fY29uc3RydWN0b3JFbmQoKTtcbiAgICB9XG5cbiAgICBfZ2V0VmFsdWUoKSB7XG4gICAgICBpZiAodGhpcy5fdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fdmFsdWUuaW5kZXggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0VmFsdWUobmV3VmFsdWUpIHtcbiAgICAgIHZhciByZWY7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdGhpcy5jaG9pY2VzWzBdKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdGhpcy5jaG9pY2VzWzBdLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHRoaXMuY2hvaWNlc1sxXSkge1xuICAgICAgICBuZXdWYWx1ZSA9IHRoaXMuY2hvaWNlc1sxXS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcblxuICAgICAgICBpZiAoKHJlZiA9IHRoaXMubGFzdFNlbGVjdGVkKSAhPSBudWxsKSB7XG4gICAgICAgICAgcmVmLnRvZ2dsZShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbmV3VmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAobmV3VmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAobmV3VmFsdWUgPyB0aGlzLmNob2ljZXNbMF0gOiB0aGlzLmNob2ljZXNbMV0pLnRvZ2dsZSgpO1xuICAgIH1cblxuICAgIF92YWxpZGF0ZShwcm92aWRlZFZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3ZpZGVkVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHByb3ZpZGVkVmFsdWUgPSB0aGlzLmZpbmRDaG9pY2UocHJvdmlkZWRWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZhbGlkV2hlbklzQ2hvaWNlKSB7XG4gICAgICAgIGlmIChwcm92aWRlZFZhbHVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuSXNDaG9pY2UgIT09IHByb3ZpZGVkVmFsdWUudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZhbGlkV2hlblNlbGVjdGVkKSB7XG4gICAgICAgIGlmICghcHJvdmlkZWRWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy52YWxpZFdoZW5UcnVlKSB7XG4gICAgICAgIGlmICgocHJvdmlkZWRWYWx1ZSAhPSBudWxsID8gcHJvdmlkZWRWYWx1ZS5pbmRleCA6IHZvaWQgMCkgIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gIH1cbiAgVHJ1ZUZhbHNlRmllbGQucHJvdG90eXBlLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gIFRydWVGYWxzZUZpZWxkLnByb3RvdHlwZS50ZW1wbGF0ZXMgPSB0ZW1wbGF0ZXM7XG4gIFRydWVGYWxzZUZpZWxkLnByb3RvdHlwZS5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICByZXR1cm4gVHJ1ZUZhbHNlRmllbGQ7XG59LmNhbGwodW5kZWZpbmVkKTtcblxuaW5oZXJpdFByb3RvKFRydWVGYWxzZUZpZWxkLCBDaG9pY2VGaWVsZCwgWydfY3JlYXRlRWxlbWVudHMnLCAnX2F0dGFjaEJpbmRpbmdzJywgJ19hdHRhY2hCaW5kaW5nc19lbFN0YXRlJywgJ19hdHRhY2hCaW5kaW5nc19zdGF0ZVRyaWdnZXJzJywgJ19hdHRhY2hCaW5kaW5nc19kaXNwbGF5JywgJ19hdHRhY2hCaW5kaW5nc192YWx1ZSddKTtcbnZhciBUcnVlRmFsc2VGaWVsZCQxID0gVHJ1ZUZhbHNlRmllbGQ7ZXhwb3J0IGRlZmF1bHQgVHJ1ZUZhbHNlRmllbGQkMTsiLCJpbXBvcnQgQ09MT1JTIGZyb20nLi4vLi4vY29uc3RhbnRzL2NvbG9ycy5qcyc7dmFyIGRlZmF1bHRzID0ge1xuICB2YWxpZFdoZW5UcnVlOiB0cnVlLFxuICBzaXplOiA1MCxcbiAgc3R5bGU6ICdjZW50ZXJlZCcsXG4gIGNvbG9yOiBDT0xPUlMuZ3JlZW4sXG4gIGJhY2tncm91bmQ6IENPTE9SUy5ncmV5X2xpZ2h0LFxuICB0cmlnZ2VyRXZlbnQ6ICdtb3VzZXVwJ1xufTtleHBvcnQgZGVmYXVsdCBkZWZhdWx0czsiLCJpbXBvcnQgRE9NIGZyb20ncXVpY2tkb20nO2ltcG9ydCBDT0xPUlMgZnJvbScuLi8uLi9jb25zdGFudHMvY29sb3JzLmpzJzt2YXIgdGVtcGxhdGUgPSBET00udGVtcGxhdGUoWydkaXYnLCB7XG4gIHJlZjogJ2ZpZWxkJyxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgd2lkdGg6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnN0YXRlLndpZHRoO1xuICAgIH0sXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgZm9udEZhbWlseTogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuc2V0dGluZ3MuZm9udEZhbWlseTtcbiAgICB9LFxuICAgIHRleHRBbGlnbjogJ2xlZnQnLFxuICAgICR2aXNpYmxlOiB7XG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJ1xuICAgIH0sXG4gICAgJHNob3dFcnJvcjoge1xuICAgICAgYW5pbWF0aW9uOiAnMC4ycyBmaWVsZEVycm9yU2hha2UnXG4gICAgfSxcbiAgICAkYWxpZ25lZFN0eWxlOiB7XG4gICAgICBwYWRkaW5nUmlnaHQ6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICByZXR1cm4gZmllbGQuc2V0dGluZ3Muc2l6ZSArIDIwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSwgWydkaXYnLCB7XG4gIHJlZjogJ2xhYmVsJyxcbiAgc3R5bGU6IHtcbiAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgbWFyZ2luQm90dG9tOiAnMTJweCcsXG4gICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgIGZvbnRTaXplOiAnMTNweCcsXG4gICAgZm9udFdlaWdodDogNjAwLFxuICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgY29sb3I6IENPTE9SUy5ibGFjayxcbiAgICBjdXJzb3I6ICdkZWZhdWx0JyxcbiAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICRzaG93TGFiZWw6IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICB9LFxuICAgICRzaG93RXJyb3I6IHtcbiAgICAgIGNvbG9yOiBDT0xPUlMucmVkXG4gICAgfSxcbiAgICAkYWxpZ25lZFN0eWxlOiB7XG4gICAgICBtYXJnaW5Cb3R0b206ICcwJyxcbiAgICAgIHRleHRBbGlnbjogJ2xlZnQnXG4gICAgfVxuICB9XG59XSwgWydkaXYnLCB7XG4gIHJlZjogJ2lubmVyd3JhcCcsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgICRhbGlnbmVkU3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6ICc1MCUnLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtNTAlKSdcbiAgICB9XG4gIH1cbn0sIFsnZGl2Jywge1xuICByZWY6ICdpbnB1dCcsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgekluZGV4OiAyLFxuICAgIHdpZHRoOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5zaXplO1xuICAgIH0sXG4gICAgaGVpZ2h0OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5zaXplIC8gMjtcbiAgICB9LFxuICAgIG1hcmdpbjogJzAgYXV0bycsXG4gICAgYmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5iYWNrZ3JvdW5kO1xuICAgIH0sXG4gICAgYm9yZGVyOiBgMXB4IHNvbGlkICR7Q09MT1JTLmdyZXlfc2VtaV9saWdodH1gLFxuICAgIGJvcmRlclJhZGl1czogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuc2V0dGluZ3Muc2l6ZTtcbiAgICB9LFxuICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gIH1cbn0sIFsnZGl2Jywge1xuICByZWY6ICdiYWNrZ3JvdW5kJyxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB6SW5kZXg6IDEsXG4gICAgbGVmdDogMCxcbiAgICByaWdodDogMCxcbiAgICB3aWR0aDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuc2V0dGluZ3Muc2l6ZSAvIDI7XG4gICAgfSxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICBib3JkZXJSYWRpdXM6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgdmFyIHNpemU7XG4gICAgICBzaXplID0gZmllbGQuc2V0dGluZ3Muc2l6ZTtcbiAgICAgIHJldHVybiBgJHtzaXplfXB4IDAgMCAke3NpemV9cHhgO1xuICAgIH0sXG4gICAgYmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5jb2xvcjtcbiAgICB9LFxuICAgIG9wYWNpdHk6IDAsXG4gICAgdHJhbnNpdGlvbjogJ29wYWNpdHkgMC4ycywgd2lkdGggMC4ycycsXG4gICAgJHRvZ2dsZWQ6IHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICB3aWR0aDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5zaXplICogMC43O1xuICAgICAgfVxuICAgIH1cbiAgfVxufV0sIFsnZGl2Jywge1xuICByZWY6ICdiYWxsJyxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB6SW5kZXg6IDIsXG4gICAgbGVmdDogMCxcbiAgICByaWdodDogMCxcbiAgICB3aWR0aDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuc2V0dGluZ3Muc2l6ZSAvIDI7XG4gICAgfSxcbiAgICBoZWlnaHQ6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLnNldHRpbmdzLnNpemUgLyAyO1xuICAgIH0sXG4gICAgbWFyZ2luOiAnMCBhdXRvJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgYm9yZGVyUmFkaXVzOiAnNTAlJyxcbiAgICBib3JkZXI6IGAxcHggc29saWQgJHtDT0xPUlMuZ3JleV9saWdodH1gLFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTU1JSknLFxuICAgIHRyYW5zaXRpb246ICd0cmFuc2Zvcm0gMC4ycycsXG4gICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICR0b2dnbGVkOiB7XG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDUwJSknLFxuICAgICAgYm9yZGVyOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIGAxcHggc29saWQgJHtmaWVsZC5zZXR0aW5ncy5jb2xvcn1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxufV1dXSwgWydkaXYnLCB7XG4gIHJlZjogJ2hlbHAnLFxuICBzdHlsZToge1xuICAgIG1hcmdpblRvcDogJzEwcHgnLFxuICAgIGZvbnRGYW1pbHk6ICdpbmhlcml0JyxcbiAgICBmb250U2l6ZTogJzExcHgnLFxuICAgIGNvbG9yOiBDT0xPUlMuZ3JleSxcbiAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgJHNob3dFcnJvcjoge1xuICAgICAgY29sb3I6IENPTE9SUy5yZWQsXG4gICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgfSxcbiAgICAkc2hvd0hlbHA6IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICB9XG4gIH1cbn1dXSk7dmFyIHRlbXBsYXRlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtkZWZhdWx0OiB0ZW1wbGF0ZX0pO2V4cG9ydHt0ZW1wbGF0ZSBhcyBhLHRlbXBsYXRlcyBhcyBifTsiLCJpbXBvcnQnQGRhbmllbGthbGVuL2lzJztpbXBvcnQnLi4vLi4vY2hlY2tzLmpzJztpbXBvcnQncXVpY2tkb20nO2ltcG9ydCBTaW1wbHlCaW5kIGZyb20nQGRhbmllbGthbGVuL3NpbXBseWJpbmQnO2ltcG9ydCcuLi8uLi9jb25zdGFudHMvcmVnZXguanMnO2ltcG9ydCB7aW5oZXJpdFByb3RvfWZyb20nLi4vLi4vaGVscGVycy5qcyc7aW1wb3J0J3NtYXJ0LWV4dGVuZCc7aW1wb3J0J2Zhc3Rkb20nO2ltcG9ydCcuLi8uLi9jb21wb25lbnRzL2NvbmRpdGlvbi5qcyc7aW1wb3J0Jy4uLy4uL2ZpZWxkL3RyYW5zZm9ybVNldHRpbmdzLmpzJztpbXBvcnQnLi4vLi4vZmllbGQvZ2xvYmFsRGVmYXVsdHMuanMnO2ltcG9ydCBGaWVsZCBmcm9tJy4uLy4uL2ZpZWxkL2luZGV4LmpzJztpbXBvcnQnLi4vLi4vY29uc3RhbnRzL2NvbG9ycy5qcyc7aW1wb3J0Jy4uL2Nob2ljZS9kZWZhdWx0cy5qcyc7aW1wb3J0Jy4uL2Nob2ljZS90ZW1wbGF0ZS1jODhmYTk1Yi5qcyc7aW1wb3J0Jy4uL2Nob2ljZS9pbmRleC5qcyc7aW1wb3J0IGRlZmF1bHRzIGZyb20nLi9kZWZhdWx0cy5qcyc7aW1wb3J0Jy4uL3RydWVmYWxzZS90ZW1wbGF0ZS0zZDZjNTRhMC5qcyc7aW1wb3J0Jy4uL3RydWVmYWxzZS9kZWZhdWx0cy5qcyc7aW1wb3J0IFRydWVGYWxzZUZpZWxkIGZyb20nLi4vdHJ1ZWZhbHNlL2luZGV4LmpzJztpbXBvcnQge2EgYXMgdGVtcGxhdGUsYiBhcyB0ZW1wbGF0ZXN9ZnJvbScuL3RlbXBsYXRlLWJmN2I5OWMxLmpzJzt2YXIgVG9nZ2xlRmllbGQ7XG5cblRvZ2dsZUZpZWxkID0gZnVuY3Rpb24gKCkge1xuICBjbGFzcyBUb2dnbGVGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICB0aGlzLl92YWx1ZSA9ICEhdGhpcy5fdmFsdWU7XG4gICAgICB0aGlzLnNldHRpbmdzLnNpemUgPSBwYXJzZUZsb2F0KHRoaXMuc2V0dGluZ3Muc2l6ZSkgfHwgZGVmYXVsdHMuc2l6ZTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3R5bGUgIT09ICdjZW50ZXJlZCcgJiYgdGhpcy5zZXR0aW5ncy5zdHlsZSAhPT0gJ2FsaWduZWQnKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3Muc3R5bGUgPSBkZWZhdWx0cy5zdHlsZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY3JlYXRlRWxlbWVudHMoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3MoKTtcblxuICAgICAgdGhpcy5fY29uc3RydWN0b3JFbmQoKTtcbiAgICB9XG5cbiAgICBfZ2V0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuXG4gICAgX3NldFZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSAhIW5ld1ZhbHVlO1xuICAgIH1cblxuICAgIF9jcmVhdGVFbGVtZW50cygpIHtcbiAgICAgIHZhciBmb3JjZU9wdHM7XG4gICAgICBmb3JjZU9wdHMgPSB7XG4gICAgICAgIHJlbGF0ZWRJbnN0YW5jZTogdGhpc1xuICAgICAgfTtcbiAgICAgIHRoaXMuZWwgPSB0aGlzLnRlbXBsYXRlLnNwYXduKHRoaXMuc2V0dGluZ3MudGVtcGxhdGVzLmRlZmF1bHQsIGZvcmNlT3B0cyk7XG4gICAgICB0aGlzLmVsLnN0YXRlKCdhbGlnbmVkU3R5bGUnLCB0aGlzLnNldHRpbmdzLnN0eWxlID09PSAnYWxpZ25lZCcpLmNoaWxkLmlubmVyd3JhcC5yYXcuX3F1aWNrRmllbGQgPSB0aGlzO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5ncygpIHtcbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX2VsU3RhdGUoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3Nfc3RhdGVUcmlnZ2VycygpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19kaXNwbGF5KCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX3ZhbHVlKCk7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX3ZhbHVlKCkge1xuICAgICAgU2ltcGx5QmluZCgnX3ZhbHVlJykub2YodGhpcykudG8odmFsdWUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgndG9nZ2xlZCcsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnX3ZhbHVlJywge1xuICAgICAgICB1cGRhdGVPbkJpbmQ6IGZhbHNlXG4gICAgICB9KS5vZih0aGlzKS50byh2YWx1ZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2lucHV0JywgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKGBldmVudDoke3RoaXMuc2V0dGluZ3MudHJpZ2dlckV2ZW50fWApLm9mKHRoaXMuZWwuY2hpbGQuaW5wdXQpLnRvKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPSAhdGhpcy5fdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfdmFsaWRhdGUocHJvdmlkZWRWYWx1ZSkge1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmFsaWRXaGVuVHJ1ZSkge1xuICAgICAgICBpZiAoIXByb3ZpZGVkVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gIH1cbiAgVG9nZ2xlRmllbGQucHJvdG90eXBlLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gIFRvZ2dsZUZpZWxkLnByb3RvdHlwZS50ZW1wbGF0ZXMgPSB0ZW1wbGF0ZXM7XG4gIFRvZ2dsZUZpZWxkLnByb3RvdHlwZS5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICByZXR1cm4gVG9nZ2xlRmllbGQ7XG59LmNhbGwodW5kZWZpbmVkKTtcblxuaW5oZXJpdFByb3RvKFRvZ2dsZUZpZWxkLCBUcnVlRmFsc2VGaWVsZCwgWydfYXR0YWNoQmluZGluZ3NfZWxTdGF0ZScsICdfYXR0YWNoQmluZGluZ3Nfc3RhdGVUcmlnZ2VycycsICdfYXR0YWNoQmluZGluZ3NfZGlzcGxheSddKTtcbnZhciBUb2dnbGVGaWVsZCQxID0gVG9nZ2xlRmllbGQ7ZXhwb3J0IGRlZmF1bHQgVG9nZ2xlRmllbGQkMTsiLCJpbXBvcnQgQ09MT1JTIGZyb20nLi4vLi4vY29uc3RhbnRzL2NvbG9ycy5qcyc7dmFyIGRlZmF1bHRzID0ge1xuICBmaWVsZHM6IHt9LFxuICBjb2xsYXBzYWJsZTogdHJ1ZSxcbiAgc3RhcnRDb2xsYXBzZWQ6IGZhbHNlLFxuICBwYWRkaW5nOiAyMCxcbiAgZmllbGRNYXJnaW46IDAsXG4gIGZpZWxkQWxpZ246ICd0b3AnLFxuICBsYWJlbFNpemU6IDE2LFxuICBjb2xvcjogQ09MT1JTLmdyZXlfbGlnaHQ0XG59O2V4cG9ydCBkZWZhdWx0IGRlZmF1bHRzOyIsImltcG9ydCBET00gZnJvbSdxdWlja2RvbSc7aW1wb3J0Jy4uLy4uL3N2Zy9jaGVja21hcmsuanMnO2ltcG9ydCcuLi8uLi9zdmcvYW5nbGVEb3duLmpzJztpbXBvcnQgY2FyZXRVcCBmcm9tJy4uLy4uL3N2Zy9jYXJldFVwLmpzJztpbXBvcnQgY2FyZXREb3duIGZyb20nLi4vLi4vc3ZnL2NhcmV0RG93bi5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9wbHVzLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2Nsb25lLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3JlbW92ZS5qcyc7aW1wb3J0IENPTE9SUyBmcm9tJy4uLy4uL2NvbnN0YW50cy9jb2xvcnMuanMnO3ZhciBhY3Rpb24gPSBET00udGVtcGxhdGUoWydkaXYnLCB7XG4gIGV2ZW50czoge1xuICAgIGluc2VydGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5pbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSgnbWFyZ2luTGVmdCcsIDUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94J1xuICB9XG59LCBbLy8gdmVydGljYWxBbGlnbjogJ21pZGRsZSdcbidkaXYnLCB7XG4gIHJlZjogJ2ljb24nLFxuICBzdHlsZToge1xuICAgIHdpZHRoOiAxNyxcbiAgICBoZWlnaHQ6IDE3LFxuICAgIGNvbG9yOiBDT0xPUlMuZ3JleSxcbiAgICBmaWxsOiBDT0xPUlMuZ3JleSxcbiAgICAkaG92ZXI6IHtcbiAgICAgIGNvbG9yOiBDT0xPUlMuZ3JleV9kYXJrLFxuICAgICAgZmlsbDogQ09MT1JTLmdyZXlfZGFya1xuICAgIH1cbiAgfVxufV1dKTtcbnZhciBjb2xsYXBzZUljb25zID0gW2NhcmV0VXAuZXh0ZW5kKHtcbiAgb3B0aW9uczoge1xuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIHRvcDogLTIsXG4gICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICAkY29sbGFwc2VkOiB7XG4gICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pLCBjYXJldERvd24uZXh0ZW5kKHtcbiAgb3B0aW9uczoge1xuICAgIHN0eWxlOiB7XG4gICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgJGNvbGxhcHNlZDoge1xuICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pXTtcbnZhciB0ZW1wbGF0ZSA9IERPTS50ZW1wbGF0ZShbJ2RpdicsIHtcbiAgcmVmOiAnZmllbGQnLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICB3aWR0aDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuc3RhdGUud2lkdGg7XG4gICAgfSxcbiAgICBmb250RmFtaWx5OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5mb250RmFtaWx5O1xuICAgIH0sXG4gICAgLy8gYmFja2dyb3VuZENvbG9yOiAoZmllbGQpLT4gZmllbGQuc2V0dGluZ3MuY29sb3JcbiAgICBib3JkZXI6IGAxcHggc29saWQgJHtDT0xPUlMuZ3JleV9saWdodH1gLFxuICAgIGJvcmRlclJhZGl1czogMyxcbiAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAvLyBsaW5lSGVpZ2h0OiAnMWVtJ1xuICAgICR2aXNpYmxlOiB7XG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJ1xuICAgIH0sXG4gICAgJHNob3dFcnJvcjoge1xuICAgICAgJGNvbGxhcHNlZDoge1xuICAgICAgICBhbmltYXRpb246ICcwLjJzIGZpZWxkRXJyb3JTaGFrZSdcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sIFsnZGl2Jywge1xuICByZWY6ICdsYWJlbCcsXG4gIHN0eWxlOiB7XG4gICAgZGlzcGxheTogJ25vbmUnLFxuICAgIGZvbnRGYW1pbHk6ICdpbmhlcml0JyxcbiAgICBmb250U2l6ZTogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuc2V0dGluZ3MubGFiZWxTaXplO1xuICAgIH0sXG4gICAgZm9udFdlaWdodDogNjAwLFxuICAgIHRleHRBbGlnbjogJ2xlZnQnLFxuICAgIGNvbG9yOiBDT0xPUlMuYmxhY2ssXG4gICAgY3Vyc29yOiAnZGVmYXVsdCcsXG4gICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICRzaG93TGFiZWw6IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICB9LFxuICAgICRzaG93RXJyb3I6IHtcbiAgICAgIGNvbG9yOiBDT0xPUlMucmVkXG4gICAgfVxuICB9XG59XSwgWydkaXYnLCB7XG4gIHJlZjogJ2FjdGlvbnMnLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuc2V0dGluZ3MucGFkZGluZyAqICgxMiAvIDIwKTtcbiAgICB9LFxuICAgIHJpZ2h0OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5wYWRkaW5nICogKDEyIC8gMjApO1xuICAgIH0sXG4gICAgbGluZUhlaWdodDogMCxcbiAgICBmb250U2l6ZTogMCxcbiAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICRzaG93TGFiZWw6IHtcbiAgICAgIHRvcDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5wYWRkaW5nICogKDIxIC8gMjApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufV0sIFsnZGl2Jywge1xuICByZWY6ICdoZWxwJyxcbiAgc3R5bGU6IHtcbiAgICBtYXJnaW5Ub3A6ICcxMHB4JyxcbiAgICBmb250RmFtaWx5OiAnaW5oZXJpdCcsXG4gICAgZm9udFNpemU6ICcxMXB4JyxcbiAgICBjb2xvcjogQ09MT1JTLmdyZXksXG4gICAgZGlzcGxheTogJ25vbmUnLFxuICAgIHdoaXRlU3BhY2U6ICdwcmUtbGluZScsXG4gICAgJHNob3dFcnJvcjoge1xuICAgICAgY29sb3I6IENPTE9SUy5yZWQsXG4gICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgfSxcbiAgICAkc2hvd0hlbHA6IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICB9XG4gIH1cbn1dLCBbJ2RpdicsIHtcbiAgcmVmOiAnaW5uZXJ3cmFwJyxcbiAgdW5wYXNzYWJsZVN0YXRlczogWyd2aXNpYmxlJywgJ2hvdmVyJywgJ2ZvY3VzJywgJ2Rpc2FibGVkJywgJ3Nob3dMYWJlbCcsICdzaG93RXJyb3InLCAnc2hvd0hlbHAnLCAnY29sbGFwc2VkJywgJ3ZhbGlkJywgJ2ludmFsaWQnXSxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBtYXJnaW5Ub3A6IDE1LFxuICAgIGZvbnRGYW1pbHk6ICdpbmhlcml0JyxcbiAgICB0ZXh0QWxpZ246ICdqdXN0aWZ5JyxcbiAgICB0ZXh0SnVzdGlmeTogJ2Rpc3RyaWJ1dGUtYWxsLWxpbmVzJyxcbiAgICBmb250U2l6ZTogMCxcbiAgICAkY29sbGFwc2VkOiB7XG4gICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICB9XG4gIH1cbn1dXSk7dmFyIHRlbXBsYXRlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHthY3Rpb246IGFjdGlvbixjb2xsYXBzZUljb25zOiBjb2xsYXBzZUljb25zLGRlZmF1bHQ6IHRlbXBsYXRlfSk7ZXhwb3J0e3RlbXBsYXRlIGFzIGEsdGVtcGxhdGVzIGFzIGIsY29sbGFwc2VJY29ucyBhcyBjLGFjdGlvbiBhcyBkfTsiLCJpbXBvcnQnQGRhbmllbGthbGVuL2lzJztpbXBvcnQgSVMgZnJvbScuLi8uLi9jaGVja3MuanMnO2ltcG9ydCBET00gZnJvbSdxdWlja2RvbSc7aW1wb3J0IFNpbXBseUJpbmQgZnJvbSdAZGFuaWVsa2FsZW4vc2ltcGx5YmluZCc7aW1wb3J0Jy4uLy4uL2NvbnN0YW50cy9yZWdleC5qcyc7aW1wb3J0Jy4uLy4uL2hlbHBlcnMuanMnO2ltcG9ydCBleHRlbmQgZnJvbSdzbWFydC1leHRlbmQnO2ltcG9ydCdmYXN0ZG9tJztpbXBvcnQnLi4vLi4vY29tcG9uZW50cy9jb25kaXRpb24uanMnO2ltcG9ydCcuLi8uLi9maWVsZC90cmFuc2Zvcm1TZXR0aW5ncy5qcyc7aW1wb3J0Jy4uLy4uL2ZpZWxkL2dsb2JhbERlZmF1bHRzLmpzJztpbXBvcnQgRmllbGQgZnJvbScuLi8uLi9maWVsZC9pbmRleC5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jaGVja21hcmsuanMnO2ltcG9ydCcuLi8uLi9zdmcvYW5nbGVEb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NhcmV0VXAuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2FyZXREb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3BsdXMuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2xvbmUuanMnO2ltcG9ydCcuLi8uLi9zdmcvcmVtb3ZlLmpzJztpbXBvcnQnLi4vLi4vY29uc3RhbnRzL2NvbG9ycy5qcyc7aW1wb3J0IGRlZmF1bHRzIGZyb20nLi9kZWZhdWx0cy5qcyc7aW1wb3J0IHthIGFzIHRlbXBsYXRlLGIgYXMgdGVtcGxhdGVzfWZyb20nLi90ZW1wbGF0ZS0wODZhODJlMi5qcyc7dmFyIEdyb3VwRmllbGQ7XG5cbkdyb3VwRmllbGQgPSBmdW5jdGlvbiAoKSB7XG4gIGNsYXNzIEdyb3VwRmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgdGhpcy5fY2FsY0ZvY3VzU3RhdGUgPSB0aGlzLl9jYWxjRm9jdXNTdGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fY2FsY0JsdXJTdGF0ZSA9IHRoaXMuX2NhbGNCbHVyU3RhdGUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2VtaXRTdWJtaXQgPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAnc3VibWl0Jyk7XG4gICAgICB0aGlzLnN0YXRlLmNvbGxhcHNlZCA9IHRoaXMuc2V0dGluZ3Muc3RhcnRDb2xsYXBzZWQgJiYgdGhpcy5zZXR0aW5ncy5jb2xsYXBzYWJsZTtcblxuICAgICAgaWYgKHRoaXMuX3ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpZWxkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmZpZWxkc0FycmF5ID0gW107XG5cbiAgICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnRzKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzKCk7XG5cbiAgICAgIHRoaXMuX2NvbnN0cnVjdG9yRW5kKCk7XG4gICAgfVxuXG4gICAgX2dldFZhbHVlKCkge1xuICAgICAgdmFyIGZpZWxkLCBuYW1lLCByZWYsIHZhbHVlcztcbiAgICAgIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZWYgPSB0aGlzLmZpZWxkcztcblxuICAgICAgZm9yIChuYW1lIGluIHJlZikge1xuICAgICAgICBmaWVsZCA9IHJlZltuYW1lXTtcbiAgICAgICAgdmFsdWVzW25hbWVdID0gZmllbGQudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgX3NldFZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgICB2YXIgbmFtZSwgdmFsdWU7XG5cbiAgICAgIGlmIChJUy5vYmplY3QobmV3VmFsdWUpKSB7XG4gICAgICAgIGZvciAobmFtZSBpbiBuZXdWYWx1ZSkge1xuICAgICAgICAgIHZhbHVlID0gbmV3VmFsdWVbbmFtZV07XG5cbiAgICAgICAgICBpZiAodGhpcy5maWVsZHNbbmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuZmllbGRzW25hbWVdLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9yZWNhbGNEaXNwbGF5KCkge1xuICAgICAgdmFyIGZpZWxkLCBpLCBsZW4sIHJlZjtcbiAgICAgIHJlZiA9IHRoaXMuZmllbGRzQXJyYXk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmaWVsZCA9IHJlZltpXTtcblxuICAgICAgICBpZiAoZmllbGQuX3JlY2FsY0Rpc3BsYXkpIHtcbiAgICAgICAgICBmaWVsZC5fcmVjYWxjRGlzcGxheSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2NyZWF0ZUVsZW1lbnRzKCkge1xuICAgICAgdmFyIGNvbmZpZywgZmllbGQsIGZpZWxkcywgZm9yY2VPcHRzLCBpLCBsZW4sIG1hcmdpbiwgbmFtZSwgcmVmLCByZWYxO1xuICAgICAgZm9yY2VPcHRzID0ge1xuICAgICAgICByZWxhdGVkSW5zdGFuY2U6IHRoaXNcbiAgICAgIH07XG4gICAgICBtYXJnaW4gPSBgMCAwICR7dGhpcy5zZXR0aW5ncy5maWVsZE1hcmdpbn1weCAwYDtcbiAgICAgIHRoaXMuZWwgPSB0aGlzLnRlbXBsYXRlLnNwYXduKHRoaXMuc2V0dGluZ3MudGVtcGxhdGVzLmRlZmF1bHQsIGZvcmNlT3B0cyk7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNvbGxhcHNhYmxlKSB7XG4gICAgICAgIHRoaXMuYWRkQWN0aW9uKCdjb2xsYXBzZScsIHRoaXMudGVtcGxhdGVzLmNvbGxhcHNlSWNvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoSVMuYXJyYXkodGhpcy5zZXR0aW5ncy5maWVsZHMpKSB7XG4gICAgICAgIGZpZWxkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHJlZiA9IHRoaXMuc2V0dGluZ3MuZmllbGRzO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGZpZWxkID0gcmVmW2ldO1xuXG4gICAgICAgICAgaWYgKCFmaWVsZC5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZpZWxkICR7dGhpcy5uYW1lIHx8IHRoaXMuSUR9Omdyb3VwIGZpZWxkcyBwcm92aWRlZCBpbiBhcnJheSBmb3JtYXQgbXVzdCBoYXZlIGEgbmFtZWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpZWxkc1tmaWVsZC5uYW1lXSA9IGZpZWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncy5maWVsZHMgPSBmaWVsZHM7XG4gICAgICB9XG5cbiAgICAgIHJlZjEgPSB0aGlzLnNldHRpbmdzLmZpZWxkcztcblxuICAgICAgZm9yIChuYW1lIGluIHJlZjEpIHtcbiAgICAgICAgZmllbGQgPSByZWYxW25hbWVdO1xuICAgICAgICBjb25maWcgPSBleHRlbmQoe1xuICAgICAgICAgIG1hcmdpbixcbiAgICAgICAgICBmaWVsZEluc3RhbmNlczogdGhpcy5maWVsZHNcbiAgICAgICAgfSwgZmllbGQsIHtcbiAgICAgICAgICBJRDogbmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5maWVsZHNBcnJheS5wdXNoKHRoaXMuZmllbGRzW25hbWVdID0gdGhpcy5idWlsZGVyKGNvbmZpZykuYXBwZW5kVG8odGhpcy5lbC5jaGlsZC5pbm5lcndyYXApKTtcbiAgICAgICAgdGhpcy5maWVsZHNbbmFtZV0ub24oJ2ZvY3VzJywgdGhpcy5fY2FsY0ZvY3VzU3RhdGUpLm9uKCdibHVyJywgdGhpcy5fY2FsY0JsdXJTdGF0ZSkub24oJ3N1Ym1pdCcsIHRoaXMuX2VtaXRTdWJtaXQpLmVsLnN0eWxlKCd2ZXJ0aWNhbEFsaWduJywgdGhpcy5zZXR0aW5ncy5maWVsZEFsaWduKS5hZnRlcignICcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsLmNoaWxkLmlubmVyd3JhcC5hcHBlbmQoRE9NLmRpdih7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICB0aGlzLmVsLnN0YXRlKCdjb2xsYXBzYWJsZScsIHRoaXMuc2V0dGluZ3MuY29sbGFwc2FibGUpO1xuICAgICAgdGhpcy5lbC5yYXcuX3F1aWNrRmllbGQgPSB0aGlzLmVsLmNoaWxkZi5pbm5lcndyYXAucmF3Ll9xdWlja0ZpZWxkID0gdGhpcztcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3MoKSB7XG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19lbFN0YXRlKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX2Rpc3BsYXkoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3Nfc3RhdGVUcmlnZ2VycygpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc192YWx1ZSgpO1xuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc19lbFN0YXRlKCkge1xuICAgICAgU2ltcGx5QmluZCgndmlzaWJsZScpLm9mKHRoaXMuc3RhdGUpLnRvKHZpc2libGUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgndmlzaWJsZScsIHZpc2libGUpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdob3ZlcmVkJykub2YodGhpcy5zdGF0ZSkudG8oaG92ZXJlZCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdob3ZlcicsIGhvdmVyZWQpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdmb2N1c2VkJykub2YodGhpcy5zdGF0ZSkudG8oZm9jdXNlZCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdmb2N1cycsIGZvY3VzZWQpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdkaXNhYmxlZCcpLm9mKHRoaXMuc3RhdGUpLnRvKGRpc2FibGVkID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ2Rpc2FibGVkJywgZGlzYWJsZWQpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdzaG93TGFiZWwnKS5vZih0aGlzLnN0YXRlKS50byhzaG93TGFiZWwgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnc2hvd0xhYmVsJywgc2hvd0xhYmVsKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnc2hvd0Vycm9yJykub2YodGhpcy5zdGF0ZSkudG8oc2hvd0Vycm9yID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ3Nob3dFcnJvcicsIHNob3dFcnJvcik7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ3Nob3dIZWxwJykub2YodGhpcy5zdGF0ZSkudG8oc2hvd0hlbHAgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnc2hvd0hlbHAnLCBzaG93SGVscCk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ2NvbGxhcHNlZCcpLm9mKHRoaXMuc3RhdGUpLnRvKGNvbGxhcHNlZCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdjb2xsYXBzZWQnLCBjb2xsYXBzZWQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gU2ltcGx5QmluZCgndmFsaWQnKS5vZih0aGlzLnN0YXRlKS50byh2YWxpZCA9PiB7XG4gICAgICAgIHRoaXMuZWwuc3RhdGUoJ3ZhbGlkJywgdmFsaWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnaW52YWxpZCcsICF2YWxpZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3NfZGlzcGxheSgpIHtcbiAgICAgIHZhciBmaWVsZCwgaSwgbGVuLCByZWY7XG4gICAgICBTaW1wbHlCaW5kKCd3aWR0aCcpLm9mKHRoaXMuc3RhdGUpLnRvKHdpZHRoID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3R5bGUoJ3dpZHRoJywgd2lkdGgpLnN0YXRlKCdkZWZpbmVkV2lkdGgnLCB3aWR0aCAhPT0gJ2F1dG8nKTtcbiAgICAgIH0pLnRyYW5zZm9ybSh0aGlzLl9mb3JtYXRXaWR0aC5iaW5kKHRoaXMpKS51cGRhdGVPbignaXNNb2JpbGUnKS5vZih0aGlzLnN0YXRlKTtcbiAgICAgIHJlZiA9IHRoaXMuZmllbGRzQXJyYXk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmaWVsZCA9IHJlZltpXTtcbiAgICAgICAgU2ltcGx5QmluZCgnZGlzYWJsZWQnKS5vZih0aGlzLnN0YXRlKS50bygnZGlzYWJsZWQnKS5vZihmaWVsZC5zdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX3N0YXRlVHJpZ2dlcnMoKSB7XG4gICAgICB2YXIgdG9nZ2xlQ29sbGFwc2U7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNvbGxhcHNhYmxlKSB7XG4gICAgICAgIHRvZ2dsZUNvbGxhcHNlID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc3RhdGUuY29sbGFwc2VkID0gIXRoaXMuc3RhdGUuY29sbGFwc2VkO1xuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2NvbGxhcHNlZCcsIHRoaXMuc3RhdGUuY29sbGFwc2VkKTtcbiAgICAgICAgfTtcblxuICAgICAgICBTaW1wbHlCaW5kKCdldmVudDpjbGljaycpLm9mKHRoaXMuZWwuY2hpbGQuY29sbGFwc2UpLnRvKHRvZ2dsZUNvbGxhcHNlKTtcbiAgICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6Y2xpY2snKS5vZih0aGlzLmVsLmNoaWxkLmxhYmVsKS50byh0b2dnbGVDb2xsYXBzZSk7XG4gICAgICAgIFNpbXBseUJpbmQoJ2NvbGxhcHNlZCcpLm9mKHRoaXMuc3RhdGUpLm9uY2UudG8oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZWNhbGNEaXNwbGF5KCk7XG4gICAgICAgIH0pLmNvbmRpdGlvbihmdW5jdGlvbiAoY29sbGFwc2VkKSB7XG4gICAgICAgICAgcmV0dXJuICFjb2xsYXBzZWQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc192YWx1ZSgpIHtcbiAgICAgIHZhciBmaWVsZCwgZmllbGROYW1lLCByZWY7XG4gICAgICByZWYgPSB0aGlzLmZpZWxkcztcblxuICAgICAgZm9yIChmaWVsZE5hbWUgaW4gcmVmKSB7XG4gICAgICAgIGZpZWxkID0gcmVmW2ZpZWxkTmFtZV07XG4gICAgICAgIFNpbXBseUJpbmQoJ192YWx1ZScpLm9mKGZpZWxkKS50byhmaWVsZE5hbWUpLm9mKHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgU2ltcGx5QmluZCgnX3ZhbHVlJywge1xuICAgICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICAgICAgfSkub2YoZmllbGQpLnRvKHZhbHVlID0+IHtcbiAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaW50ZXJhY3RlZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zdGF0ZS52YWxpZCA9IHRoaXMudmFsaWRhdGUodm9pZCAwLCB0cnVlKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdpbnB1dCcsIHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3ZhbGlkYXRlKHByb3ZpZGVkVmFsdWUsIHRlc3RVbnJlcXVpcmVkLCByZXBvcnQpIHtcbiAgICAgIHZhciBmaWVsZCwgaSwgaXNWYWxpZCwgbGVuLCByZWYsIHNvbWVJbnZhbGlkO1xuICAgICAgc29tZUludmFsaWQgPSBmYWxzZTtcbiAgICAgIHJlZiA9IHRoaXMuZmllbGRzQXJyYXk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmaWVsZCA9IHJlZltpXTtcblxuICAgICAgICBpZiAoIWZpZWxkLnN0YXRlLnZpc2libGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXBvcnQpIHtcbiAgICAgICAgICBpc1ZhbGlkID0gZmllbGQudmFsaWRhdGVBbmRSZXBvcnQocHJvdmlkZWRWYWx1ZVtmaWVsZC5uYW1lXSwgdGVzdFVucmVxdWlyZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzVmFsaWQgPSBmaWVsZC52YWxpZGF0ZShwcm92aWRlZFZhbHVlW2ZpZWxkLm5hbWVdLCB0ZXN0VW5yZXF1aXJlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICBzb21lSW52YWxpZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICFzb21lSW52YWxpZDtcbiAgICB9XG5cbiAgICBfY2FsY0ZvY3VzU3RhdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZS5mb2N1c2VkID0gdGhpcy5maWVsZHNBcnJheS5zb21lKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICByZXR1cm4gZmllbGQuc3RhdGUuZm9jdXNlZDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9jYWxjQmx1clN0YXRlKCkge1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQodGhpcy5fY2FsY0ZvY3VzU3RhdGUpO1xuICAgIH1cblxuICAgIGZvY3VzKCkge1xuICAgICAgdmFyIGZpZWxkLCBpLCBsZW4sIHJlZjtcbiAgICAgIHRoaXMuc3RhdGUuY29sbGFwc2VkID0gZmFsc2U7XG4gICAgICByZWYgPSB0aGlzLmZpZWxkc0FycmF5O1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZmllbGQgPSByZWZbaV07XG5cbiAgICAgICAgaWYgKGZpZWxkLmZvY3VzKSB7XG4gICAgICAgICAgcmV0dXJuIGZpZWxkLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBibHVyKCkge1xuICAgICAgdmFyIGZpZWxkLCBpLCBsZW4sIHJlZjtcbiAgICAgIHJlZiA9IHRoaXMuZmllbGRzQXJyYXk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmaWVsZCA9IHJlZltpXTtcblxuICAgICAgICBpZiAoZmllbGQuYmx1cikge1xuICAgICAgICAgIHJldHVybiBmaWVsZC5ibHVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRBY3Rpb24obmFtZSwgaWNvbnMsIGNhbGxiYWNrLCBwcmVwZW5kKSB7XG4gICAgICB2YXIgYWN0aW9uLCBpLCBpY29uLCBsZW47XG5cbiAgICAgIGlmIChpY29ucyAmJiAhSVMuYXJyYXkoaWNvbnMpKSB7XG4gICAgICAgIGljb25zID0gW2ljb25zXTtcbiAgICAgIH1cblxuICAgICAgYWN0aW9uID0gdGhpcy50ZW1wbGF0ZXMuYWN0aW9uLnNwYXduKHRoaXMuc2V0dGluZ3MudGVtcGxhdGVzLmFjdGlvbiwge1xuICAgICAgICByZWxhdGVkSW5zdGFuY2U6IHRoaXNcbiAgICAgIH0pO1xuICAgICAgYWN0aW9uLnJlZiA9IGFjdGlvbi5vcHRpb25zLnJlZiA9IG5hbWU7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGljb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGljb24gPSBpY29uc1tpXTtcbiAgICAgICAgYWN0aW9uLmNoaWxkLmljb24uYXBwZW5kKGljb24pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsLmNoaWxkLmFjdGlvbnNbcHJlcGVuZCA/ICdwcmVwZW5kJyA6ICdhcHBlbmQnXShhY3Rpb24pO1xuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6Y2xpY2snKS5vZihhY3Rpb24pLnRvKGNhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9XG5cbiAgfVxuICBHcm91cEZpZWxkLnByb3RvdHlwZS50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICBHcm91cEZpZWxkLnByb3RvdHlwZS50ZW1wbGF0ZXMgPSB0ZW1wbGF0ZXM7XG4gIEdyb3VwRmllbGQucHJvdG90eXBlLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIEdyb3VwRmllbGQucHJvdG90eXBlLnNoYWxsb3dTZXR0aW5ncyA9IFsnZmllbGRzJ107XG4gIHJldHVybiBHcm91cEZpZWxkO1xufS5jYWxsKHVuZGVmaW5lZCk7XG5cbnZhciBHcm91cEZpZWxkJDEgPSBHcm91cEZpZWxkO2V4cG9ydCBkZWZhdWx0IEdyb3VwRmllbGQkMTsiLCJpbXBvcnQgRE9NIGZyb20ncXVpY2tkb20nO2ltcG9ydCcuLi8uLi9zdmcvY2hlY2ttYXJrLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2FuZ2xlRG93bi5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jYXJldFVwLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NhcmV0RG93bi5qcyc7aW1wb3J0IHBsdXMgZnJvbScuLi8uLi9zdmcvcGx1cy5qcyc7aW1wb3J0IGNsb25lIGZyb20nLi4vLi4vc3ZnL2Nsb25lLmpzJztpbXBvcnQgcmVtb3ZlIGZyb20nLi4vLi4vc3ZnL3JlbW92ZS5qcyc7aW1wb3J0IENPTE9SUyBmcm9tJy4uLy4uL2NvbnN0YW50cy9jb2xvcnMuanMnO2ltcG9ydCB7YyBhcyBjb2xsYXBzZUljb25zfWZyb20nLi4vZ3JvdXAvdGVtcGxhdGUtMDg2YTgyZTIuanMnO3ZhciB0ZW1wbGF0ZSA9IERPTS50ZW1wbGF0ZShbJ2RpdicsIHtcbiAgcmVmOiAnZmllbGQnLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICB3aWR0aDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuc3RhdGUud2lkdGg7XG4gICAgfSxcbiAgICBmb250RmFtaWx5OiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5mb250RmFtaWx5O1xuICAgIH0sXG4gICAgYm9yZGVyUmFkaXVzOiAzLFxuICAgIHRleHRBbGlnbjogJ2xlZnQnLFxuICAgICR2aXNpYmxlOiB7XG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJ1xuICAgIH0sXG4gICAgJHNob3dFcnJvcjoge1xuICAgICAgYW5pbWF0aW9uOiAnMC4ycyBmaWVsZEVycm9yU2hha2UnXG4gICAgfVxuICB9XG59LCBbJ2RpdicsIHtcbiAgcmVmOiAnbGFiZWwnLFxuICBzdHlsZToge1xuICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICBmb250RmFtaWx5OiAnaW5oZXJpdCcsXG4gICAgZm9udFNpemU6ICcxNnB4JyxcbiAgICBmb250V2VpZ2h0OiA2MDAsXG4gICAgdGV4dEFsaWduOiAnbGVmdCcsXG4gICAgY29sb3I6IENPTE9SUy5ibGFjayxcbiAgICBjdXJzb3I6ICdkZWZhdWx0JyxcbiAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgJHNob3dMYWJlbDoge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgIH0sXG4gICAgJHNob3dFcnJvcjoge1xuICAgICAgY29sb3I6IENPTE9SUy5yZWRcbiAgICB9XG4gIH1cbn1dLCBbJ2RpdicsIHtcbiAgcmVmOiAnY29sbGFwc2UnLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogNSxcbiAgICByaWdodDogMCxcbiAgICBsaW5lSGVpZ2h0OiAwLFxuICAgIGZvbnRTaXplOiAwLFxuICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAkc2hvd0xhYmVsOiB7XG4gICAgICAkY29sbGFwc2FibGU6IHtcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgfVxuICAgIH1cbiAgfVxufSwgWydkaXYnLCB7XG4gIHJlZjogJ2ljb24nLFxuICBzdHlsZToge1xuICAgIHdpZHRoOiAxNyxcbiAgICBoZWlnaHQ6IDE3LFxuICAgIGNvbG9yOiBDT0xPUlMuZ3JleSxcbiAgICBmaWxsOiBDT0xPUlMuZ3JleSxcbiAgICAkaG92ZXI6IHtcbiAgICAgIGNvbG9yOiBDT0xPUlMuZ3JleV9kYXJrLFxuICAgICAgZmlsbDogQ09MT1JTLmdyZXlfZGFya1xuICAgIH1cbiAgfVxufSwgLi4uY29sbGFwc2VJY29uc11dLCBbJ2RpdicsIHtcbiAgcmVmOiAnaGVscCcsXG4gIHN0eWxlOiB7XG4gICAgbWFyZ2luVG9wOiAnMTBweCcsXG4gICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgIGZvbnRTaXplOiAnMTFweCcsXG4gICAgY29sb3I6IENPTE9SUy5ncmV5LFxuICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAkc2hvd0Vycm9yOiB7XG4gICAgICBjb2xvcjogQ09MT1JTLnJlZCxcbiAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICB9LFxuICAgICRzaG93SGVscDoge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgIH1cbiAgfVxufV0sIFsnZGl2Jywge1xuICByZWY6ICdpbm5lcndyYXAnLFxuICB1bnBhc3NhYmxlU3RhdGVzOiBbJ3Zpc2libGUnLCAnaG92ZXInLCAnZm9jdXMnLCAnZGlzYWJsZWQnLCAnc2hvd0xhYmVsJywgJ3Nob3dFcnJvcicsICdzaG93SGVscCcsICdjb2xsYXBzZWQnLCAndmFsaWQnLCAnaW52YWxpZCddLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIG1hcmdpblRvcDogMTUsXG4gICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgIHRleHRBbGlnbjogJ2p1c3RpZnknLFxuICAgIHRleHRKdXN0aWZ5OiAnZGlzdHJpYnV0ZS1hbGwtbGluZXMnLFxuICAgIGZvbnRTaXplOiAwLFxuICAgICRjb2xsYXBzZWQ6IHtcbiAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgIH1cbiAgfVxufSwgWydkaXYnLCB7XG4gIHJlZjogJ2FkZEJ1dHRvbicsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgcGFkZGluZzogMTIsXG4gICAgYmFja2dyb3VuZENvbG9yOiBDT0xPUlMuZ3JleV9zZW1pX2xpZ2h0LFxuICAgIGJvcmRlclJhZGl1czogMyxcbiAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgbGluZUhlaWdodDogJzFlbScsXG4gICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAkZGlzYWJsZWQ6IHtcbiAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgIH0sXG4gICAgJGlubGluZVN0eWxlOiB7XG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIHRvcDogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBmaWVsZC5zZXR0aW5ncy5ncm91cE1hcmdpbiAvIDIgKiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sIFsnZGl2Jywge1xuICBzdHlsZToge1xuICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgIHdpZHRoOiAxNSxcbiAgICBoZWlnaHQ6IDE1LFxuICAgIGNvbG9yOiBDT0xPUlMuYmxhY2ssXG4gICAgZmlsbDogQ09MT1JTLmJsYWNrXG4gIH1cbn0sIHBsdXNdXV1dKTtcbnZhciBjbG9uZUljb24gPSBjbG9uZS5leHRlbmQoe1xuICBvcHRpb25zOiB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHdpZHRoOiAxMVxuICAgIH1cbiAgfVxufSk7XG52YXIgcmVtb3ZlSWNvbiA9IHJlbW92ZS5leHRlbmQoe1xuICBvcHRpb25zOiB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHdpZHRoOiAxMVxuICAgIH1cbiAgfVxufSk7XG52YXIgYmxvY2tHcm91cCA9IHt9O1xudmFyIGlubGluZUdyb3VwID0ge1xuICBkZWZhdWx0OiB7XG4gICAgLy8gb3B0aW9uczogc3R5bGU6XG4gICAgLy8gXHR2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJ1xuICAgIGNoaWxkcmVuOiB7XG4gICAgICBpbm5lcndyYXA6IHtcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICBpbnNlcnRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnRBZnRlcih0aGlzLnBhcmVudC5jaGlsZC5pbm5lcndyYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnc3RhdGljJyxcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS10YWJsZSdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGFjdGlvbjogWydkaXYnLCB7XG4gICAgZXZlbnRzOiB7XG4gICAgICBpbnNlcnRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0eWxlKCdib3JkZXJUb3AnLCBgMXB4IHNvbGlkICR7Q09MT1JTLmdyZXl9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgIGRpc3BsYXk6ICd0YWJsZS1yb3cnLFxuICAgICAgcGFkZGluZzogNFxuICAgIH1cbiAgfSwgWydkaXYnLCB7XG4gICAgcmVmOiAnaWNvbicsXG4gICAgc3R5bGU6IHtcbiAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgZGlzcGxheTogJ3RhYmxlLWNlbGwnLFxuICAgICAgY29sb3I6IENPTE9SUy5ibGFjayxcbiAgICAgIGZpbGw6IENPTE9SUy5ibGFjayxcbiAgICAgIG9wYWNpdHk6IDAuNixcbiAgICAgICRob3Zlcjoge1xuICAgICAgICBvcGFjaXR5OiAxXG4gICAgICB9XG4gICAgfVxuICB9XV1cbn07dmFyIHRlbXBsYXRlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtkZWZhdWx0OiB0ZW1wbGF0ZSxjbG9uZUljb246IGNsb25lSWNvbixyZW1vdmVJY29uOiByZW1vdmVJY29uLGJsb2NrR3JvdXA6IGJsb2NrR3JvdXAsaW5saW5lR3JvdXA6IGlubGluZUdyb3VwfSk7ZXhwb3J0e2lubGluZUdyb3VwIGFzIGEsYmxvY2tHcm91cCBhcyBiLHRlbXBsYXRlIGFzIGMsdGVtcGxhdGVzIGFzIGQsY2xvbmVJY29uIGFzIGUscmVtb3ZlSWNvbiBhcyBmfTsiLCJpbXBvcnQncXVpY2tkb20nO2ltcG9ydCcuLi8uLi9zdmcvY2hlY2ttYXJrLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2FuZ2xlRG93bi5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jYXJldFVwLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NhcmV0RG93bi5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9wbHVzLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2Nsb25lLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3JlbW92ZS5qcyc7aW1wb3J0Jy4uLy4uL2NvbnN0YW50cy9jb2xvcnMuanMnO2ltcG9ydCcuLi9ncm91cC90ZW1wbGF0ZS0wODZhODJlMi5qcyc7aW1wb3J0IHthIGFzIGlubGluZUdyb3VwLGIgYXMgYmxvY2tHcm91cH1mcm9tJy4vdGVtcGxhdGUtN2MyODRlNjEuanMnO3ZhciBkZWZhdWx0cyA9IHtcbiAgZmllbGRzOiBudWxsLFxuICBzdHlsZTogJ2Jsb2NrJyxcbiAgY29sbGFwc2FibGU6IHRydWUsXG4gIHN0YXJ0Q29sbGFwc2VkOiBmYWxzZSxcbiAgZ3JvdXBNYXJnaW46IDEwLFxuICBncm91cFdpZHRoOiAnMTAwJScsXG4gIGF1dG9XaWR0aDogdHJ1ZSxcbiAgYXV0b1JlbW92ZUVtcHR5OiBmYWxzZSxcbiAgZHluYW1pY0xhYmVsOiBmYWxzZSxcbiAgbWluSXRlbXM6IG51bGwsXG4gIG1heEl0ZW1zOiBudWxsLFxuICBkcmFnZ2FibGU6IGZhbHNlLFxuICBjbG9uZWFibGU6IGZhbHNlLFxuICByZW1vdmVhYmxlOiB0cnVlLFxuICBzaW5nbGVNb2RlOiBmYWxzZSxcbiAgbnVtYmVyaW5nOiBmYWxzZSxcbiAgbXVsdGlwbGU6IHRydWUsXG4gIGdyb3VwU2V0dGluZ3M6IHtcbiAgICBsYWJlbFNpemU6IDE0LFxuICAgIGlubGluZToge1xuICAgICAgcGFkZGluZzogMCxcbiAgICAgIGZpZWxkTWFyZ2luOiAwLFxuICAgICAgd2lkdGg6ICdhdXRvJyxcbiAgICAgIGNvbGxhcHNhYmxlOiBmYWxzZSxcbiAgICAgIHN0YXJ0Q29sbGFwc2VkOiBmYWxzZSxcbiAgICAgIHRlbXBsYXRlczogaW5saW5lR3JvdXBcbiAgICB9LFxuICAgIGJsb2NrOiB7XG4gICAgICBzdGFydENvbGxhcHNlZDogZmFsc2UsXG4gICAgICB0ZW1wbGF0ZXM6IGJsb2NrR3JvdXBcbiAgICB9XG4gIH1cbn07ZXhwb3J0IGRlZmF1bHQgZGVmYXVsdHM7IiwiaW1wb3J0J0BkYW5pZWxrYWxlbi9pcyc7aW1wb3J0IElTIGZyb20nLi4vLi4vY2hlY2tzLmpzJztpbXBvcnQncXVpY2tkb20nO2ltcG9ydCBTaW1wbHlCaW5kIGZyb20nQGRhbmllbGthbGVuL3NpbXBseWJpbmQnO2ltcG9ydCcuLi8uLi9jb25zdGFudHMvcmVnZXguanMnO2ltcG9ydCB7aW5jbHVkZXMsaW5zZXJ0QWZ0ZXIscmVtb3ZlSXRlbX1mcm9tJy4uLy4uL2hlbHBlcnMuanMnO2ltcG9ydCBleHRlbmQgZnJvbSdzbWFydC1leHRlbmQnO2ltcG9ydCdmYXN0ZG9tJztpbXBvcnQnLi4vLi4vY29tcG9uZW50cy9jb25kaXRpb24uanMnO2ltcG9ydCcuLi8uLi9maWVsZC90cmFuc2Zvcm1TZXR0aW5ncy5qcyc7aW1wb3J0Jy4uLy4uL2ZpZWxkL2dsb2JhbERlZmF1bHRzLmpzJztpbXBvcnQgRmllbGQgZnJvbScuLi8uLi9maWVsZC9pbmRleC5qcyc7aW1wb3J0Jy4uLy4uL3N2Zy9jaGVja21hcmsuanMnO2ltcG9ydCcuLi8uLi9zdmcvYW5nbGVEb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL2NhcmV0VXAuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2FyZXREb3duLmpzJztpbXBvcnQnLi4vLi4vc3ZnL3BsdXMuanMnO2ltcG9ydCcuLi8uLi9zdmcvY2xvbmUuanMnO2ltcG9ydCcuLi8uLi9zdmcvcmVtb3ZlLmpzJztpbXBvcnQnLi4vLi4vY29uc3RhbnRzL2NvbG9ycy5qcyc7aW1wb3J0Jy4uL2dyb3VwL3RlbXBsYXRlLTA4NmE4MmUyLmpzJztpbXBvcnQge2MgYXMgdGVtcGxhdGUsZCBhcyB0ZW1wbGF0ZXN9ZnJvbScuL3RlbXBsYXRlLTdjMjg0ZTYxLmpzJztpbXBvcnQgZGVmYXVsdHMgZnJvbScuL2RlZmF1bHRzLmpzJzt2YXIgUmVwZWF0ZXJGaWVsZDtcblxuUmVwZWF0ZXJGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgY2xhc3MgUmVwZWF0ZXJGaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHZhciBiYXNlLCBkaWZmO1xuICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuX2NhbGNGb2N1c1N0YXRlID0gdGhpcy5fY2FsY0ZvY3VzU3RhdGUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2NhbGNCbHVyU3RhdGUgPSB0aGlzLl9jYWxjQmx1clN0YXRlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9lbWl0U3VibWl0ID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ3N1Ym1pdCcpO1xuICAgICAgdGhpcy5ncm91cExhYmVsID0gSVMuc3RyaW5nKHRoaXMuc2V0dGluZ3MubnVtYmVyaW5nKSA/IHRoaXMuc2V0dGluZ3MubnVtYmVyaW5nIDogJ0l0ZW0nO1xuICAgICAgdGhpcy5sYWJlbFJlZ2V4ID0gbmV3IFJlZ0V4cChgXiR7dGhpcy5ncm91cExhYmVsfSBcXFxcZCsoPzpcXDogKT9gKTtcbiAgICAgIHRoaXMuc3RhdGUuY29sbGFwc2VkID0gdGhpcy5zZXR0aW5ncy5zdGFydENvbGxhcHNlZCAmJiB0aGlzLnNldHRpbmdzLmNvbGxhcHNhYmxlO1xuXG4gICAgICBpZiAodGhpcy5fdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldHRpbmdzLl9ncm91cFNldHRpbmdzID0gZXh0ZW5kLm5vdEtleXMoWydpbmxpbmUnLCAnYmxvY2snXSkuY2xvbmUodGhpcy5zZXR0aW5ncy5ncm91cFNldHRpbmdzKTtcbiAgICAgIHRoaXMuc2V0dGluZ3MuZ3JvdXBTZXR0aW5ncyA9IGV4dGVuZC5rZXlzKFsnaW5saW5lJywgJ2Jsb2NrJ10pLmNsb25lKHRoaXMuc2V0dGluZ3MuZ3JvdXBTZXR0aW5ncyk7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0eWxlID09PSAnYmxvY2snKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZmllbGQpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5zaW5nbGVNb2RlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2luZ2xlTW9kZSkge1xuICAgICAgICB0aGlzLnNldHRpbmdzLmZpZWxkcyA9IFt0aGlzLnNldHRpbmdzLmZpZWxkIHx8IHRoaXMuc2V0dGluZ3MuZmllbGRzXTtcbiAgICAgIH1cblxuICAgICAgaWYgKChiYXNlID0gdGhpcy5zZXR0aW5ncykudmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBiYXNlLnZhbHVlID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLm1pbkl0ZW1zICYmIHRoaXMuc2V0dGluZ3MudmFsdWUubGVuZ3RoIDwgdGhpcy5zZXR0aW5ncy5taW5JdGVtcykge1xuICAgICAgICBkaWZmID0gdGhpcy5zZXR0aW5ncy5taW5JdGVtcyAtIHRoaXMuc2V0dGluZ3MudmFsdWUubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgtLWRpZmYpIHtcbiAgICAgICAgICB0aGlzLnNldHRpbmdzLnZhbHVlLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fY3JlYXRlRWxlbWVudHMoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3MoKTtcblxuICAgICAgdGhpcy5fY29uc3RydWN0b3JFbmQoKTtcbiAgICB9XG5cbiAgICBfZ2V0VmFsdWUoKSB7XG4gICAgICB2YXIgZ3JvdXAsIGksIGluZGV4LCBsZW4sIHJlZiwgdmFsdWVzO1xuICAgICAgdmFsdWVzID0gW107XG4gICAgICByZWYgPSB0aGlzLl92YWx1ZTtcblxuICAgICAgZm9yIChpbmRleCA9IGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpbmRleCA9ICsraSkge1xuICAgICAgICBncm91cCA9IHJlZltpbmRleF07XG4gICAgICAgIHZhbHVlc1tpbmRleF0gPSBncm91cC52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICBfc2V0VmFsdWUobmV3VmFsdWUpIHtcbiAgICAgIHZhciBpLCBpbmRleCwgbGVuLCB2YWx1ZTtcblxuICAgICAgaWYgKCFJUy5hcnJheShuZXdWYWx1ZSkpIHtcbiAgICAgICAgdGhpcy5hZGRJdGVtKG5ld1ZhbHVlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGluZGV4ID0gaSA9IDAsIGxlbiA9IG5ld1ZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgaW5kZXggPSArK2kpIHtcbiAgICAgICAgICB2YWx1ZSA9IG5ld1ZhbHVlW2luZGV4XTtcblxuICAgICAgICAgIGlmICh0aGlzLl92YWx1ZVtpbmRleF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVbaW5kZXhdLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkSXRlbSh2YWx1ZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUVsZW1lbnRzKCkge1xuICAgICAgdmFyIGZvcmNlT3B0cztcbiAgICAgIGZvcmNlT3B0cyA9IHtcbiAgICAgICAgcmVsYXRlZEluc3RhbmNlOiB0aGlzXG4gICAgICB9O1xuICAgICAgdGhpcy5lbCA9IHRoaXMudGVtcGxhdGUuc3Bhd24odGhpcy5zZXR0aW5ncy50ZW1wbGF0ZXMuZGVmYXVsdCwgZm9yY2VPcHRzKTtcbiAgICAgIHRoaXMuZWwuc3RhdGUoJ2NvbGxhcHNhYmxlJywgdGhpcy5zZXR0aW5ncy5jb2xsYXBzYWJsZSk7XG4gICAgICB0aGlzLmVsLnN0YXRlKGAke3RoaXMuc2V0dGluZ3Muc3R5bGV9U3R5bGVgLCB0cnVlKTtcbiAgICAgIHRoaXMuZWwucmF3Ll9xdWlja0ZpZWxkID0gdGhpcy5lbC5jaGlsZGYuaW5uZXJ3cmFwLnJhdy5fcXVpY2tGaWVsZCA9IHRoaXM7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzKCkge1xuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfZWxTdGF0ZSgpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hCaW5kaW5nc19kaXNwbGF5KCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzX3N0YXRlVHJpZ2dlcnMoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3NfdmFsdWUoKTtcbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3NfZWxTdGF0ZSgpIHtcbiAgICAgIFNpbXBseUJpbmQoJ3Zpc2libGUnKS5vZih0aGlzLnN0YXRlKS50byh2aXNpYmxlID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ3Zpc2libGUnLCB2aXNpYmxlKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZGlzYWJsZWQnKS5vZih0aGlzLnN0YXRlKS50byhkaXNhYmxlZCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdkaXNhYmxlZCcsIGRpc2FibGVkKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnc2hvd0xhYmVsJykub2YodGhpcy5zdGF0ZSkudG8oc2hvd0xhYmVsID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ3Nob3dMYWJlbCcsIHNob3dMYWJlbCk7XG4gICAgICB9KTtcbiAgICAgIFNpbXBseUJpbmQoJ3Nob3dFcnJvcicpLm9mKHRoaXMuc3RhdGUpLnRvKHNob3dFcnJvciA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0YXRlKCdzaG93RXJyb3InLCBzaG93RXJyb3IpO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdzaG93SGVscCcpLm9mKHRoaXMuc3RhdGUpLnRvKHNob3dIZWxwID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ3Nob3dIZWxwJywgc2hvd0hlbHApO1xuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdjb2xsYXBzZWQnKS5vZih0aGlzLnN0YXRlKS50byhjb2xsYXBzZWQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zdGF0ZSgnY29sbGFwc2VkJywgY29sbGFwc2VkKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFNpbXBseUJpbmQoJ3ZhbGlkJykub2YodGhpcy5zdGF0ZSkudG8odmFsaWQgPT4ge1xuICAgICAgICB0aGlzLmVsLnN0YXRlKCd2YWxpZCcsIHZhbGlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc3RhdGUoJ2ludmFsaWQnLCAhdmFsaWQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX2Rpc3BsYXkoKSB7XG4gICAgICB2YXIgZ3JvdXAsIGksIGxlbiwgcmVmO1xuICAgICAgU2ltcGx5QmluZCgnd2lkdGgnKS5vZih0aGlzLnN0YXRlKS50byh3aWR0aCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnN0eWxlKCd3aWR0aCcsIHdpZHRoKS5zdGF0ZSgnZGVmaW5lZFdpZHRoJywgd2lkdGggIT09ICdhdXRvJyk7XG4gICAgICB9KS50cmFuc2Zvcm0odGhpcy5fZm9ybWF0V2lkdGguYmluZCh0aGlzKSkudXBkYXRlT24oJ2lzTW9iaWxlJykub2YodGhpcy5zdGF0ZSk7XG4gICAgICBTaW1wbHlCaW5kKCdzaG93RXJyb3InLCB7XG4gICAgICAgIHVwZGF0ZU9uQmluZDogZmFsc2VcbiAgICAgIH0pLm9mKHRoaXMuc3RhdGUpLnRvKHNob3dFcnJvciA9PiB7XG4gICAgICAgIHZhciBncm91cCwgaSwgbGVuLCByZWYsIHJlc3VsdHM7XG4gICAgICAgIHJlZiA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICByZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgZ3JvdXAgPSByZWZbaV07XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGdyb3VwLnN0YXRlLnNob3dFcnJvciA9IHNob3dFcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH0pO1xuICAgICAgcmVmID0gdGhpcy5fdmFsdWU7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBncm91cCA9IHJlZltpXTtcbiAgICAgICAgU2ltcGx5QmluZCgnZGlzYWJsZWQnKS5vZih0aGlzLnN0YXRlKS50bygnZGlzYWJsZWQnKS5vZihmaWVsZC5zdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2F0dGFjaEJpbmRpbmdzX3N0YXRlVHJpZ2dlcnMoKSB7XG4gICAgICB2YXIgdG9nZ2xlQ29sbGFwc2U7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNvbGxhcHNhYmxlKSB7XG4gICAgICAgIHRvZ2dsZUNvbGxhcHNlID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc3RhdGUuY29sbGFwc2VkID0gIXRoaXMuc3RhdGUuY29sbGFwc2VkO1xuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2NvbGxhcHNlZCcsIHRoaXMuc3RhdGUuY29sbGFwc2VkKTtcbiAgICAgICAgfTtcblxuICAgICAgICBTaW1wbHlCaW5kKCdldmVudDpjbGljaycpLm9mKHRoaXMuZWwuY2hpbGQuY29sbGFwc2UpLnRvKHRvZ2dsZUNvbGxhcHNlKTtcbiAgICAgICAgU2ltcGx5QmluZCgnZXZlbnQ6Y2xpY2snKS5vZih0aGlzLmVsLmNoaWxkLmxhYmVsKS50byh0b2dnbGVDb2xsYXBzZSk7XG4gICAgICAgIFNpbXBseUJpbmQoJ2NvbGxhcHNlZCcpLm9mKHRoaXMuc3RhdGUpLm9uY2UudG8oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZWNhbGNEaXNwbGF5KCk7XG4gICAgICAgIH0pLmNvbmRpdGlvbihmdW5jdGlvbiAoY29sbGFwc2VkKSB7XG4gICAgICAgICAgcmV0dXJuICFjb2xsYXBzZWQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5nc192YWx1ZSgpIHtcbiAgICAgIFNpbXBseUJpbmQoJ2FycmF5Ol92YWx1ZScsIHtcbiAgICAgICAgdXBkYXRlT25CaW5kOiB0cnVlXG4gICAgICB9KS5vZih0aGlzKS50bygodmFsdWUsIHByZXZWYWx1ZSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5fcmVjYWxjTGFiZWxzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldlZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5pbnRlcmFjdGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS52YWxpZCA9IHRoaXMudmFsaWRhdGUodm9pZCAwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBTaW1wbHlCaW5kKCdldmVudDpjbGljaycpLm9mKHRoaXMuZWwuY2hpbGQuYWRkQnV0dG9uKS50bygoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZEl0ZW0oKS5mb2N1cygpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3ZhbGlkYXRlKHByb3ZpZGVkVmFsdWUsIHRlc3RVbnJlcXVpcmVkKSB7XG4gICAgICB2YXIgZ3JvdXAsIGksIGlzVmFsaWQsIGxlbiwgcmVmO1xuICAgICAgcmVmID0gdGhpcy5fdmFsdWU7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBncm91cCA9IHJlZltpXTtcbiAgICAgICAgaXNWYWxpZCA9IGdyb3VwLnZhbGlkYXRlKHByb3ZpZGVkVmFsdWVbZ3JvdXAubmFtZV0sIHRlc3RVbnJlcXVpcmVkKTtcblxuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgX2NhbGNGb2N1c1N0YXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZm9jdXNlZCA9IHRoaXMuX3ZhbHVlLnNvbWUoZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBmaWVsZC5zdGF0ZS5mb2N1c2VkO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2NhbGNCbHVyU3RhdGUoKSB7XG4gICAgICByZXR1cm4gc2V0VGltZW91dCh0aGlzLl9jYWxjRm9jdXNTdGF0ZSk7XG4gICAgfVxuXG4gICAgZm9jdXMoKSB7XG4gICAgICB2YXIgcmVmO1xuICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLl92YWx1ZVswXSkgIT0gbnVsbCA/IHJlZi5mb2N1cygpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIGJsdXIoKSB7XG4gICAgICB2YXIgZmllbGQsIGksIGxlbiwgcmVmO1xuICAgICAgcmVmID0gdGhpcy5fdmFsdWU7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmaWVsZCA9IHJlZltpXTtcblxuICAgICAgICBpZiAoZmllbGQuYmx1cikge1xuICAgICAgICAgIGZpZWxkLmJsdXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9yZWNhbGNMYWJlbHMoKSB7XG4gICAgICB2YXIgZ3JvdXAsIGksIGluZGV4LCBsZW4sIHJlZjtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3R5bGUgPT09ICdibG9jaycpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLm51bWJlcmluZyAmJiAhdGhpcy5zZXR0aW5ncy5keW5hbWljTGFiZWwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZWYgPSB0aGlzLl92YWx1ZTtcblxuICAgICAgICBmb3IgKGluZGV4ID0gaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGluZGV4ID0gKytpKSB7XG4gICAgICAgICAgZ3JvdXAgPSByZWZbaW5kZXhdO1xuXG4gICAgICAgICAgdGhpcy5fcmVjYWxjTGFiZWwoZ3JvdXAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9yZWNhbGNMYWJlbChncm91cCwgaW5kZXgpIHtcbiAgICAgIHZhciBleGlzdGluZ0xhYmVsLCBuZXdMYWJlbDtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZHluYW1pY0xhYmVsICYmIGdyb3VwLmZpZWxkc1t0aGlzLnNldHRpbmdzLmR5bmFtaWNMYWJlbF0pIHtcbiAgICAgICAgbmV3TGFiZWwgPSBncm91cC5maWVsZHNbdGhpcy5zZXR0aW5ncy5keW5hbWljTGFiZWxdLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmdMYWJlbCA9IGdyb3VwLnN0YXRlLmxhYmVsIHx8ICcnO1xuICAgICAgICBleGlzdGluZ0xhYmVsID0gZXhpc3RpbmdMYWJlbC5yZXBsYWNlKHRoaXMubGFiZWxSZWdleCwgJycpO1xuICAgICAgICBuZXdMYWJlbCA9IGAke3RoaXMuZ3JvdXBMYWJlbH0gJHtpbmRleCArIDF9YDtcblxuICAgICAgICBpZiAoZXhpc3RpbmdMYWJlbCkge1xuICAgICAgICAgIG5ld0xhYmVsICs9IGA6ICR7ZXhpc3RpbmdMYWJlbH1gO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncm91cC5zdGF0ZS5sYWJlbCA9IG5ld0xhYmVsO1xuICAgIH1cblxuICAgIF9yZWNhbGNEaXNwbGF5KCkge1xuICAgICAgdmFyIGdyb3VwLCBpLCBsZW4sIHJlZjtcbiAgICAgIHJlZiA9IHRoaXMuX3ZhbHVlO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSByZWZbaV07XG5cbiAgICAgICAgaWYgKGdyb3VwLl9yZWNhbGNEaXNwbGF5KSB7XG4gICAgICAgICAgZ3JvdXAuX3JlY2FsY0Rpc3BsYXkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGFkZEl0ZW0odmFsdWUsIHNraXBJbnNlcnQsIHNraXBFbWl0KSB7XG4gICAgICB2YXIgZmlyc3RGaWVsZCwgZ3JvdXAsIG1hcmdpbiwgcmVmcmVzaENoaWxkcmVuLCBzZXR0aW5ncztcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubWF4SXRlbXMgJiYgdGhpcy5fdmFsdWUubGVuZ3RoID09PSB0aGlzLnNldHRpbmdzLm1heEl0ZW1zIHx8IHRoaXMuc3RhdGUuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtYXJnaW4gPSB0aGlzLnNldHRpbmdzLnN0eWxlID09PSAnaW5saW5lJyA/IGAwICR7dGhpcy5zZXR0aW5ncy5ncm91cE1hcmdpbn1weCAke3RoaXMuc2V0dGluZ3MuZ3JvdXBNYXJnaW59cHggMGAgOiBgMCAwICR7dGhpcy5zZXR0aW5ncy5ncm91cE1hcmdpbn1weCAwYDtcbiAgICAgIHNldHRpbmdzID0gZXh0ZW5kKHtcbiAgICAgICAgdHlwZTogJ2dyb3VwJyxcbiAgICAgICAgZmllbGRzOiB0aGlzLnNldHRpbmdzLmZpZWxkcyxcbiAgICAgICAgbWFyZ2luLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSwgdGhpcy5zZXR0aW5ncy5fZ3JvdXBTZXR0aW5ncywgdGhpcy5zZXR0aW5ncy5ncm91cFNldHRpbmdzW3RoaXMuc2V0dGluZ3Muc3R5bGVdKTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2luZ2xlTW9kZSkge1xuICAgICAgICBmaXJzdEZpZWxkID0gdGhpcy5zZXR0aW5ncy5maWVsZHNbMF0ubmFtZTtcblxuICAgICAgICBzZXR0aW5ncy5nZXR0ZXIgPSBmdW5jdGlvbiAoZmllbGRzKSB7XG4gICAgICAgICAgcmV0dXJuIGZpZWxkc1tmaXJzdEZpZWxkXTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZXR0aW5ncy5zZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW2Ake2ZpcnN0RmllbGR9YF06IHZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZ3JvdXAgPSB0aGlzLmJ1aWxkZXIoc2V0dGluZ3MpO1xuICAgICAgZ3JvdXAuZWwuY2hpbGQuYWN0aW9ucy5hcHBlbmQodGhpcy5zZXR0aW5ncy5ncm91cFNldHRpbmdzW3RoaXMuc2V0dGluZ3Muc3R5bGVdKTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2xvbmVhYmxlKSB7XG4gICAgICAgIGdyb3VwLmFkZEFjdGlvbignY2xvbmUnLCB0aGlzLnRlbXBsYXRlcy5jbG9uZUljb24sIHRoaXMuY2xvbmVJdGVtLmJpbmQodGhpcywgZ3JvdXApLCB0aGlzLnNldHRpbmdzLnN0eWxlID09PSAnYmxvY2snKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucmVtb3ZlYWJsZSkge1xuICAgICAgICBncm91cC5hZGRBY3Rpb24oJ3JlbW92ZScsIHRoaXMudGVtcGxhdGVzLnJlbW92ZUljb24sIHRoaXMucmVtb3ZlSXRlbS5iaW5kKHRoaXMsIGdyb3VwKSwgdGhpcy5zZXR0aW5ncy5zdHlsZSA9PT0gJ2Jsb2NrJyk7XG4gICAgICB9XG5cbiAgICAgIGdyb3VwLm9uKCdmb2N1cycsIHRoaXMuX2NhbGNGb2N1c1N0YXRlKTtcbiAgICAgIGdyb3VwLm9uKCdibHVyJywgdGhpcy5fY2FsY0JsdXJTdGF0ZSk7XG4gICAgICBncm91cC5vbignc3VibWl0JywgdGhpcy5fZW1pdFN1Ym1pdCk7XG4gICAgICBTaW1wbHlCaW5kKCdldmVudDppbnB1dCcpLm9mKGdyb3VwKS50bygoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2lucHV0JywgdGhpcy5fdmFsdWUsIGdyb3VwKTtcbiAgICAgIH0pO1xuICAgICAgU2ltcGx5QmluZCgnZGlzYWJsZWQnKS5vZih0aGlzLnN0YXRlKS50bygnZGlzYWJsZWQnKS5vZihncm91cC5zdGF0ZSk7XG4gICAgICByZWZyZXNoQ2hpbGRyZW4gPSBncm91cC5lbC5jaGlsZGY7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmR5bmFtaWNMYWJlbCkge1xuICAgICAgICBncm91cC5vbignaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY2FsY0xhYmVsKGdyb3VwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmF1dG9SZW1vdmVFbXB0eSkge1xuICAgICAgICBncm91cC5vbmNlKCdibHVyJywgKCkgPT4ge1xuICAgICAgICAgIGlmICghZ3JvdXAuc3RhdGUuaW50ZXJhY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlSXRlbShncm91cCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCkge1xuICAgICAgICBncm91cC5zdGF0ZS53aWR0aCA9IHRoaXMuc2V0dGluZ3MuZ3JvdXBXaWR0aDtcbiAgICAgICAgZ3JvdXAuZWwuY2hpbGQuaW5uZXJ3cmFwLm9uY2UoJ2luc2VydGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0eWxlKCd3aWR0aCcsIGBjYWxjKDEwMCUgLSAke3RoaXMucGFyZW50LmNoaWxkLmFjdGlvbnMud2lkdGggfHwgMTd9cHgpYCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNraXBJbnNlcnQpIHtcbiAgICAgICAgZ3JvdXAuaW5zZXJ0QmVmb3JlKHRoaXMuZWwuY2hpbGQuYWRkQnV0dG9uKTtcblxuICAgICAgICBpZiAoIXNraXBFbWl0KSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdpdGVtQWRkJywgZ3JvdXApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmFsdWUucHVzaChncm91cCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG5cbiAgICBjbG9uZUl0ZW0oZ3JvdXApIHtcbiAgICAgIHZhciBjbG9uZTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubWF4SXRlbXMgJiYgdGhpcy5fdmFsdWUubGVuZ3RoID09PSB0aGlzLnNldHRpbmdzLm1heEl0ZW1zIHx8IHRoaXMuc3RhdGUuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluY2x1ZGVzKHRoaXMuX3ZhbHVlLCBncm91cCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjbG9uZSA9IHRoaXMuYWRkSXRlbShncm91cC52YWx1ZSwgdHJ1ZSk7XG4gICAgICBjbG9uZS5pbnNlcnRBZnRlcihncm91cC5lbCk7XG4gICAgICBpbnNlcnRBZnRlcih0aGlzLl92YWx1ZSwgZ3JvdXAsIGNsb25lKTtcbiAgICAgIHRoaXMuZW1pdCgnaXRlbUFkZCcsIGNsb25lKTtcbiAgICAgIHRoaXMuZW1pdCgnaXRlbUNsb25lJywgY2xvbmUpO1xuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cblxuICAgIHJlbW92ZUl0ZW0oZ3JvdXApIHtcbiAgICAgIHZhciByZWYsIHJlbW92ZWQsIHRhcmdldEluZGV4O1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5taW5JdGVtcyAmJiB0aGlzLl92YWx1ZS5sZW5ndGggPT09IHRoaXMuc2V0dGluZ3MubWluSXRlbXMgfHwgdGhpcy5zdGF0ZS5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRhcmdldEluZGV4ID0gTWF0aC5tYXgoMSwgdGhpcy5fdmFsdWUuaW5kZXhPZihncm91cCkpO1xuXG4gICAgICBpZiAocmVtb3ZlZCA9IHJlbW92ZUl0ZW0odGhpcy5fdmFsdWUsIGdyb3VwKSkge1xuICAgICAgICBncm91cC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZW1pdCgnaXRlbVJlbW92ZScsIGdyb3VwKTtcblxuICAgICAgICBpZiAoKHJlZiA9IHRoaXMuX3ZhbHVlW3RhcmdldEluZGV4IC0gMV0pICE9IG51bGwpIHtcbiAgICAgICAgICByZWYuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gISFyZW1vdmVkO1xuICAgIH1cblxuICB9XG4gIFJlcGVhdGVyRmllbGQucHJvdG90eXBlLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gIFJlcGVhdGVyRmllbGQucHJvdG90eXBlLnRlbXBsYXRlcyA9IHRlbXBsYXRlcztcbiAgUmVwZWF0ZXJGaWVsZC5wcm90b3R5cGUuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgUmVwZWF0ZXJGaWVsZC5wcm90b3R5cGUuc2hhbGxvd1NldHRpbmdzID0gWydmaWVsZHMnXTtcbiAgcmV0dXJuIFJlcGVhdGVyRmllbGQ7XG59LmNhbGwodW5kZWZpbmVkKTtcblxudmFyIFJlcGVhdGVyRmllbGQkMSA9IFJlcGVhdGVyRmllbGQ7ZXhwb3J0IGRlZmF1bHQgUmVwZWF0ZXJGaWVsZCQxOyIsImltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi9oZWxwZXJzJ1xuaW1wb3J0IHByb21pc2VFdmVudCBmcm9tICdwLWV2ZW50J1xuaW1wb3J0IGV4dGVuZCBmcm9tICdzbWFydC1leHRlbmQnXG5pbXBvcnQgRE9NIGZyb20gJ3F1aWNrZG9tJ1xuaW1wb3J0IENPTE9SUyBmcm9tICcuLi9zcmMvY29uc3RhbnRzL2NvbG9ycydcbmltcG9ydCBjaGFpIGZyb20gJ2NoYWknXG5pbXBvcnQgY2hhaURvbSBmcm9tICdjaGFpLWRvbSdcbmltcG9ydCBjaGFpU3R5bGUgZnJvbSAnY2hhaS1zdHlsZSdcbmltcG9ydCBjaGFpQWxtb3N0IGZyb20gJ2NoYWktYWxtb3N0J1xuaW1wb3J0IGNoYWlBc3NlcnR0eXBlIGZyb20gJ2NoYWktYXNzZXJ0dHlwZSdcbmltcG9ydCBjaGFpRXZlbnRzIGZyb20gJ2NoYWktZXZlbnRzJ1xuY2hhaS51c2UoY2hhaURvbSlcbmNoYWkudXNlKGNoYWlTdHlsZSlcbmNoYWkudXNlKGNoYWlBbG1vc3QpXG5jaGFpLnVzZShjaGFpQXNzZXJ0dHlwZSlcbmNoYWkudXNlKGNoYWlFdmVudHMpXG5jaGFpLmNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCA9IDFlM1xubW9jaGEuc2V0dXAoJ3RkZCcpXG5tb2NoYS5zbG93KDQwMClcbm1vY2hhLnRpbWVvdXQoMTIwMDApXG5tb2NoYS5iYWlsKCkgdW5sZXNzIHdpbmRvdy5fX2thcm1hX19cbmFzc2VydCA9IGNoYWkuYXNzZXJ0XG5leHBlY3QgPSBjaGFpLmV4cGVjdFxud2luZG93LnNhbmRib3ggPSBudWxsXG5cbmltcG9ydCBxdWlja2ZpZWxkIGZyb20gJy4uL2J1aWxkL3F1aWNrZmllbGQnXG5pbXBvcnQgVGV4dGFyZWFGaWVsZCBmcm9tICcuLi9idWlsZC9maWVsZHMvdGV4dGFyZWEnXG5pbXBvcnQgTnVtYmVyRmllbGQgZnJvbSAnLi4vYnVpbGQvZmllbGRzL251bWJlcidcbmltcG9ydCBTZWxlY3RGaWVsZCBmcm9tICcuLi9idWlsZC9maWVsZHMvc2VsZWN0J1xuaW1wb3J0IENob2ljZUZpZWxkIGZyb20gJy4uL2J1aWxkL2ZpZWxkcy9jaG9pY2UnXG5pbXBvcnQgVHJ1ZWZhbHNlRmllbGQgZnJvbSAnLi4vYnVpbGQvZmllbGRzL3RydWVmYWxzZSdcbmltcG9ydCBUb2dnbGVGaWVsZCBmcm9tICcuLi9idWlsZC9maWVsZHMvdG9nZ2xlJ1xuaW1wb3J0IEdyb3VwRmllbGQgZnJvbSAnLi4vYnVpbGQvZmllbGRzL2dyb3VwJ1xuaW1wb3J0IFJlcGVhdGVyRmllbGQgZnJvbSAnLi4vYnVpbGQvZmllbGRzL3JlcGVhdGVyJ1xuaW1wb3J0IEZpbGVGaWVsZCBmcm9tICcuLi9idWlsZC9maWVsZHMvZmlsZSdcbnF1aWNrZmllbGQucmVnaXN0ZXIoJ3RleHRhcmVhJywgVGV4dGFyZWFGaWVsZClcbnF1aWNrZmllbGQucmVnaXN0ZXIoJ251bWJlcicsIE51bWJlckZpZWxkKVxucXVpY2tmaWVsZC5yZWdpc3Rlcignc2VsZWN0JywgU2VsZWN0RmllbGQpXG5xdWlja2ZpZWxkLnJlZ2lzdGVyKCdjaG9pY2UnLCBDaG9pY2VGaWVsZClcbnF1aWNrZmllbGQucmVnaXN0ZXIoJ3RydWVmYWxzZScsIFRydWVmYWxzZUZpZWxkKVxucXVpY2tmaWVsZC5yZWdpc3RlcigndG9nZ2xlJywgVG9nZ2xlRmllbGQpXG5xdWlja2ZpZWxkLnJlZ2lzdGVyKCdncm91cCcsIEdyb3VwRmllbGQpXG5xdWlja2ZpZWxkLnJlZ2lzdGVyKCdyZXBlYXRlcicsIFJlcGVhdGVyRmllbGQpXG4jIHF1aWNrZmllbGQucmVnaXN0ZXIoJ2ZpbGUnLCBGaWxlRmllbGQpXG53aW5kb3cucXVpY2tmaWVsZCA9IHF1aWNrZmllbGRcblxuZW1pdEV2ZW50ID0gKHRhcmdldCwgZXZlbnQsIHRyaWdnZXIpLT5cblx0cHJvbWlzZSA9IHByb21pc2VFdmVudCh0YXJnZXQsIGV2ZW50KVxuXHR0cmlnZ2VyKClcblx0cmV0dXJuIHByb21pc2VcblxuXG5zdWl0ZSBcIlF1aWNrRmllbGRcIiwgKCktPlx0XG5cdHRlYXJkb3duICgpLT5cblx0XHRsYXN0Q2hpbGQgPSBzYW5kYm94LmNoaWxkcmVuW3NhbmRib3guY2hpbGRyZW4ubGVuZ3RoLTFdXG5cdFx0bGFzdENoaWxkLnJlbW92ZSgpIGlmIGxhc3RDaGlsZD8ucmVmIGlzICd0ZXN0VGl0bGUnXG5cdFxuXHRzdWl0ZVNldHVwICgpLT5cblx0XHRoZWxwZXJzLnJlc3RhcnRTYW5kYm94KClcblxuXG5cdHN1aXRlIFwiY3JlYXRpb25cIiwgKCktPlxuXHRcdHRlYXJkb3duKGhlbHBlcnMucmVzdGFydFNhbmRib3gpXG5cblx0XHR0ZXN0IFwidGV4dCBmaWVsZFwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQodHlwZTondGV4dCcpLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGQuZWwucGFyZW50LCBzYW5kYm94XG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGQuZWwuY2hpbGQuaW5wdXQuYXR0cigndHlwZScpLCAndGV4dCdcblxuXHRcdHRlc3QgXCJ0ZXh0YXJlYSBmaWVsZFwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQodHlwZTondGV4dGFyZWEnKS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0YXNzZXJ0LmVxdWFsIGZpZWxkLmVsLnBhcmVudCwgc2FuZGJveFxuXG5cdFx0dGVzdCBcIm51bWJlciBmaWVsZFwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQodHlwZTonbnVtYmVyJykuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZC5lbC5wYXJlbnQsIHNhbmRib3hcblxuXHRcdHRlc3QgXCJzZWxlY3QgZmllbGRcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHR5cGU6J3NlbGVjdCcpLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGQuZWwucGFyZW50LCBzYW5kYm94XG5cblx0XHR0ZXN0IFwiY2hvaWNlIGZpZWxkXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh0eXBlOidjaG9pY2UnLCBjaG9pY2VzOlsnYScsJ2InXSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZC5lbC5wYXJlbnQsIHNhbmRib3hcblxuXHRcdHRlc3QgXCJ0cnVlZmFsc2UgZmllbGRcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHR5cGU6J3RydWVmYWxzZScpLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGQuZWwucGFyZW50LCBzYW5kYm94XG5cblx0XHR0ZXN0IFwidG9nZ2xlIGZpZWxkXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh0eXBlOid0b2dnbGUnKS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0YXNzZXJ0LmVxdWFsIGZpZWxkLmVsLnBhcmVudCwgc2FuZGJveFxuXG5cdFx0c3VpdGUgXCJtaXNjXCIsICgpLT5cblx0XHRcdHRlc3QgXCJ3aXRoIG11bHRpcGxlIG9wdGlvbnMgb2JqZWN0XCIsICgpLT5cblx0XHRcdFx0Y29uZmlnID0gdHlwZTondGV4dCcsIGxhYmVsOidhYmMnLCB2YWx1ZTonMTIzJ1xuXHRcdFx0XHRmaWVsZDEgPSBxdWlja2ZpZWxkKGNvbmZpZylcblx0XHRcdFx0ZmllbGQyID0gcXVpY2tmaWVsZChjb25maWcsIHtsYWJlbDonZGVmJ30sIHtoZWlnaHQ6NTAsIHZhbHVlOic0NTYnfSlcblxuXHRcdFx0XHRleHBlY3QoY29uZmlnKS50by5lcWwgdHlwZTondGV4dCcsIGxhYmVsOidhYmMnLCB2YWx1ZTonMTIzJ1xuXHRcdFx0XHRleHBlY3QoZmllbGQxLnNldHRpbmdzLmxhYmVsKS50by5lcXVhbCAnYWJjJ1xuXHRcdFx0XHRleHBlY3QoZmllbGQyLnNldHRpbmdzLmxhYmVsKS50by5lcXVhbCAnZGVmJ1xuXHRcdFx0XHRleHBlY3QoZmllbGQxLnNldHRpbmdzLmhlaWdodCkudG8uZXF1YWwgNDZcblx0XHRcdFx0ZXhwZWN0KGZpZWxkMi5zZXR0aW5ncy5oZWlnaHQpLnRvLmVxdWFsIDUwXG5cdFx0XHRcdGV4cGVjdChmaWVsZDEudmFsdWUpLnRvLmVxdWFsICcxMjMnXG5cdFx0XHRcdGV4cGVjdChmaWVsZDIudmFsdWUpLnRvLmVxdWFsICc0NTYnXG5cblxuXHRzdWl0ZSBcInRleHQgZmllbGRcIiwgKCktPlxuXHRcdHN1aXRlU2V0dXAgKCktPlxuXHRcdFx0aGVscGVycy5hZGRUaXRsZShcInRleHQgZmllbGRcIilcblx0XHRcdEBjb250cm9sID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGxhYmVsOidSZWd1bGFyJ30pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0dGVhcmRvd24gKCktPlxuXHRcdFx0QGNvbnRyb2wudmFsdWUgPSAnJ1xuXG5cdFx0dGVzdCBcImdldHRlci9zZXR0ZXJcIiwgKCktPlxuXHRcdFx0Z2V0dGVyID0gKHZhbHVlKS0+IFwiZXhhbXBsZS5jb20vI3t2YWx1ZX1cIlxuXHRcdFx0c2V0dGVyID0gKHZhbHVlKS0+IHZhbHVlLnRvTG93ZXJDYXNlKClcblx0XHRcdGZpZWxkQSA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDoncGF0aCcsIGdldHRlcn0pXG5cdFx0XHRmaWVsZEIgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J3BhdGgnLCBzZXR0ZXJ9KVxuXHRcdFx0ZmllbGRDID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGxhYmVsOidwYXRoJywgZ2V0dGVyLCBzZXR0ZXJ9KVxuXG5cdFx0XHRleHBlY3QoZmllbGRBLnZhbHVlKS50by5lcXVhbCAnZXhhbXBsZS5jb20vJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQS5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICcnXG5cdFx0XHRleHBlY3QoZmllbGRCLnZhbHVlKS50by5lcXVhbCAnJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQi5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICcnXG5cdFx0XHRleHBlY3QoZmllbGRDLnZhbHVlKS50by5lcXVhbCAnZXhhbXBsZS5jb20vJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQy5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICcnXG5cblx0XHRcdGhlbHBlcnMuc2ltdWxhdGVLZXlzKGZpZWxkQS5lbC5jaGlsZC5pbnB1dC5yYXcsICdBYkMnKVxuXHRcdFx0aGVscGVycy5zaW11bGF0ZUtleXMoZmllbGRCLmVsLmNoaWxkLmlucHV0LnJhdywgJ0FiQycpXG5cdFx0XHRoZWxwZXJzLnNpbXVsYXRlS2V5cyhmaWVsZEMuZWwuY2hpbGQuaW5wdXQucmF3LCAnQWJDJylcblx0XHRcdGV4cGVjdChmaWVsZEEudmFsdWUpLnRvLmVxdWFsICdleGFtcGxlLmNvbS9BYkMnXG5cdFx0XHRleHBlY3QoZmllbGRBLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJ0FiQydcblx0XHRcdGV4cGVjdChmaWVsZEIudmFsdWUpLnRvLmVxdWFsICdhYmMnXG5cdFx0XHRleHBlY3QoZmllbGRCLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJ2FiYydcblx0XHRcdGV4cGVjdChmaWVsZEMudmFsdWUpLnRvLmVxdWFsICdleGFtcGxlLmNvbS9hYmMnXG5cdFx0XHRleHBlY3QoZmllbGRDLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJ2FiYydcblxuXHRcdFx0ZmllbGRBLnZhbHVlID0gJ0RlRidcblx0XHRcdGZpZWxkQi52YWx1ZSA9ICdEZUYnXG5cdFx0XHRmaWVsZEMudmFsdWUgPSAnRGVGJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQS52YWx1ZSkudG8uZXF1YWwgJ2V4YW1wbGUuY29tL0RlRidcblx0XHRcdGV4cGVjdChmaWVsZEEuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnRGVGJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQi52YWx1ZSkudG8uZXF1YWwgJ2RlZidcblx0XHRcdGV4cGVjdChmaWVsZEIuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnZGVmJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQy52YWx1ZSkudG8uZXF1YWwgJ2V4YW1wbGUuY29tL2RlZidcblx0XHRcdGV4cGVjdChmaWVsZEMuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnZGVmJ1xuXG5cblx0XHR0ZXN0IFwid2l0aCBoZWxwIG1lc3NhZ2VcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J1dpdGggSGVscCBNZXNzYWdlJywgaGVscDonaGVscCA8Yj5tZXNzYWdlPC9iPiBoZXJlJ30pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRleHBlY3QoZmllbGQuZWwudGV4dCkudG8uaW5jbHVkZSAnaGVscCBtZXNzYWdlIGhlcmUnXG5cdFx0XHRleHBlY3QoZmllbGQuZWxzLmhlbHAuaHRtbCkudG8uZXF1YWwgJ2hlbHAgPGI+bWVzc2FnZTwvYj4gaGVyZSdcblx0XHRcdGV4cGVjdChAY29udHJvbC5lbHMuaGVscC5odG1sKS50by5lcXVhbCAnJ1xuXHRcdFx0XG5cdFx0XHRleHBlY3QoQGNvbnRyb2wuZWwucmF3KS50by5oYXZlLnN0eWxlICdtYXJnaW5Cb3R0b20nLCAnMHB4J1xuXHRcdFx0ZXhwZWN0KGZpZWxkLmVsLnJhdykudG8uaGF2ZS5zdHlsZSAnbWFyZ2luQm90dG9tJywgJzI1cHgnXG5cdFx0XHRcblx0XHRcdGZpZWxkLnN0YXRlLmhlbHAgPSAnJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkLmVsLnJhdykudG8uaGF2ZS5zdHlsZSAnbWFyZ2luQm90dG9tJywgJzBweCdcblx0XHRcdGV4cGVjdChmaWVsZC5lbHMuaGVscC5odG1sKS50by5lcXVhbCAnJ1xuXHRcdFx0XG5cdFx0XHRmaWVsZC5zdGF0ZS5lcnJvciA9ICdhYmMxMjMnXG5cdFx0XHRleHBlY3QoZmllbGQuZWwucmF3KS50by5oYXZlLnN0eWxlICdtYXJnaW5Cb3R0b20nLCAnMHB4J1xuXHRcdFx0ZXhwZWN0KGZpZWxkLmVscy5oZWxwLmh0bWwpLnRvLmVxdWFsICcnXG5cblx0XHRcdGZpZWxkLnN0YXRlLnNob3dFcnJvciA9IHRydWVcblx0XHRcdGV4cGVjdChmaWVsZC5lbC5yYXcpLnRvLmhhdmUuc3R5bGUgJ21hcmdpbkJvdHRvbScsICcyNXB4J1xuXHRcdFx0ZXhwZWN0KGZpZWxkLmVscy5oZWxwLmh0bWwpLnRvLmVxdWFsICdhYmMxMjMnXG5cblx0XHRcdGZpZWxkLnN0YXRlLmhlbHAgPSAnZGVmNDU2J1xuXHRcdFx0ZXhwZWN0KGZpZWxkLmVsLnJhdykudG8uaGF2ZS5zdHlsZSAnbWFyZ2luQm90dG9tJywgJzI1cHgnXG5cdFx0XHRleHBlY3QoZmllbGQuZWxzLmhlbHAuaHRtbCkudG8uZXF1YWwgJ2RlZjQ1Nidcblx0XHRcdFxuXHRcdFx0ZmllbGQuc3RhdGUuaGVscCA9ICcnXG5cdFx0XHRmaWVsZC5zdGF0ZS5zaG93RXJyb3IgPSBmYWxzZVxuXHRcdFx0ZXhwZWN0KGZpZWxkLmVsLnJhdykudG8uaGF2ZS5zdHlsZSAnbWFyZ2luQm90dG9tJywgJzI1cHgnXG5cdFx0XHRleHBlY3QoZmllbGQuZWxzLmhlbHAuaHRtbCkudG8uZXF1YWwgJ2hlbHAgPGI+bWVzc2FnZTwvYj4gaGVyZSdcblxuXG5cdFx0dGVzdCBcIndpdGhvdXQgbGFiZWxcIiwgKCktPlxuXHRcdFx0d2l0aExhYmVsID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGxhYmVsOidXaXRoIExhYmVsJ30pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHR3aXRob3V0TGFiZWwgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgcGxhY2Vob2xkZXI6J1dpdGhvdXQgTGFiZWwnfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdERPTS5iYXRjaChbXG5cdFx0XHRcdHdpdGhMYWJlbC5lbHMubGFiZWxcblx0XHRcdFx0d2l0aExhYmVsLmVscy5pbm5lcndyYXBcblx0XHRcdFx0d2l0aExhYmVsLmVscy5pbnB1dFxuXHRcdFx0XHR3aXRob3V0TGFiZWwuZWxzLmxhYmVsXG5cdFx0XHRcdHdpdGhvdXRMYWJlbC5lbHMuaW5uZXJ3cmFwXG5cdFx0XHRcdHdpdGhvdXRMYWJlbC5lbHMuaW5wdXRcblx0XHRcdF0pLnN0eWxlICd0cmFuc2l0aW9uJywgbnVsbFxuXG5cdFx0XHRhc3NlcnQuZXF1YWwgd2l0aExhYmVsLmVsLmNoaWxkLnBsYWNlaG9sZGVyLmh0bWwsICdXaXRoIExhYmVsJ1xuXHRcdFx0YXNzZXJ0LmVxdWFsIHdpdGhMYWJlbC5lbC5jaGlsZC5sYWJlbC5odG1sLCAnV2l0aCBMYWJlbCdcblx0XHRcdGFzc2VydC5lcXVhbCB3aXRoTGFiZWwuZWwuY2hpbGQubGFiZWwuc3R5bGUoJ29wYWNpdHknKSwgJzAnXG5cdFx0XHRcblx0XHRcdGFzc2VydC5lcXVhbCB3aXRob3V0TGFiZWwuZWwuY2hpbGQucGxhY2Vob2xkZXIuaHRtbCwgJ1dpdGhvdXQgTGFiZWwnXG5cdFx0XHRhc3NlcnQubm90RXF1YWwgd2l0aG91dExhYmVsLmVsLmNoaWxkLmxhYmVsLmh0bWwsICdXaXRob3V0IExhYmVsJ1xuXHRcdFx0YXNzZXJ0LmVxdWFsIHdpdGhvdXRMYWJlbC5lbC5jaGlsZC5sYWJlbC5zdHlsZSgnb3BhY2l0eScpLCAnMCdcblxuXHRcdFx0aW5pdGlhbFRvcCA9XG5cdFx0XHRcdHdpdGhMYWJlbDogd2l0aExhYmVsLmVsLmNoaWxkLmlucHV0LnJlY3QudG9wXG5cdFx0XHRcdHdpdGhvdXRMYWJlbDogd2l0aG91dExhYmVsLmVsLmNoaWxkLmlucHV0LnJlY3QudG9wXG5cdFx0XHRcblx0XHRcdHdpdGhMYWJlbC52YWx1ZSA9ICdhYmMxMjMnXG5cdFx0XHR3aXRob3V0TGFiZWwudmFsdWUgPSAnYWJjMTIzJ1xuXG5cdFx0XHRhc3NlcnQubm90RXF1YWwgd2l0aExhYmVsLmVsLmNoaWxkLmlucHV0LnJlY3QudG9wLCBpbml0aWFsVG9wLndpdGhMYWJlbFxuXHRcdFx0YXNzZXJ0LmVxdWFsIHdpdGhvdXRMYWJlbC5lbC5jaGlsZC5pbnB1dC5yZWN0LnRvcCwgaW5pdGlhbFRvcC53aXRob3V0TGFiZWxcblx0XHRcdGFzc2VydC5lcXVhbCB3aXRoTGFiZWwuZWwuY2hpbGQubGFiZWwuc3R5bGUoJ29wYWNpdHknKSwgJzEnXG5cdFx0XHRhc3NlcnQuZXF1YWwgd2l0aG91dExhYmVsLmVsLmNoaWxkLmxhYmVsLnN0eWxlKCdvcGFjaXR5JyksICcwJ1xuXG5cblx0XHR0ZXN0IFwid2l0aCBpY29uXCIsICgpLT5cblx0XHRcdGljb25GaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDonV2l0aCBJY29uJywgaWNvbjonQid9KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cblx0XHR0ZXN0IFwiY3VzdG9tIGhlaWdodC9mb250c2l6ZVwiLCAoKS0+XG5cdFx0XHRmaWVsZEEgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J0N1c3RvbSBIZWlnaHQnLCBoZWlnaHQ6NDAsIGZvbnRTaXplOjEzLCBhdXRvV2lkdGg6dHJ1ZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRmaWVsZEIgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J0N1c3RvbSBIZWlnaHQnLCBoZWlnaHQ6NjAsIGZvbnRTaXplOjE2LCBhdXRvV2lkdGg6dHJ1ZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHRcdGFzc2VydC5pc0F0TGVhc3QgQGNvbnRyb2wuZWwuaGVpZ2h0LCBAY29udHJvbC5zZXR0aW5ncy5oZWlnaHRcblx0XHRcdGFzc2VydC5pc0F0TW9zdCBAY29udHJvbC5lbC5oZWlnaHQsIEBjb250cm9sLnNldHRpbmdzLmhlaWdodCs1XG5cdFx0XHRcblx0XHRcdGFzc2VydC5pc0F0TGVhc3QgZmllbGRBLmVsLmhlaWdodCwgNDBcblx0XHRcdGFzc2VydC5pc0F0TW9zdCBmaWVsZEEuZWwuaGVpZ2h0LCA0NVxuXHRcdFx0XG5cdFx0XHRhc3NlcnQuaXNBdExlYXN0IGZpZWxkQi5lbC5oZWlnaHQsIDYwXG5cdFx0XHRhc3NlcnQuaXNBdE1vc3QgZmllbGRCLmVsLmhlaWdodCwgNjVcblxuXG5cdFx0dGVzdCBcImN1c3RvbSBib3JkZXJcIiwgKCktPlxuXHRcdFx0Y3VzdG9tID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGxhYmVsOidDdXN0b20gQm9yZGVyJywgYm9yZGVyOicwIDAgMnB4IDAnfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdFxuXHRcdFx0YXNzZXJ0LmRlZXBFcXVhbCBoZWxwZXJzLmdldEJvcmRlclNpZGVzKEBjb250cm9sLmVsLmNoaWxkLmlubmVyd3JhcCksIHt0b3A6JzFweCcsIGxlZnQ6JzFweCcsIHJpZ2h0OicxcHgnLCBib3R0b206JzFweCd9XG5cdFx0XHRhc3NlcnQuZGVlcEVxdWFsIGhlbHBlcnMuZ2V0Qm9yZGVyU2lkZXMoY3VzdG9tLmVsLmNoaWxkLmlubmVyd3JhcCksIHt0b3A6JzBweCcsIGxlZnQ6JzBweCcsIHJpZ2h0OicwcHgnLCBib3R0b206JzJweCd9XG5cblxuXHRcdHRlc3QgXCJkZWZhdWx0IHZhbHVlXCIsICgpLT5cblx0XHRcdGZpZWxkQSA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnfSlcblx0XHRcdGZpZWxkQiA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBkZWZhdWx0VmFsdWU6J3ZhbHVlQid9KVxuXHRcdFx0ZmllbGRDID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIHZhbHVlOid2YWx1ZUMnfSlcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZEEudmFsdWUsICcnXG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGRBLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSwgJydcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZEIudmFsdWUsICd2YWx1ZUInXG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGRCLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSwgJ3ZhbHVlQidcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZEMudmFsdWUsICd2YWx1ZUMnXG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGRDLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSwgJ3ZhbHVlQydcblxuXG5cdFx0dGVzdCBcImRpc2FibGVkXCIsICgpLT5cblx0XHRcdGZpZWxkQSA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDonRGlzYWJsZWQnLCBhdXRvV2lkdGg6dHJ1ZSwgZGlzYWJsZWQ6dHJ1ZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRmaWVsZEIgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J0Rpc2FibGVkIHcvIHZhbHVlJywgYXV0b1dpZHRoOnRydWUsIGRpc2FibGVkOnRydWUsIHZhbHVlOidhYmMxMjMnfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdHdpbmRvdy5hc3NlcnQgPSBhc3NlcnRcblx0XHRcdGV4cGVjdChAY29udHJvbC52YWx1ZSkudG8uZXF1YWwgJydcblx0XHRcdGV4cGVjdChAY29udHJvbC5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICcnXG5cdFx0XHRleHBlY3QoQGNvbnRyb2wuZWwuY2hpbGQuaW5uZXJ3cmFwLnJhdykudG8uaGF2ZS5zdHlsZSAnYmFja2dyb3VuZENvbG9yJywgJ3doaXRlJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQS52YWx1ZSkudG8uZXF1YWwgJydcblx0XHRcdGV4cGVjdChmaWVsZEEuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQS5lbC5jaGlsZC5pbm5lcndyYXAucmF3KS50by5oYXZlLnN0eWxlICdiYWNrZ3JvdW5kQ29sb3InLCBDT0xPUlMuZ3JleV9saWdodFxuXHRcdFx0ZXhwZWN0KGZpZWxkQi52YWx1ZSkudG8uZXF1YWwgJ2FiYzEyMydcblx0XHRcdGV4cGVjdChmaWVsZEIuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnYWJjMTIzJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQi5lbC5jaGlsZC5pbm5lcndyYXAucmF3KS50by5oYXZlLnN0eWxlICdiYWNrZ3JvdW5kQ29sb3InLCBDT0xPUlMuZ3JleV9saWdodFxuXG5cdFx0XHQjIGV4cGVjdChAY29udHJvbC5zdGF0ZS5mb2N1c2VkKS50by5lcXVhbCBmYWxzZVxuXHRcdFx0IyBAY29udHJvbC5mb2N1cygpXG5cdFx0XHQjIGV4cGVjdChAY29udHJvbC5zdGF0ZS5mb2N1c2VkKS50by5lcXVhbCB0cnVlXG5cblx0XHRcdCMgZXhwZWN0KGZpZWxkQS5zdGF0ZS5mb2N1c2VkKS50by5lcXVhbCBmYWxzZVxuXHRcdFx0IyBmaWVsZEEuZm9jdXMoKVxuXHRcdFx0IyBQcm9taXNlLmRlbGF5KDUpLnRoZW4gKCktPlxuXHRcdFx0IyBcdGV4cGVjdChmaWVsZEEuc3RhdGUuZm9jdXNlZCkudG8uZXF1YWwgZmFsc2VcblxuXG5cdFx0dGVzdCBcImNvbmRpdGlvbnNcIiwgKCktPlxuXHRcdFx0bWFzdGVyID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGxhYmVsOidNYXN0ZXIgRmllbGQnLCBJRDonbWFzdGVyRmllbGQnLCBtYXNrOidhYWEtMTExJywgcmVxdWlyZWQ6dHJ1ZSwgYXV0b1dpZHRoOnRydWV9KS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0c2xhdmUgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J1NsYXZlIEZpZWxkJywgY29uZGl0aW9uczpbdGFyZ2V0OidtYXN0ZXJGaWVsZCddLCBhdXRvV2lkdGg6dHJ1ZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblxuXHRcdHRlc3QgXCJhdXRvd2lkdGhcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J0F1dG93aWR0aCcsIGF1dG9XaWR0aDp0cnVlLCBjaGVja21hcms6ZmFsc2V9KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cblx0XHR0ZXN0IFwiaW5wdXQgZXZlbnRcIiwgKCktPlxuXHRcdFx0Y291bnQgPSAwXG5cdFx0XHRmaWVsZCA9IEBjb250cm9sXG5cdFx0XHRpbnB1dCA9IGZpZWxkLmVscy5pbnB1dC5yYXdcblx0XHRcdGZpZWxkLm9uICdpbnB1dCcsICgpLT4gY291bnQrK1xuXHRcdFx0XG5cblx0XHRcdFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHRcdC50aGVuICgpLT4gZXhwZWN0KGNvdW50KS50by5lcXVhbCAwXG5cdFx0XHRcdC50aGVuICgpLT4gZW1pdEV2ZW50IGZpZWxkLCAnaW5wdXQnLCAoKT0+IGZpZWxkLnZhbHVlID0gJ2NoYW5nZSdcblx0XHRcdFx0LnRoZW4gKCktPiBleHBlY3QoY291bnQpLnRvLmVxdWFsIDFcblx0XHRcdFx0LnRoZW4gKCktPiBlbWl0RXZlbnQgZmllbGQsICdpbnB1dCcsICgpPT4gZmllbGQudmFsdWUgPSAnY2hhbmdlMidcblx0XHRcdFx0LnRoZW4gKCktPiBleHBlY3QoY291bnQpLnRvLmVxdWFsIDJcblx0XHRcdFx0LnRoZW4gKCktPiBlbWl0RXZlbnQgZmllbGQsICdpbnB1dCcsICgpPT4gaGVscGVycy5zaW11bGF0ZUtleXMoaW5wdXQsICdhJylcblx0XHRcdFx0LnRoZW4gKCktPiBleHBlY3QoY291bnQpLnRvLmVxdWFsIDNcblx0XHRcdFx0LnRoZW4gKCktPiBlbWl0RXZlbnQgZmllbGQsICdpbnB1dCcsICgpPT4gaGVscGVycy5zaW11bGF0ZUtleXMoaW5wdXQsICdhYmMnKVxuXHRcdFx0XHQudGhlbiAoKS0+IGV4cGVjdChjb3VudCkudG8uZXF1YWwgNlxuXG5cblx0XHRzdWl0ZSBcIm9wdGlvbnMvYXV0b2NvbXBsZXRlXCIsICgpLT5cblx0XHRcdHN1aXRlU2V0dXAgKCktPlxuXHRcdFx0XHRAZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J015IG9wdGlvbnMgZmllbGQnLCBjaG9pY2VzOlsnYXBwbGUnLCAnYmFuYW5hJywgJ29yYW5nZScsICdiYW5hbmEgcmVwdWJsaWMnLCB7bGFiZWw6J29yYW5nZSBzcGxpdCcsIHZhbHVlOidzcGxpdCd9XX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRcdEBjaG9pY2VzID0gQGZpZWxkLmRyb3Bkb3duLmNob2ljZXNcblx0XHRcdFx0QGRyb3Bkb3duRWwgPSBAZmllbGQuZHJvcGRvd24uZWxzLmNvbnRhaW5lci5yYXdcblx0XHRcdFx0QGlucHV0RWwgPSBAZmllbGQuZWwuY2hpbGQuaW5wdXQucmF3XG5cdFx0XHRcblx0XHRcdHRlYXJkb3duICgpLT5cblx0XHRcdFx0QGZpZWxkLmJsdXIoKVxuXHRcdFx0XHRAZmllbGQudmFsdWUgPSAnJ1xuXG5cdFx0XHR0ZXN0IFwidHJpZ2dlcmluZ1wiLCAoKS0+XG5cdFx0XHRcdFByb21pc2UuYmluZChAKVxuXHRcdFx0XHRcdC50aGVuICgpLT5cblx0XHRcdFx0XHRcdGV4cGVjdChAZHJvcGRvd25FbCkubm90LnRvLmJlLmRpc3BsYXllZFxuXHRcdFx0XHRcdFx0cHJvbWlzZSA9IHByb21pc2VFdmVudChAZmllbGQuZWwuY2hpbGQuaW5wdXQsICdmb2N1cycpXG5cdFx0XHRcdFx0XHRAZmllbGQuZm9jdXMoKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHByb21pc2VcblxuXHRcdFx0XHRcdC50aGVuICgpLT5cblx0XHRcdFx0XHRcdGV4cGVjdChAZHJvcGRvd25FbCkubm90LnRvLmJlLmRpc3BsYXllZFxuXHRcdFx0XHRcdFx0aGVscGVycy5zaW11bGF0ZUtleXMoQGlucHV0RWwsICdhJylcblx0XHRcdFx0XHRcdGV4cGVjdChAZHJvcGRvd25FbCkudG8uYmUuZGlzcGxheWVkXG5cdFx0XHRcdFx0XHRwcm9taXNlID0gcHJvbWlzZUV2ZW50KEBmaWVsZC5lbC5jaGlsZC5pbnB1dCwgJ2JsdXInKVxuXHRcdFx0XHRcdFx0QGZpZWxkLmJsdXIoKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHByb21pc2VcblxuXHRcdFx0XHRcdC50aGVuICgpLT5cblx0XHRcdFx0XHRcdGV4cGVjdChAZHJvcGRvd25FbCkubm90LnRvLmJlLmRpc3BsYXllZFxuXHRcdFx0XHRcdFx0QGZpZWxkLmZvY3VzKClcblx0XHRcdFx0XHRcdGhlbHBlcnMuc2ltdWxhdGVBY3Rpb24oQGlucHV0RWwsICdkb3duJylcblx0XHRcdFx0XHRcdGV4cGVjdChAZHJvcGRvd25FbCkubm90LnRvLmJlLmRpc3BsYXllZFxuXG5cdFx0XHRcdFx0LnRoZW4gKCktPlxuXHRcdFx0XHRcdFx0aGVscGVycy5zaW11bGF0ZUtleXMoQGlucHV0RWwsICdhJylcblx0XHRcdFx0XHRcdGV4cGVjdChAZHJvcGRvd25FbCkudG8uYmUuZGlzcGxheWVkXG5cblx0XHRcdFx0XHQudGhlbiAoKS0+XG5cdFx0XHRcdFx0XHRwcm9taXNlID0gcHJvbWlzZUV2ZW50KEBmaWVsZC5lbC5jaGlsZC5pbnB1dCwgJ2JsdXInKVxuXHRcdFx0XHRcdFx0QGZpZWxkLmJsdXIoKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHByb21pc2VcblxuXHRcdFx0XHRcdC50aGVuICgpLT5cblx0XHRcdFx0XHRcdEBmaWVsZC5kcm9wZG93bi5pc09wZW4gPSB0cnVlXG5cdFx0XHRcdFx0XHRleHBlY3QoQGRyb3Bkb3duRWwpLnRvLmJlLmRpc3BsYXllZFxuXHRcdFx0XHRcdFx0QGZpZWxkLmRyb3Bkb3duLmlzT3BlbiA9IGZhbHNlXG5cdFx0XHRcdFx0XHRleHBlY3QoQGRyb3Bkb3duRWwpLm5vdC50by5iZS5kaXNwbGF5ZWRcblxuXG5cdFx0XHR0ZXN0IFwiaGlnaGxpZ2h0aW5nXCIsICgpLT5cblx0XHRcdFx0QGZpZWxkLmZvY3VzKClcblx0XHRcdFx0XG5cdFx0XHRcdGhlbHBlcnMuc2ltdWxhdGVLZXlzKEBpbnB1dEVsLCAnYScpXG5cdFx0XHRcdGV4cGVjdChAZmllbGQuZHJvcGRvd24uY3VycmVudEhpZ2hsaWdodGVkKS50by5lcXVhbCBudWxsXG5cdFx0XHRcdFxuXHRcdFx0XHRoZWxwZXJzLnNpbXVsYXRlQWN0aW9uKEBpbnB1dEVsLCAnZG93bicpXG5cdFx0XHRcdGV4cGVjdChAZmllbGQuZHJvcGRvd24uY3VycmVudEhpZ2hsaWdodGVkKS50by5lcXVhbCBAY2hvaWNlc1swXVxuXHRcdFx0XHRcblx0XHRcdFx0aGVscGVycy5zaW11bGF0ZUFjdGlvbihAaW5wdXRFbCwgJ2Rvd24nKVxuXHRcdFx0XHRoZWxwZXJzLnNpbXVsYXRlQWN0aW9uKEBpbnB1dEVsLCAnZG93bicpXG5cdFx0XHRcdGV4cGVjdChAZmllbGQuZHJvcGRvd24uY3VycmVudEhpZ2hsaWdodGVkKS50by5lcXVhbCBAY2hvaWNlc1syXVxuXHRcdFx0XHRcblx0XHRcdFx0aGVscGVycy5zaW11bGF0ZUFjdGlvbihAaW5wdXRFbCwgJ2Rvd24nKVxuXHRcdFx0XHRoZWxwZXJzLnNpbXVsYXRlQWN0aW9uKEBpbnB1dEVsLCAnZG93bicpXG5cdFx0XHRcdGV4cGVjdChAZmllbGQuZHJvcGRvd24uY3VycmVudEhpZ2hsaWdodGVkKS50by5lcXVhbCBAY2hvaWNlc1s0XVxuXHRcdFx0XHRcblx0XHRcdFx0aGVscGVycy5zaW11bGF0ZUFjdGlvbihAaW5wdXRFbCwgJ2Rvd24nKVxuXHRcdFx0XHRleHBlY3QoQGZpZWxkLmRyb3Bkb3duLmN1cnJlbnRIaWdobGlnaHRlZCkudG8uZXF1YWwgQGNob2ljZXNbMF1cblx0XHRcdFx0XG5cdFx0XHRcdGhlbHBlcnMuc2ltdWxhdGVBY3Rpb24oQGlucHV0RWwsICd1cCcpXG5cdFx0XHRcdGV4cGVjdChAZmllbGQuZHJvcGRvd24uY3VycmVudEhpZ2hsaWdodGVkKS50by5lcXVhbCBAY2hvaWNlc1s0XVxuXHRcdFx0XHRcblx0XHRcdFx0aGVscGVycy5zaW11bGF0ZUFjdGlvbihAaW5wdXRFbCwgJ3VwJylcblx0XHRcdFx0ZXhwZWN0KEBmaWVsZC5kcm9wZG93bi5jdXJyZW50SGlnaGxpZ2h0ZWQpLnRvLmVxdWFsIEBjaG9pY2VzWzNdXG5cblx0XHRcdFx0QGZpZWxkLmJsdXIoKVxuXHRcdFx0XHRleHBlY3QoQGZpZWxkLmRyb3Bkb3duLmN1cnJlbnRIaWdobGlnaHRlZCkudG8uZXF1YWwgbnVsbFxuXG5cblx0XHRcdHRlc3QgXCJmaWx0ZXJpbmdcIiwgKCktPlxuXHRcdFx0XHRnZXRWaXNpYmxlID0gKCk9PiBAY2hvaWNlcy5maWx0ZXIoKGNob2ljZSktPiBjaG9pY2UudmlzaWJsZSkubWFwKChjaG9pY2UpLT4gY2hvaWNlLnZhbHVlKVxuXHRcdFx0XHRAZmllbGQuZm9jdXMoKVxuXG5cdFx0XHRcdGV4cGVjdChnZXRWaXNpYmxlKCkpLnRvLmVxbCBbJ2FwcGxlJywgJ2JhbmFuYScsICdvcmFuZ2UnLCAnYmFuYW5hIHJlcHVibGljJywgJ3NwbGl0J11cblx0XHRcdFx0XG5cdFx0XHRcdGhlbHBlcnMuc2ltdWxhdGVLZXlzKEBpbnB1dEVsLCAnYmFuJylcblx0XHRcdFx0ZXhwZWN0KGdldFZpc2libGUoKSkudG8uZXFsIFsnYmFuYW5hJywgJ2JhbmFuYSByZXB1YmxpYyddXG5cdFx0XHRcdFxuXHRcdFx0XHRoZWxwZXJzLnNpbXVsYXRlS2V5cyhAaW5wdXRFbCwgJ2FuYScpXG5cdFx0XHRcdGV4cGVjdChnZXRWaXNpYmxlKCkpLnRvLmVxbCBbJ2JhbmFuYScsICdiYW5hbmEgcmVwdWJsaWMnXVxuXHRcdFx0XHRcblx0XHRcdFx0aGVscGVycy5zaW11bGF0ZUtleXMoQGlucHV0RWwsICcgJylcblx0XHRcdFx0ZXhwZWN0KGdldFZpc2libGUoKSkudG8uZXFsIFsnYmFuYW5hIHJlcHVibGljJ11cblx0XHRcdFx0XG5cdFx0XHRcdEBmaWVsZC52YWx1ZSA9ICdvcmEnXG5cdFx0XHRcdGV4cGVjdChnZXRWaXNpYmxlKCkpLnRvLmVxbCBbJ29yYW5nZScsICdzcGxpdCddXG5cblxuXHRcdFx0dGVzdCBcInNlbGVjdGluZ1wiLCAoKS0+XG5cdFx0XHRcdEBmaWVsZC5mb2N1cygpXG5cblx0XHRcdFx0ZXhwZWN0KEBmaWVsZC52YWx1ZSkudG8uZXF1YWwgJydcblx0XHRcdFx0XG5cdFx0XHRcdEBjaG9pY2VzWzFdLmVsLmVtaXQgJ2NsaWNrJ1xuXHRcdFx0XHRleHBlY3QoQGZpZWxkLnZhbHVlKS50by5lcXVhbCAnYmFuYW5hJ1xuXHRcdFx0XHRleHBlY3QoQGlucHV0RWwudmFsdWUpLnRvLmVxdWFsICdiYW5hbmEnXG5cdFx0XHRcdFxuXHRcdFx0XHRAZmllbGQuZm9jdXMoKTsgQGZpZWxkLnN0YXRlLnR5cGluZyA9IHRydWVcblx0XHRcdFx0QGZpZWxkLnZhbHVlID0gJ29yYSdcblx0XHRcdFx0aGVscGVycy5zaW11bGF0ZUFjdGlvbihAaW5wdXRFbCwgJ2Rvd24nKVxuXHRcdFx0XHRoZWxwZXJzLnNpbXVsYXRlQWN0aW9uKEBpbnB1dEVsLCAnZG93bicpXG5cdFx0XHRcdGV4cGVjdChAZmllbGQuZHJvcGRvd24uY3VycmVudEhpZ2hsaWdodGVkKS50by5lcXVhbCBAY2hvaWNlc1s0XVxuXHRcdFx0XHRleHBlY3QoQGZpZWxkLnZhbHVlKS50by5lcXVhbCAnb3JhJ1xuXHRcdFx0XHRleHBlY3QoQGlucHV0RWwudmFsdWUpLnRvLmVxdWFsICdvcmEnXG5cdFx0XHRcdFxuXHRcdFx0XHRoZWxwZXJzLnNpbXVsYXRlQWN0aW9uKEBpbnB1dEVsLCAnZW50ZXInKVxuXHRcdFx0XHRleHBlY3QoQGZpZWxkLnZhbHVlKS50by5lcXVhbCAnc3BsaXQnXG5cdFx0XHRcdGV4cGVjdChAaW5wdXRFbC52YWx1ZSkudG8uZXF1YWwgJ29yYW5nZSBzcGxpdCdcblx0XHRcdFx0XG5cdFx0XHRcdEBmaWVsZC52YWx1ZSA9ICdvcmFuZ2UnXG5cdFx0XHRcdGV4cGVjdChAZmllbGQudmFsdWUpLnRvLmVxdWFsICdvcmFuZ2UnXG5cdFx0XHRcdGV4cGVjdChAaW5wdXRFbC52YWx1ZSkudG8uZXF1YWwgJ29yYW5nZSdcblx0XHRcdFx0XG5cdFx0XHRcdEBmaWVsZC52YWx1ZSA9ICdvcmFuZ2Ugc3BsaXQnXG5cdFx0XHRcdGV4cGVjdChAZmllbGQudmFsdWUpLnRvLmVxdWFsICdzcGxpdCdcblx0XHRcdFx0ZXhwZWN0KEBpbnB1dEVsLnZhbHVlKS50by5lcXVhbCAnb3JhbmdlIHNwbGl0J1xuXG5cblxuXHRcdHN1aXRlIFwia2V5Ym9hcmQvY3VzdG9tLXR5cGVcIiwgKCktPlxuXHRcdFx0dGVzdCBcInBhc3N3b3JkXCIsICgpLT5cblx0XHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J1Bhc3N3b3JkJywga2V5Ym9hcmQ6J3Bhc3N3b3JkJ30pLmFwcGVuZFRvKHNhbmRib3gpXG5cblxuXHRcdFx0dGVzdCBcImVtYWlsXCIsICgpLT5cblx0XHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J0VtYWlsJywgSUQ6J2VtYWlsJywga2V5Ym9hcmQ6J2VtYWlsJywgcmVxdWlyZWQ6dHJ1ZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGxhYmVsOidFbWFpbCcsIGtleWJvYXJkOidlbWFpbCcsIG1hc2s6e2d1aWRlOmZhbHNlfSwgcmVxdWlyZWQ6dHJ1ZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblxuXHRcdFx0dGVzdCBcIm51bWJlciAoc2ltbHVhdGVkKVwiLCAoKS0+XG5cdFx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGxhYmVsOidOdW1iZXIgKHNpbWx1YXRlZCknLCBrZXlib2FyZDonbnVtYmVyJywgdmFsaWRXaGVuUmVnZXg6L1teMF0vLCBhdXRvV2lkdGg6dHJ1ZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblxuXHRcdHN1aXRlIFwibWFza1wiLCAoKS0+XG5cdFx0XHRzdWl0ZVNldHVwICgpLT4gaGVscGVycy5hZGRUaXRsZSgnbWFzaycpXG5cdFx0XHRcblx0XHRcdHRlc3QgXCJhbHBoYVwiLCAoKS0+XG5cdFx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGxhYmVsOidOYW1lJywgbWFzazonTkFNRScsIHdpZHRoOic1MCUnfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J0Z1bGwgTmFtZScsIG1hc2s6J0ZVTExOQU1FJywgd2lkdGg6JzUwJSd9KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cdFx0XHR0ZXN0IFwibnVtZXJpY1wiLCAoKS0+XG5cdFx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGxhYmVsOidQaG9uZScsIGRpc3RhbmNlOjEwLCB3aWR0aDonNTAlJywgbW9iaWxlV2lkdGg6JzEwMCUnLCBtYXNrOicoMTExKSAxMTEtMTExMSd9KS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDonUGhvbmUnLCBkaXN0YW5jZToxMCwgd2lkdGg6JzUwJScsIG1vYmlsZVdpZHRoOicxMDAlJywga2V5Ym9hcmQ6J3Bob25lJ30pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHRcdHRlc3QgXCJhbHBoYW51bWVyaWNcIiwgKCktPlxuXHRcdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDonTGljZW5jZSBQbGF0ZScsIG1hc2s6e3BhdHRlcm46J2FhYS0xMTEnLCB0cmFuc2Zvcm06KHYpLT4gdi50b1VwcGVyQ2FzZSgpfX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHRcdHRlc3QgXCJwcmVmaXhcIiwgKCktPlxuXHRcdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBsYWJlbDonRG9sbGFyJywgbWFzazp7cGF0dGVybjonTlVNQkVSJywgcHJlZml4OickJywgZGVjaW1hbDp0cnVlLCBzZXA6dHJ1ZX19KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cdFx0XHR0ZXN0IFwiZGF0ZVwiLCAoKS0+XG5cdFx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGxhYmVsOidEYXRlJywga2V5Ym9hcmQ6J2RhdGUnLCBhdXRvV2lkdGg6dHJ1ZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGxhYmVsOidEYXRlJywgbWFzazp7cGF0dGVybjpbJ0RBVEUnLCdtbSAvIHl5J119LCBhdXRvV2lkdGg6dHJ1ZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHRcdHRlc3QgXCJsaXRlcmFsXCIsICgpLT5cblx0XHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J0xpdGVyYWwnLCBtYXNrOidNeSBOXFxcXGFtZSBpcyBhKyBLXFxcXGFsZW4nfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXHRcdFx0dGVzdCBcIm9wdGlvbmFsc1wiLCAoKS0+XG5cdFx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dCcsIGxhYmVsOidPcHRpb25hbHMnLCBtYXNrOidhYWFbQUFBXTExMSd9KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cdFx0XHR0ZXN0IFwiY3VzdG9tIHBhdHRlcm5zXCIsICgpLT5cblx0XHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0JywgbGFiZWw6J09ubHkgc3BlY2lmaWMgY2hhcnMnLCBtYXNrOntwYXR0ZXJuOicmJistYWEtMTExLVsgYWErXScsIGN1c3RvbVBhdHRlcm5zOlxuXHRcdFx0XHRcdCcmJzogL1thYjEyXS9cblx0XHRcdFx0XHQnYSc6IC9bMC00XS9cblx0XHRcdFx0fX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblxuXHRzdWl0ZSBcIm51bWJlciBmaWVsZFwiLCAoKS0+XG5cdFx0c3VpdGVTZXR1cCAoKS0+XG5cdFx0XHRoZWxwZXJzLmFkZFRpdGxlKCdudW1iZXIgZmllbGQnKVxuXG5cdFx0dGVzdCBcImJhc2ljXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTonbnVtYmVyJywgbGFiZWw6J051bWJlcicsIGF1dG9XaWR0aDpmYWxzZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHR0ZXN0LnNraXAgXCJnZXR0ZXIvc2V0dGVyXCIsICgpLT5cblx0XHRcdGdldHRlciA9ICh2YWx1ZSktPiAodmFsdWUgb3IgMCkgKiAxMFxuXHRcdFx0c2V0dGVyID0gKHZhbHVlKS0+ICh2YWx1ZSBvciAwKSAqIDJcblx0XHRcdGZpZWxkQSA9IHF1aWNrZmllbGQoe3R5cGU6J251bWJlcicsIGxhYmVsOidOdW1iZXInLCBhdXRvV2lkdGg6dHJ1ZSwgZ2V0dGVyfSlcblx0XHRcdGZpZWxkQiA9IHF1aWNrZmllbGQoe3R5cGU6J251bWJlcicsIGxhYmVsOidOdW1iZXInLCBhdXRvV2lkdGg6dHJ1ZSwgc2V0dGVyfSlcblx0XHRcdGZpZWxkQyA9IHF1aWNrZmllbGQoe3R5cGU6J251bWJlcicsIGxhYmVsOidOdW1iZXInLCBhdXRvV2lkdGg6dHJ1ZSwgZ2V0dGVyLCBzZXR0ZXJ9KVxuXG5cdFx0XHRleHBlY3QoZmllbGRBLnZhbHVlKS50by5lcXVhbCAwXG5cdFx0XHRleHBlY3QoZmllbGRBLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJydcblx0XHRcdGV4cGVjdChmaWVsZEIudmFsdWUpLnRvLmVxdWFsIDBcblx0XHRcdGV4cGVjdChmaWVsZEIuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQy52YWx1ZSkudG8uZXF1YWwgMFxuXHRcdFx0ZXhwZWN0KGZpZWxkQy5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICcnXG5cblx0XHRcdGhlbHBlcnMuc2ltdWxhdGVLZXlzKGZpZWxkQS5lbC5jaGlsZC5pbnB1dC5yYXcsICczJylcblx0XHRcdGhlbHBlcnMuc2ltdWxhdGVLZXlzKGZpZWxkQi5lbC5jaGlsZC5pbnB1dC5yYXcsICczJylcblx0XHRcdGhlbHBlcnMuc2ltdWxhdGVLZXlzKGZpZWxkQy5lbC5jaGlsZC5pbnB1dC5yYXcsICczJylcblx0XHRcdGV4cGVjdChmaWVsZEEudmFsdWUpLnRvLmVxdWFsIDMwXG5cdFx0XHRleHBlY3QoZmllbGRBLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJzMnXG5cdFx0XHRleHBlY3QoZmllbGRCLnZhbHVlKS50by5lcXVhbCA2XG5cdFx0XHRleHBlY3QoZmllbGRCLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJzYnXG5cdFx0XHRleHBlY3QoZmllbGRDLnZhbHVlKS50by5lcXVhbCA2MFxuXHRcdFx0ZXhwZWN0KGZpZWxkQy5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICc2J1xuXG5cdFx0XHRmaWVsZEEudmFsdWUgPSAxMlxuXHRcdFx0ZmllbGRCLnZhbHVlID0gMTJcblx0XHRcdGZpZWxkQy52YWx1ZSA9IDEyXG5cdFx0XHRleHBlY3QoZmllbGRBLnZhbHVlKS50by5lcXVhbCAxMjBcblx0XHRcdGV4cGVjdChmaWVsZEEuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnMTInXG5cdFx0XHRleHBlY3QoZmllbGRCLnZhbHVlKS50by5lcXVhbCAyNFxuXHRcdFx0ZXhwZWN0KGZpZWxkQi5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICcyNCdcblx0XHRcdGV4cGVjdChmaWVsZEMudmFsdWUpLnRvLmVxdWFsIDI0MFxuXHRcdFx0ZXhwZWN0KGZpZWxkQy5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICcyNCdcblxuXG5cdFx0dGVzdCBcIm1pbi9tYXhcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOidudW1iZXInLCBsYWJlbDonTnVtYmVyIChtaW4vbWF4KScsIG1pblZhbHVlOjEwLCBtYXhWYWx1ZToxMDAwLCBhdXRvV2lkdGg6dHJ1ZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblxuXHRcdHRlc3QgXCJtaW4vbWF4L3N0ZXBcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOidudW1iZXInLCBsYWJlbDonTnVtYmVyIChtaW4vbWF4L3N0ZXApJywgbWluVmFsdWU6MTAsIG1heFZhbHVlOjEwMCwgc3RlcDozLCBhdXRvV2lkdGg6dHJ1ZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblxuXHRcdHRlc3QgXCJtaW4vbWF4L3N0ZXAgKGVuZm9yY2VkKVwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J251bWJlcicsIGxhYmVsOidOdW1iZXIgKGVuZm9yY2VkKScsIG1pblZhbHVlOjEwLCBtYXhWYWx1ZToxMDAsIHN0ZXA6MTIsIGVuZm9yY2U6dHJ1ZSwgYXV0b1dpZHRoOnRydWV9KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cdFx0XG5cdFx0dGVzdCBcImRlY2ltYWwgc3RlcFwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J251bWJlcicsIGxhYmVsOidOdW1iZXIgKGRlY2ltYWwgc3RlcCknLCBtaW5WYWx1ZTowLjEsIG1heFZhbHVlOjEwMCwgc3RlcDowLjEsIGF1dG9XaWR0aDp0cnVlfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXG5cdHN1aXRlIFwidGV4dGFyZWEgZmllbGRcIiwgKCktPlxuXHRcdHN1aXRlU2V0dXAgKCktPlxuXHRcdFx0aGVscGVycy5hZGRUaXRsZSgndGV4dGFyZWEgZmllbGQnKVxuXHRcblx0XHR0ZXN0IFwiYmFzaWNcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0YXJlYScsIGxhYmVsOidUZXh0YXJlYScsIHdpZHRoOiczMDBweCcsIGhlaWdodDonMjUwcHgnLCBhdXRvSGVpZ2h0OmZhbHNlfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXHRcdHRlc3QgXCJnZXR0ZXIvc2V0dGVyXCIsICgpLT5cblx0XHRcdGdldHRlciA9ICh2YWx1ZSktPiBcImV4YW1wbGUuY29tLyN7dmFsdWV9XCJcblx0XHRcdHNldHRlciA9ICh2YWx1ZSktPiB2YWx1ZS50b0xvd2VyQ2FzZSgpXG5cdFx0XHRmaWVsZEEgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0YXJlYScsIGxhYmVsOidwYXRoJywgZ2V0dGVyfSlcblx0XHRcdGZpZWxkQiA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHRhcmVhJywgbGFiZWw6J3BhdGgnLCBzZXR0ZXJ9KVxuXHRcdFx0ZmllbGRDID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dGFyZWEnLCBsYWJlbDoncGF0aCcsIGdldHRlciwgc2V0dGVyfSlcblxuXHRcdFx0ZXhwZWN0KGZpZWxkQS52YWx1ZSkudG8uZXF1YWwgJ2V4YW1wbGUuY29tLydcblx0XHRcdGV4cGVjdChmaWVsZEEuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQi52YWx1ZSkudG8uZXF1YWwgJydcblx0XHRcdGV4cGVjdChmaWVsZEIuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQy52YWx1ZSkudG8uZXF1YWwgJ2V4YW1wbGUuY29tLydcblx0XHRcdGV4cGVjdChmaWVsZEMuZWwuY2hpbGQuaW5wdXQucmF3LnZhbHVlKS50by5lcXVhbCAnJ1xuXG5cdFx0XHRoZWxwZXJzLnNpbXVsYXRlS2V5cyhmaWVsZEEuZWwuY2hpbGQuaW5wdXQucmF3LCAnQWJDJylcblx0XHRcdGhlbHBlcnMuc2ltdWxhdGVLZXlzKGZpZWxkQi5lbC5jaGlsZC5pbnB1dC5yYXcsICdBYkMnKVxuXHRcdFx0aGVscGVycy5zaW11bGF0ZUtleXMoZmllbGRDLmVsLmNoaWxkLmlucHV0LnJhdywgJ0FiQycpXG5cdFx0XHRleHBlY3QoZmllbGRBLnZhbHVlKS50by5lcXVhbCAnZXhhbXBsZS5jb20vQWJDJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQS5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICdBYkMnXG5cdFx0XHRleHBlY3QoZmllbGRCLnZhbHVlKS50by5lcXVhbCAnYWJjJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQi5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICdhYmMnXG5cdFx0XHRleHBlY3QoZmllbGRDLnZhbHVlKS50by5lcXVhbCAnZXhhbXBsZS5jb20vYWJjJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQy5lbC5jaGlsZC5pbnB1dC5yYXcudmFsdWUpLnRvLmVxdWFsICdhYmMnXG5cblx0XHRcdGZpZWxkQS52YWx1ZSA9ICdEZUYnXG5cdFx0XHRmaWVsZEIudmFsdWUgPSAnRGVGJ1xuXHRcdFx0ZmllbGRDLnZhbHVlID0gJ0RlRidcblx0XHRcdGV4cGVjdChmaWVsZEEudmFsdWUpLnRvLmVxdWFsICdleGFtcGxlLmNvbS9EZUYnXG5cdFx0XHRleHBlY3QoZmllbGRBLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJ0RlRidcblx0XHRcdGV4cGVjdChmaWVsZEIudmFsdWUpLnRvLmVxdWFsICdkZWYnXG5cdFx0XHRleHBlY3QoZmllbGRCLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJ2RlZidcblx0XHRcdGV4cGVjdChmaWVsZEMudmFsdWUpLnRvLmVxdWFsICdleGFtcGxlLmNvbS9kZWYnXG5cdFx0XHRleHBlY3QoZmllbGRDLmVsLmNoaWxkLmlucHV0LnJhdy52YWx1ZSkudG8uZXF1YWwgJ2RlZidcblxuXG5cdFx0dGVzdCBcImF1dG9oZWlnaHRcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0ZXh0YXJlYScsIGxhYmVsOidUZXh0YXJlYSAoYXV0b0hlaWdodCknLCB3aWR0aDonMzAwcHgnLCBtYXhIZWlnaHQ6NTAwfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcblx0XHR0ZXN0IFwiYXV0b3dpZHRoXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondGV4dGFyZWEnLCBsYWJlbDonVGV4dGFyZWEgKGF1dG93aWR0aCknLCBhdXRvV2lkdGg6dHJ1ZSwgbWF4V2lkdGg6MzAwfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXG5cdHN1aXRlIFwic2VsZWN0IGZpZWxkXCIsICgpLT5cblx0XHRzdWl0ZVNldHVwICgpLT5cblx0XHRcdGhlbHBlcnMuYWRkVGl0bGUoJ3NlbGVjdCBmaWVsZCcpXG5cblx0XHR0ZXN0IFwic2luZ2xlIHNlbGVjdGFibGVcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOidzZWxlY3QnLCBsYWJlbDonTXkgQ2hvaWNlcyAoc2luZ2xlKScsIGNob2ljZXM6WydBcHBsZScsICdBcHBsZSBKdWljZScsICdCYW5hbmEnLCAnT3JhbmdlJywge2xhYmVsOidMZW1vbicsIHZhbHVlOidsaW1lJywgY29uZGl0aW9uczp7J2VtYWlsJzondmFsaWQnfX1dfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXHRcdHRlc3QgXCJtdWx0aSBzZWxlY3RhYmxlXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTonc2VsZWN0JywgbGFiZWw6J015IENob2ljZXMgKG11bHRpKScsIGNob2ljZXM6WydBcHBsZScsICdCYW5hbmEnLCAnT3JhbmdlJywgJ0xpbWUnLCAnS2l3aSddLCBtdWx0aXBsZTp0cnVlLCBkZWZhdWx0VmFsdWU6J0FwcGxlJ30pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGQudmFsdWUsICdBcHBsZSdcblxuXHRcdHRlc3QgXCJkZWZhdWx0IHZhbHVlXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTonc2VsZWN0JywgbGFiZWw6J015IENob2ljZXMgKGRlZmF1bHQpJywgY2hvaWNlczpbJ0FwcGxlJywgJ0JhbmFuYScsICdPcmFuZ2UnLCB7bGFiZWw6J0xlbW9uJywgdmFsdWU6J2xpbWUnLCBjb25kaXRpb25zOnsnZW1haWwnOid2YWxpZCd9fV0sIHZhbHVlOidCYW5hbmEnfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZC52YWx1ZSwgJ0JhbmFuYSdcblx0XHRcdFxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOidzZWxlY3QnLCBsYWJlbDonTXkgQ2hvaWNlcyAoZGVmYXVsdCknLCB2YWx1ZTonQmFuYW5hJ30pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGQudmFsdWUsICdCYW5hbmEnXG5cblx0XHR0ZXN0IFwiY3Vzb3RtIGJvcmRlclwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3NlbGVjdCcsIGxhYmVsOidDdXN0b20gQm9yZGVyJywgY2hvaWNlczpbJ0FwcGxlJywgJ0JhbmFuYScsICdPcmFuZ2UnXSwgYm9yZGVyOicwIDAgMnB4IDAnLCBtYXJnaW46JzAgMCAzMHB4J30pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHR0ZXN0IFwibm8gY2hvaWNlc1wiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3NlbGVjdCcsIGxhYmVsOidObyBjaG9pY2VzJywgYXV0b1dpZHRoOnRydWV9KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cdFx0dGVzdCBcIm1hbnkgY2hvaWNlc1wiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3NlbGVjdCcsIGxhYmVsOidNYW55IENob2ljZXMnLCBjaG9pY2VzOmhlbHBlcnMuY29tcGFueU5hbWVzLCBhdXRvV2lkdGg6dHJ1ZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblxuXHRzdWl0ZSBcImNob2ljZSBmaWVsZFwiLCAoKS0+XG5cdFx0c3VpdGVTZXR1cCAoKS0+XG5cdFx0XHRoZWxwZXJzLmFkZFRpdGxlKCdjaG9pY2UgZmllbGQnKVxuXHRcdFx0QGNvbnRyb2wgPSBxdWlja2ZpZWxkKHt0eXBlOidjaG9pY2UnLCBjaG9pY2VzOlsnQXBwbGUnLCAnQmFuYW5hJywgJ09yYW5nZSddLCByZXF1aXJlZDp0cnVlfSlcblx0XHRcdEBjb250cm9sTXVsdGkgPSBxdWlja2ZpZWxkKHt0eXBlOidjaG9pY2UnLCBjaG9pY2VzOlsnQXBwbGUnLCAnQmFuYW5hJywgJ09yYW5nZSddLCByZXF1aXJlZDp0cnVlLCBtdWx0aXBsZTp0cnVlfSlcblxuXHRcdHRlc3QgXCJzaW5nbGUgc2VsZWN0YWJsZVwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J2Nob2ljZScsIGxhYmVsOidNeSBDaG9pY2VzIChzaW5nbGUpJywgY2hvaWNlczpbJ0FwcGxlJywgJ0JhbmFuYScsICdPcmFuZ2UnXX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHR0ZXN0IFwibXVsdGkgc2VsZWN0YWJsZVwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J2Nob2ljZScsIGxhYmVsOidNeSBDaG9pY2VzIChtdWx0aSknLCBjaG9pY2VzOlsnQXBwbGUnLCAnQmFuYW5hJywgJ09yYW5nZScsICdMaW1lJywgJ0tpd2knXSwgcGVyR3JvdXA6MywgbXVsdGlwbGU6dHJ1ZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHR0ZXN0IFwiZGVmYXVsdCB2YWx1ZVwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J2Nob2ljZScsIGxhYmVsOidNeSBDaG9pY2VzIChzaW5nbGUpJywgY2hvaWNlczpbJ0FwcGxlJywgJ0JhbmFuYScsICdPcmFuZ2UnXSwgdmFsdWU6J09yYW5nZSd9KS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0YXNzZXJ0LmVxdWFsIGZpZWxkLnZhbHVlLCAnT3JhbmdlJ1xuXHRcdFx0YXNzZXJ0LmVxdWFsIGZpZWxkLmZpbmRDaG9pY2UoJ09yYW5nZScpLnNlbGVjdGVkLCB0cnVlXG5cdFx0XHRcblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTonY2hvaWNlJywgbGFiZWw6J015IENob2ljZXMgKG11bHRpKScsIGNob2ljZXM6WydBcHBsZScsICdCYW5hbmEnLCAnT3JhbmdlJywgJ0xpbWUnLCAnS2l3aSddLCBtdWx0aXBsZTp0cnVlLCB2YWx1ZTpbJ0JhbmFuYScsICdMaW1lJ119KS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0YXNzZXJ0LmRlZXBFcXVhbCBmaWVsZC52YWx1ZSwgWydCYW5hbmEnLCAnTGltZSddXG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGQuZmluZENob2ljZSgnQmFuYW5hJykuc2VsZWN0ZWQsIHRydWVcblx0XHRcdGFzc2VydC5lcXVhbCBmaWVsZC5maW5kQ2hvaWNlKCdMaW1lJykuc2VsZWN0ZWQsIHRydWVcblxuXHRcdHRlc3QgXCJjb25kaXRpb25zXCIsICgpLT5cblx0XHRcdG1hc3RlciA9IHF1aWNrZmllbGQoe3R5cGU6J3RleHQnLCBJRDonbWFzdGVyJywgcmVxdWlyZWQ6dHJ1ZX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J2Nob2ljZScsIGxhYmVsOidNeSBDaG9pY2VzIChzaW5nbGUpJywgY2hvaWNlczpbXG5cdFx0XHRcdCdBcHBsZSdcblx0XHRcdFx0e2xhYmVsOidCYW5hbmEnLCB2YWx1ZTonYmFuYW5hJywgY29uZGl0aW9uczp7J21hc3Rlcic6L15iYW5hL319XG5cdFx0XHRcdCdPcmFuZ2UnXG5cdFx0XHRcdHtsYWJlbDonTGVtb24nLCB2YWx1ZTonbGltZScsIGNvbmRpdGlvbnM6eydtYXN0ZXInOid2YWxpZCd9fVxuXHRcdFx0XX0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHR0ZXN0IFwiZ2V0dGVyL3NldHRlclwiLCAoKS0+XG5cdFx0XHRnZXR0ZXIgPSAodmFsdWUpLT4gdmFsdWU/LnRvVXBwZXJDYXNlKCkgb3IgdmFsdWVcblx0XHRcdHNldHRlciA9ICh2YWx1ZSktPiBpZiB2YWx1ZT8udmFsdWUgaXMgJ0JhbmFuYScgdGhlbiAnQXBwbGUnIGVsc2UgdmFsdWVcblx0XHRcdGZpZWxkQSA9IHF1aWNrZmllbGQoe3R5cGU6J2Nob2ljZScsIGNob2ljZXM6WydBcHBsZScsJ0JhbmFuYScsJ09yYW5nZSddLCBnZXR0ZXJ9KS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0ZmllbGRCID0gcXVpY2tmaWVsZCh7dHlwZTonY2hvaWNlJywgY2hvaWNlczpbJ0FwcGxlJywnQmFuYW5hJywnT3JhbmdlJ10sIHNldHRlcn0pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRmaWVsZEMgPSBxdWlja2ZpZWxkKHt0eXBlOidjaG9pY2UnLCBjaG9pY2VzOlsnQXBwbGUnLCdCYW5hbmEnLCdPcmFuZ2UnXSwgZ2V0dGVyLCBzZXR0ZXJ9KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cdFx0XHRleHBlY3QoZmllbGRBLnZhbHVlKS50by5lcXVhbCB1bmRlZmluZWRcblx0XHRcdGV4cGVjdChmaWVsZEEudmFsdWVSYXcpLnRvLmVxdWFsIG51bGxcblx0XHRcdGV4cGVjdChmaWVsZEIudmFsdWUpLnRvLmVxdWFsIHVuZGVmaW5lZFxuXHRcdFx0ZXhwZWN0KGZpZWxkQi52YWx1ZVJhdykudG8uZXF1YWwgbnVsbFxuXHRcdFx0ZXhwZWN0KGZpZWxkQy52YWx1ZSkudG8uZXF1YWwgdW5kZWZpbmVkXG5cdFx0XHRleHBlY3QoZmllbGRDLnZhbHVlUmF3KS50by5lcXVhbCBudWxsXG5cblx0XHRcdGZpZWxkQS5jaG9pY2VzWzFdLmVsLmVtaXQgJ2NsaWNrJ1xuXHRcdFx0ZmllbGRCLmNob2ljZXNbMV0uZWwuZW1pdCAnY2xpY2snXG5cdFx0XHRmaWVsZEMuY2hvaWNlc1sxXS5lbC5lbWl0ICdjbGljaydcblx0XHRcdGV4cGVjdChmaWVsZEEudmFsdWUpLnRvLmVxdWFsICdCQU5BTkEnXG5cdFx0XHRleHBlY3QoZmllbGRBLnZhbHVlUmF3Py52YWx1ZSkudG8uZXF1YWwgJ0JhbmFuYSdcblx0XHRcdGV4cGVjdChmaWVsZEIudmFsdWUpLnRvLmVxdWFsICdBcHBsZSdcblx0XHRcdGV4cGVjdChmaWVsZEIudmFsdWVSYXc/LnZhbHVlKS50by5lcXVhbCAnQXBwbGUnXG5cdFx0XHRleHBlY3QoZmllbGRDLnZhbHVlKS50by5lcXVhbCAnQVBQTEUnXG5cdFx0XHRleHBlY3QoZmllbGRDLnZhbHVlUmF3Py52YWx1ZSkudG8uZXF1YWwgJ0FwcGxlJ1xuXG5cdFx0XHRmaWVsZEEudmFsdWUgPSAnT3JhbmdlJ1xuXHRcdFx0ZmllbGRCLnZhbHVlID0gJ09yYW5nZSdcblx0XHRcdGZpZWxkQy52YWx1ZSA9ICdPcmFuZ2UnXG5cdFx0XHRleHBlY3QoZmllbGRBLnZhbHVlKS50by5lcXVhbCAnT1JBTkdFJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQS52YWx1ZVJhdz8udmFsdWUpLnRvLmVxdWFsICdPcmFuZ2UnXG5cdFx0XHRleHBlY3QoZmllbGRCLnZhbHVlKS50by5lcXVhbCAnT3JhbmdlJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQi52YWx1ZVJhdz8udmFsdWUpLnRvLmVxdWFsICdPcmFuZ2UnXG5cdFx0XHRleHBlY3QoZmllbGRDLnZhbHVlKS50by5lcXVhbCAnT1JBTkdFJ1xuXHRcdFx0ZXhwZWN0KGZpZWxkQy52YWx1ZVJhdz8udmFsdWUpLnRvLmVxdWFsICdPcmFuZ2UnXG5cblxuXHRcdHRlc3QgXCJ2YWxpZCB3aGVuIHNlbGVjdGVkXCIsICgpLT5cblx0XHRcdHNpbmdsZSA9IHF1aWNrZmllbGQoe3R5cGU6J2Nob2ljZScsIGNob2ljZXM6WydBcHBsZScsICdCYW5hbmEnLCAnT3JhbmdlJ10sIHJlcXVpcmVkOnRydWUsIHZhbGlkV2hlblNlbGVjdGVkOnRydWV9KVxuXHRcdFx0bXVsdGlwbGUgPSBxdWlja2ZpZWxkKHt0eXBlOidjaG9pY2UnLCBjaG9pY2VzOlsnQXBwbGUnLCAnQmFuYW5hJywgJ09yYW5nZSddLCByZXF1aXJlZDp0cnVlLCB2YWxpZFdoZW5TZWxlY3RlZDoyLCBtdWx0aXBsZTp0cnVlfSlcblx0XHRcdGV4cGVjdChzaW5nbGUudmFsaWRhdGUoKSkudG8uZXF1YWwgZmFsc2Vcblx0XHRcdGV4cGVjdChtdWx0aXBsZS52YWxpZGF0ZSgpKS50by5lcXVhbCBmYWxzZVxuXHRcdFx0ZXhwZWN0KEBjb250cm9sLnZhbGlkYXRlKCkpLnRvLmVxdWFsIGZhbHNlXG5cdFx0XHRleHBlY3QoQGNvbnRyb2xNdWx0aS52YWxpZGF0ZSgpKS50by5lcXVhbCBmYWxzZVxuXHRcdFx0XG5cdFx0XHRzaW5nbGUudmFsdWUgPSBtdWx0aXBsZS52YWx1ZSA9IEBjb250cm9sLnZhbHVlID0gQGNvbnRyb2xNdWx0aS52YWx1ZSA9ICdCYW5hbmEnXG5cdFx0XHRleHBlY3Qoc2luZ2xlLnZhbGlkYXRlKCkpLnRvLmVxdWFsIHRydWVcblx0XHRcdGV4cGVjdChtdWx0aXBsZS52YWxpZGF0ZSgpKS50by5lcXVhbCBmYWxzZVxuXHRcdFx0ZXhwZWN0KEBjb250cm9sLnZhbGlkYXRlKCkpLnRvLmVxdWFsIHRydWVcblx0XHRcdGV4cGVjdChAY29udHJvbE11bHRpLnZhbGlkYXRlKCkpLnRvLmVxdWFsIHRydWVcblx0XHRcdFxuXHRcdFx0bXVsdGlwbGUudmFsdWUgPSBbJ0FwcGxlJywgJ0JhbmFuYSddXG5cdFx0XHRleHBlY3QobXVsdGlwbGUudmFsaWRhdGUoKSkudG8uZXF1YWwgdHJ1ZVxuXG5cblx0c3VpdGUgXCJ0cnVlZmFsc2UgZmllbGRcIiwgKCktPlxuXHRcdHN1aXRlU2V0dXAgKCktPlxuXHRcdFx0aGVscGVycy5hZGRUaXRsZSgndHJ1ZWZhbHNlIGZpZWxkJylcblx0XHRcblx0XHR0ZXN0IFwiYmFzaWNcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0cnVlZmFsc2UnLCBsYWJlbDonSXMgaXQgdHJ1ZSBvciBmYWxzZT8nLCB3aWR0aDonYXV0byd9KS5hcHBlbmRUbyhzYW5kYm94KS5lbC5zdHlsZSAnbWFyZ2luUmlnaHQnLCAyMFxuXHRcdFx0YXNzZXJ0LmVxdWFsIGZpZWxkLnZhbHVlLCBudWxsXG5cblx0XHR0ZXN0IFwiZGVmYXVsdCB2YWx1ZVwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3RydWVmYWxzZScsIGxhYmVsOidJdFxcJ3MgZmFsc2UgYnkgZGVmYXVsdCcsIHdpZHRoOidhdXRvJywgY2hvaWNlTGFiZWxzOlsnWWVzJywgJ05vJ10sIHZhbHVlOmZhbHNlfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdGZpZWxkLmVsLnN0eWxlICdtYXJnaW5SaWdodCcsIDIwXG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGQudmFsdWUsIGZhbHNlXG5cdFx0XHRcblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondHJ1ZWZhbHNlJywgbGFiZWw6J0l0XFwncyB0cnVlIGJ5IGRlZmF1bHQnLCB3aWR0aDonYXV0bycsIGNob2ljZUxhYmVsczpbJ1llcycsICdObyddLCB2YWx1ZTp0cnVlfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdGZpZWxkLmVsLnN0eWxlICdtYXJnaW5SaWdodCcsIDIwXG5cdFx0XHRhc3NlcnQuZXF1YWwgZmllbGQudmFsdWUsIHRydWVcblxuXG5cdHN1aXRlIFwidG9nZ2xlIGZpZWxkXCIsICgpLT5cblx0XHRzdWl0ZVNldHVwICgpLT5cblx0XHRcdGhlbHBlcnMuYWRkVGl0bGUoJ3RvZ2dsZSBmaWVsZCcpXG5cdFx0XG5cdFx0dGVzdCBcImJhc2ljXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondG9nZ2xlJywgbGFiZWw6J1RoZSB0b2dnbGUgZmllbGQnLCB3aWR0aDonYXV0byd9KS5hcHBlbmRUbyhzYW5kYm94KS5lbC5zdHlsZSAnbWFyZ2luUmlnaHQnLCAyMFxuXG5cdFx0dGVzdCBcImRlZmF1bHQgdmFsdWVcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOid0b2dnbGUnLCBsYWJlbDonVG9nZ2xlZCBieSBkZWZhdWx0Jywgd2lkdGg6JzEzMHB4JywgZGVmYXVsdFZhbHVlOjF9KS5hcHBlbmRUbyhzYW5kYm94KS5lbC5zdHlsZSAnbWFyZ2luUmlnaHQnLCAyMFxuXG5cdFx0dGVzdCBcImN1c3RvbSBzaXplXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondG9nZ2xlJywgbGFiZWw6J0N1c3RvbSBzaXplIHRvZ2dsZScsIHdpZHRoOidhdXRvJywgc2l6ZTo0MH0pLmFwcGVuZFRvKHNhbmRib3gpLmVsLnN0eWxlICdtYXJnaW5SaWdodCcsIDIwXG5cblx0XHR0ZXN0IFwiYWxpZ25lZCBzdHlsZVwiLCAoKS0+XG5cdFx0XHRmaWVsZCA9IHF1aWNrZmllbGQoe3R5cGU6J3RvZ2dsZScsIGxhYmVsOidBbGlnbmVkIHN0eWxlJywgc3R5bGU6J2FsaWduZWQnLCB3aWR0aDonYXV0byd9KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cdFx0dGVzdCBcImFsaWduZWQgc3R5bGUgKyBkZWZpbmVkIHdpZHRoXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondG9nZ2xlJywgbGFiZWw6J0FsaWduZWQgc3R5bGUgd2l0aCBkZWZpbmVkIHdpZHRoJywgc3R5bGU6J2FsaWduZWQnLCB3aWR0aDonNDAwcHgnfSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTondG9nZ2xlJywgbGFiZWw6J0FsaWduZWQgc3R5bGUgd2l0aCBkZWZpbmVkIHdpZHRoJywgc3R5bGU6J2FsaWduZWQnLCB3aWR0aDonMjAwcHgnfSkuYXBwZW5kVG8oc2FuZGJveClcblxuXG5cdHN1aXRlIFwiZ3JvdXAgZmllbGRcIiwgKCktPlxuXHRcdHNldHVwIGhlbHBlcnMuYWRkRGl2aWRlclxuXHRcdHN1aXRlU2V0dXAgKCktPlxuXHRcdFx0aGVscGVycy5hZGRUaXRsZSgnZ3JvdXAgZmllbGQnKVxuXHRcdFx0QGZpZWxkcyA9IFxuXHRcdFx0XHRmaXJzdDpcblx0XHRcdFx0XHR0eXBlOiAndGV4dCdcblx0XHRcdFx0XHRsYWJlbDogJ0ZpcnN0J1xuXHRcdFx0XHRcdHdpZHRoOiAnNDklJ1xuXHRcdFx0XHRzZWNvbmQ6XG5cdFx0XHRcdFx0dHlwZTogJ3RleHQnXG5cdFx0XHRcdFx0bGFiZWw6ICdTZWNvbmQnXG5cdFx0XHRcdFx0d2lkdGg6ICc0OSUnXG5cdFx0XHRcdHRoaXJkOlxuXHRcdFx0XHRcdHR5cGU6ICdzZWxlY3QnXG5cdFx0XHRcdFx0bGFiZWw6ICdUaGlyZCdcblx0XHRcdFx0XHR3aWR0aDogJzc0JSdcblx0XHRcdFx0XHRjaG9pY2VzOiBbJ0FwcGxlJywgJ0JhbmFuYScsICdLaXdpJ11cblx0XHRcdFx0XHR2YWx1ZTogJ0tpd2knXG5cdFx0XHRcdGZvdXJ0aDpcblx0XHRcdFx0XHR0eXBlOiAndG9nZ2xlJ1xuXHRcdFx0XHRcdGxhYmVsOiAnRm91cnRoJ1xuXHRcdFx0XHRcdHN0eWxlOiAnYWxpZ25lZCdcblx0XHRcdFx0XHR3aWR0aDogJzI0JSdcblx0XHRcdFx0XHRjb25kaXRpb25zOiB0aGlyZDonS2l3aSdcblx0XHRcdFxuXHRcdFx0QGNvbnRyb2wgPSBxdWlja2ZpZWxkKHt0eXBlOidncm91cCcsIGxhYmVsOidCYXNpYyBHcm91cCcsIHdpZHRoOic3MCUnLCBmaWVsZE1hcmdpbjoxMCwgZmllbGRBbGlnbjonbWlkZGxlJywgQGZpZWxkc30pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XG5cdFx0dGVzdCBcImJhc2ljXCIsICgpLT5cblx0XHRcdGV4cGVjdChAY29udHJvbC52YWx1ZSkudG8uZXFsIHtmaXJzdDonJywgc2Vjb25kOicnLCB0aGlyZDonS2l3aScsIGZvdXJ0aDpmYWxzZX1cblx0XHRcdGV4cGVjdChAY29udHJvbC5zdGF0ZS5pbnRlcmFjdGVkKS50by5lcXVhbCBmYWxzZVxuXG5cdFx0XHRAY29udHJvbC52YWx1ZSA9IHtmaXJzdDondmFsdWVBJywgdGhpcmQ6J0thd2EnLCBmb3VydGg6dHJ1ZSwgZmlmdGg6JzUnfVxuXHRcdFx0ZXhwZWN0KEBjb250cm9sLnZhbHVlKS50by5lcWwge2ZpcnN0Oid2YWx1ZUEnLCBzZWNvbmQ6JycsIHRoaXJkOidLYXdhJywgZm91cnRoOnRydWV9XG5cdFx0XHRleHBlY3QoQGNvbnRyb2wuc3RhdGUuaW50ZXJhY3RlZCkudG8uZXF1YWwgdHJ1ZVxuXHRcdFx0XG5cdFx0XHRAY29udHJvbC52YWx1ZSA9IHtzZWNvbmQ6J3ZhbHVlQicsIHRoaXJkOidBcHBsZSd9XG5cdFx0XHRleHBlY3QoQGNvbnRyb2wudmFsdWUpLnRvLmVxbCB7Zmlyc3Q6J3ZhbHVlQScsIHNlY29uZDondmFsdWVCJywgdGhpcmQ6J0FwcGxlJywgZm91cnRoOnRydWV9XG5cblx0XHRcdEBjb250cm9sLnZhbHVlID0gbnVsbFxuXHRcdFx0ZXhwZWN0KEBjb250cm9sLnZhbHVlKS50by5lcWwge2ZpcnN0Oid2YWx1ZUEnLCBzZWNvbmQ6J3ZhbHVlQicsIHRoaXJkOidBcHBsZScsIGZvdXJ0aDp0cnVlfVxuXG5cblx0XHR0ZXN0IFwiY29sbGFwc2VkIGJ5IGRlZmF1bHRcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOidncm91cCcsIHdpZHRoOic3MCUnLCBmaWVsZE1hcmdpbjoxMCwgc3RhcnRDb2xsYXBzZWQ6dHJ1ZSwgQGZpZWxkc30pLmFwcGVuZFRvKHNhbmRib3gpXG5cdFx0XHRleHBlY3QoQGNvbnRyb2wuZWxzLmlubmVyd3JhcC5yYXcpLnRvLmJlLmRpc3BsYXllZFxuXHRcdFx0ZXhwZWN0KGZpZWxkLmVscy5pbm5lcndyYXAucmF3KS5ub3QudG8uYmUuZGlzcGxheWVkXG5cdFx0XHRcblx0XHRcdEBjb250cm9sLnN0YXRlLmNvbGxhcHNlZCA9IHRydWVcblx0XHRcdGZpZWxkLnN0YXRlLmNvbGxhcHNlZCA9IGZhbHNlXG5cdFx0XHRleHBlY3QoQGNvbnRyb2wuZWxzLmlubmVyd3JhcC5yYXcpLm5vdC50by5iZS5kaXNwbGF5ZWRcblx0XHRcdGV4cGVjdChmaWVsZC5lbHMuaW5uZXJ3cmFwLnJhdykudG8uYmUuZGlzcGxheWVkXG5cblx0XHRcdEBjb250cm9sLmVscy5jb2xsYXBzZS5lbWl0ICdjbGljaydcblx0XHRcdGZpZWxkLmVscy5jb2xsYXBzZS5lbWl0ICdjbGljaydcblx0XHRcdGV4cGVjdChAY29udHJvbC5lbHMuaW5uZXJ3cmFwLnJhdykudG8uYmUuZGlzcGxheWVkXG5cdFx0XHRleHBlY3QoZmllbGQuZWxzLmlubmVyd3JhcC5yYXcpLm5vdC50by5iZS5kaXNwbGF5ZWRcblxuXG5cdFx0dGVzdCBcImRlZmF1bHQgdmFsdWVcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHt0eXBlOidncm91cCcsIHdpZHRoOic3MCUnLCBmaWVsZE1hcmdpbjoxMCwgQGZpZWxkcywgdmFsdWU6e2ZpcnN0OidmaXJzdFZhbHVlJywgdGhpcmQ6J0JhbmFuYSd9fSlcblx0XHRcdGV4cGVjdChmaWVsZC52YWx1ZSkudG8uZXFsIHtmaXJzdDonZmlyc3RWYWx1ZScsIHNlY29uZDonJywgdGhpcmQ6J0JhbmFuYScsIGZvdXJ0aDpmYWxzZX1cblx0XHRcblx0XHQjIHRlc3QgXCJpbmxpbmUgbW9kZVwiLCAoKS0+XG5cdFx0IyBcdGZpZWxkID0gcXVpY2tmaWVsZCh7dHlwZTonZ3JvdXAnLCB3aWR0aDonNzAlJywgZmllbGRNYXJnaW46MTAsIEBmaWVsZHMsIHZhbHVlOntmaXJzdDonZmlyc3RWYWx1ZScsIHRoaXJkOidCYW5hbmEnfX0pXG5cdFx0IyBcdGV4cGVjdChmaWVsZC52YWx1ZSkudG8uZXFsIHtmaXJzdDonZmlyc3RWYWx1ZScsIHNlY29uZDonJywgdGhpcmQ6J0JhbmFuYScsIGZvdXJ0aDpmYWxzZX1cblxuXG5cdHN1aXRlIFwicmVwZWF0ZXIgZmllbGRcIiwgKCktPlxuXHRcdHNldHVwIGhlbHBlcnMuYWRkRGl2aWRlclxuXHRcdHN1aXRlU2V0dXAgKCktPlxuXHRcdFx0aGVscGVycy5hZGREaXZpZGVyKDQwKVxuXHRcdFx0QGZpZWxkcyA9IFxuXHRcdFx0XHRmaXJzdDpcblx0XHRcdFx0XHR0eXBlOiAndGV4dCdcblx0XHRcdFx0XHRuYW1lOiAnZmlyc3QnXG5cdFx0XHRcdFx0bGFiZWw6ICdGaXJzdCdcblx0XHRcdFx0XHR3aWR0aDogJzQ5JSdcblx0XHRcdFx0c2Vjb25kOlxuXHRcdFx0XHRcdHR5cGU6ICd0ZXh0J1xuXHRcdFx0XHRcdG5hbWU6ICdzZWNvbmQnXG5cdFx0XHRcdFx0bGFiZWw6ICdTZWNvbmQnXG5cdFx0XHRcdFx0d2lkdGg6ICc0OSUnXG5cdFx0XHRcblx0XHRcdEBjb250cm9sID0gcXVpY2tmaWVsZCh7dHlwZToncmVwZWF0ZXInLCBsYWJlbDonQmFzaWMgUmVwZWF0ZXInLCB3aWR0aDonNzAlJywgZmllbGRNYXJnaW46MTAsIG51bWJlcmluZzp0cnVlLCBjbG9uZWFibGU6dHJ1ZSwgQGZpZWxkc30pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHR0ZXN0IFwiYmxvY2tcIiwgKCktPlxuXHRcdFx0ZXhwZWN0KEBjb250cm9sLnZhbHVlKS50by5lcWwgW11cblx0XHRcdGV4cGVjdChAY29udHJvbC5zdGF0ZS5pbnRlcmFjdGVkKS50by5lcXVhbCBmYWxzZVxuXHRcdFx0XG5cdFx0XHRAY29udHJvbC5lbHMuYWRkQnV0dG9uLmVtaXQgJ2NsaWNrJ1xuXHRcdFx0ZXhwZWN0KEBjb250cm9sLnZhbHVlKS50by5lcWwgW3tmaXJzdDonJywgc2Vjb25kOicnfV1cblx0XHRcdGV4cGVjdChAY29udHJvbC5zdGF0ZS5pbnRlcmFjdGVkKS50by5lcXVhbCB0cnVlXG5cblx0XHRcdEBjb250cm9sLnZhbHVlID0ge2ZpcnN0OidhYmMnLCBzZWNvbmQ6J2RlZid9XG5cdFx0XHRleHBlY3QoQGNvbnRyb2wudmFsdWUpLnRvLmVxbCBbe2ZpcnN0OicnLCBzZWNvbmQ6Jyd9LCB7Zmlyc3Q6J2FiYycsIHNlY29uZDonZGVmJ31dXG5cdFx0XHRleHBlY3QoQGNvbnRyb2wuX3ZhbHVlWzBdLmVscy5sYWJlbC50ZXh0KS50by5lcXVhbCAnSXRlbSAxJ1xuXHRcdFx0ZXhwZWN0KEBjb250cm9sLl92YWx1ZVsxXS5lbHMubGFiZWwudGV4dCkudG8uZXF1YWwgJ0l0ZW0gMidcblxuXHRcdFx0QGNvbnRyb2wuX3ZhbHVlWzBdLmVscy5yZW1vdmUuZW1pdCAnY2xpY2snXG5cdFx0XHRleHBlY3QoQGNvbnRyb2wudmFsdWUpLnRvLmVxbCBbe2ZpcnN0OidhYmMnLCBzZWNvbmQ6J2RlZid9XVxuXHRcdFx0ZXhwZWN0KEBjb250cm9sLl92YWx1ZVswXS5lbHMubGFiZWwudGV4dCkudG8uZXF1YWwgJ0l0ZW0gMSdcblx0XHRcdFxuXHRcdFx0QGNvbnRyb2wudmFsdWUgPSBbe2ZpcnN0OidBQkMnfSwge3NlY29uZDonREVGJ31dXG5cdFx0XHRleHBlY3QoQGNvbnRyb2wudmFsdWUpLnRvLmVxbCBbe2ZpcnN0OidBQkMnLCBzZWNvbmQ6J2RlZid9LCB7Zmlyc3Q6JycsIHNlY29uZDonREVGJ31dXG5cblxuXHRcdHRlc3QgXCJpbmxpbmVcIiwgKCktPlxuXHRcdFx0ZmllbGQgPSBxdWlja2ZpZWxkKHtcblx0XHRcdFx0dHlwZToncmVwZWF0ZXInXG5cdFx0XHRcdGxhYmVsOidJbmxpbmUgUmVwZWF0ZXInXG5cdFx0XHRcdHdpZHRoOic3MCUnXG5cdFx0XHRcdGZpZWxkTWFyZ2luOjEwXG5cdFx0XHRcdG51bWJlcmluZzp0cnVlXG5cdFx0XHRcdGF1dG9SZW1vdmVFbXB0eTogdHJ1ZVxuXHRcdFx0XHRzdHlsZTonaW5saW5lJ1xuXHRcdFx0XHR2YWx1ZTogW3tmaXJzdDonYWJjJywgc2Vjb25kOicxMjMnfSwge3NlY29uZDonNDU2J31dXG5cdFx0XHRcdGZpZWxkczpcblx0XHRcdFx0XHRmaXJzdDogZXh0ZW5kKHthdXRvV2lkdGg6dHJ1ZX0sIEBmaWVsZHMuZmlyc3QpXG5cdFx0XHRcdFx0c2Vjb25kOiBleHRlbmQoe2F1dG9XaWR0aDp0cnVlfSwgQGZpZWxkcy5zZWNvbmQpXG5cdFx0XHR9KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cdFx0XHRleHBlY3QoZmllbGQudmFsdWUpLnRvLmVxbCBbXG5cdFx0XHRcdHtmaXJzdDonYWJjJywgc2Vjb25kOicxMjMnfVxuXHRcdFx0XHR7Zmlyc3Q6JycsIHNlY29uZDonNDU2J31cblx0XHRcdF1cblxuXG5cdFx0dGVzdCBcImlubGluZSBzaW5nbGVNb2RlXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7XG5cdFx0XHRcdHR5cGU6J3JlcGVhdGVyJ1xuXHRcdFx0XHRsYWJlbDonSW5saW5lIFJlcGVhdGVyJ1xuXHRcdFx0XHR3aWR0aDonNzAlJ1xuXHRcdFx0XHRmaWVsZE1hcmdpbjogMTBcblx0XHRcdFx0YXV0b1dpZHRoOiBmYWxzZVxuXHRcdFx0XHRhdXRvUmVtb3ZlRW1wdHk6IHRydWVcblx0XHRcdFx0bnVtYmVyaW5nOnRydWVcblx0XHRcdFx0c3R5bGU6J2lubGluZSdcblx0XHRcdFx0c2luZ2xlTW9kZTogdHJ1ZVxuXHRcdFx0XHRncm91cFNldHRpbmdzOiBpbmxpbmU6IHdpZHRoOiAnMTAwJSdcblx0XHRcdFx0ZmllbGRzOiBleHRlbmQuY2xvbmUoQGZpZWxkcy5maXJzdCwge3dpZHRoOicxMDAlJ30pXG5cdFx0XHR9KS5hcHBlbmRUbyhzYW5kYm94KVxuXG5cdFx0XHRleHBlY3QoZmllbGQudmFsdWUpLnRvLmVxbCBbXVxuXHRcdFx0ZmllbGQudmFsdWUgPSBbJ2FiYycsICcxMjMnXVxuXHRcdFx0ZXhwZWN0KGZpZWxkLnZhbHVlKS50by5lcWwgWydhYmMnLCAnMTIzJ11cblx0XHRcdGZpZWxkLnZhbHVlID0gJ2RlZidcblx0XHRcdGV4cGVjdChmaWVsZC52YWx1ZSkudG8uZXFsIFsnYWJjJywgJzEyMycsICdkZWYnXVxuXG5cblx0XHR0ZXN0IFwiZHluYW1pY0xhYmVsXCIsICgpLT5cblx0XHRcdGZpZWxkID0gcXVpY2tmaWVsZCh7XG5cdFx0XHRcdHR5cGU6J3JlcGVhdGVyJ1xuXHRcdFx0XHRsYWJlbDonSW5saW5lIFJlcGVhdGVyJ1xuXHRcdFx0XHR3aWR0aDonNzAlJ1xuXHRcdFx0XHRkeW5hbWljTGFiZWw6ICdmaXJzdCdcblx0XHRcdFx0ZmllbGRNYXJnaW46MTBcblx0XHRcdFx0YXV0b1JlbW92ZUVtcHR5OiB0cnVlXG5cdFx0XHRcdHZhbHVlOiBbe2ZpcnN0OidhYmMnLCBzZWNvbmQ6JzEyMyd9LCB7c2Vjb25kOic0NTYnfV1cblx0XHRcdFx0ZmllbGRzOlxuXHRcdFx0XHRcdGZpcnN0OiBleHRlbmQoe2F1dG9XaWR0aDp0cnVlfSwgQGZpZWxkcy5maXJzdClcblx0XHRcdFx0XHRzZWNvbmQ6IGV4dGVuZCh7YXV0b1dpZHRoOnRydWV9LCBAZmllbGRzLnNlY29uZClcblx0XHRcdH0pLmFwcGVuZFRvKHNhbmRib3gpXG5cblx0XHRcdGV4cGVjdChmaWVsZC5fdmFsdWVbMF0uZWwuY2hpbGQubGFiZWwudGV4dCkudG8uZXF1YWwgJ2FiYydcblx0XHRcdGV4cGVjdChmaWVsZC5fdmFsdWVbMV0uZWwuY2hpbGQubGFiZWwudGV4dCkudG8uZXF1YWwgJydcblxuXHRcdFx0ZmllbGQudmFsdWUgPSBbe2ZpcnN0OidkZWYnfSwge2ZpcnN0OicxMjMnfV1cblx0XHRcdGV4cGVjdChmaWVsZC5fdmFsdWVbMF0uZWwuY2hpbGQubGFiZWwudGV4dCkudG8uZXF1YWwgJ2RlZidcblx0XHRcdGV4cGVjdChmaWVsZC5fdmFsdWVbMV0uZWwuY2hpbGQubGFiZWwudGV4dCkudG8uZXF1YWwgJzEyMydcblx0XHRcdCMgZXhwZWN0KGZpZWxkLnZhbHVlKS50by5lcWwgW1xuXHRcdFx0IyBcdHtmaXJzdDonYWJjJywgc2Vjb25kOicxMjMnfVxuXHRcdFx0IyBcdHtmaXJzdDonJywgc2Vjb25kOic0NTYnfVxuXHRcdFx0IyBdXG5cblxuXHRzdWl0ZSBcIi5jb25maWcoKVwiLCAoKS0+XG5cdFx0dGVzdCBcImNyZWF0ZXMgYSBuZXcgY29weSBvZiBRdWlja0ZpZWxkIHdpdGggc2V0dGluZyBvdmVycmlkZXMgYW5kIHRlbXBsYXRlIG92ZXJyaWRlc1wiLCAoKS0+XG5cdFx0XHRxdWlja2ZpZWxkMiA9IHF1aWNrZmllbGQuY29uZmlnKFxuXHRcdFx0XHRnbG9iYWw6XG5cdFx0XHRcdFx0Zm9udEZhbWlseTogJ2hlbHZldGljYSdcblx0XHRcdFx0XHR3aWR0aDogJzUwJSdcblx0XHRcdFx0XHRyZXF1aXJlZDogdHJ1ZVxuXHRcdFx0XHRcdGJvcmRlcjogJzAgMCAycHggMCdcblx0XHRcdFx0XHRtYXJnaW46ICcwIDEwcHggMTBweCAwJ1xuXHRcdFx0XHRcdGZvbnRTaXplOiAxM1xuXHRcdFx0XHRcdGlucHV0UGFkZGluZzogOFxuXG5cdFx0XHRcdHRleHQ6XG5cdFx0XHRcdFx0aGVpZ2h0OiA0MFxuXHRcdFx0XHRcdGF1dG9XaWR0aDogdHJ1ZVxuXHRcdFx0XHRcdGlucHV0UGFkZGluZzogMFxuXHRcdFx0XHRcdGNoZWNrbWFyazogZmFsc2Vcblx0XHRcdFx0XHRtaW5MZW5ndGg6IDJcblx0XHRcdFx0XHRtYXNrOlxuXHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI6ICcqJ1xuXHRcdFx0XHRcdFx0ZGVjaW1hbDogdHJ1ZVxuXG5cdFx0XHQsXG5cdFx0XHRcdGdsb2JhbDpcblx0XHRcdFx0XHRmaWVsZDpcblx0XHRcdFx0XHRcdG9wdGlvbnM6IHN0eWxlOlxuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJ1xuXG5cdFx0XHRcdFx0XHRjaGlsZHJlbjpcblx0XHRcdFx0XHRcdFx0bGFiZWw6IG9wdGlvbnM6IHN0eWxlOlxuXHRcdFx0XHRcdFx0XHRcdCRmb2N1czogY29sb3I6IENPTE9SUy5ncmVlblxuXHRcdFx0XHRcdFx0XHRpbm5lcndyYXA6IG9wdGlvbnM6IHN0eWxlOlxuXHRcdFx0XHRcdFx0XHRcdCRmb2N1czogYm9yZGVyQ29sb3I6IENPTE9SUy5ncmVlblxuXHRcdFx0XHRcblx0XHRcdFx0dGV4dDpcblx0XHRcdFx0XHRkZWZhdWx0OiBjaGlsZHJlbjpcblx0XHRcdFx0XHRcdGxhYmVsOiBvcHRpb25zOiBzdHlsZTpcblx0XHRcdFx0XHRcdFx0Zm9udFdlaWdodDogNzAwXG5cdFx0XHRcdFxuXHRcdFx0XHRjaG9pY2U6XG5cdFx0XHRcdFx0Y2hvaWNlOiBvcHRpb25zOiBzdHlsZTpcblx0XHRcdFx0XHRcdCRzZWxlY3RlZDogY29sb3I6IENPTE9SUy5ncmVlblxuXHRcdFx0KVxuXG5cdFx0XHRleHBlY3QocXVpY2tmaWVsZDIpLm5vdC50by5lcXVhbChxdWlja2ZpZWxkKVxuXHRcdFx0dGV4dEEgPSBxdWlja2ZpZWxkKHR5cGU6J3RleHQnLCBsYWJlbDondGV4dEEnKS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0dGV4dEIgPSBxdWlja2ZpZWxkMih0eXBlOid0ZXh0JywgbGFiZWw6J3RleHRCJywgYXV0b1dpZHRoOmZhbHNlKS5hcHBlbmRUbyhzYW5kYm94KTsgaGVscGVycy5hZGREaXZpZGVyKClcblx0XHRcdHRleHRDID0gcXVpY2tmaWVsZDIodHlwZTondGV4dCcsIGxhYmVsOid0ZXh0QycsIG1hc2s6e3BhdHRlcm46J05VTUJFUicsIHN1ZmZpeDonJSd9KS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0dGV4dEQgPSBxdWlja2ZpZWxkMih0eXBlOid0ZXh0JywgbGFiZWw6J3RleHREJywgbWFzazp7cGF0dGVybjonREFURScsIHN1ZmZpeDonJSd9KS5hcHBlbmRUbyhzYW5kYm94KVxuXHRcdFx0Y2hvaWNlID0gcXVpY2tmaWVsZDIodHlwZTonY2hvaWNlJywgY2hvaWNlczpbJ0FwcGxlJywgJ0JhbmFuYScsICdPcmFuZ2UnXSkuYXBwZW5kVG8oc2FuZGJveClcblx0XHRcdFxuXHRcdFx0ZXhwZWN0KHRleHRBLmVsLnN0eWxlICdmb250RmFtaWx5JykudG8uZXF1YWwgcXVpY2tmaWVsZC5GaWVsZDo6Z2xvYmFsRGVmYXVsdHMuZm9udEZhbWlseVxuXHRcdFx0ZXhwZWN0KHRleHRCLmVsLnN0eWxlICdmb250RmFtaWx5JykudG8uZXF1YWwgJ2hlbHZldGljYSdcblx0XHRcdGV4cGVjdCh0ZXh0QS5lbC5zdHlsZSAndmVydGljYWxBbGlnbicpLnRvLmVxdWFsICd0b3AnXG5cdFx0XHRleHBlY3QodGV4dEIuZWwuc3R5bGUgJ3ZlcnRpY2FsQWxpZ24nKS50by5lcXVhbCAnbWlkZGxlJ1xuXHRcdFx0ZXhwZWN0KHRleHRBLmVsLnN0eWxlUGFyc2VkICdtYXJnaW5Cb3R0b20nKS50by5lcXVhbCAwXG5cdFx0XHRleHBlY3QodGV4dEIuZWwuc3R5bGVQYXJzZWQgJ21hcmdpbkJvdHRvbScpLnRvLmVxdWFsIDEwXG5cdFx0XHRleHBlY3QodGV4dEEuZWwuc3R5bGVTYWZlICd3aWR0aCcsdHJ1ZSkudG8uZXF1YWwgJzEwMCUnXG5cdFx0XHRleHBlY3QodGV4dEIuZWwuc3R5bGVTYWZlICd3aWR0aCcsdHJ1ZSkudG8uZXF1YWwgJzUwJSdcblx0XHRcdGV4cGVjdCh0ZXh0QS5lbC5jaGlsZC5sYWJlbC5zdHlsZVBhcnNlZCAnZm9udFdlaWdodCcsdHJ1ZSkudG8uZXF1YWwgNjAwXG5cdFx0XHRleHBlY3QodGV4dEIuZWwuY2hpbGQubGFiZWwuc3R5bGVQYXJzZWQgJ2ZvbnRXZWlnaHQnLHRydWUpLnRvLmVxdWFsIDcwMFxuXHRcdFx0ZXhwZWN0KHRleHRBLmVsLmhlaWdodCkudG8uZXF1YWwgcXVpY2tmaWVsZC5GaWVsZC50ZXh0OjpkZWZhdWx0cy5oZWlnaHRcblx0XHRcdGV4cGVjdCh0ZXh0Qi5lbC5oZWlnaHQpLnRvLmVxdWFsIDQwXG5cdFx0XHRleHBlY3QodGV4dEEuZWwuY2hpbGQuY2hlY2ttYXJrKS50by5iZS5vYmplY3QoKVxuXHRcdFx0ZXhwZWN0KHRleHRCLmVsLmNoaWxkLmNoZWNrbWFyaykubm90LnRvLmJlLm9iamVjdCgpXG5cdFx0XHRleHBlY3QoaGVscGVycy5nZXRCb3JkZXJTaWRlcyh0ZXh0QS5lbHMuaW5uZXJ3cmFwKSkudG8uZXFsIHt0b3A6JzFweCcsIGxlZnQ6JzFweCcsIHJpZ2h0OicxcHgnLCBib3R0b206JzFweCd9XG5cdFx0XHRleHBlY3QoaGVscGVycy5nZXRCb3JkZXJTaWRlcyh0ZXh0Qi5lbHMuaW5uZXJ3cmFwKSkudG8uZXFsIHt0b3A6JzBweCcsIGxlZnQ6JzBweCcsIHJpZ2h0OicwcHgnLCBib3R0b206JzJweCd9XG5cdFx0XHRleHBlY3QodGV4dEEudmFsaWRhdGUoKSkudG8uZXF1YWwgdHJ1ZVxuXHRcdFx0ZXhwZWN0KHRleHRCLnZhbGlkYXRlKCkpLnRvLmVxdWFsIGZhbHNlXG5cblx0XHRcdGhlbHBlcnMuc2ltdWxhdGVLZXlzKHRleHRBLmVsLmNoaWxkLmlucHV0LnJhdywgJ2FiYycpXG5cdFx0XHRoZWxwZXJzLnNpbXVsYXRlS2V5cyh0ZXh0Qi5lbC5jaGlsZC5pbnB1dC5yYXcsICdhYmMnKVxuXHRcdFx0ZXhwZWN0KHRleHRBLnZhbGlkYXRlKCkpLnRvLmVxdWFsIHRydWVcblx0XHRcdGV4cGVjdCh0ZXh0Qi52YWxpZGF0ZSgpKS50by5lcXVhbCB0cnVlXG5cblx0XHRcdGhlbHBlcnMuc2ltdWxhdGVLZXlzKHRleHRELmVsLmNoaWxkLmlucHV0LnJhdywgJzEnKVxuXHRcdFx0ZXhwZWN0KHRleHRELnZhbHVlKS50by5lcXVhbCAnMSovKiovKioqKidcblxuXHRcdFx0RE9NLmJhdGNoKFt0ZXh0QS5lbHMubGFiZWwsIHRleHRCLmVscy5sYWJlbCwgdGV4dEEuZWxzLmlubmVyd3JhcCwgdGV4dEIuZWxzLmlubmVyd3JhcF0pLnN0eWxlICd0cmFuc2l0aW9uJywgbnVsbFxuXHRcdFx0dGV4dEEuc3RhdGUuZm9jdXNlZCA9IHRleHRCLnN0YXRlLmZvY3VzZWQgPSB0cnVlXG5cdFx0XHRleHBlY3QodGV4dEEuZWwuY2hpbGQubGFiZWwucmF3KS50by5oYXZlLnN0eWxlICdjb2xvcicsIENPTE9SUy5vcmFuZ2Vcblx0XHRcdGV4cGVjdCh0ZXh0Qi5lbC5jaGlsZC5sYWJlbC5yYXcpLnRvLmhhdmUuc3R5bGUgJ2NvbG9yJywgQ09MT1JTLmdyZWVuXG5cdFx0XHRleHBlY3QodGV4dEEuZWwuY2hpbGQuaW5uZXJ3cmFwLnJhdykudG8uaGF2ZS5zdHlsZSAnYm9yZGVyQ29sb3InLCBDT0xPUlMub3JhbmdlXG5cdFx0XHRleHBlY3QodGV4dEIuZWwuY2hpbGQuaW5uZXJ3cmFwLnJhdykudG8uaGF2ZS5zdHlsZSAnYm9yZGVyQ29sb3InLCBDT0xPUlMuZ3JlZW5cblx0XHRcdHRleHRBLmJsdXIoKVxuXHRcdFx0dGV4dEIuYmx1cigpXG5cblx0XHRcdGNob2ljZS52YWx1ZSA9ICdCYW5hbmEnXG5cdFx0XHRleHBlY3QoY2hvaWNlLnZhbHVlUmF3LmxhYmVsKS50by5lcXVhbCAnQmFuYW5hJ1xuXHRcdFx0ZXhwZWN0KGNob2ljZS52YWx1ZVJhdy5lbC5yYXcpLnRvLmhhdmUuc3R5bGUgJ2NvbG9yJywgQ09MT1JTLmdyZWVuXG5cblxuXG5cblxuXG5cblxuXG4iXSwibmFtZXMiOlsia2V5Ym9hcmQiLCJLZXlib2FyZCIsIlVTX0VOR0xJU0giLCJ0YXJnZXQiLCJrZXlzIiwidmFsdWUiLCJmb2N1cyIsImRpc3BhdGNoRXZlbnRzRm9ySW5wdXQiLCJkaXNwYXRjaEV2ZW50c0ZvckFjdGlvbiIsIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiUkVHRVhfTEVOX1ZBTCIsIlJFR0VYX0RJR0lUUyIsIlJFR0VYX1NQQUNFIiwiUkVHRVhfS0VCQUIiLCJJTVBPUlRBTlQiLCJQT1NTSUJMRV9QUkVGSVhFUyIsIlJFUVVJUkVTX1VOSVRfVkFMVUUiLCJRVUFEX1NIT1JUSEFORFMiLCJESVJFQ1RJT05TIiwiZm9yRWFjaCIsInByb3BlcnR5IiwiZGlyZWN0aW9uIiwiaSIsImxlbiIsInB1c2giLCJsZW5ndGgiLCJTQU1QTEVfU1RZTEUiLCJzdHlsZUNvbmZpZyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiaW5jbHVkZXMiLCJpdGVtIiwiaW5kZXhPZiIsImlzSXRlcmFibGUiLCJub2RlVHlwZSIsInRvS2ViYWJDYXNlIiwic3RyaW5nIiwicmVwbGFjZSIsImUiLCJsZXR0ZXIiLCJjb25jYXQiLCJ0b0xvd2VyQ2FzZSIsImlzUHJvcFN1cHBvcnRlZCIsImlzVmFsdWVTdXBwb3J0ZWQiLCJ3aW5kb3ciLCJDU1MiLCJzdXBwb3J0cyIsImdldFByZWZpeCIsInNraXBJbml0aWFsQ2hlY2siLCJqIiwibGVuMSIsInByZWZpeCIsIm5vcm1hbGl6ZVByb3BlcnR5Iiwibm9ybWFsaXplVmFsdWUiLCJ0ZXN0Iiwic29ydCIsImFycmF5IiwiZ3JlYXQiLCJsZXNzIiwicGl2b3QiLCJoYXNoIiwiaHNoIiwiY2hhckNvZGVBdCIsInJ1bGVUb1N0cmluZyIsInJ1bGUiLCJpbXBvcnRhbnQiLCJvdXRwdXQiLCJwcm9wIiwicHJvcHMiLCJPYmplY3QiLCJpbmxpbmVTdHlsZUNvbmZpZyIsImNyZWF0ZSIsImlubGluZVN0eWxlIiwidmFsdWVUb1N0b3JlIiwibGV2ZWwiLCJjb25maWciLCJzdHlsZUVsIiwiaWQiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJlbCIsImNvbnRlbnQiLCJjYWNoZSIsInRleHRDb250ZW50IiwiY2xlYXJJbmxpbmVTdHlsZSIsImtleSIsInZlcnNpb24iLCJfcXVpY2tjc3MiLCJpbmRleCIsInF1aWNrY3NzIiwidGFyZ2V0RWwiLCJjb21wdXRlZFN0eWxlIiwic3ViRWwiLCJzdWJQcm9wZXJ0eSIsInN1YlZhbHVlIiwiX2NvbXB1dGVkU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwic2V0UHJvcGVydHkiLCJhbmltYXRpb24iLCJuYW1lJCQxIiwiZnJhbWVzIiwiZnJhbWUiLCJnZW5lcmF0ZWQiLCJydWxlcyIsInJlZ2lzdGVyIiwiY2xhc3NOYW1lIiwicmVmIiwiY2xlYXJSZWdpc3RlcmVkIiwiVU5TRVQiLCJzdXBwb3J0c1Byb3BlcnR5IiwiX2V4dGVuZCIsImlzQXJyYXkiLCJpc09iamVjdCIsIl9zaG91bGREZWVwRXh0ZW5kIiwiQXJyYXkiLCJ0b1N0cmluZyIsImNhbGwiLCJzaG91bGREZWVwRXh0ZW5kIiwib3B0aW9ucyIsInBhcmVudEtleSIsImRlZXAiLCJub3REZWVwIiwiZGVlcE9ubHkiLCJleHRlbmQiLCJzb3VyY2VzIiwic291cmNlIiwic291cmNlVmFsdWUiLCJzdWJUYXJnZXQiLCJ0YXJnZXRWYWx1ZSIsImFsbG93TnVsbCIsIm51bGxEZWxldGVzIiwibm90S2V5cyIsIm93biIsImhhc093blByb3BlcnR5IiwiZ2xvYmFsRmlsdGVyIiwiZmlsdGVycyIsImdsb2JhbFRyYW5zZm9ybSIsInRyYW5zZm9ybXMiLCJtb2RpZmllcnMiLCJuZXdCdWlsZGVyIiwibm9ybWFsaXplS2V5cyIsInByaW1hcnlCdWlsZGVyIiwiaXNCYXNlIiwiX2J1aWxkZXIiLCJidWlsZGVyIiwidGhlVGFyZ2V0IiwiJF9sZW4iLCJhcmd1bWVudHMiLCIkX2kiLCJzaGlmdCIsImRlZmluZVByb3BlcnRpZXMiLCJnZXQiLCJfIiwidHJhbnNmb3JtIiwiZmlsdGVyIiwicHJpbWFyeUJ1aWxkZXIkMSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsImRlZmluZWQiLCJzdWJqZWN0Iiwib2JqZWN0Iiwib2JqZWN0UGxhaW4iLCJudW1iZXIiLCJpc05hTiIsIm51bWJlckxvb3NlIiwiTnVtYmVyIiwiaXRlcmFibGUiLCJmdW5jdGlvbl8iLCJuYXRpdmVzIiwiZnJlZXplIiwiZG9tRG9jIiwiZG9tRWwiLCJkb21UZXh0IiwiZG9tTm9kZSIsImRvbVRleHRhcmVhIiwibm9kZU5hbWUiLCJkb21JbnB1dCIsImRvbVNlbGVjdCIsImRvbUZpZWxkIiwiZG9tIiwiQVZBSUxfU0VUUyIsIkNoZWNrcyIsImFyZ3MiLCJzbGljZSIsInNldHMiLCJzZXQiLCJsb2FkIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXJyIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsImFycjIiLCJpdGVyIiwiZnJvbSIsInRlbXBsYXRlIiwiZWxlbWVudCIsIklTIiwiSVNfIiwicXVpY2tEb21FbCIsIm5hbWUiLCJJUyQxIiwiUXVpY2tFbGVtZW50IiwiUXVpY2tXaW5kb3ciLCJfcXVpY2tkb20iLCJxdWlja2RvbSIsImFyZyIsInByZXZDb3VudCIsImNvdW50IiwiX3Bvc3RDcmVhdGlvbiIsImFyZ3NMZW5ndGgiLCJjaGlsZCIsImNoaWxkcmVuIiwidHlwZSIsImFwcGx5Iiwic3Bhd24iLCJ1cGRhdGVPcHRpb25zIiwiX3F1aWNrRWxlbWVudCIsImV4aXN0aW5nIiwidGV4dCIsImFwcGVuZCIsImh0bWwiLCJpbm5lckhUTUwiLCJjb250YWluZXIiLCJjaGlsZE5vZGVzIiwiYmF0Y2giLCJpc1F1aWNrRWwiLCJpc0VsIiwiaW5pdCIsIlF1aWNrRWxlbWVudF8iLCJRdWlja1dpbmRvd18iLCJyZW1vdmVJdGVtIiwiaXRlbUluZGV4Iiwic3BsaWNlIiwibm9ybWFsaXplRWxlbWVudEFyZyIsImlzU3RhdGVTdHlsZSIsInJlZ2lzdGVyU3R5bGUiLCJjYWNoZWQiLCJzdHlsZUNhY2hlIiwiZm5zIiwiX2NsYXNzIiwidmFsdWVzIiwiUkVHRVhfV0hJVEVTUEFDRSIsIm9uXyIsImV2ZW50TmFtZXMiLCJjYWxsYmFjayIsInVzZUNhcHR1cmUiLCJpc1ByaXZhdGUiLCJfdGhpcyIsImNhbGxiYWNrUmVmIiwic3BsaXQiLCJfZXZlbnRDYWxsYmFja3MiLCJfX3JlZnMiLCJmdW5jdGlvbiIsIl9pbnNlcnRlZCIsIl9wYXJlbnQiLCJldmVudE5hbWUiLCJiYXNlIiwiX2xpc3RlblRvIiwiZXZlbnQiLCJfaW52b2tlSGFuZGxlcnMiLCJvbmNlIiwiX3RoaXMyIiwiX29uY2VDYWxsYmFjayIsIm9uIiwib25jZUNhbGxiYWNrIiwib2ZmIiwib2ZmXyIsIl90aGlzMyIsImVtaXQiLCJidWJibGVzIiwidW5kZWZpbmVkIiwiY2FuY2VsYWJsZSIsImRhdGEiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJlbWl0UHJpdmF0ZSIsImNhbGxiYWNrcyIsImNiIiwiZXZlbnROYW1lVG9MaXN0ZW5Gb3IiLCJsaXN0ZW5NZXRob2QiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnRzIiwicmVzdWx0IiwicmVsYXRlZCIsImN1cnJlbnRTdGF0ZVN0eWxlIiwidGhlbiIsImZvcmNlU3R5bGUiLCJzdHlsZVNhZmUiLCJza2lwQ29tcHV0ZWQiLCJjb21wdXRlZCIsInNhbXBsZSIsInN0eWxlUGFyc2VkIiwicGFyc2VGbG9hdCIsInJlY2FsY1N0eWxlIiwicmVjYWxjQ2hpbGRyZW4iLCJ0YXJnZXRTdHlsZXMiLCJfcmVzb2x2ZUZuU3R5bGVzIiwiX2dldEFjdGl2ZVN0YXRlcyIsIl9jaGlsZHJlbiIsInN0YXRlIiwic3RhdGVzIiwiX3N0YXRlIiwiX3N0YXRlU2hhcmVkIiwiX3N0YXRlcyIsIl9zdHlsZXMiLCJoaWRlIiwic2hvdyIsImRpc3BsYXkiLCJvcmllbnRhdGlvbkdldHRlciIsIndpZHRoIiwiaGVpZ2h0IiwiYXNwZWN0UmF0aW9HZXR0ZXIiLCJzdHlsZSQxIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiUXVpY2tXaW5kb3ckMSIsIlF1aWNrV2luZG93JDIiLCJyYXciLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJNZWRpYVF1ZXJ5IiwiUlVMRV9ERUlMSU1JVEVSIiwiTWVkaWFRdWVyeSQxIiwidGVzdFJ1bGUiLCJwYXJzZVF1ZXJ5IiwicXVlcnlTdHJpbmciLCJxdWVyeVNwbGl0IiwicGFyZW50IiwicGFyZW50TWF0Y2hpbmciLCJtYXAiLCJnZXR0ZXIiLCJrZXlQcmVmaXgiLCJtYXgiLCJtaW4iLCJvcmllbnRhdGlvbiIsImFzcGVjdFJhdGlvIiwicGFyc2VkVmFsdWUiLCJzdHJpbmdWYWx1ZSIsInF1ZXJ5IiwiY3VycmVudFZhbHVlIiwicGFzc2VkIiwiU3RhdGVDaGFpbiIsIlN0YXRlQ2hhaW4kMSIsImpvaW4iLCJ3aXRob3V0IiwiaXNBcHBsaWNhYmxlIiwib3RoZXJBY3RpdmUiLCJhY3RpdmUiLCJCQVNFX1NUQVRFX1RSSUdHRVJTIiwiQ0FDSEVEX0ZOX0lOU0VSVEVEIiwiX25vcm1hbGl6ZU9wdGlvbnMiLCJiYXNlMSIsImJhc2UyIiwiYmFzZTMiLCJiYXNlNCIsImJhc2U1IiwicmVsYXRlZEluc3RhbmNlIiwiY2xhc3MiLCJ1cmwiLCJocmVmIiwidW5wYXNzYWJsZVN0YXRlcyIsInBhc3NTdGF0ZVRvQ2hpbGRyZW4iLCJwYXNzRGF0YVRvQ2hpbGRyZW4iLCJzdGF0ZVRyaWdnZXJzIiwiY2xvbmUiLCJfcGFyc2VUZXh0cyIsIl90ZXh0cyIsIl9wYXJzZVN0eWxlcyIsInN0eWxlcyIsInN0b3JlIiwiX21lZGlhU3RhdGVzIiwiX3Byb3ZpZGVkU3RhdGVzIiwiX3Byb3ZpZGVkU3RhdGVzU2hhcmVkIiwiX2ZsYXR0ZW5OZXN0ZWRTdGF0ZXMiLCJzcGVjaWFsU3RhdGVzIiwic3RhdGVTdHlsZXMiLCJzdGF0ZV8iLCIkYmFzZSIsImZsYXR0ZW5OZXN0ZWRTdGF0ZXMiLCJzdHlsZU9iamVjdCIsImNoYWluIiwiaGFzTm9uU3RhdGVQcm9wcyIsInN0YXRlQ2hhaW4iLCJzdHlsZUtleXMiLCJ0ZXh0cyIsIl9hcHBseU9wdGlvbnMiLCJoYW5kbGVyIiwibWV0aG9kIiwicmVmMSIsInJlZjIiLCJhdHRyIiwic3JjIiwic2VsZWN0ZWQiLCJjaGVja2VkIiwiYXR0cnMiLCJfYXBwbHlSZWdpc3RlcmVkU3R5bGUiLCJzdHlsZUFmdGVySW5zZXJ0IiwiaW52b2tlQ29tcHV0ZXJzT25jZSIsIl9pbnZva2VkQ29tcHV0ZXJzIiwicmVjYWxjT25SZXNpemUiLCJtZXRob2RzIiwiY29tcHV0ZXJzIiwiYXBwbHlEYXRhIiwiX2luaXQiLCJfcnVuQ29tcHV0ZXIiLCJfYXR0YWNoU3RhdGVFdmVudHMiLCJmb3JjZSIsImRpc2FibGVyIiwiZW5hYmxlciIsInRyaWdnZXIiLCJfcHJveHlQYXJlbnQiLCJuZXdQYXJlbnQiLCJsYXN0UGFyZW50IiwicGFyZW50cyIsImRvY3VtZW50RWxlbWVudCIsIl91bnByb3h5UGFyZW50IiwibWVkaWFTdGF0ZXMiLCJyZXN1bHRzIiwiaW5pdCQxIiwiYWxpYXNlcyIsInBhcmVudHNVbnRpbCIsIl9nZXRQYXJlbnRzIiwiaXNSZWYiLCJuZXh0UGFyZW50Iiwic2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yIiwicXVlcnlBbGwiLCJxdWVyeVNlbGVjdG9yQWxsIiwiX2dldENoaWxkUmVmcyIsImZyZXNoQ29weSIsImNoaWxkUmVmcyIsInJlZnMiLCJfY2hpbGRSZWZzIiwiX2dldEluZGV4QnlQcm9wIiwibWFpbiIsIl9maWx0ZXJFbGVtZW50cyIsInRyYXZlcnNpbmciLCJwYXJlbnROb2RlIiwibmV4dFNpYmxpbmciLCJuZXh0RWxlbWVudFNpYmxpbmciLCJuZXh0QWxsIiwic2libGluZ3MiLCJuZXh0IiwicHJldmlvdXNTaWJsaW5nIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsInByZXZBbGwiLCJwcmV2U2libGluZyIsInByZXYiLCJyZXZlcnNlIiwiRFVNTVlfQVJSQVkiLCJ0YXJnZXRTdGF0ZSIsImFjdGl2ZVN0YXRlcyIsImRlc2lyZWRWYWx1ZSIsInRvZ2dsZSIsIl9zdGF0ZVBpcGVUYXJnZXQiLCJ0b2dnbGVTdGF0ZSIsInJlc2V0U3RhdGUiLCJhY3RpdmVTdGF0ZSIsInBpcGVTdGF0ZSIsInRhcmdldFN0eWxlIiwic3VwZXJpb3JTdGF0ZXMiLCJpbmNsdWRlQmFzZSIsInNraXBGbnMiLCJlbnRyeSIsImsiLCJzdXBlcmlvclN0eWxlcyIsImFkZENsYXNzIiwiX3JlbW92ZVJlZ2lzdGVyZWRTdHlsZSIsInJlc2V0VmFsdWUiLCJyZW1vdmVDbGFzcyIsIl90dXJuU3R5bGVPTiIsInNoYXJlZFN0YXRlcyIsIl9nZXRTdXBlcmlvclN0YXRlcyIsIl9nZXRTaGFyZWRTdGF0ZXMiLCJfdHVyblN0eWxlT0ZGIiwiYWN0aXZlU2hhcmVkU3RhdGVzIiwiX3R1cm5UZXh0T04iLCJ0YXJnZXRUZXh0IiwiX3R1cm5UZXh0T0ZGIiwic3RhdGVUb0V4Y2x1ZGUiLCJpbmNsdWRlU2hhcmVkU3RhdGVzIiwicGxhaW5TdGF0ZXMiLCJjYW5kaWRhdGUiLCJzdXBlcmlvciIsInRhcmdldFN0YXRlSW5kZXgiLCJzdGF0ZSQxIiwidG9UZW1wbGF0ZSIsImVsQ2xvbmUiLCJsZW4yIiwibmV3RWwiLCJjbG9uZU5vZGUiLCJwcmV2UGFyZW50IiwiX3JlbW92ZUNoaWxkIiwiX3JlZnJlc2hQYXJlbnQiLCJhcHBlbmRUbyIsInByZXBlbmQiLCJ1bnNoaWZ0IiwiaW5zZXJ0QmVmb3JlIiwiZmlyc3RDaGlsZCIsInByZXBlbmRUbyIsImFmdGVyIiwibXlJbmRleCIsImluc2VydEFmdGVyIiwiYmVmb3JlIiwiZGV0YWNoIiwicmVtb3ZlIiwiZW1wdHkiLCJ3cmFwIiwiY3VycmVudFBhcmVudCIsInVud3JhcCIsImdyYW5kUGFyZW50IiwicGFyZW50Q2hpbGRyZW4iLCJwYXJlbnRTaWJsaW5nIiwiaGFzQ2xhc3MiLCJjbGFzc0xpc3QiLCJ0YXJnZXRJbmRleCIsInRvZ2dsZUNsYXNzIiwic2V0UmVmIiwidGFyZ2V0Q2hpbGQiLCJyZXBsYWNlbWVudENoaWxkIiwiaW5kZXhPZkNoaWxkIiwicmVwbGFjZUNoaWxkIiwicmVtb3ZlQ2hpbGQiLCJtYW5pcHVsYXRpb24iLCJuZXdWYWx1ZSIsInN2ZyIsImxpc3QiLCJwb3AiLCJ1cGRhdGVTdGF0ZVN0eWxlcyIsInBhcnNlZCIsInVwZGF0ZWRTdGF0ZXMiLCJ1cGRhdGVTdGF0ZVRleHRzIiwicGFzc1Rocm91Z2giLCJkZWZhdWx0cyIsImNvbXB1dGVyIiwiYXBwbGljYXRpb24iLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJhdHRyaWJ1dGVzQW5kUHJvcGVydGllcyIsIlF1aWNrRWxlbWVudCQxIiwic3ZnTmFtZXNwYWNlIiwiUXVpY2tFbGVtZW50JDIiLCJjcmVhdGVUZXh0Tm9kZSIsImNyZWF0ZUVsZW1lbnROUyIsInRvSlNPTiIsInNjaGVtYSIsIm1hdGNoZXNTY2hlbWEiLCJQQVJTRV9FUlJPUl9QUkVGSVgiLCJwYXJzZVRyZWUiLCJwYXJzZVRyZWUkMSIsInRyZWUiLCJwYXJzZUNoaWxkcmVuIiwiRXJyb3IiLCJTdHJpbmciLCJOT1RfREVFUF9LRVlTIiwiTk9UX0tFWVMiLCJfZXh0ZW5kQnlSZWYiLCJleHRlbmRUZW1wbGF0ZSIsImV4dGVuZFRlbXBsYXRlJDEiLCJjdXJyZW50T3B0cyIsIm5ld09wdHMiLCJnbG9iYWxPcHRzIiwiY3VycmVudENoaWxkIiwiY3VycmVudENoaWxkcmVuIiwiZ2xvYmFsT3B0c1RyYW5zZm9ybSIsIm1heExlbmd0aCIsIm5lZWRzVGVtcGxhdGVXcmFwIiwibmV3Q2hpbGQiLCJuZXdDaGlsZFByb2Nlc3NlZCIsIm5ld0NoaWxkcmVuIiwibm9DaGFuZ2VzIiwicmVtYWluaW5nTmV3Q2hpbGRyZW4iLCJvcHRzIiwiTWF0aCIsIlF1aWNrVGVtcGxhdGUkMSIsImV4dGVuZEJ5UmVmIiwibmV3Q2hpbGRyZW5SZWZzIiwiUXVpY2tUZW1wbGF0ZSIsImlzVHJlZSIsImV4dGVuZCQkMSIsIm5ld1ZhbHVlcyIsImNoaWxkRGF0YSIsIl9leHRlbmRUZW1wbGF0ZSIsImlzVGVtcGxhdGUiLCJRdWlja0JhdGNoIiwiUXVpY2tCYXRjaCQxIiwiZWxlbWVudHMiLCJyZXR1cm5SZXN1bHRzMSIsInJldHVyblJlc3VsdHMiLCJfcmV0dXJuIiwicmV0dXJuTmV4dCIsImxhc3RSZXN1bHRzIiwicmVzdWx0czEiLCJfZWxlbWVudCIsIlNIT1JUQ1VUUyIsInNob3J0Y3V0IiwicmVzdGFydFNhbmRib3giLCJmaWVsZCIsInNhbmRib3giLCJxdWlja2ZpZWxkIiwiaW5zdGFuY2VzIiwiRE9NIiwiZGl2IiwiYm9yZGVyIiwicGFkZGluZyIsImJveFNpemluZyIsImJvZHkiLCJ0aXRsZSIsIm1hcmdpbiIsIm1hcmdpblRvcCIsIm1hcmdpbkJvdHRvbSIsImZvbnRTaXplIiwiZm9udFdlaWdodCIsImZvbnRGYW1pbHkiLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJwcm9taXNlIiwib25GaW5hbGx5IiwidmFsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJlcnIiLCJUaW1lb3V0RXJyb3IiLCJtZXNzYWdlIiwibXMiLCJmYWxsYmFjayIsInJlamVjdCIsInRpbWVyIiwic2V0VGltZW91dCIsInBGaW5hbGx5IiwiY2xlYXJUaW1lb3V0IiwiZW1pdHRlciIsImNhbmNlbCIsInJldCIsImFzc2lnbiIsInJlamVjdGlvbkV2ZW50cyIsIm11bHRpQXJncyIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYmluZCIsInJlc29sdmVIYW5kbGVyIiwicmVqZWN0SGFuZGxlciIsInJlYXNvbiIsInJlamVjdGlvbkV2ZW50IiwidGltZW91dCIsInBUaW1lb3V0IiwicmVkIiwiZ3JlZW4iLCJvcmFuZ2UiLCJibGFjayIsImdyZXlfZGFyayIsImdyZXkiLCJncmV5X3NlbWlfbGlnaHQiLCJncmV5X2xpZ2h0IiwiZ3JleV9saWdodDIiLCJncmV5X2xpZ2h0MyIsImdyZXlfbGlnaHQ0IiwiZXhjbHVkZSIsImV4Y2x1ZGVzIiwiZXhjbHVkZVByb3BzIiwicmVzIiwiZXh0ZW5kRXhjbHVkZSIsIkFzc2VydGlvbkVycm9yIiwiX3Byb3BzIiwic3NmIiwic2hvd0RpZmYiLCJjYWxsZWUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsInN0YWNrIiwiaGFzUHJvcGVydHkiLCJwYXJzZVBhdGgiLCJwYXRoIiwic3RyIiwicGFydHMiLCJtYXRjaCIsIm1hcE1hdGNoZXMiLCJyZWdleHAiLCJtQXJyIiwiZXhlYyIsInAiLCJpbnRlcm5hbEdldFBhdGhWYWx1ZSIsInBhdGhEZXB0aCIsInRlbXBvcmFyeVZhbHVlIiwicGFydCIsImludGVybmFsU2V0UGF0aFZhbHVlIiwidGVtcE9iaiIsInByb3BOYW1lIiwicHJvcFZhbCIsImdldFBhdGhJbmZvIiwibGFzdCIsImluZm8iLCJleGlzdHMiLCJnZXRQYXRoVmFsdWUiLCJzZXRQYXRoVmFsdWUiLCJmbGFnIiwiZmxhZ3MiLCJfX2ZsYWdzIiwibmVnYXRlIiwiZXhwciIsInByb21pc2VFeGlzdHMiLCJnbG9iYWxPYmplY3QiLCJnbG9iYWwiLCJzZWxmIiwiaXNEb20iLCJzeW1ib2xFeGlzdHMiLCJtYXBFeGlzdHMiLCJNYXAiLCJzZXRFeGlzdHMiLCJTZXQiLCJ3ZWFrTWFwRXhpc3RzIiwiV2Vha01hcCIsIndlYWtTZXRFeGlzdHMiLCJXZWFrU2V0IiwiZGF0YVZpZXdFeGlzdHMiLCJEYXRhVmlldyIsInN5bWJvbEl0ZXJhdG9yRXhpc3RzIiwic3ltYm9sVG9TdHJpbmdUYWdFeGlzdHMiLCJ0b1N0cmluZ1RhZyIsInNldEVudHJpZXNFeGlzdHMiLCJlbnRyaWVzIiwibWFwRW50cmllc0V4aXN0cyIsInNldEl0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJtYXBJdGVyYXRvclByb3RvdHlwZSIsImFycmF5SXRlcmF0b3JFeGlzdHMiLCJhcnJheUl0ZXJhdG9yUHJvdG90eXBlIiwic3RyaW5nSXRlcmF0b3JFeGlzdHMiLCJzdHJpbmdJdGVyYXRvclByb3RvdHlwZSIsInRvU3RyaW5nTGVmdFNsaWNlTGVuZ3RoIiwidG9TdHJpbmdSaWdodFNsaWNlTGVuZ3RoIiwibW9kdWxlIiwidHlwZURldGVjdCIsInR5cGVvZk9iaiIsImxvY2F0aW9uIiwibmF2aWdhdG9yIiwibWltZVR5cGVzIiwicGx1Z2lucyIsIkhUTUxFbGVtZW50IiwidGFnTmFtZSIsInN0cmluZ1RhZyIsIm9ialByb3RvdHlwZSIsIlJlZ0V4cCIsIkRhdGUiLCJleHBvcnRzIiwiZXhwZWN0VHlwZXMiLCJ0eXBlcyIsImZsYWdNc2ciLCJzc2ZpIiwidCIsImFydCIsImNoYXJBdCIsIm9yIiwib2JqVHlwZSIsInNvbWUiLCJleHBlY3RlZCIsImdldEFjdHVhbCIsIl9vYmoiLCJGdW5jdGlvbiIsImZ1bmN0aW9uTmFtZU1hdGNoIiwiZ2V0RnVuY05hbWUiLCJhRnVuYyIsImdldFByb3BlcnRpZXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiYWRkUHJvcGVydHkiLCJwcm90byIsImdldEVudW1lcmFibGVQcm9wZXJ0aWVzIiwiaW5jbHVkZVN0YWNrIiwidHJ1bmNhdGVUaHJlc2hvbGQiLCJ1c2VQcm94eSIsInByb3h5RXhjbHVkZWRLZXlzIiwiaW5zcGVjdCIsInNob3dIaWRkZW4iLCJkZXB0aCIsImNvbG9ycyIsImN0eCIsInNlZW4iLCJzdHlsaXplIiwiZm9ybWF0VmFsdWUiLCJpc0RPTUVsZW1lbnQiLCJyZWN1cnNlVGltZXMiLCJwcmltaXRpdmUiLCJmb3JtYXRQcmltaXRpdmUiLCJvdXRlckhUTUwiLCJ4bWxWZXJzaW9uIiwieG1sU2VyaWFsaXplciIsIlhNTFNlcmlhbGl6ZXIiLCJzZXJpYWxpemVUb1N0cmluZyIsIm5zIiwidmlzaWJsZUtleXMiLCJuYW1lU3VmZml4IiwiaXNFcnJvciIsImdldE5hbWUiLCJpc1JlZ0V4cCIsImlzRGF0ZSIsInRvVVRDU3RyaW5nIiwiZm9ybWF0RXJyb3IiLCJ0eXBlZEFycmF5IiwiYnJhY2VzIiwiaXNUeXBlZEFycmF5IiwiZm9ybWF0QXJyYXkiLCJmb3JtYXRUeXBlZEFycmF5IiwiZm9ybWF0UHJvcGVydHkiLCJyZWR1Y2VUb1NpbmdsZVN0cmluZyIsInNpbXBsZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJJbmZpbml0eSIsImwiLCJwcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImxpbmUiLCJzdWJzdHIiLCJyZWR1Y2UiLCJjdXIiLCJudW1MaW5lc0VzdCIsImFyIiwib2JqZWN0VG9TdHJpbmciLCJyZSIsImQiLCJvIiwib2JqRGlzcGxheSIsImtzdHIiLCJnZXRNZXNzYWdlIiwiYWN0dWFsIiwibXNnIiwidHJhbnNmZXJGbGFncyIsImFzc2VydGlvbiIsImluY2x1ZGVBbGwiLCJGYWtlTWFwIiwiX2tleSIsInJhbmRvbSIsIm5vdyIsImdldE1hcCIsInNldE1hcCIsImlzRXh0ZW5zaWJsZSIsIk1lbW9pemVNYXAiLCJtZW1vaXplQ29tcGFyZSIsImxlZnRIYW5kT3BlcmFuZCIsInJpZ2h0SGFuZE9wZXJhbmQiLCJtZW1vaXplTWFwIiwiaXNQcmltaXRpdmUiLCJsZWZ0SGFuZE1hcCIsIm1lbW9pemVTZXQiLCJkZWVwRXF1YWwiLCJjb21wYXJhdG9yIiwiZXh0ZW5zaXZlRGVlcEVxdWFsIiwic2ltcGxlUmVzdWx0Iiwic2ltcGxlRXF1YWwiLCJtZW1vaXplIiwibWVtb2l6ZVJlc3VsdExlZnQiLCJtZW1vaXplUmVzdWx0UmlnaHQiLCJjb21wYXJhdG9yUmVzdWx0IiwibGVmdEhhbmRUeXBlIiwiZXh0ZW5zaXZlRGVlcEVxdWFsQnlUeXBlIiwidmFsdWVPZiIsIml0ZXJhYmxlRXF1YWwiLCJyZWdleHBFcXVhbCIsImdlbmVyYXRvckVxdWFsIiwiVWludDhBcnJheSIsImJ1ZmZlciIsImVudHJpZXNFcXVhbCIsIm9iamVjdEVxdWFsIiwic2l6ZSIsImxlZnRIYW5kSXRlbXMiLCJyaWdodEhhbmRJdGVtcyIsImdhdGhlckVudHJpZXMiLCJnZXRHZW5lcmF0b3JFbnRyaWVzIiwiaGFzSXRlcmF0b3JGdW5jdGlvbiIsImdldEl0ZXJhdG9yRW50cmllcyIsIml0ZXJhdG9yRXJyb3IiLCJnZW5lcmF0b3IiLCJnZW5lcmF0b3JSZXN1bHQiLCJhY2N1bXVsYXRvciIsImRvbmUiLCJnZXRFbnVtZXJhYmxlS2V5cyIsImtleXNFcXVhbCIsImxlZnRIYW5kS2V5cyIsInJpZ2h0SGFuZEtleXMiLCJsZWZ0SGFuZEVudHJpZXMiLCJyaWdodEhhbmRFbnRyaWVzIiwiaXNQcm94eUVuYWJsZWQiLCJQcm94eSIsIlJlZmxlY3QiLCJwcm9wZXJ0eUdldHRlciIsIm5ld0Fzc2VydGlvbiIsImNoYWkiLCJBc3NlcnRpb24iLCJmbkxlbmd0aERlc2MiLCJhZGRMZW5ndGhHdWFyZCIsImZuIiwiYXNzZXJ0aW9uTmFtZSIsImlzQ2hhaW5hYmxlIiwiYnVpbHRpbnMiLCJwcm94aWZ5Iiwibm9uQ2hhaW5hYmxlTWV0aG9kTmFtZSIsInByb3h5R2V0dGVyIiwiaGFzIiwib3JkZXJlZFByb3BlcnRpZXMiLCJhIiwiYiIsInN0cmluZ0Rpc3RhbmNlIiwic3RyQSIsInN0ckIiLCJtZW1vIiwiYWRkTWV0aG9kIiwibWV0aG9kV3JhcHBlciIsIm92ZXJ3cml0ZVByb3BlcnR5IiwiX2dldCIsIl9zdXBlciIsIm92ZXJ3cml0aW5nUHJvcGVydHlHZXR0ZXIiLCJvcmlnTG9ja1NzZmkiLCJvdmVyd3JpdGVNZXRob2QiLCJfbWV0aG9kIiwib3ZlcndyaXRpbmdNZXRob2RXcmFwcGVyIiwiY2FuU2V0UHJvdG90eXBlIiwic2V0UHJvdG90eXBlT2YiLCJ0ZXN0Rm4iLCJleGNsdWRlTmFtZXMiLCJwcm9wRGVzYyIsImFkZENoYWluYWJsZU1ldGhvZCIsImNoYWluaW5nQmVoYXZpb3IiLCJjaGFpbmFibGVCZWhhdmlvciIsIl9fbWV0aG9kcyIsImNoYWluYWJsZU1ldGhvZEdldHRlciIsImNoYWluYWJsZU1ldGhvZFdyYXBwZXIiLCJhc3NlcnRlck5hbWVzIiwiYXNzZXJ0ZXJOYW1lIiwicGQiLCJvdmVyd3JpdGVDaGFpbmFibGVNZXRob2QiLCJfY2hhaW5pbmdCZWhhdmlvciIsIm92ZXJ3cml0aW5nQ2hhaW5hYmxlTWV0aG9kR2V0dGVyIiwib3ZlcndyaXRpbmdDaGFpbmFibGVNZXRob2RXcmFwcGVyIiwiY29tcGFyZUJ5SW5zcGVjdCIsImdldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW0iLCJnZXRPd25FbnVtZXJhYmxlUHJvcGVydGllcyIsImNvbXBhdGlibGVJbnN0YW5jZSIsInRocm93biIsImVycm9yTGlrZSIsImNvbXBhdGlibGVDb25zdHJ1Y3RvciIsImNvbXBhdGlibGVNZXNzYWdlIiwiZXJyTWF0Y2hlciIsImNvbXBhcmlzb25TdHJpbmciLCJnZXRGdW5jdGlvbk5hbWUiLCJjb25zdHJ1Y3RvckZuIiwiZ2V0Q29uc3RydWN0b3JOYW1lIiwiY29uc3RydWN0b3JOYW1lIiwidHJpbSIsInJlcXVpcmUkJDAiLCJyZXF1aXJlJCQxIiwicmVxdWlyZSQkMiIsInJlcXVpcmUkJDMiLCJyZXF1aXJlJCQ0IiwicmVxdWlyZSQkNSIsInJlcXVpcmUkJDYiLCJyZXF1aXJlJCQ3IiwicmVxdWlyZSQkOCIsInJlcXVpcmUkJDkiLCJwYXRodmFsIiwicmVxdWlyZSQkMTAiLCJyZXF1aXJlJCQxMSIsInJlcXVpcmUkJDEyIiwicmVxdWlyZSQkMTMiLCJyZXF1aXJlJCQxNCIsInJlcXVpcmUkJDE1IiwicmVxdWlyZSQkMTYiLCJyZXF1aXJlJCQxNyIsInJlcXVpcmUkJDE4IiwicmVxdWlyZSQkMTkiLCJyZXF1aXJlJCQyMCIsInJlcXVpcmUkJDIxIiwicmVxdWlyZSQkMjIiLCJyZXF1aXJlJCQyMyIsInJlcXVpcmUkJDI0IiwiX2NoYWkiLCJ1dGlsIiwibG9ja1NzZmkiLCJjb25zb2xlIiwid2FybiIsImFzc2VydCIsIm5lZ2F0ZU1zZyIsIl9hY3R1YWwiLCJvayIsImFuIiwiYXJ0aWNsZSIsIlNhbWVWYWx1ZVplcm8iLCJpbmNsdWRlQ2hhaW5pbmdCZWhhdmlvciIsImluY2x1ZGUiLCJpc0RlZXAiLCJpbmNsdWRlZCIsImlzRXFsIiwiZXFsIiwiZmlyc3RFcnIiLCJudW1FcnJzIiwicHJvcEFzc2VydGlvbiIsImNoZWNrRXJyb3IiLCJpdGVtc0NvdW50IiwiY2hlY2tBcmd1bWVudHMiLCJhc3NlcnRFcXVhbCIsImFzc2VydEVxbCIsImFzc2VydEFib3ZlIiwibiIsImRvTGVuZ3RoIiwibXNnUHJlZml4IiwiblR5cGUiLCJzaG91bGRUaHJvdyIsInRvIiwiaGF2ZSIsImVycm9yTWVzc2FnZSIsInByaW50T2JqIiwiYXNzZXJ0TGVhc3QiLCJhc3NlcnRCZWxvdyIsImFzc2VydE1vc3QiLCJzdGFydCIsImZpbmlzaCIsInN0YXJ0VHlwZSIsImZpbmlzaFR5cGUiLCJyYW5nZSIsImFzc2VydEluc3RhbmNlT2YiLCJpc0luc3RhbmNlT2YiLCJhc3NlcnRQcm9wZXJ0eSIsImlzTmVzdGVkIiwiaXNPd24iLCJwYXRoSW5mbyIsImFzc2VydE93blByb3BlcnR5IiwiYXNzZXJ0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiYWN0dWFsRGVzY3JpcHRvciIsImFzc2VydExlbmd0aENoYWluIiwiYXNzZXJ0TGVuZ3RoIiwiYXNzZXJ0TWF0Y2giLCJpcyIsImFzc2VydEtleXMiLCJrZXlzVHlwZSIsImRlZXBTdHIiLCJtaXhlZEFyZ3NNc2ciLCJhbnkiLCJhbGwiLCJleHBlY3RlZEtleSIsImFjdHVhbEtleSIsImV2ZXJ5IiwiYXNzZXJ0VGhyb3dzIiwiZXJyTXNnTWF0Y2hlciIsImNhdWdodEVyciIsImV2ZXJ5QXJnSXNVbmRlZmluZWQiLCJldmVyeUFyZ0lzRGVmaW5lZCIsIkJvb2xlYW4iLCJlcnJvckxpa2VGYWlsIiwiZXJyTXNnTWF0Y2hlckZhaWwiLCJlcnJvckxpa2VTdHJpbmciLCJpc0NvbXBhdGlibGVJbnN0YW5jZSIsImlzQ29tcGF0aWJsZUNvbnN0cnVjdG9yIiwicGxhY2Vob2xkZXIiLCJpc0NvbXBhdGlibGVNZXNzYWdlIiwicmVzcG9uZFRvIiwiaXRzZWxmIiwiY29udGV4dCIsInNhdGlzZnkiLCJtYXRjaGVyIiwiY2xvc2VUbyIsImRlbHRhIiwiYWJzIiwiaXNTdWJzZXRPZiIsInN1YnNldCIsInN1cGVyc2V0IiwiY21wIiwiY29udGFpbnMiLCJvcmRlcmVkIiwiZWxlbSIsImlkeCIsIm1hdGNoSWR4IiwiZWxlbTIiLCJiZSIsImZhaWxNc2ciLCJmYWlsTmVnYXRlTXNnIiwib25lT2YiLCJhc3NlcnRDaGFuZ2VzIiwiaW5pdGlhbCIsImZpbmFsIiwibXNnT2JqIiwiYXNzZXJ0SW5jcmVhc2VzIiwiYXNzZXJ0RGVjcmVhc2VzIiwiYXNzZXJ0RGVsdGEiLCJiZWhhdmlvciIsInJlYWxEZWx0YSIsImV4cHJlc3Npb24iLCJpc1NlYWxlZCIsImlzRnJvemVuIiwiaXNGaW5pdGUiLCJleHBlY3QiLCJmYWlsIiwib3BlcmF0b3IiLCJsb2FkU2hvdWxkIiwic2hvdWxkR2V0dGVyIiwic2hvdWxkU2V0dGVyIiwic2hvdWxkIiwiZXF1YWwiLCJ2YWwxIiwidmFsMiIsIlRocm93IiwiZXJydCIsImVycnMiLCJleGlzdCIsIm5vdCIsIlNob3VsZCIsImV4cHJlc3MiLCJlcnJtc2ciLCJpc09rIiwiaXNOb3RPayIsImFjdCIsImV4cCIsIm5vdEVxdWFsIiwic3RyaWN0RXF1YWwiLCJub3RTdHJpY3RFcXVhbCIsImRlZXBTdHJpY3RFcXVhbCIsIm5vdERlZXBFcXVhbCIsImlzQWJvdmUiLCJhYnYiLCJhYm92ZSIsImlzQXRMZWFzdCIsImF0bHN0IiwibGVhc3QiLCJpc0JlbG93IiwiYmx3IiwiYmVsb3ciLCJpc0F0TW9zdCIsImF0bXN0IiwibW9zdCIsImlzVHJ1ZSIsImlzTm90VHJ1ZSIsImlzRmFsc2UiLCJpc05vdEZhbHNlIiwiaXNOdWxsIiwiaXNOb3ROdWxsIiwiTmFOIiwiaXNOb3ROYU4iLCJub3RFeGlzdHMiLCJpc1VuZGVmaW5lZCIsImlzRGVmaW5lZCIsImlzRnVuY3Rpb24iLCJpc05vdEZ1bmN0aW9uIiwiaXNOb3RPYmplY3QiLCJpc05vdEFycmF5IiwiaXNTdHJpbmciLCJpc05vdFN0cmluZyIsImlzTnVtYmVyIiwiaXNOb3ROdW1iZXIiLCJmaW5pdGUiLCJpc0Jvb2xlYW4iLCJpc05vdEJvb2xlYW4iLCJ0eXBlT2YiLCJub3RUeXBlT2YiLCJpbnN0YW5jZU9mIiwibm90SW5zdGFuY2VPZiIsImluYyIsIm5vdEluY2x1ZGUiLCJkZWVwSW5jbHVkZSIsIm5vdERlZXBJbmNsdWRlIiwibmVzdGVkSW5jbHVkZSIsIm5lc3RlZCIsIm5vdE5lc3RlZEluY2x1ZGUiLCJkZWVwTmVzdGVkSW5jbHVkZSIsIm5vdERlZXBOZXN0ZWRJbmNsdWRlIiwib3duSW5jbHVkZSIsIm5vdE93bkluY2x1ZGUiLCJkZWVwT3duSW5jbHVkZSIsIm5vdERlZXBPd25JbmNsdWRlIiwibm90TWF0Y2giLCJub3RQcm9wZXJ0eSIsInByb3BlcnR5VmFsIiwibm90UHJvcGVydHlWYWwiLCJkZWVwUHJvcGVydHlWYWwiLCJub3REZWVwUHJvcGVydHlWYWwiLCJvd25Qcm9wZXJ0eSIsIm5vdE93blByb3BlcnR5Iiwib3duUHJvcGVydHlWYWwiLCJub3RPd25Qcm9wZXJ0eVZhbCIsImRlZXBPd25Qcm9wZXJ0eVZhbCIsIm5vdERlZXBPd25Qcm9wZXJ0eVZhbCIsIm5lc3RlZFByb3BlcnR5Iiwibm90TmVzdGVkUHJvcGVydHkiLCJuZXN0ZWRQcm9wZXJ0eVZhbCIsIm5vdE5lc3RlZFByb3BlcnR5VmFsIiwiZGVlcE5lc3RlZFByb3BlcnR5VmFsIiwibm90RGVlcE5lc3RlZFByb3BlcnR5VmFsIiwibGVuZ3RoT2YiLCJoYXNBbnlLZXlzIiwiaGFzQWxsS2V5cyIsImNvbnRhaW5zQWxsS2V5cyIsImNvbnRhaW4iLCJkb2VzTm90SGF2ZUFueUtleXMiLCJkb2VzTm90SGF2ZUFsbEtleXMiLCJoYXNBbnlEZWVwS2V5cyIsImhhc0FsbERlZXBLZXlzIiwiY29udGFpbnNBbGxEZWVwS2V5cyIsImRvZXNOb3RIYXZlQW55RGVlcEtleXMiLCJkb2VzTm90SGF2ZUFsbERlZXBLZXlzIiwidGhyb3dzIiwiYXNzZXJ0RXJyIiwidGhyb3ciLCJkb2VzTm90VGhyb3ciLCJhcHByb3hpbWF0ZWx5Iiwic2FtZU1lbWJlcnMiLCJzZXQxIiwic2V0MiIsInNhbWUiLCJtZW1iZXJzIiwibm90U2FtZU1lbWJlcnMiLCJzYW1lRGVlcE1lbWJlcnMiLCJub3RTYW1lRGVlcE1lbWJlcnMiLCJzYW1lT3JkZXJlZE1lbWJlcnMiLCJub3RTYW1lT3JkZXJlZE1lbWJlcnMiLCJzYW1lRGVlcE9yZGVyZWRNZW1iZXJzIiwibm90U2FtZURlZXBPcmRlcmVkTWVtYmVycyIsImluY2x1ZGVNZW1iZXJzIiwibm90SW5jbHVkZU1lbWJlcnMiLCJpbmNsdWRlRGVlcE1lbWJlcnMiLCJub3RJbmNsdWRlRGVlcE1lbWJlcnMiLCJpbmNsdWRlT3JkZXJlZE1lbWJlcnMiLCJub3RJbmNsdWRlT3JkZXJlZE1lbWJlcnMiLCJpbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzIiwibm90SW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyIsImluTGlzdCIsImNoYW5nZXMiLCJjaGFuZ2UiLCJjaGFuZ2VzQnkiLCJ0bXBNc2ciLCJieSIsImRvZXNOb3RDaGFuZ2UiLCJjaGFuZ2VzQnV0Tm90QnkiLCJidXQiLCJpbmNyZWFzZXMiLCJpbmNyZWFzZSIsImluY3JlYXNlc0J5IiwiZG9lc05vdEluY3JlYXNlIiwiaW5jcmVhc2VzQnV0Tm90QnkiLCJkZWNyZWFzZXMiLCJkZWNyZWFzZSIsImRlY3JlYXNlc0J5IiwiZG9lc05vdERlY3JlYXNlIiwiZG9lc05vdERlY3JlYXNlQnkiLCJkZWNyZWFzZXNCdXROb3RCeSIsImlmRXJyb3IiLCJleHRlbnNpYmxlIiwiaXNOb3RFeHRlbnNpYmxlIiwic2VhbGVkIiwiaXNOb3RTZWFsZWQiLCJmcm96ZW4iLCJpc05vdEZyb3plbiIsImlzRW1wdHkiLCJpc05vdEVtcHR5IiwiYWxpYXMiLCJhcyIsInVzZWQiLCJ1c2UiLCJjb3JlIiwiY2hhaURvbSIsInJlcXVpcmUiLCJ1dGlscyIsImVsVG9TdHJpbmciLCJkZXNjIiwiTm9kZUxpc3QiLCJhdHRyaWJ1dGVzIiwiYXR0ckFzc2VydCIsIm9iakRlc2MiLCJhY3R1YWxMZW5ndGgiLCJtYXRjaGVzIiwic3ViaXRlbSIsImNoYWlTdHlsZSIsImlzTm9uQ29sb3JzIiwicHJvcGVydHlWYWx1ZSIsImNvbXBhcmVDU1NWYWx1ZSIsImVsZW1lbnRUYWciLCJ0aHJvd01lc3NhZ2UiLCJ0aHJvd01lc3NhZ2VOZWdhdGl2ZSIsInByb3BlcnR5SGlmZW5DYXNlIiwiZmFrZSIsImlmcmFtZSIsInZpc2liaWxpdHkiLCJmYWtlU3R5bGUiLCJoYXNBdXRvVmFsdWUiLCJyZWciLCJlc2NhcGVSZWdFeHAiLCJnZXRQcm90b3R5cGVPZkV4aXN0cyIsImh0bWxFbGVtZW50RXhpc3RzIiwiaXNBcnJheUV4aXN0cyIsImNsZWFyIiwiY2xlYXJNYXAiLCJkZWxldGUiLCJkZWxldGVNYXAiLCJERUZBVUxUX1RPTEVSQU5DRSIsImJvdGhOdW1iZXJzIiwiYWxtb3N0RXF1YWwiLCJ0b2wiLCJ0b2xlcmFuY2UiLCJjaGFpQWxtb3N0IiwiY3VzdG9tVG9sZXJhbmNlIiwic3RhbmRhcmRUb2xlcmFuY2UiLCJvdmVycmlkZUFzc2VydEVxdWFsIiwib3ZlcnJpZGVBc3NlcnRFcWwiLCJ0b2xlcmFuY2VPdmVycmlkZSIsImdsb2JhbHMiLCJzdHJpbmdzIiwibWVzc2FnZXMiLCJwcmVkaWNhdGVzIiwiZnVuY3Rpb25zIiwibWF5YmUiLCJjb2xsZWN0aW9ucyIsIm5lZ2luZiIsInBvc2luZiIsImhhdmVTeW1ib2xzIiwidiIsInMiLCJhbCIsImYiLCJhc3NpZ25lZCIsInplcm8iLCJpbmZpbml0eSIsImludGVnZXIiLCJldmVuIiwib2RkIiwiZ3JlYXRlciIsImJldHdlZW4iLCJncmVhdGVyT3JFcXVhbCIsImxlc3NPckVxdWFsIiwiaW5SYW5nZSIsInBvc2l0aXZlIiwibmVnYXRpdmUiLCJlbXB0eVN0cmluZyIsIm5vbkVtcHR5U3RyaW5nIiwiYm9vbGVhbiIsImVtcHR5T2JqZWN0Iiwibm9uRW1wdHlPYmplY3QiLCJpbnN0YW5jZVN0cmljdCIsImxpa2UiLCJlbXB0eUFycmF5Iiwibm9uRW1wdHlBcnJheSIsImFycmF5TGlrZSIsImRhdGUiLCJoYXNMZW5ndGgiLCJORUdBVElWRV9JTkZJTklUWSIsIlBPU0lUSVZFX0lORklOSVRZIiwibWl4aW4iLCJjcmVhdGVNb2RpZmllZFByZWRpY2F0ZXMiLCJhc3NlcnRNb2RpZmllciIsImFzc2VydEltcGwiLCJub3RNb2RpZmllciIsIm5vdEltcGwiLCJtYXliZU1vZGlmaWVyIiwibWF5YmVJbXBsIiwiY3JlYXRlTW9kaWZpZWRNb2RpZmllciIsImNyZWF0ZU9mUHJlZGljYXRlcyIsImNyZWF0ZU9mTW9kaWZpZXJzIiwiY3JlYXRlTWF5YmVPZk1vZGlmaWVycyIsImV4cG9ydEZ1bmN0aW9ucyIsImxocyIsInJocyIsIngiLCJ5Iiwic3Vic3RyaW5nIiwicmVnZXgiLCJlcnJvciIsImFyY2hldHlwZSIsIml0ZXJhdGlvbiIsImdldFRpbWUiLCJtYXBTaW1wbGUiLCJtYXBDb21wbGV4IiwicHJlZGljYXRlIiwibSIsInRlc3RBcnJheSIsInRlc3RPYmplY3QiLCJkZWZhdWx0TWVzc2FnZSIsImFzc2VydFByZWRpY2F0ZSIsImFyZ0NvdW50IiwiRXJyb3JUeXBlIiwibW9kaWZpZWRQcmVkaWNhdGUiLCJvZk1vZGlmaWVyIiwiY29sbGVjdGlvbiIsImNvZXJjZUNvbGxlY3Rpb24iLCJpZ25vcmUiLCJtb2RpZmllciIsImNyZWF0ZU1vZGlmaWVkRnVuY3Rpb25zIiwibW9kaWZpZWQiLCJvZiIsImNoZWNrIiwidGhpcyIsInBsdWdpbiIsImlzRW1pdHRlciIsIkV2ZW50RW1pdHRlciIsIkV2ZW50VGFyZ2V0Iiwibm9kZSIsImJyb3dzZXIiLCJyZWdpc3RlcmVkIiwicmVnaXN0ZXJBbmltYXRpb25zIiwib3BhY2l0eSIsIm9iamVjdGFibGUiLCJsb2ciLCJyIiwiaCIsInUiLCJzaWxlbnQiLCJPIiwiaUEiLCJDIiwiYyIsImRlbGF5IiwidGhyb3R0bGUiLCJzaW1wbGVTZWxlY3RvciIsInByb21pc2VUcmFuc2Zvcm1zIiwiZGlzcGF0Y2hFdmVudHMiLCJzZW5kQXJyYXlDb3BpZXMiLCJ1cGRhdGVFdmVuSWZTYW1lIiwidXBkYXRlT25CaW5kIiwiX3NiIiwiRWxlbWVudCIsInVBUyIsImciLCJIIiwic1UiLCJSIiwic1YiLCJmRFYiLCJEIiwiaUQiLCJpTyIsImlTIiwiaU4iLCJpRiIsImlCSSIsIlgiLCJpQiIsImlzSSIsIkRNIiwiZEkiLCJkUiIsImRDIiwiZUMiLCJIVE1MQ29sbGVjdGlvbiIsImpRdWVyeSIsImVBUyIsImROIiwiTSIsIkkiLCJPRCIsInByIiwib1IiLCJ0ZlMiLCJpc0wiLCJPRyIsIk9TIiwiQ1NTU3R5bGVEZWNsYXJhdGlvbiIsIlMiLCJFIiwiUCIsIl9zYl9JRCIsIl9zYl9tYXAiLCJnQiIsIklEIiwic2UiLCJWIiwiTiIsIkEiLCJCIiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsIkYiLCJUIiwiRyIsIkwiLCJ3IiwiZXJJUCIsImVyRk4iLCJlckVWIiwiZW1wdHlMaXN0IiwiZXJPRCIsImVyTVgiLCJzbyIsImNDIiwic1MiLCJzUCIsInNDIiwic2V0dGluZ3MiLCJkZWZhdWx0T3B0aW9ucyIsInVuQmluZEFsbCIsInJBUyIsIm9EIiwic3VicyIsInNNIiwicE0iLCJhdEVWIiwibUMiLCJjSCIsImFTIiwidEYiLCJkZSIsInBCIiwic1BIIiwicFZMIiwiUGgiLCJ0eE4iLCJhRVYiLCJpc011bHRpIiwiYmluZGluZ3MiLCJ1TyIsIlZSIiwiclMiLCJERVMiLCJyUEkiLCJ1ckVWRSIsInNlbGVjdGlvblN0YXJ0Iiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJwQ1QiLCJwSU0iLCJwcyIsImlFIiwiZUUiLCJ1UyIsImRMIiwibFUiLCJ1VCIsImNOIiwiYU0iLCJzcyIsImFEIiwiYVBJIiwiUEkiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJhVVYiLCJldk4iLCJyRVZFIiwiZXZIIiwiVSIsImVNIiwibGlzdGVuIiwiZXZPIiwiYmluZGluZ0RhdGEiLCJzRyIsIm9QIiwiZE0iLCJvcmlnaW5hbCIsIm9iamVjdHMiLCJzdWJzY3JpYmVycyIsImNyZWF0ZUJQIiwicGF0Y2hDYWNoZWRCUCIsInBhcnNlSW50IiwicmVtb3ZlTWV0aG9kIiwiZW1pdE1ldGhvZCIsIm50IiwiYVAiLCJXIiwiJCIsImNoYWluVG8iLCJZIiwidHJhbnNmb3JtU2VsZiIsIlEiLCJxIiwidHJhbnNmb3JtQWxsIiwieiIsImNvbmRpdGlvbiIsIkoiLCJjb25kaXRpb25BbGwiLCJLIiwiYm90aFdheXMiLCJaIiwidW5CaW5kIiwidHQiLCJwb2xsRXZlcnkiLCJldCIsInN0b3BQb2xsaW5nIiwiaXQiLCJzZXRPcHRpb24iLCJzdCIsImRpc2FsbG93RnJvbSIsInVwZGF0ZU9uIiwicmVtb3ZlVXBkYXRlciIsImFuZCIsImFkZEJQIiwidXBkYXRlIiwidHdvV2F5IiwicGlwZSIsIkluIiwicnQiLCJkZWZpbmUiLCJ1bWQiLCJzaW1wbHliaW5kIiwiUkVHRVgiLCJ3aGl0ZVNwYWNlIiwibnVtZXJpYyIsIndpZGVudW1lcmljIiwiYWxwaGFudW1lcmljIiwiZW1haWwiLCJub29wIiwicmVwZWF0IiwibmV3SXRlbSIsImhleFRvUkdCQSIsImhleCIsImFscGhhIiwiZGVmYXVsdENvbG9yIiwiY29sb3IiLCJjYWxjUGFkZGluZyIsImRlc2lyZWRIZWlnaHQiLCJjZWlsIiwidW5sb2NrU2Nyb2xsIiwiZXhjbHVkZWRFbCIsIl9pc0xvY2tlZCIsImxvY2tTY3JvbGwiLCJ3aGVlbERlbHRhIiwic2Nyb2xsVG9wIiwicHJldmVudERlZmF1bHQiLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJmdXp6eU1hdGNoIiwibmVlZGxlIiwiaGF5c3RhY2siLCJjYXNlU2Vuc2l0aXZlIiwiaEkiLCJoTGVuZ3RoIiwibWF0Y2hlZENvdW50IiwibkkiLCJuTGVuZ3RoIiwibmVlZGxlQ2hhciIsInRvVXBwZXJDYXNlIiwic3RhcnRzV2l0aCIsImdldEluZGV4T2ZGaXJzdERpZmYiLCJzb3VyY2VTdHJpbmciLCJjb21wYXJlU3RyaW5nIiwiY3VycmVudFBvcyIsInBhcnNlQ3NzU2hvcnRoYW5kVmFsdWUiLCJzaG9ydGhhbmRTaWRlVmFsdWUiLCJzaWRlIiwidXBkYXRlU2hvcnRoYW5kVmFsdWUiLCJpbmhlcml0UHJvdG8iLCJSRVFVSVJFRF9GSUVMRF9NRVRIT0RTIiwid2luIiwiZGVidWciLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIkZhc3REb20iLCJyZWFkcyIsIndyaXRlcyIsIm1lYXN1cmUiLCJ0YXNrIiwic2NoZWR1bGVGbHVzaCIsIm11dGF0ZSIsImZhc3Rkb20iLCJpbml0aWFsaXplIiwiY2F0Y2giLCJzY2hlZHVsZWQiLCJmbHVzaCIsInJ1blRhc2tzIiwidGFza3MiLCJDb25kaXRpb24iLCJmaWVsZDEiLCJjYWxsYmFjazEiLCJzYXRpc2ZpZWQiLCJhbGxGaWVsZHMiLCJTaW1wbHlCaW5kIiwib2xkVmFsdWUiLCJjb21wYXJpc29uIiwiY29tcGFyaXNvbk9wZXJhdG9ycyIsInBhc3NlZENvbXBhcmlzb25zIiwidmlzaWJsZSIsInZhbGlkYXRlIiwibmVzdGVkT2JqZWN0IiwicHJvcGVydHlDaGFpbiIsInNlZWtlZFZhbHVlIiwiaGVscGVycyIsInRlc3RNYXNrIiwiY29uZGl0aW9ucyIsInZhbGlkQ29uZGl0aW9ucyIsInZhbGlkYXRlQ29uZGl0aW9ucyIsIkNvbmRpdGlvbiQxIiwidHJhbnNmb3JtU2V0dGluZ3MiLCJjaG9pY2VzIiwibGFiZWwiLCJ2YWxpZFdoZW5SZWdleCIsImdsb2JhbERlZmF1bHRzIiwidGVtcGxhdGVzIiwiaGVscCIsInJlcXVpcmVkIiwiZGlzYWJsZWQiLCJkZWZhdWx0VmFsdWUiLCJtb2JpbGVXaWR0aCIsIm1vYmlsZVRocmVzaG9sZCIsImRpc3RhbmNlIiwiaW5wdXRQYWRkaW5nIiwibGFiZWxTaXplIiwiaWNvbiIsImljb25TaXplIiwic2V0dGVyIiwidmFsaWRhdG9yIiwiY2xlYXJFcnJvck9uVmFsaWQiLCJtYWtlUm9vbUZvckhlbHAiLCJGaWVsZCIsImN1cnJlbnRJRCIsInNldHRpbmdPdmVycmlkZXMiLCJ0ZW1wbGF0ZU92ZXJyaWRlcyIsInNoYWxsb3dTZXR0aW5ncyIsInRyYW5zZm9ybVNldHRpbmdzXyIsImRlZmF1bHQiLCJmaWVsZEluc3RhbmNlcyIsIl92YWx1ZSIsInZhbGlkIiwiZm9jdXNlZCIsImhvdmVyZWQiLCJmaWxsZWQiLCJpbnRlcmFjdGVkIiwiaXNNb2JpbGUiLCJzaG93TGFiZWwiLCJzaG93SGVscCIsInNob3dFcnJvciIsIl9jb25zdHJ1Y3RvckVuZCIsImNoaWxkZiIsIm11bHRpcGxlIiwicHJldlNob3ciLCJjaGFuZ2VBbW91bnQiLCJfcXVpY2tGaWVsZCIsIl9mb3JtYXRXaWR0aCIsImRlc3Ryb3kiLCJyZW1vdmVGcm9tRE9NIiwiX2Rlc3Ryb3kiLCJwcm92aWRlZFZhbHVlIiwiY29yZVZhbHVlUHJvcCIsInRlc3RVbnJlcXVpcmVkIiwicmVwb3J0IiwiaXNWYWxpZCIsIl92YWxpZGF0ZSIsInBhc3NlZENvbmRpdGlvbnMiLCJ0b2dnbGVWaXNpYmlsaXR5IiwidmFsaWRhdGVBbmRSZXBvcnQiLCJfZ2V0VmFsdWUiLCJfc2V0VmFsdWUiLCJGaWVsZCQxIiwia2V5Q29kZXMiLCJLRVlDT0RFUyIsImVudGVyIiwiZXNjIiwiY3RybCIsImFsdCIsInN1cGVyIiwic3VwZXIyIiwidXAiLCJkb3duIiwiaHlwaGVuIiwidW5kZXJzY29yZSIsInF1ZXN0aW9uIiwiZXhjbGFtYXRpb24iLCJmcm9udHNsYXNoIiwiYmFja3NsYXNoIiwiY29tbWEiLCJwZXJpb2QiLCJzcGFjZSIsImFueUFycm93IiwiY29kZSIsImFueU1vZGlmaWVyIiwiYW55QWxwaGEiLCJhbnlOdW1lcmljIiwiYW55QWxwaGFOdW1lcmljIiwiYW55UHJpbnRhYmxlIiwiY2hlY2ttYXJrIiwidmlld0JveCIsInRhYmluZGV4IiwiZm9jdXNhYmxlIiwiZmlsbCIsInBvaW50cyIsImFuZ2xlRG93biIsIm91dGxpbmUiLCJjYXJldFVwIiwiY2FyZXREb3duIiwicGx1cyIsInBvc2l0aW9uIiwiekluZGV4Iiwib3ZlcmZsb3ciLCJkcm9wZG93biIsInJlY3QiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3hTaGFkb3ciLCJib3JkZXJXaWR0aCIsImJvcmRlclN0eWxlIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJSYWRpdXMiLCIkaXNPcGVuIiwiJGhhc1Zpc2libGVDaG9pY2VzIiwib3ZlcmZsb3dTY3JvbGxpbmciLCJvdmVyZmxvd1N0eWxlIiwiY2hvaWNlIiwidXNlclNlbGVjdCIsImxpbmVIZWlnaHQiLCJjdXJzb3IiLCIkdmlzaWJsZSIsIiR1bmF2YWlsYWJsZSIsIiRob3ZlciIsInZlcnRpY2FsQWxpZ24iLCJ0ZXh0QWxpZ24iLCJzdHJva2UiLCIkc2VsZWN0ZWQiLCJ0ZXh0T3ZlcmZsb3ciLCJ3b3JkV3JhcCIsIm1heFdpZHRoIiwicGFkZGluZ1JpZ2h0Iiwic2Nyb2xsSW5kaWNhdG9yVXAiLCJzY3JvbGxJbmRpY2F0b3JEb3duIiwiYm9yZGVyVG9wIiwiJHNob3dIZWxwIiwidGVtcGxhdGUkMSIsIm1heEhlaWdodCIsInR5cGVCdWZmZXIiLCJDaG9pY2UiLCJEcm9wZG93biIsIkxpc3QiLCJpbml0aWFsQ2hvaWNlcyIsImlzT3BlbiIsIl9zZXR0aW5nRmlsdGVycyIsImxhc3RTZWxlY3RlZCIsImN1cnJlbnRIaWdobGlnaHRlZCIsInZpc2libGVDaG9pY2VzQ291bnQiLCJ2aXNpYmxlQ2hvaWNlcyIsImVscyIsIl9zZWxlY3RlZENhbGxiYWNrIiwiX2NyZWF0ZUVsZW1lbnRzIiwiX2F0dGFjaEJpbmRpbmdzIiwiYWRkQ2hvaWNlIiwiX2F0dGFjaEJpbmRpbmdzX2VsU3RhdGUiLCJfYXR0YWNoQmluZGluZ3NfZGlzcGxheSIsIl9hdHRhY2hCaW5kaW5nc19zY3JvbGxJbmRpY2F0b3JzIiwiY3VycmVudCIsImFwcGVuZENob2ljZXMiLCJjYWxjRGlzcGxheSIsInNjcm9sbFRvQ2hvaWNlIiwic2V0VHJhbnNsYXRlIiwibmV3Q2hvaWNlIiwicHJldkNob2ljZSIsImlucHV0Iiwia2V5Q29kZSIsImhpZ2hsaWdodFByZXYiLCJoaWdobGlnaHROZXh0IiwidHlwZUJ1ZmZlclRpbWVvdXQiLCJjaG9pY2VJblZpZXciLCJzaG93Qm90dG9tSW5kaWNhdG9yIiwic2hvd1RvcEluZGljYXRvciIsInN0YXJ0U2Nyb2xsaW5nIiwic3RvcFNjcm9sbGluZyIsImFwcGVuZGVkQ2hvaWNlcyIsInJlbW92ZUNob2ljZSIsImZpbmRDaG9pY2VBbnkiLCJyZXBsYWNlQ2hvaWNlcyIsIm5ld0Nob2ljZXMiLCJvblNlbGVjdGVkIiwiZmluZENob2ljZSIsImJ5TGFiZWwiLCJjdXJyZW50SW5kZXgiLCJzY3JvbGxVcCIsInNjcm9sbERvd24iLCJib3R0b21DdXRvZmYiLCJjbGlwcGluZ1BhcmVudCIsImNsaXBwaW5nUmVjdCIsImN1dG9mZiIsImlzQm90dG9tQ3V0b2ZmIiwiaXNUb3BDdXRvZmYiLCJuZWVkc05ld0hlaWdodCIsInNlbGZSZWN0IiwidG9wQ3V0b2ZmIiwidHJhbnNsYXRpb24iLCJ3aW5kb3dDdXRvZmYiLCJ3aW5kb3dIZWlnaHQiLCJzZXREaW1lbnNpb25zIiwiaW5uZXJ3cmFwIiwib2Zmc2V0IiwiZGlzdGFuZUZyb21Ub3AiLCJzZWxlY3RlZEhlaWdodCIsIm9mZnNldFRvcCIsImNob2ljZVJlY3QiLCJkb3duUGFkZGluZyIsImxpc3RSZWN0IiwidXBQYWRkaW5nIiwic2Nyb2xsSW50ZXJ2YWxJRCIsInVuYXZhaWxhYmxlIiwiaW5pdGlhbGl6ZWQiLCJzdG9wUHJvcGFnYXRpb24iLCJuZXdTdGF0ZSIsInByZXZTdGF0ZSIsIndhc1NlbGVjdGVkIiwiRHJvcGRvd24kMSIsImxvYWRlZCIsIl9fZXNNb2R1bGUiLCJwbGFjZWhvbGRlckNoYXIiLCJwcmV2aW91c0NvbmZvcm1lZFZhbHVlIiwicHJldmlvdXNQbGFjZWhvbGRlciIsImN1cnJlbnRDYXJldFBvc2l0aW9uIiwiY29uZm9ybWVkVmFsdWUiLCJyYXdWYWx1ZSIsImluZGV4ZXNPZlBpcGVkQ2hhcnMiLCJjYXJldFRyYXBJbmRleGVzIiwiZ3VpZGUiLCJjb252ZXJ0TWFza1RvUGxhY2Vob2xkZXIiLCJrZWVwQ2hhclBvc2l0aW9ucyIsImNoYXIiLCJpc05ldyIsIm1ldGEiLCJzb21lQ2hhcnNSZWplY3RlZCIsIm1hc2tXaXRob3V0Q2FyZXRUcmFwcyIsImluZGV4ZXMiLCJwcm9jZXNzQ2FyZXRUcmFwcyIsImlucHV0RWxlbWVudCIsIm1hc2siLCJzaG93TWFzayIsInNlbGVjdGlvbkVuZCIsInJlamVjdGVkIiwiYWN0aXZlRWxlbWVudCIsInVzZXJBZ2VudCIsImRkIiwibW0iLCJ5eSIsInl5eXkiLCJsYXN0SW5kZXhPZiIsInN1ZmZpeCIsImluY2x1ZGVUaG91c2FuZHNTZXBhcmF0b3IiLCJ0aG91c2FuZHNTZXBhcmF0b3JTeW1ib2wiLCJhbGxvd0RlY2ltYWwiLCJkZWNpbWFsU3ltYm9sIiwiZGVjaW1hbExpbWl0IiwicmVxdWlyZURlY2ltYWwiLCJhbGxvd05lZ2F0aXZlIiwiYWxsb3dMZWFkaW5nWmVyb2VzIiwiaW50ZWdlckxpbWl0IiwiTWFzayIsImRlZmF1bHRQYXR0ZXJuQ2hhcnMiLCJwcmV2VmFsdWUiLCJwcmV2Q3Vyc29yIiwicGF0dGVybiIsInBhdHRlcm5SYXciLCJwYXR0ZXJuU2V0dGVyIiwicGxhY2Vob2xkZXJSZWdleCIsImNoYXJzIiwiY3VzdG9tUGF0dGVybnMiLCJzZXRQYXR0ZXJuIiwiZ2V0U3RhdGUiLCJzZWxlY3Rpb24iLCJlbmQiLCJnZXRQbGFjZWhvbGRlciIsInJlc29sdmVQYXR0ZXJuIiwiY29weSIsInRyYXBJbmRleGVzIiwicHJldlBhdHRlcm4iLCJyZXNvbHZlZFBhdHRlcm4iLCJ1cGRhdGVWYWx1ZSIsInVwZGF0ZUZpZWxkIiwicGFyc2VQYXR0ZXJuIiwicGFyc2VUcmFuc2Zvcm0iLCJzZXRWYWx1ZSIsImVzY2FwZWQiLCJtYXNrQWRkb25zIiwiZW1haWxNYXNrIiwiY3JlYXRlTnVtYmVyTWFzayIsInNlcCIsImRlY2ltYWwiLCJsaW1pdCIsImNyZWF0ZUF1dG9Db3JyZWN0ZWREYXRlUGlwZSIsIm5ld1BhdHRlcm4iLCJ0cmFuc2Zvcm1lZCIsIm1hc2tDb3JlIiwiY29uZm9ybVRvTWFzayIsImFkanVzdENhcmV0UG9zaXRpb24iLCJNYXNrJDEiLCJDT0xPUlMiLCJ0ZXh0RmllbGRUZW1wbGF0ZSIsIiRzaG93RXJyb3IiLCJ0cmFuc2l0aW9uIiwicG9pbnRlckV2ZW50cyIsIiRmaWxsZWQiLCIkc2hvd0xhYmVsIiwiJGZvY3VzIiwiJGRpc2FibGVkIiwiaWNvblNpYmxpbmciLCJpbnB1dFNpYmxpbmciLCJwYWRkaW5nTGVmdCIsInN1YnRyYWN0IiwiYXV0b1dpZHRoIiwiYXBwZWFyYW5jZSIsImJhY2tncm91bmRDbGlwIiwidG90YWxIZWlnaHQiLCJ3b3JrYWJsZUhlaWdodCIsImZsb29yIiwiaG9yaXoiLCJ2ZXJ0aSIsInBhZGRpbmdUb3AiLCJvZmZzZXRXaWR0aCIsInRyYW5zZm9ybU9yaWdpbiIsIiRpbnZhbGlkIiwidmFsaWRXaGVuSXNDaG9pY2UiLCJtaW5XaWR0aCIsIm1pbkxlbmd0aCIsIlRleHRGaWVsZCIsInR5cGluZyIsIl9yZWNhbGNEaXNwbGF5IiwiX2F0dGFjaEJpbmRpbmdzX2Rpc3BsYXlfYXV0b1dpZHRoIiwiX2F0dGFjaEJpbmRpbmdzX3ZhbHVlIiwiX2F0dGFjaEJpbmRpbmdzX2F1dG9jb21wbGV0ZSIsIl9hdHRhY2hCaW5kaW5nc19zdGF0ZVRyaWdnZXJzIiwiY2hlY2ttYXJrX21hc2sxIiwiY2hlY2ttYXJrX21hc2syIiwiY2hlY2ttYXJrX3BhdGNoIiwiX2dldElucHV0QXV0b1dpZHRoIiwicmVzZXRJbnB1dCIsImlzVHlwaW5nIiwic2hvdWxkQmVWaXNpYmxlIiwic2VsZWN0ZWRDaG9pY2UiLCJibHVyIiwiX3NjaGVkdWxlQ3Vyc29yUmVzZXQiLCJjdXJyZW50Q3Vyc29yIiwiZGlmZkluZGV4IiwibmV3Q3Vyc29yIiwibm9ybWFsaXplQ3Vyc29yUG9zIiwiX3NldFZhbHVlSWZOb3RTZXQiLCJpbnB1dFdpZHRoIiwibGFiZWxXaWR0aCIsInNjcm9sbExlZnQiLCJzY3JvbGxXaWR0aCIsIl9nZXRXaWR0aFNldHRpbmciLCJwYXJlbnRXaWR0aCIsIm1hdGNoaW5nQ2hvaWNlIiwiVGV4dEZpZWxkJDEiLCJjcmVhdGVCdWlsZGVyIiwidGFyZ2V0RmllbGQiLCJyZXF1aXJlZE1ldGhvZCIsIm5ld1NldHRpbmdzIiwibmV3VGVtcGxhdGVzIiwiZ2xvYmFsQ29uZmlnIiwib3JpZ2luYWxUZW1wbGF0ZXMiLCJvdXRwdXRTZXR0aW5ncyIsIm91dHB1dFRlbXBsYXRlcyIsInF1aWNrZmllbGQkMSIsImF1dG9IZWlnaHQiLCJtaW5IZWlnaHQiLCJjb3VudGVyIiwicmVzaXplIiwiVGV4dGFyZWFGaWVsZCIsImZvcmNlT3B0cyIsIl9hdHRhY2hCaW5kaW5nc19kaXNwbGF5X2F1dG9IZWlnaHQiLCJfZ2V0SW5wdXRBdXRvSGVpZ2h0IiwiaW5wdXRIZWlnaHQiLCJwcmV2SGVpZ2h0IiwiVGV4dGFyZWFGaWVsZCQxIiwidmFsaWRXaGVuTWluIiwidmFsaWRXaGVuTWF4IiwiYnV0dG9ucyIsIm1pblZhbHVlIiwibWF4VmFsdWUiLCJzdGVwIiwiZW5mb3JjZSIsInN0ZXBCdXR0b24iLCIkYWN0aXZlIiwiTnVtYmVyRmllbGQiLCJwcmVjaXNpb24iLCJfbm9ybWFsaXplVmFsdWUiLCJfYXR0YWNoQmluZGluZ3Nfc3RlcEV2ZW50cyIsInNlbGVjdE51bWJlclBhcnQiLCJzdGVwVXAiLCJzdGVwRG93biIsIl9yb3VuZFRvTmVhcmVzdCIsIm11bHRpcGxpZXIiLCJ0b0ZpeGVkIiwicm91bmRlZCIsIk51bWJlckZpZWxkJDEiLCJ2YWxpZFdoZW5DaG9zZU1pbiIsImxhYmVsRmlsdGVyIiwidGFiSW5kZXgiLCJTZWxlY3RGaWVsZCIsInNldENob2ljZSIsInZhbHVlTGFiZWwiLCJfYXR0YWNoQmluZGluZ3NfZHJvcGRvd24iLCJsYWJlbEZvcm1hdCIsImVzY0xpc3RlbmVyIiwidHJpZ2dlcmluZ0tleWNvZGVzIiwidmFsaWRDaG9pY2VzIiwib3B0aW9uIiwiU2VsZWN0RmllbGQkMSIsInZhbGlkV2hlblNlbGVjdGVkIiwic2hvd1NlbGVjdEFsbCIsInBlckdyb3VwIiwic3BhY2luZyIsImNob2ljZUdyb3VwIiwibWFyZ2luTGVmdCIsIiRkZWZpbmVkV2lkdGgiLCJjaG9pY2VJY29uIiwiQ2hvaWNlRmllbGQiLCJjaG9pY2VHcm91cHMiLCJncm91cEluZGV4IiwiZ3JvdXBFbCIsImluZGV4MSIsImljb25FbCIsInRvdGFsSW5kZXgiLCJDaG9pY2VGaWVsZCQxIiwiY2hvaWNlJDEiLCJjaG9pY2VJY29uJDEiLCJjaG9pY2VHcm91cCQxIiwidmFsaWRXaGVuVHJ1ZSIsImNob2ljZUxhYmVscyIsIlRydWVGYWxzZUZpZWxkIiwiVHJ1ZUZhbHNlRmllbGQkMSIsImJhY2tncm91bmQiLCJ0cmlnZ2VyRXZlbnQiLCIkYWxpZ25lZFN0eWxlIiwiJHRvZ2dsZWQiLCJUb2dnbGVGaWVsZCIsIlRvZ2dsZUZpZWxkJDEiLCJmaWVsZHMiLCJjb2xsYXBzYWJsZSIsInN0YXJ0Q29sbGFwc2VkIiwiZmllbGRNYXJnaW4iLCJmaWVsZEFsaWduIiwiYWN0aW9uIiwiaW5zZXJ0ZWQiLCJjb2xsYXBzZUljb25zIiwiJGNvbGxhcHNlZCIsInRleHRKdXN0aWZ5IiwiR3JvdXBGaWVsZCIsIl9jYWxjRm9jdXNTdGF0ZSIsIl9jYWxjQmx1clN0YXRlIiwiX2VtaXRTdWJtaXQiLCJjb2xsYXBzZWQiLCJmaWVsZHNBcnJheSIsImFkZEFjdGlvbiIsInRvZ2dsZUNvbGxhcHNlIiwiY29sbGFwc2UiLCJmaWVsZE5hbWUiLCJzb21lSW52YWxpZCIsImljb25zIiwiYWN0aW9ucyIsIkdyb3VwRmllbGQkMSIsIiRjb2xsYXBzYWJsZSIsIiRpbmxpbmVTdHlsZSIsImdyb3VwTWFyZ2luIiwiY2xvbmVJY29uIiwicmVtb3ZlSWNvbiIsImJsb2NrR3JvdXAiLCJpbmxpbmVHcm91cCIsImdyb3VwV2lkdGgiLCJhdXRvUmVtb3ZlRW1wdHkiLCJkeW5hbWljTGFiZWwiLCJtaW5JdGVtcyIsIm1heEl0ZW1zIiwiZHJhZ2dhYmxlIiwiY2xvbmVhYmxlIiwicmVtb3ZlYWJsZSIsInNpbmdsZU1vZGUiLCJudW1iZXJpbmciLCJncm91cFNldHRpbmdzIiwiaW5saW5lIiwiYmxvY2siLCJSZXBlYXRlckZpZWxkIiwiZGlmZiIsImdyb3VwTGFiZWwiLCJsYWJlbFJlZ2V4IiwiX2dyb3VwU2V0dGluZ3MiLCJncm91cCIsImFkZEl0ZW0iLCJfcmVjYWxjTGFiZWxzIiwiYWRkQnV0dG9uIiwiX3JlY2FsY0xhYmVsIiwiZXhpc3RpbmdMYWJlbCIsIm5ld0xhYmVsIiwic2tpcEluc2VydCIsInNraXBFbWl0IiwiZmlyc3RGaWVsZCIsInJlZnJlc2hDaGlsZHJlbiIsImNsb25lSXRlbSIsInJlbW92ZWQiLCJSZXBlYXRlckZpZWxkJDEiLCJlbWl0RXZlbnQiLCJjaGFpQXNzZXJ0dHlwZSIsImNoYWlFdmVudHMiLCJtb2NoYSIsInNldHVwIiwic2xvdyIsIl9fa2FybWFfXyIsImJhaWwiLCJUcnVlZmFsc2VGaWVsZCIsInByb21pc2VFdmVudCIsInN1aXRlIiwidGVhcmRvd24iLCJsYXN0Q2hpbGQiLCJzdWl0ZVNldHVwIiwiZmllbGQyIiwiY29udHJvbCIsImZpZWxkQSIsImZpZWxkQiIsImZpZWxkQyIsImluaXRpYWxUb3AiLCJ3aXRoTGFiZWwiLCJ3aXRob3V0TGFiZWwiLCJpY29uRmllbGQiLCJjdXN0b20iLCJtYXN0ZXIiLCJzbGF2ZSIsImRyb3Bkb3duRWwiLCJpbnB1dEVsIiwiZGlzcGxheWVkIiwiZ2V0VmlzaWJsZSIsInNraXAiLCJjb250cm9sTXVsdGkiLCJyZWYzIiwicmVmNCIsInJlZjUiLCJ2YWx1ZVJhdyIsInNpbmdsZSIsImZpcnN0Iiwic2Vjb25kIiwidGhpcmQiLCJmb3VydGgiLCJmaWZ0aCIsInF1aWNrZmllbGQyIiwidGV4dEEiLCJ0ZXh0QiIsInRleHRDIiwidGV4dEQiXSwibWFwcGluZ3MiOiI0RkFBQSxtQkFBZSxDQUNiLFdBRGEsRUFFYixnQkFGYSxFQUdiLDhCQUhhLEVBSWIseUJBSmEsRUFLYixjQUxhLEVBTWIsdUJBTmEsRUFPYiwwQkFQYSxFQVFiLGdCQVJhLEVBU2IsZ0JBVGEsRUFVYiw2QkFWYSxFQVdiLGdCQVhhLEVBWWIsOEJBWmEsRUFhYixpQkFiYSxFQWNiLGdCQWRhLEVBZWIsNkJBZmEsRUFnQmIsNEJBaEJhLEVBaUJiLGVBakJhLEVBa0JiLFlBbEJhLEVBbUJiLHNCQW5CYSxFQW9CYixnQkFwQmEsRUFxQmIsMkJBckJhLEVBc0JiLGlCQXRCYSxFQXVCYiwrQkF2QmEsRUF3QmIsa0JBeEJhLEVBeUJiLG1CQXpCYSxFQTBCYixnQkExQmEsRUEyQmIsZ0JBM0JhLEVBNEJiLDJCQTVCYSxFQTZCYixnQkE3QmEsRUE4QmIsZ0JBOUJhLEVBK0JiLGtCQS9CYSxFQWdDYix5QkFoQ2EsRUFpQ2IsNEJBakNhLEVBa0NiLGdCQWxDYSxFQW1DYiw0QkFuQ2EsRUFvQ2IsMkJBcENhLEVBcUNiLGlCQXJDYSxFQXNDYixnQkF0Q2EsRUF1Q2IsZ0JBdkNhLEVBd0NiLGdCQXhDYSxFQXlDYiwwQkF6Q2EsRUEwQ2Isd0JBMUNhLEVBMkNiLDBCQTNDYSxFQTRDYixnQkE1Q2EsRUE2Q2Isa0JBN0NhLEVBOENiLGVBOUNhLEVBK0NiLGNBL0NhLEVBZ0RiLFlBaERhLEVBaURiLGdDQWpEYSxFQWtEYix1QkFsRGEsQ0FBZixDQ0FBLElBQUksVUFBVSxHQUFHLFVBQVUsT0FBTyxFQUFFO0VBQ2xDLElBQUksT0FBTyxDQUFDLGFBQWEsQ0FBQyxVQUFVLElBQUksT0FBTyxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLEtBQUssSUFBSSxFQUFFO0lBQy9GLE9BQU8sSUFBSSxDQUFDO0dBQ2I7O0VBRUQsUUFBUSxPQUFPLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRTtJQUNuQyxLQUFLLE9BQU87TUFDVixPQUFPLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNsQyxLQUFLLFVBQVU7TUFDYixPQUFPLElBQUksQ0FBQztHQUNmOztFQUVELElBQUksaUJBQWlCLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDOUIsT0FBTyxJQUFJLENBQUM7R0FDYjs7RUFFRCxPQUFPLEtBQUssQ0FBQztDQUNkLENBQUM7O0FBRUYsU0FBUyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUU7RUFDbEMsSUFBSSxPQUFPLENBQUMsZUFBZSxJQUFJLE9BQU8sQ0FBQyxlQUFlLENBQUMsV0FBVyxFQUFFLEtBQUssTUFBTSxFQUFFO0lBQy9FLE9BQU8sSUFBSSxDQUFDO0dBQ2I7RUFDRCxJQUFJLE9BQU8sQ0FBQyxlQUFlLElBQUksT0FBTyxDQUFDLGVBQWUsQ0FBQyxXQUFXLEVBQUUsS0FBSyxTQUFTLElBQUksT0FBTyxDQUFDLFVBQVUsRUFBRTtJQUN4RyxPQUFPLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztHQUM5QztFQUNELE9BQU8sS0FBSyxDQUFDO0NBQ2Q7O0FBRUQsU0FBUyxlQUFlLENBQUMsS0FBSyxFQUFFO0VBQzlCLFFBQVEsS0FBSyxDQUFDLElBQUk7SUFDaEIsS0FBSyxNQUFNO01BQ1QsT0FBTyxJQUFJLENBQUM7SUFDZCxLQUFLLE9BQU87TUFDVixPQUFPLElBQUksQ0FBQztJQUNkLEtBQUssVUFBVTtNQUNiLE9BQU8sSUFBSSxDQUFDO0lBQ2QsS0FBSyxRQUFRO01BQ1gsT0FBTyxJQUFJLENBQUM7SUFDZCxLQUFLLEtBQUs7TUFDUixPQUFPLElBQUksQ0FBQztJQUNkLEtBQUssS0FBSztNQUNSLE9BQU8sSUFBSSxDQUFDO0lBQ2Q7TUFDRSxPQUFPLEtBQUssQ0FBQztHQUNoQjtDQUNGOztBQUVELElBQUksY0FBYyxHQUFHLFVBQVUsUUFBUSxFQUFFLFdBQVcsRUFBRTtFQUNwRCxJQUFJLEVBQUUsUUFBUSxZQUFZLFdBQVcsQ0FBQyxFQUFFO0lBQ3RDLE1BQU0sSUFBSSxTQUFTLENBQUMsbUNBQW1DLENBQUMsQ0FBQztHQUMxRDtDQUNGLENBQUM7O0FBRUYsSUFBSSxXQUFXLEdBQUcsWUFBWTtFQUM1QixTQUFTLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUU7SUFDdkMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7TUFDckMsSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQzFCLFVBQVUsQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDLFVBQVUsSUFBSSxLQUFLLENBQUM7TUFDdkQsVUFBVSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7TUFDL0IsSUFBSSxPQUFPLElBQUksVUFBVSxFQUFFLFVBQVUsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO01BQ3RELE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsVUFBVSxDQUFDLENBQUM7S0FDM0Q7R0FDRjs7RUFFRCxPQUFPLFVBQVUsV0FBVyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUU7SUFDckQsSUFBSSxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FBQztJQUNwRSxJQUFJLFdBQVcsRUFBRSxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDNUQsT0FBTyxXQUFXLENBQUM7R0FDcEIsQ0FBQztDQUNILEVBQUUsQ0FBQzs7QUFFSixJQUFJLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2xCLElBQUksSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDbEIsSUFBSSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNqQixJQUFJLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDOzs7QUFHbkIsSUFBSSxTQUFTLEdBQUc7RUFDZCxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUM7RUFDWixLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUM7RUFDYixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUM7RUFDVixLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUM7Q0FDZCxDQUFDO0FBQ0YsU0FBUyxDQUFDLEdBQUcsR0FBRyxTQUFTLENBQUMsSUFBSSxHQUFHLFNBQVMsQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDLEVBQUUsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDOzs7Ozs7O0FBT2xGLElBQUksU0FBUzs7Ozs7QUFLYixTQUFTLFNBQVMsQ0FBQyxTQUFTLEVBQUUsT0FBTyxFQUFFO0VBQ3JDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7O0VBRWhDLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0VBQzNCLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxFQUFFLFNBQVMsR0FBRyxJQUFJLENBQUMsQ0FBQztFQUNwQyxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsRUFBRSxTQUFTLEdBQUcsSUFBSSxDQUFDLENBQUM7RUFDcEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsU0FBUyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0VBQ2xDLElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxFQUFFLFNBQVMsR0FBRyxLQUFLLENBQUMsQ0FBQztFQUN0QyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztDQUN4QixDQUFDOzs7Ozs7QUFNRixTQUFTLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUN0QixTQUFTLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUN0QixTQUFTLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUNwQixTQUFTLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUN4QixJQUFJLFFBQVEsR0FBRyxZQUFZOzs7OztFQUt6QixTQUFTLFFBQVEsQ0FBQyxrQkFBa0IsRUFBRSxnQkFBZ0IsRUFBRTtJQUN0RCxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDOztJQUUvQixJQUFJLENBQUMsbUJBQW1CLEdBQUcsa0JBQWtCLENBQUM7SUFDOUMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLGdCQUFnQixDQUFDO0dBQzNDOzs7Ozs7Ozs7O0VBVUQsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ3JCLEdBQUcsRUFBRSxzQkFBc0I7SUFDM0IsS0FBSyxFQUFFLFNBQVMsb0JBQW9CLENBQUMsU0FBUyxFQUFFO01BQzlDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQztNQUNuQyxLQUFLLElBQUksUUFBUSxJQUFJLEdBQUcsRUFBRTtRQUN4QixJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLEVBQUU7VUFDdkQsSUFBSSxvQkFBb0IsR0FBRyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7VUFDekMsSUFBSSxTQUFTLENBQUMsT0FBTyxLQUFLLG9CQUFvQixDQUFDLE9BQU8sSUFBSSxTQUFTLENBQUMsU0FBUyxLQUFLLG9CQUFvQixDQUFDLFNBQVMsRUFBRTtZQUNoSCxPQUFPLFFBQVEsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLENBQUM7V0FDL0I7U0FDRjtPQUNGO01BQ0QsT0FBTyxJQUFJLENBQUM7S0FDYjs7Ozs7Ozs7Ozs7R0FXRixFQUFFO0lBQ0QsR0FBRyxFQUFFLDBCQUEwQjtJQUMvQixLQUFLLEVBQUUsU0FBUyx3QkFBd0IsQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRTtNQUNoRSxJQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsYUFBYSxDQUFDO01BQ3BDLElBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUM7TUFDbEMsSUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQzs7TUFFekIsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUM7O01BRW5CLElBQUk7UUFDRixLQUFLLEdBQUcsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7T0FDekIsQ0FBQyxPQUFPLENBQUMsRUFBRTtRQUNWLEtBQUssR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDO09BQzFDOztNQUVELEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQzs7TUFFbEMsUUFBUSxJQUFJO1FBQ1YsS0FBSyxXQUFXO1VBQ2QsS0FBSyxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1VBQ3ZFLE1BQU07O1FBRVIsS0FBSyxTQUFTLENBQUMsS0FBSyxVQUFVLENBQUMsS0FBSyxPQUFPO1VBQ3pDLEtBQUssQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDLFFBQVEsQ0FBQztVQUNwQyxLQUFLLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUM7VUFDaEMsS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDO1VBQ2xDLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQztVQUNsQyxLQUFLLENBQUMsT0FBTyxHQUFHLElBQUksS0FBSyxVQUFVLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLFNBQVMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUM7VUFDL0YsS0FBSyxDQUFDLFFBQVEsR0FBRyxJQUFJLEtBQUssVUFBVSxHQUFHLEtBQUssQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO1VBQ3pELEtBQUssQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQztVQUM1QixNQUFNO09BQ1Q7O01BRUQsT0FBTyxLQUFLLENBQUM7S0FDZDs7Ozs7Ozs7OztHQVVGLEVBQUU7SUFDRCxHQUFHLEVBQUUseUJBQXlCO0lBQzlCLEtBQUssRUFBRSxTQUFTLHVCQUF1QixDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUU7TUFDdEQsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxDQUFDO01BQ2hELElBQUksQ0FBQywwQkFBMEIsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUM7S0FDcEQ7Ozs7Ozs7Ozs7R0FVRixFQUFFO0lBQ0QsR0FBRyxFQUFFLHdCQUF3QjtJQUM3QixLQUFLLEVBQUUsU0FBUyxzQkFBc0IsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFO01BQ3BELElBQUksb0JBQW9CLEdBQUcsQ0FBQyxDQUFDO01BQzdCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDdEQsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMvRCxJQUFJLENBQUMsK0JBQStCLENBQUMsTUFBTSxFQUFFLG9CQUFvQixFQUFFLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN4RixJQUFJLENBQUMsMEJBQTBCLENBQUMsU0FBUyxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUMxRCxvQkFBb0IsR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDO09BQzVDO01BQ0QsSUFBSSxDQUFDLCtCQUErQixDQUFDLE1BQU0sRUFBRSxvQkFBb0IsRUFBRSxDQUFDLENBQUMsQ0FBQztLQUN2RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBb0NGLEVBQUU7SUFDRCxHQUFHLEVBQUUsNEJBQTRCO0lBQ2pDLEtBQUssRUFBRSxTQUFTLDBCQUEwQixDQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUU7TUFDNUQsSUFBSSxtQkFBbUIsR0FBRyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssU0FBUyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7TUFDbkcsSUFBSSxNQUFNLEdBQUcsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLFNBQVMsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQzs7TUFFL0YsSUFBSSxtQkFBbUIsRUFBRTtRQUN2QixJQUFJLENBQUMsK0JBQStCLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxTQUFTLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDO09BQzlFOztNQUVELElBQUksWUFBWSxHQUFHLEtBQUssQ0FBQyxDQUFDO01BQzFCLElBQUksTUFBTSxHQUFHLFNBQVMsQ0FBQyxJQUFJLEVBQUU7UUFDM0IsWUFBWSxHQUFHLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDO09BQzVFOztNQUVELElBQUksWUFBWSxJQUFJLE1BQU0sQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLElBQUksSUFBSSxDQUFDLHlCQUF5QixDQUFDLE1BQU0sQ0FBQyxFQUFFO1FBQ2hHLElBQUksYUFBYSxHQUFHLEtBQUssQ0FBQyxDQUFDO1FBQzNCLElBQUksTUFBTSxHQUFHLFNBQVMsQ0FBQyxLQUFLLEVBQUU7VUFDNUIsYUFBYSxHQUFHLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQzlFO1FBQ0QsSUFBSSxhQUFhLElBQUksYUFBYSxDQUFDLFFBQVEsSUFBSSxNQUFNLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxFQUFFO1VBQ2xGLElBQUksTUFBTSxHQUFHLFNBQVMsQ0FBQyxLQUFLLEVBQUU7WUFDNUIsSUFBSSxjQUFjLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixDQUFDLFdBQVcsRUFBRSxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFDbkYsTUFBTSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsQ0FBQzs7WUFFckMsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFDM0UsTUFBTSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQztXQUNsQztTQUNGO09BQ0Y7O01BRUQsSUFBSSxNQUFNLEdBQUcsU0FBUyxDQUFDLEVBQUUsRUFBRTtRQUN6QixJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsd0JBQXdCLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUMzRSxNQUFNLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDO09BQ2xDOztNQUVELElBQUksbUJBQW1CLEVBQUU7UUFDdkIsSUFBSSxDQUFDLCtCQUErQixDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDO09BQ3RFO0tBQ0Y7Ozs7Ozs7Ozs7OztHQVlGLEVBQUU7SUFDRCxHQUFHLEVBQUUsaUNBQWlDO0lBQ3RDLEtBQUssRUFBRSxTQUFTLCtCQUErQixDQUFDLE1BQU0sRUFBRSxpQkFBaUIsRUFBRSxlQUFlLEVBQUU7TUFDMUYsSUFBSSxNQUFNLEdBQUcsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLFNBQVMsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQzs7TUFFL0YsSUFBSSxvQkFBb0IsR0FBRyxpQkFBaUIsQ0FBQztNQUM3QyxJQUFJLFdBQVcsR0FBRyxDQUFDLGlCQUFpQixHQUFHLElBQUksTUFBTSxJQUFJLENBQUM7TUFDdEQsSUFBSSxZQUFZLEdBQUcsQ0FBQyxlQUFlLEdBQUcsSUFBSSxNQUFNLElBQUksQ0FBQztNQUNyRCxJQUFJLFdBQVcsR0FBRyxDQUFDLGlCQUFpQixHQUFHLElBQUksTUFBTSxJQUFJLENBQUM7TUFDdEQsSUFBSSxZQUFZLEdBQUcsQ0FBQyxlQUFlLEdBQUcsSUFBSSxNQUFNLElBQUksQ0FBQztNQUNyRCxJQUFJLFlBQVksR0FBRyxDQUFDLGlCQUFpQixHQUFHLEtBQUssTUFBTSxLQUFLLENBQUM7TUFDekQsSUFBSSxhQUFhLEdBQUcsQ0FBQyxlQUFlLEdBQUcsS0FBSyxNQUFNLEtBQUssQ0FBQztNQUN4RCxJQUFJLFVBQVUsR0FBRyxDQUFDLGlCQUFpQixHQUFHLEdBQUcsTUFBTSxHQUFHLENBQUM7TUFDbkQsSUFBSSxXQUFXLEdBQUcsQ0FBQyxlQUFlLEdBQUcsR0FBRyxNQUFNLEdBQUcsQ0FBQzs7TUFFbEQsSUFBSSxZQUFZLEdBQUcsTUFBTSxHQUFHLFNBQVMsQ0FBQyxFQUFFLENBQUM7TUFDekMsSUFBSSxjQUFjLEdBQUcsTUFBTSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUM7O01BRTdDLElBQUksWUFBWSxJQUFJLFdBQVcsS0FBSyxJQUFJLElBQUksWUFBWSxLQUFLLEtBQUssRUFBRTs7UUFFbEUsb0JBQW9CLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDOUIsTUFBTSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsT0FBTyxFQUFFLElBQUksU0FBUyxDQUFDLG9CQUFvQixFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO09BQ3hJOztNQUVELElBQUksWUFBWSxJQUFJLFdBQVcsS0FBSyxJQUFJLElBQUksWUFBWSxLQUFLLEtBQUssRUFBRTs7UUFFbEUsb0JBQW9CLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDOUIsTUFBTSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsT0FBTyxFQUFFLElBQUksU0FBUyxDQUFDLG9CQUFvQixFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO09BQ3hJOztNQUVELElBQUksWUFBWSxJQUFJLFlBQVksS0FBSyxJQUFJLElBQUksYUFBYSxLQUFLLEtBQUssRUFBRTs7UUFFcEUsb0JBQW9CLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDL0IsTUFBTSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsT0FBTyxFQUFFLElBQUksU0FBUyxDQUFDLG9CQUFvQixFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO09BQ3pJOztNQUVELElBQUksWUFBWSxJQUFJLFVBQVUsS0FBSyxJQUFJLElBQUksV0FBVyxLQUFLLEtBQUssRUFBRTs7UUFFaEUsb0JBQW9CLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDN0IsTUFBTSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsT0FBTyxFQUFFLElBQUksU0FBUyxDQUFDLG9CQUFvQixFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO09BQ3ZJOztNQUVELElBQUksY0FBYyxJQUFJLFdBQVcsS0FBSyxLQUFLLElBQUksWUFBWSxLQUFLLElBQUksRUFBRTs7UUFFcEUsb0JBQW9CLElBQUksSUFBSSxDQUFDO1FBQzdCLE1BQU0sQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLFNBQVMsRUFBRSxJQUFJLFNBQVMsQ0FBQyxvQkFBb0IsRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztPQUMxSTs7TUFFRCxJQUFJLGNBQWMsSUFBSSxXQUFXLEtBQUssS0FBSyxJQUFJLFlBQVksS0FBSyxJQUFJLEVBQUU7O1FBRXBFLG9CQUFvQixJQUFJLElBQUksQ0FBQztRQUM3QixNQUFNLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxTQUFTLEVBQUUsSUFBSSxTQUFTLENBQUMsb0JBQW9CLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7T0FDMUk7O01BRUQsSUFBSSxjQUFjLElBQUksWUFBWSxLQUFLLEtBQUssSUFBSSxhQUFhLEtBQUssSUFBSSxFQUFFOztRQUV0RSxvQkFBb0IsSUFBSSxLQUFLLENBQUM7UUFDOUIsTUFBTSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsU0FBUyxFQUFFLElBQUksU0FBUyxDQUFDLG9CQUFvQixFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO09BQzNJOztNQUVELElBQUksY0FBYyxJQUFJLFVBQVUsS0FBSyxLQUFLLElBQUksV0FBVyxLQUFLLElBQUksRUFBRTs7UUFFbEUsb0JBQW9CLElBQUksR0FBRyxDQUFDO1FBQzVCLE1BQU0sQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLFNBQVMsRUFBRSxJQUFJLFNBQVMsQ0FBQyxvQkFBb0IsRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztPQUN6STs7TUFFRCxJQUFJLG9CQUFvQixLQUFLLGVBQWUsRUFBRTtRQUM1QyxNQUFNLElBQUksS0FBSyxDQUFDLDJDQUEyQyxHQUFHLGVBQWUsSUFBSSxTQUFTLEdBQUcsb0JBQW9CLENBQUMsQ0FBQyxDQUFDO09BQ3JIO0tBQ0Y7Ozs7Ozs7OztHQVNGLEVBQUU7SUFDRCxHQUFHLEVBQUUsb0JBQW9CO0lBQ3pCLEtBQUssRUFBRSxTQUFTLGtCQUFrQixDQUFDLE1BQU0sRUFBRTtNQUN6QyxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUM7TUFDbkIsSUFBSSxTQUFTLEdBQUcsQ0FBQyxDQUFDOztNQUVsQixJQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO01BQzlCLElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQzs7TUFFM0IsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLElBQUksRUFBRTtRQUM1QixRQUFRLElBQUksQ0FBQyxXQUFXLEVBQUU7VUFDeEIsS0FBSyxNQUFNO1lBQ1QsU0FBUyxJQUFJLElBQUksQ0FBQyxNQUFNO1VBQzFCLEtBQUssTUFBTTtZQUNULFNBQVMsSUFBSSxJQUFJLENBQUMsTUFBTTtVQUMxQixLQUFLLEtBQUs7WUFDUixTQUFTLElBQUksR0FBRyxDQUFDLE1BQU07VUFDekIsS0FBSyxPQUFPO1lBQ1YsU0FBUyxJQUFJLEtBQUssQ0FBQyxNQUFNO1VBQzNCO1lBQ0UsTUFBTSxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsTUFBTSxHQUFHLHVCQUF1QixHQUFHLElBQUksQ0FBQyxDQUFDO1NBQ3JFO09BQ0YsQ0FBQyxDQUFDOztNQUVILElBQUksUUFBUSxDQUFDLFdBQVcsRUFBRSxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtRQUNwRCxPQUFPLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO09BQzFELE1BQU0sSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUNoQyxJQUFJLGlCQUFpQixHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUUsU0FBUyxJQUFJLGlCQUFpQixDQUFDLFNBQVMsQ0FBQztRQUN6QyxPQUFPLEdBQUcsaUJBQWlCLENBQUMsT0FBTyxDQUFDO09BQ3JDLE1BQU07UUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxNQUFNLEdBQUcscUJBQXFCLEdBQUcsUUFBUSxDQUFDLENBQUM7T0FDckU7O01BRUQsT0FBTyxJQUFJLFNBQVMsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDMUM7Ozs7Ozs7OztHQVNGLEVBQUU7SUFDRCxHQUFHLEVBQUUsc0JBQXNCO0lBQzNCLEtBQUssRUFBRSxTQUFTLG9CQUFvQixDQUFDLFFBQVEsRUFBRTtNQUM3QyxPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsSUFBSSxJQUFJLENBQUM7S0FDbkQ7Ozs7Ozs7R0FPRixFQUFFO0lBQ0QsR0FBRyxFQUFFLDJCQUEyQjtJQUNoQyxLQUFLLEVBQUUsU0FBUyx5QkFBeUIsQ0FBQyxNQUFNLEVBQUU7TUFDaEQsSUFBSSxDQUFDLE1BQU0sRUFBRTtRQUNYLE9BQU8sS0FBSyxDQUFDO09BQ2Q7O01BRUQsT0FBTyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDM0I7R0FDRixDQUFDLENBQUMsQ0FBQztFQUNKLE9BQU8sUUFBUSxDQUFDO0NBQ2pCLEVBQUUsQ0FBQzs7QUFFSixJQUFJLCtCQUErQixHQUFHO0VBQ3BDLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3hCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDO0VBQzdCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDO0VBQ3pCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDO0VBQzdCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDO0VBQ3pCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDO0VBQ3pCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDO0VBQ3pCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDO0VBQ3pCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3hCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3hCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3hCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3hCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3hCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3hCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3hCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3hCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3hCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3hCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDO0VBQzdCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDO0VBQ3pCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDO0VBQzdCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDO0VBQ3pCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDO0VBQzdCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDO0VBQzdCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDO0VBQ3pCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDO0VBQ3pCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDO0VBQ3pCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDO0VBQ3pCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3hCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3hCLEVBQUUsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3hCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0VBQ3pCLEdBQUcsRUFBRSxJ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
